<html lang="zh-cn">
<head>
<meta charset="utf-8"/>
<div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/6620334.html" id="cb_post_title_url">[LeetCode] Sliding Window Median 滑动窗口中位数</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value.</p>
<p>Examples: </p>
<p><code>[2,3,4]</code> , the median is <code>3</code></p>
<p><code>[2,3]</code>, the median is <code>(2 + 3) / 2 = 2.5</code> </p>
<p>Given an array <em>nums</em>, there is a sliding window of size <em>k</em> which is moving from the very left of the array to the very right. You can only see the <em>k</em>
 numbers in the window. Each time the sliding window moves right by one 
position. Your job is to output the median array for each window in the 
original array.</p>
<p>For example,<br/>
Given <em>nums</em> = <code>[1,3,-1,-3,5,3,6,7]</code>, and <em>k</em> = 3.</p>
<pre>Window position                Median
---------------               -----
[1  3  -1] -3  5  3  6  7       1
 1 [3  -1  -3] 5  3  6  7       -1
 1  3 [-1  -3  5] 3  6  7       -1
 1  3  -1 [-3  5  3] 6  7       3
 1  3  -1  -3 [5  3  6] 7       5
 1  3  -1  -3  5 [3  6  7]      6
</pre>
<p>Therefore, return the median sliding window as <code>[1,-1,-1,3,5,6]</code>.</p>
<p><strong>Note: </strong><br/>
You may assume <em>k</em> is always valid, ie: 1 ≤ k ≤ input array's size for non-empty array.</p>
<p> </p>
<p>这道题给了我们一个数组，还是滑动窗口的大小，让我们求滑动窗口的中位数。我想起来之前也有一道滑动窗口的题<a href="http://www.cnblogs.com/grandyang/p/4656517.html">Sliding Window Maximum</a>，于是想套用那道题的方法，可以用deque怎么也做不出，因为求中位数并不是像求最大值那样只操作deque的首尾元素。后来看到了史蒂芬大神的方法，原来是要用一个multiset集合，和一个指向最中间元素的iterator。我们首先将数组的前k个数组加入集合中，由于multiset自带排序功能，所以我们通过k/2能快速的找到指向最中间的数字的迭代器mid，如果k为奇数，那么mid指向的数字就是中位数；如果k为偶数，那么mid指向的数跟前面那个数求平均值就是中位数。当我们添加新的数字到集合中，multiset会根据新数字的大小加到正确的位置，然后我们看如果这个新加入的数字比之前的mid指向的数小，那么中位数肯定被拉低了，所以mid往前移动一个，再看如果要删掉的数小于等于mid指向的数(注意这里加等号是因为要删的数可能就是mid指向的数)，则mid向后移动一个。然后我们将滑动窗口最左边的数删掉，我们不能直接根据值来用erase来删数字，因为这样有可能删掉多个相同的数字，而是应该用lower_bound来找到第一个不小于目标值的数，通过iterator来删掉确定的一个数字，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">double</span>&gt; medianSlidingWindow(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; nums, <span style="color: #0000ff;">int</span><span style="color: #000000;"> k) {
        vector</span>&lt;<span style="color: #0000ff;">double</span>&gt;<span style="color: #000000;"> res;
        multiset</span>&lt;<span style="color: #0000ff;">double</span>&gt; ms(nums.begin(), nums.begin() +<span style="color: #000000;"> k);
        auto mid </span>= next(ms.begin(), k /  <span style="color: #800080;">2</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = k; ; ++<span style="color: #000000;">i) {
            res.push_back((</span>*mid + *prev(mid,  <span style="color: #800080;">1</span> - k % <span style="color: #800080;">2</span>)) / <span style="color: #800080;">2</span><span style="color: #000000;">);        
            </span><span style="color: #0000ff;">if</span> (i == nums.size()) <span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
            ms.insert(nums[i]);
            </span><span style="color: #0000ff;">if</span> (nums[i] &lt; *mid) --<span style="color: #000000;">mid;
            </span><span style="color: #0000ff;">if</span> (nums[i - k] &lt;= *mid) ++<span style="color: #000000;">mid;
            ms.erase(ms.lower_bound(nums[i </span>-<span style="color: #000000;"> k]));
        }
    }
};</span></pre>
</div>
<p> </p>
<p>上面的方法用到了很多STL内置的函数，比如next，lower_bound啥的，下面我们来看一种不使用这些函数的解法。这种解法跟<a href="http://www.cnblogs.com/grandyang/p/4896673.html">Find Median from Data Stream</a>那题的解法很类似，都是维护了small和large两个堆，分别保存有序数组的左半段和右半段的数字，保持small的长度大于等于large的长度。我们开始遍历数组nums，如果i&gt;=k，说明此时滑动窗口已经满k个了，再滑动就要删掉最左值了，我们分别在small和large中查找最左值，有的话就删掉。然后处理增加数字的情况（分两种情况：1.如果small的长度小于large的长度，再看如果large是空或者新加的数小于等于large的首元素，我们把此数加入small中。否则就把large的首元素移出并加入small中，然后把新数字加入large。2.如果small的长度大于large，再看如果新数字大于small的尾元素，那么新数字加入large中，否则就把small的尾元素移出并加入large中，把新数字加入small中）。最后我们再计算中位数并加入结果res中，根据k的奇偶性来分别处理，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">double</span>&gt; medianSlidingWindow(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; nums, <span style="color: #0000ff;">int</span><span style="color: #000000;"> k) {
        vector</span>&lt;<span style="color: #0000ff;">double</span>&gt;<span style="color: #000000;"> res;
        multiset</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> small, large;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; nums.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (i &gt;=<span style="color: #000000;"> k) {
                </span><span style="color: #0000ff;">if</span> (small.count(nums[i - k])) small.erase(small.find(nums[i -<span style="color: #000000;"> k]));
                </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (large.count(nums[i - k])) large.erase(large.find(nums[i -<span style="color: #000000;"> k]));
            }
            </span><span style="color: #0000ff;">if</span> (small.size() &lt;=<span style="color: #000000;"> large.size()) {
                </span><span style="color: #0000ff;">if</span> (large.empty() || nums[i] &lt;= *<span style="color: #000000;">large.begin()) small.insert(nums[i]);
                </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    small.insert(</span>*<span style="color: #000000;">large.begin());
                    large.erase(large.begin());
                    large.insert(nums[i]);
                }
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                </span><span style="color: #0000ff;">if</span> (nums[i] &gt;= *<span style="color: #000000;">small.rbegin()) large.insert(nums[i]);
                </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    large.insert(</span>*<span style="color: #000000;">small.rbegin());
                    small.erase(</span>--<span style="color: #000000;">small.end());
                    small.insert(nums[i]);
                }
            }
            </span><span style="color: #0000ff;">if</span> (i &gt;= (k - <span style="color: #800080;">1</span><span style="color: #000000;">)) {
                </span><span style="color: #0000ff;">if</span> (k % <span style="color: #800080;">2</span>) res.push_back(*<span style="color: #000000;">small.rbegin());
                </span><span style="color: #0000ff;">else</span> res.push_back(((<span style="color: #0000ff;">double</span>)*small.rbegin() + *large.begin()) / <span style="color: #800080;">2</span><span style="color: #000000;">);
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4896673.html">Find Median from Data Stream</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4656517.html">Sliding Window Maximum</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/74905/c-o-n-logk-using-two-std-set" target="_blank">https://discuss.leetcode.com/topic/74905/c-o-n-logk-using-two-std-set</a></p>
<p><a href="https://discuss.leetcode.com/topic/75160/easy-to-understand-clean-java-code" target="_blank">https://discuss.leetcode.com/topic/75160/easy-to-understand-clean-java-code</a></p>
<p><a href="https://discuss.leetcode.com/topic/74963/o-n-log-k-c-using-multiset-and-updating-middle-iterator" target="_blank">https://discuss.leetcode.com/topic/74963/o-n-log-k-c-using-multiset-and-updating-middle-iterator</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-03-26 06:05</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=6620334" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(6620334);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7644725.html" id="cb_post_title_url">[LeetCode] Largest Palindrome Product 最大回文串乘积</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="question-description">
<p>Find the largest palindrome made from the product of two n-digit numbers.</p>
<p>Since the result could be very large, you should return the largest palindrome mod 1337.</p>
<p>Example:</p>
<p>Input: 2</p>
<p>Output: 987</p>
<p>Explanation: 99 x 91 = 9009, 9009 % 1337 = 987</p>
<p> </p>
<p>Note:</p>
<p>The range of n is [1,8].</p>
<p> </p>
<p>这道题给我们一个数字n，问两个n位数的乘积组成的最大回文数是多少，返回的结果对1337取余。博主刚开始用暴力搜索做，遍历所有的数字组合，求乘积，再来判断是否是回文数，最终TLE了，只能换一种思路来做。论坛上的这种思路真心叼啊，博主感觉这题绝比不该Easy啊。首先我们还是要确定出n位数的范围，最大值upper，可以取到，最小值lower，不能取到。然后我们遍历这区间的所有数字，对于每个遍历到的数字，我们用当前数字当作回文数的前半段，将其翻转一下拼接到后面，此时组成一个回文数，这里用到了一个规律，当n&gt;1时，两个n位数乘积的最大回文数一定是2n位的。下面我们就要来验证这个回文数能否由两个n位数相乘的来，我们还是遍历区间中的数，从upper开始遍历，但此时结束位置不是lower，而是当前数的平方大于回文数，因为我们遍历的是相乘得到回文数的两个数中的较大数，一旦超过这个范围，就变成较小数了，就重复计算了。比如对于回文数9009，其是由99和91组成的，其较大数的范围是[99,95]，所以当遍历到94时，另一个数至少需要是95，而这种情况在之前已经验证过了。当回文数能整除较大数时，说明是成立的，直接对1337取余返回即可，参见代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> largestPalindrome(<span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        </span><span style="color: #0000ff;">int</span> upper = pow(<span style="color: #800080;">10</span>, n) - <span style="color: #800080;">1</span>, lower = upper / <span style="color: #800080;">10</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = upper; i &gt; lower; --<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">string</span> t =<span style="color: #000000;"> to_string(i);
            </span><span style="color: #0000ff;">long</span> p = stol(t + <span style="color: #0000ff;">string</span><span style="color: #000000;">(t.rbegin(), t.rend()));
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">long</span> j = upper; j * j &gt; p; --<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> (p % j == <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span> p % <span style="color: #800080;">1337</span><span style="color: #000000;">;
            }
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">9</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/74372/an-easy-9-line-java-solution">https://discuss.leetcode.com/topic/74372/an-easy-9-line-java-solution</a></p>
<p><a href="https://discuss.leetcode.com/topic/74125/java-solution-using-assumed-max-palindrom">https://discuss.leetcode.com/topic/74125/java-solution-using-assumed-max-palindrom</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p>
</div></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-10-10 11:32</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7644725" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7644725);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/9741220.html" id="cb_post_title_url">[LeetCode] Generate Random Point in a Circle 生成圆中的随机点</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given the radius and x-y positions of the center of a circle, write a function <code>randPoint</code> which generates a uniform random point in the circle.</p>
<p>Note:</p>
<ol>
<li>input and output values are in <a href="https://www.webopedia.com/TERM/F/floating_point_number.html" target="_blank">floating-point</a>.</li>
<li>radius and x-y position of the center of the circle is passed into the class constructor.</li>
<li>a point on the circumference of the circle is considered to be in the circle.</li>
<li><code>randPoint</code> returns a size 2 array containing x-position and y-position of the random point, in that order.</li>
</ol>
<div>
<p>Example 1:</p>
<pre>Input: 
<span id="example-input-1-1">["Solution","randPoint","randPoint","randPoint"]
<span id="example-input-1-2">[[1,0,0],[],[],[]]
Output: <span id="example-output-1">[null,[-0.72939,-0.65505],[-0.78502,-0.28626],[-0.83119,-0.19803]]
</span></span></span></pre>
<div>
<p>Example 2:</p>
<pre>Input: 
<span id="example-input-2-1">["Solution","randPoint","randPoint","randPoint"]
<span id="example-input-2-2">[[10,5,-7.5],[],[],[]]
Output: <span id="example-output-2">[null,[11.52438,-8.33273],[2.46992,-16.21705],[11.13430,-12.42337]]</span></span></span></pre>
</div>
<p>Explanation of Input Syntax:</p>
<p>The input is two lists: the subroutines called and their arguments. <code>Solution</code>'s constructor has three arguments, the radius, x-position of the center, and y-position of the center of the circle. <code>randPoint</code> has no arguments. Arguments are always wrapped with a list, even if there aren't any.</p>
</div>
<p> </p>
<p>这道题给了我们一个圆，包括中点位置和半径，让我们随机生成圆中的任意一个点。这里说明了圆上也当作是圆中，而且这里的随机意味着要等概率。思绪飘回了高中时代，努力搜索着那一丝丝残留的记忆，终于，我把还给老师的知识又要了回来，圆的方程表示为 (x - a) ^ 2 + (y - b) ^ 2 = r ^ 2，这里的 (a, b) 是圆心位置，r为半径。那么我们想如何生成圆中的任意位置呢，如果用这种方式来生成，那么我们先随机出一个x，那么随机出y的时候还要考虑其是否在圆中间，比较麻烦。继续回到高中时代，模糊的记忆中飘来了三个字，极坐标。是的，圆还可以用极坐标的形式来表示，我们只需随机出一个角度theta，再随机出一个小于半径的长度，这样我们就可以得到圆中的坐标位置了，哦耶～ 那么先来生成theta吧，我们知道一圈是360度，即2pi，所以我们随机出一个 [0, 1] 中的小数，再乘以2pi，就可以了。然后就是随机小于半径的长度，这里有个问题需要注意一下，我们并不是直接随机出一个 [0, 1] 中的小数再乘以半径r，而是要对随机出的[0, 1] 中的小数取个平方根再乘以半径r。这是为啥呢，简单来说，是为了保证等概率。如果不用平方根的话，那么表示圆的时候 (len * cos(theta)) ^ 2 + (len * sin(theta) ^ 2，这里就相当于对随机出的[0, 1] 中的小数平方了，那么其就不是等概率的了，因为两个小于1的小数相乘了，其会更加靠近0，这就是为啥我们要平方一下的原因。最后在求点位置的时候要加上圆心的偏移即可，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    Solution(</span><span style="color: #0000ff;">double</span> radius, <span style="color: #0000ff;">double</span> x_center, <span style="color: #0000ff;">double</span><span style="color: #000000;"> y_center) {
        r </span>= radius; centerX = x_center; centerY =<span style="color: #000000;"> y_center;
    }
    
    vector</span>&lt;<span style="color: #0000ff;">double</span>&gt;<span style="color: #000000;"> randPoint() {
        </span><span style="color: #0000ff;">double</span> theta = <span style="color: #800080;">2</span> * M_PI * ((<span style="color: #0000ff;">double</span>)rand() /<span style="color: #000000;"> RAND_MAX);
        </span><span style="color: #0000ff;">double</span> len = sqrt((<span style="color: #0000ff;">double</span>)rand() / RAND_MAX) *<span style="color: #000000;"> r;
        </span><span style="color: #0000ff;">return</span> {centerX + len * cos(theta), centerY + len *<span style="color: #000000;"> sin(theta)};
    }

</span><span style="color: #0000ff;">private</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">double</span><span style="color: #000000;"> r, centerX, centerY;
};</span></pre>
</div>
<p> </p>
<p>我们也可以不用极坐标来做，由于之前刚做过<a class="link-post-title" href="https://www.cnblogs.com/grandyang/p/9727206.html" id="link_post_title">Implement Rand10() Using Rand7()</a>，对其中的拒绝采样Rejection Sampling还有印象，所以我们也可以用其来做。这其实就是拒绝采样的经典应用，在一个正方形中有均匀分布的点，让我们随机出其内切圆中的一个点，那么就是我们随机出x和y之后，然后算其平方和，如果小于等于r平方，说明其在圆内，我们可以返回其坐标，记得加上圆心偏移，否则我们重新进行采样。关于拒绝采样的方法可以参见我之前那篇博客<a class="link-post-title" href="https://www.cnblogs.com/grandyang/p/9727206.html" id="link_post_title">Implement Rand10() Using Rand7()</a>，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    Solution(</span><span style="color: #0000ff;">double</span> radius, <span style="color: #0000ff;">double</span> x_center, <span style="color: #0000ff;">double</span><span style="color: #000000;"> y_center) {
        r </span>= radius; centerX = x_center; centerY =<span style="color: #000000;"> y_center;
    }
    
    vector</span>&lt;<span style="color: #0000ff;">double</span>&gt;<span style="color: #000000;"> randPoint() {
        </span><span style="color: #0000ff;">while</span> (<span style="color: #0000ff;">true</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">double</span> x = (<span style="color: #800080;">2</span> * (<span style="color: #0000ff;">double</span>)rand() / RAND_MAX - <span style="color: #800080;">1.0</span>) *<span style="color: #000000;"> r;
            </span><span style="color: #0000ff;">double</span> y = (<span style="color: #800080;">2</span> * (<span style="color: #0000ff;">double</span>)rand() / RAND_MAX - <span style="color: #800080;">1.0</span>) *<span style="color: #000000;"> r;
            </span><span style="color: #0000ff;">if</span> (x * x + y * y &lt;= r * r) <span style="color: #0000ff;">return</span> {centerX + x, centerY +<span style="color: #000000;"> y};
        }
    }

</span><span style="color: #0000ff;">private</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">double</span><span style="color: #000000;"> r, centerX, centerY;
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a class="link-post-title" href="https://www.cnblogs.com/grandyang/p/9727206.html" id="link_post_title">Implement Rand10() Using Rand7()</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a href="http://www.cnblogs.com/grandyang/p/4606334.html" target="_blank">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-10-03 23:09</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=9741220" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(9741220);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/6208062.html" id="cb_post_title_url">[LeetCode] Total Hamming Distance 全部汉明距离</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>The <a href="https://en.wikipedia.org/wiki/Hamming_distance" target="_blank">Hamming distance</a> between two integers is the number of positions at which the corresponding bits are different.</p>
<p>Now your job is to find the total Hamming distance between all pairs of the given numbers.</p>
<p>Example:</p>
<pre>Input: 4, 14, 2

Output: 6

Explanation: In binary representation, the 4 is 0100, 14 is 1110, and 2 is 0010 (just
showing the four bits relevant in this case). So the answer will be:
HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.
</pre>
<p> </p>
<p>Note:</p>
<ol>
<li>Elements of the given array are in the range of <code>0 </code>to <code>10^9</code></li>
<li>Length of the array will not exceed <code>10^4</code>.</li>
</ol>
<p> </p>
<p>这道题是之前那道<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/6201215.html" id="homepage1_HomePageDays_DaysList_ctl01_DayList_TitleUrl_0">Hamming Distance</a>的拓展，由于有之前那道题的经验，我们知道需要用异或来求每个位上的情况，那么我们需要来找出某种规律来，比如我们看下面这个例子，4，14，2和1：</p>
<p>4:     0 1 0 0</p>
<p>14:   1 1 1 0</p>
<p>2:     0 0 1 0</p>
<p>1:     0 0 0 1</p>
<p>我们先看最后一列，有三个0和一个1，那么它们之间相互的汉明距离就是3，即1和其他三个0分别的距离累加，然后在看第三列，累加汉明距离为4，因为每个1都会跟两个0产生两个汉明距离，同理第二列也是4，第一列是3。我们仔细观察累计汉明距离和0跟1的个数，我们可以发现其实就是0的个数乘以1的个数，发现了这个重要的规律，那么整道题就迎刃而解了，只要统计出每一位的1的个数即可，参见代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> totalHammingDistance(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, n =<span style="color: #000000;"> nums.size();
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; <span style="color: #800080;">32</span>; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">int</span> cnt = <span style="color: #800080;">0</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span><span style="color: #000000;"> num : nums) {
                </span><span style="color: #0000ff;">if</span> (num &amp; (<span style="color: #800080;">1</span> &lt;&lt; i)) ++<span style="color: #000000;">cnt;
            }
            res </span>+= cnt * (n -<span style="color: #000000;"> cnt);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/6201215.html" id="homepage1_HomePageDays_DaysList_ctl01_DayList_TitleUrl_0">Hamming Distance</a></p>
<p> </p>
<p><a href="http://www.cnblogs.com/grandyang/p/4606334.html" target="_blank">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-12-21 16:08</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=6208062" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(6208062);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/6275742.html" id="cb_post_title_url">[LeetCode] Number Complement 补数</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="row">
<div class="col-md-12">
<div class="row">
<div class="col-md-12">
<div class="question-content">
<p>Given a positive integer, output its complement number. The complement strategy is to flip the bits of its binary representation.</p>
<p>Note:</p>
<ol>
<li>The given integer is guaranteed to fit within the range of a 32-bit signed integer.</li>
<li>You could assume no leading zero bit in the integer’s binary representation.</li>
</ol>
<p> </p>
<p>Example 1:</p>
<pre>Input: 5
Output: 2
Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input: 1
Output: 0
Explanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0.
</pre>
<p> </p>
<p>这道题给了我们一个数，让我们求补数。通过分析题目汇总的例子，我们知道需要做的就是每个位翻转一下就行了，但是翻转的起始位置上从最高位的1开始的，前面的0是不能被翻转的，所以我们从高往低遍历，如果遇到第一个1了后，我们的flag就赋值为true，然后就可以进行翻转了，翻转的方法就是对应位异或一个1即可，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> findComplement(<span style="color: #0000ff;">int</span><span style="color: #000000;"> num) {
        </span><span style="color: #0000ff;">bool</span> start = <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">31</span>; i &gt;= <span style="color: #800080;">0</span>; --<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (num &amp; (<span style="color: #800080;">1</span> &lt;&lt; i)) start = <span style="color: #0000ff;">true</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> (start) num ^= (<span style="color: #800080;">1</span> &lt;&lt;<span style="color: #000000;"> i);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> num;
    }
};</span></pre>
</div>
<p> </p>
<p>由于位操作里面的取反符号～本身就可以翻转位，但是如果直接对num取反的话就是每一位都翻转了，而最高位1之前的0是不能翻转的，所以我们只要用一个mask来标记最高位1前面的所有0的位置，然后对mask取反后，与上对num取反的结果即可，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> findComplement(<span style="color: #0000ff;">int</span><span style="color: #000000;"> num) {
        </span><span style="color: #0000ff;">int</span> mask =<span style="color: #000000;"> INT_MAX;
        </span><span style="color: #0000ff;">while</span> (mask &amp; num) mask &lt;&lt;= <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span> ~mask &amp; ~<span style="color: #000000;">num;
    }
};</span></pre>
</div>
<p> </p>
<p>再来看一种迭代的写法，一行搞定碉堡了，思路就是每次都右移一位，并根据最低位的值先进行翻转，如果当前值小于等于1了，就不用再调用递归函数了，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> findComplement(<span style="color: #0000ff;">int</span><span style="color: #000000;"> num) {
        </span><span style="color: #0000ff;">return</span> (<span style="color: #800080;">1</span> - num % <span style="color: #800080;">2</span>) + <span style="color: #800080;">2</span> * (num &lt;= <span style="color: #800080;">1</span> ? <span style="color: #800080;">0</span> : findComplement(num / <span style="color: #800080;">2</span><span style="color: #000000;">));
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/74627/3-line-c" target="_blank">https://discuss.leetcode.com/topic/74627/3-line-c</a></p>
<p><a href="https://discuss.leetcode.com/topic/74968/simple-java-one-line-solution" target="_blank">https://discuss.leetcode.com/topic/74968/simple-java-one-line-solution</a></p>
<p><a href="https://discuss.leetcode.com/topic/74642/java-1-line-bit-manipulation-solution" target="_blank">https://discuss.leetcode.com/topic/74642/java-1-line-bit-manipulation-solution</a></p>
<p> </p>
</div>
</div>
</div>
</div>
</div>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-01-11 23:55</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=6275742" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(6275742);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/6181626.html" id="cb_post_title_url">[LeetCode] Heaters 加热器</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="row">
<div class="col-md-12">
<div class="row">
<div class="col-md-12">
<div class="question-content">
<p>Winter is coming! Your first job during the contest is to design a standard heater with fixed warm radius to warm all the houses.</p>
<p>Now, you are given positions of houses and heaters on a horizontal line, find out minimum radius of heaters so that all houses could be covered by those heaters.</p>
<p>So, your input will be the positions of houses and heaters seperately, and your expected output will be the minimum radius standard of heaters.</p>
<p>Note:</p>
<ol>
<li>Numbers of houses and heaters you are given are non-negative and will not exceed 25000.</li>
<li>Positions of houses and heaters you are given are non-negative and will not exceed 10^9.</li>
<li>As long as a house is in the heaters' warm radius range, it can be warmed.</li>
<li>All the heaters follow your radius standard and the warm radius will the same.</li>
</ol>
<p> </p>
<p>Example 1:</p>
<pre>Input: [1,2,3],[2]
Output: 1
Explanation: The only heater was placed in the position 2, and if we use the radius 1 standard, then all the houses can be warmed.
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input: [1,2,3,4],[1,4]
Output: 1
Explanation: The two heater was placed in the position 1 and 4. We need to use radius 1 standard, then all the houses can be warmed.
</pre>
<p> </p>
<p>这道题是一道蛮有意思的题目，首先我们看题目中的例子，不管是houses还是heaters数组都是有序的，所以我们也需要给输入的这两个数组先排序，以免其为乱序。我们就拿第二个例子来分析，我们的目标是houses中的每一个数字都要被cover到，那么我们就遍历houses数组，对每一个数组的数字，我们在heaters中找能包含这个数字的左右范围，然后看离左右两边谁近取谁的值，如果某个house位置比heaters中最小的数字还小，那么肯定要用最小的heater去cover，反之如果比最大的数字还大，就用最大的数字去cover。对于每个数字算出的半径，我们要取其中最大的值。通过上面的分析，我们就不难写出代码了，我们在heater中两个数一组进行检查，如果后面一个数和当前house位置差的绝对值小于等于前面一个数和当前house位置差的绝对值，那么我们继续遍历下一个位置的数。跳出循环的条件是遍历到heater中最后一个数，或者上面的小于等于不成立，此时heater中的值和当前house位置的差的绝对值就是能cover当前house的最小半径，我们更新结果res即可，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> findRadius(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; houses, vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> heaters) {
        </span><span style="color: #0000ff;">int</span> n = heaters.size(), j = <span style="color: #800080;">0</span>, res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        sort(houses.begin(), houses.end());
        sort(heaters.begin(), heaters.end());
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; houses.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">int</span> cur =<span style="color: #000000;"> houses[i];
            </span><span style="color: #0000ff;">while</span> (j &lt; n - <span style="color: #800080;">1</span> &amp;&amp; abs(heaters[j + <span style="color: #800080;">1</span>] - cur) &lt;= abs(heaters[j] -<span style="color: #000000;"> cur)) {
                </span>++<span style="color: #000000;">j;
            }
            res </span>= max(res, abs(heaters[j] -<span style="color: #000000;"> cur));
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>还是上面的思路，我们可以用二分查找法来快速找到第一个大于等于当前house位置的数，如果这个数存在，那么我们可以算出其和house的差值，并且如果这个数不是heater的首数字，我们可以算出house和前面一个数的差值，这两个数中取较小的为cover当前house的最小半径，然后我们每次更新结果res即可，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> findRadius(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; houses, vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> heaters) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, n =<span style="color: #000000;"> heaters.size();
        sort(heaters.begin(), heaters.end());
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span><span style="color: #000000;"> house : houses) {
            </span><span style="color: #0000ff;">int</span> left = <span style="color: #800080;">0</span>, right =<span style="color: #000000;"> n;
            </span><span style="color: #0000ff;">while</span> (left &lt;<span style="color: #000000;"> right) {
                </span><span style="color: #0000ff;">int</span> mid = left + (right - left) / <span style="color: #800080;">2</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">if</span> (heaters[mid] &lt; house) left = mid + <span style="color: #800080;">1</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">else</span> right =<span style="color: #000000;"> mid;
            }
            </span><span style="color: #0000ff;">int</span> dist1 = (right == n) ? INT_MAX : heaters[right] -<span style="color: #000000;"> house;
            </span><span style="color: #0000ff;">int</span> dist2 = (right == <span style="color: #800080;">0</span>) ? INT_MAX : house - heaters[right - <span style="color: #800080;">1</span><span style="color: #000000;">];
            res </span>=<span style="color: #000000;"> max(res, min(dist1, dist2));
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>我们可以用STL中的lower_bound来代替二分查找的代码来快速找到第一个大于等于目标值的位置，其余部分均和上面方法相同，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> findRadius(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; houses, vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> heaters) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        sort(heaters.begin(), heaters.end());
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span><span style="color: #000000;"> house : houses) {
            auto pos </span>=<span style="color: #000000;"> lower_bound(heaters.begin(), heaters.end(), house);
            </span><span style="color: #0000ff;">int</span> dist1 = (pos == heaters.end()) ? INT_MAX : *pos -<span style="color: #000000;"> house;
            </span><span style="color: #0000ff;">int</span> dist2 = (pos == heaters.begin()) ? INT_MAX : house - *(--<span style="color: #000000;">pos);
            res </span>=<span style="color: #000000;"> max(res, min(dist1, dist2));
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/71450/simple-java-solution-with-2-pointers" target="_blank">https://discuss.leetcode.com/topic/71450/simple-java-solution-with-2-pointers</a></p>
<p><a href="https://discuss.leetcode.com/topic/71460/short-and-clean-java-binary-search-solution/2" target="_blank">https://discuss.leetcode.com/topic/71460/short-and-clean-java-binary-search-solution/2</a></p>
<p><a href="https://discuss.leetcode.com/topic/71440/c-solution-using-lower_bound-binary-search-with-comments" target="_blank">https://discuss.leetcode.com/topic/71440/c-solution-using-lower_bound-binary-search-with-comments</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p>
</div>
</div>
</div>
</div>
</div></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-12-14 23:45</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=6181626" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(6181626);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/6188893.html" id="cb_post_title_url">[LeetCode] Ones and Zeroes 一和零</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p>  </p>
<div class="row">
<div class="col-md-12">
<div class="row">
<div class="col-md-12">
<div class="question-content">
<p>In the computer world, use restricted resource you have to generate maximum benefit is what we always want to pursue.</p>
<p>For now, suppose you are a dominator of m <code>0s</code> and n <code>1s</code> respectively. On the other hand, there is an array with strings consisting of only <code>0s</code> and <code>1s</code>.</p>
<p>Now your task is to find the maximum number of strings that you can form with given m <code>0s</code> and n <code>1s</code>. Each <code>0</code> and <code>1</code> can be used at most once.</p>
<p>Note:</p>
<ol>
<li>The given numbers of <code>0s</code> and <code>1s</code> will both not exceed <code>100</code></li>
<li>The size of given string array won't exceed <code>600</code>.</li>
</ol>
<p> </p>
<p>Example 1:</p>
<pre>Input: Array = {"10", "0001", "111001", "1", "0"}, m = 5, n = 3
Output: 4

Explanation: This are totally 4 strings can be formed by the using of 5 0s and 3 1s, which are “10,”0001”,”1”,”0”
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input: Array = {"10", "0", "1"}, m = 1, n = 1
Output: 2

Explanation: You could form "10", but then you'd have nothing left. Better form "0" and "1".
</pre>
<p> </p>
<p>这道题是一道典型的应用DP来解的题，如果我们看到这种求总数，而不是列出所有情况的题，十有八九都是用DP来解，重中之重就是在于找出递推式。如果你第一反应没有想到用DP来做，想得是用贪心算法来做，比如先给字符串数组排个序，让长度小的字符串在前面，然后遍历每个字符串，遇到0或者1就将对应的m和n的值减小，这种方法在有的时候是不对的，比如对于{"11", "01", "10"}，m=2，n=2这个例子，我们将遍历完“11”的时候，把1用完了，那么对于后面两个字符串就没法处理了，而其实正确的答案是应该组成后面两个字符串才对。所以我们需要建立一个二维的DP数组，其中dp[i][j]表示有i个0和j个1时能组成的最多字符串的个数，而对于当前遍历到的字符串，我们统计出其中0和1的个数为zeros和ones，然后dp[i - zeros][j - ones]表示当前的i和j减去zeros和ones之前能拼成字符串的个数，那么加上当前的zeros和ones就是当前dp[i][j]可以达到的个数，我们跟其原有数值对比取较大值即可，所以递推式如下：</p>
<p>dp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + 1);</p>
<div>
<div class="btn btn-xs btn-warning" id="company_tags">有了递推式，我们就可以很容易的写出代码如下：</div>
<div class="btn btn-xs btn-warning"> </div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="interviewed-div">
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> findMaxForm(vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp; strs, <span style="color: #0000ff;">int</span> m, <span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; dp(m + <span style="color: #800080;">1</span>, vector&lt;<span style="color: #0000ff;">int</span>&gt;(n + <span style="color: #800080;">1</span>, <span style="color: #800080;">0</span><span style="color: #000000;">));
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">string</span><span style="color: #000000;"> str : strs) {
            </span><span style="color: #0000ff;">int</span> zeros = <span style="color: #800080;">0</span>, ones = <span style="color: #800080;">0</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span> c : str) (c == <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span>) ? ++zeros : ++<span style="color: #000000;">ones;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = m; i &gt;= zeros; --<span style="color: #000000;">i) {
                </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = n; j &gt;= ones; --<span style="color: #000000;">j) {
                    dp[i][j] </span>= max(dp[i][j], dp[i - zeros][j - ones] + <span style="color: #800080;">1</span><span style="color: #000000;">);
                }
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> dp[m][n];
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/5138186.html">Coin Change</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/71438/c-dp-solution-with-comments" target="_blank">https://discuss.leetcode.com/topic/71438/c-dp-solution-with-comments</a></p>
<p><a href="https://discuss.leetcode.com/topic/71417/java-iterative-dp-solution-o-mn-space" target="_blank">https://discuss.leetcode.com/topic/71417/java-iterative-dp-solution-o-mn-space</a></p>
</div>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-12-16 23:53</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=6188893" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(6188893);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/6238425.html" id="cb_post_title_url">[LeetCode] Matchsticks to Square 火柴棍组成正方形</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Remember the story of Little Match Girl? By now, you know exactly what matchsticks the little match girl has, please find out a way you can make one square by using up all those matchsticks. You should not break any stick, but you can link them up, and each matchstick must be used exactly one time.</p>
<p>Your input will be several matchsticks the girl has, represented with their stick length. Your output will either be true or false, to represent whether you could make one square using all the matchsticks the little match girl has.</p>
<p>Example 1:</p>
<pre>Input: [1,1,2,2,2]
Output: true

Explanation: You can form a square with length 2, one side of the square came two sticks with length 1.
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input: [3,3,3,3,4]
Output: false

Explanation: You cannot find a way to form a square with all the matchsticks.
</pre>
<p> </p>
<p>Note:</p>
<ol>
<li>The length sum of the given matchsticks is in the range of <code>0</code> to <code>10^9</code>.</li>
<li>The length of the given matchstick array will not exceed <code>15</code>.</li>
</ol>
<p> </p>
<p>我已经服了LeetCode了，连卖火柴的小女孩也能改编成题目，还能不能愉快的玩耍了，坐等灰姑娘，丑小鸭的改编题了。好了，言归正传，这道题让我们用数组中的数字来摆出一个正方形。跟之前有道题<a href="http://www.cnblogs.com/grandyang/p/5951422.html">Partition Equal Subset Sum</a>有点像，那道题问我们能不能将一个数组分成和相等的两个子数组，而这道题实际上是让我们将一个数组分成四个和相等的子数组。我一开始尝试着用那题的解法来做，首先来判断数组之和是否是4的倍数，然后还是找能否分成和相等的两个子数组，但是在遍历的时候加上判断如果数组中某一个数字大于一条边的长度时返回false。最后我们同时检查dp数组中一条边长度位置上的值跟两倍多一条边长度位置上的值是否为true，这种方法不幸TLE了。所以只能上论坛求助各路大神了，发现了可以用优化过的递归来解，递归的方法基本上等于brute force，但是C++版本的直接递归没法通过OJ，而是要先给数组从大到小的顺序排序，这样大的数字先加，如果超过target了，就直接跳过了后面的再次调用递归的操作，效率会提高不少，所以会通过OJ。下面来看代码，我们建立一个长度为4的数组sums来保存每个边的长度和，我们希望每条边都等于target，数组总和的四分之一。然后我们遍历sums中的每条边，我们判断如果加上数组中的当前数字大于target，那么我们跳过，如果没有，我们就加上这个数字，然后对数组中下一个位置调用递归，如果返回为真，我们返回true，否则我们再从sums中对应位置将这个数字减去继续循环，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> makesquare(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        </span><span style="color: #0000ff;">if</span> (nums.empty() || nums.size() &lt; <span style="color: #800080;">4</span>) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> sum = accumulate(nums.begin(), nums.end(), <span style="color: #800080;">0</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">if</span> (sum % <span style="color: #800080;">4</span> != <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; sums(<span style="color: #800080;">4</span>, <span style="color: #800080;">0</span><span style="color: #000000;">);
        sort(nums.rbegin(), nums.rend());
        </span><span style="color: #0000ff;">return</span> helper(nums, sums, <span style="color: #800080;">0</span>, sum / <span style="color: #800080;">4</span><span style="color: #000000;">);
    }
    </span><span style="color: #0000ff;">bool</span> helper(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; nums, vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; sums, <span style="color: #0000ff;">int</span> pos, <span style="color: #0000ff;">int</span><span style="color: #000000;"> target) {
        </span><span style="color: #0000ff;">if</span> (pos &gt;=<span style="color: #000000;"> nums.size()) {
            </span><span style="color: #0000ff;">return</span> sums[<span style="color: #800080;">0</span>] == target &amp;&amp; sums[<span style="color: #800080;">1</span>] == target &amp;&amp; sums[<span style="color: #800080;">2</span>] ==<span style="color: #000000;"> target;
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; <span style="color: #800080;">4</span>; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (sums[i] + nums[pos] &gt; target) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
            sums[i] </span>+=<span style="color: #000000;"> nums[pos];
            </span><span style="color: #0000ff;">if</span> (helper(nums, sums, pos + <span style="color: #800080;">1</span>, target)) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
            sums[i] </span>-=<span style="color: #000000;"> nums[pos];
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>其实这题还有迭代的方法，很巧妙的利用到了位操作的特性，前面的基本求和跟判断还是一样，然后建立一个变量all，初始化为(1 &lt;&lt; n) - 1，这是什么意思呢，all其实是一个mask，数组中有多少个数字，all就有多少个1，表示全选所有的数字，然后变量target表示一条边的长度。我们建立两个一位向量masks和validHalf，其中masks保存和target相等的几个数字位置的mask，validHalf保存某个mask是否是总和的一半。然后我们从0遍历到all，实际上就是遍历所有子数组，然后我们根据mask来计算出子数组的和，注意这里用了15，而不是32，因为题目中说了数组元素个数不会超过15个。我们算出的子数组之和如果等于一条边的长度target，我们遍历masks数组中其他等于target的子数组，如果两个mask相与不为0，说明有公用的数字，直接跳过；否则将两个mask或起来，说明我们当前选的数字之和为数组总和的一半，更新validHalf的对应位置，然后我们通过all取出所有剩下的数组，并在validHalf里查找，如果也为true，说明我们成功的找到了四条边，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> makesquare(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        </span><span style="color: #0000ff;">if</span> (nums.empty() || nums.size() &lt; <span style="color: #800080;">4</span>) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> sum = accumulate(nums.begin(), nums.end(), <span style="color: #800080;">0</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">if</span> (sum % <span style="color: #800080;">4</span> != <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> n = nums.size(), all = (<span style="color: #800080;">1</span> &lt;&lt; n) - <span style="color: #800080;">1</span>, target = sum / <span style="color: #800080;">4</span><span style="color: #000000;">;
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; masks, validHalf(<span style="color: #800080;">1</span> &lt;&lt; n, <span style="color: #0000ff;">false</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt;= all; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">int</span> curSum = <span style="color: #800080;">0</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt;= <span style="color: #800080;">15</span>; ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> ((i &gt;&gt; j) &amp; <span style="color: #800080;">1</span>) curSum +=<span style="color: #000000;"> nums[j];
            }
            </span><span style="color: #0000ff;">if</span> (curSum ==<span style="color: #000000;"> target) {
                </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span><span style="color: #000000;"> mask : masks) {
                    </span><span style="color: #0000ff;">if</span> ((mask &amp; i) != <span style="color: #800080;">0</span>) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">int</span> half = mask |<span style="color: #000000;"> i;
                    validHalf[half] </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">if</span> (validHalf[all ^ half]) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                }
                masks.push_back(i);
            }
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/5951422.html">Partition Equal Subset Sum</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/72107/java-dfs-solution-with-explanation" target="_blank">https://discuss.leetcode.com/topic/72107/java-dfs-solution-with-explanation</a></p>
<p><a href="https://discuss.leetcode.com/topic/72232/c-bit-masking-dp-solution-with-detailed-comments" target="_blank">https://discuss.leetcode.com/topic/72232/c-bit-masking-dp-solution-with-detailed-comments</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-12-30 22:07</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=6238425" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(6238425);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/6254527.html" id="cb_post_title_url">[LeetCode] Concatenated Words 连接的单词</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a list of words (without duplicates), please write a program that returns all concatenated words in the given list of words.</p>
<p>A concatenated word is defined as a string that is comprised entirely of at least two shorter words in the given array.</p>
<p>Example:</p>
<pre>Input: ["cat","cats","catsdogcats","dog","dogcatsdog","hippopotamuses","rat","ratcatdogcat"]

Output: ["catsdogcats","dogcatsdog","ratcatdogcat"]

Explanation: "catsdogcats" can be concatenated by "cats", "dog" and "cats"; <br/> "dogcatsdog" can be concatenated by "dog", "cats" and "dog"; <br/>"ratcatdogcat" can be concatenated by "rat", "cat", "dog" and "cat".
</pre>
<p> </p>
<p>Note:</p>
<ol>
<li>The number of elements of the given array will not exceed <code>10,000</code></li>
<li>The length sum of elements in the given array will not exceed <code>600,000</code>.</li>
<li>All the input string will only include lower case letters.</li>
<li>The returned elements order does not matter.</li>
</ol>
<p> </p>
<p>这道题给了一个由单词组成的数组，某些单词是可能由其他的单词组成的，让我们找出所有这样的单词。这道题跟之前那道<a href="http://www.cnblogs.com/grandyang/p/4257740.html" target="_blank">Word Break</a>十分类似，我们可以对每一个单词都调用之前那题的方法，我们首先把所有单词都放到一个unordered_set中，这样可以快速找到某个单词是否在数组中存在。对于当前要判断的单词，我们先将其从set中删去，然后调用之前的<a href="http://www.cnblogs.com/grandyang/p/4257740.html" target="_blank">Word Break</a>的解法，具体讲解可以参见之前的帖子。如果是可以拆分，那么我们就存入结果res中，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; findAllConcatenatedWordsInADict(vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp;<span style="color: #000000;"> words) {
        </span><span style="color: #0000ff;">if</span> (words.size() &lt;= <span style="color: #800080;">2</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;"> {};
        vector</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> res;
        unordered_set</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> dict(words.begin(), words.end());
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">string</span><span style="color: #000000;"> word : words) {
            dict.erase(word);
            </span><span style="color: #0000ff;">int</span> len =<span style="color: #000000;"> word.size();
            </span><span style="color: #0000ff;">if</span> (len == <span style="color: #800080;">0</span>) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
            vector</span>&lt;<span style="color: #0000ff;">bool</span>&gt; v(len + <span style="color: #800080;">1</span>, <span style="color: #0000ff;">false</span><span style="color: #000000;">);
            v[</span><span style="color: #800080;">0</span>] = <span style="color: #0000ff;">true</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; len + <span style="color: #800080;">1</span>; ++<span style="color: #000000;">i) {
                </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; i; ++<span style="color: #000000;">j) {
                    </span><span style="color: #0000ff;">if</span> (v[j] &amp;&amp; dict.count(word.substr(j, i -<span style="color: #000000;"> j))) {
                        v[i] </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    }
                }
            }
            </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (v.back()) res.push_back(word);
            dict.insert(word);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种方法跟上面的方法很类似，不同的是判断每个单词的时候不用将其移除set，而是在判断的过程中加了判断，使其不会判断单词本身是否在集合set中存在，而且由于对单词中子字符串的遍历顺序不同，加了一些优化在里面，使得其运算速度更快一些，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; findAllConcatenatedWordsInADict(vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp;<span style="color: #000000;"> words) {
        vector</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> res;
        unordered_set</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> dict(words.begin(), words.end());
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">string</span><span style="color: #000000;"> word : words) {
            </span><span style="color: #0000ff;">int</span> n =<span style="color: #000000;"> word.size();
            </span><span style="color: #0000ff;">if</span> (n == <span style="color: #800080;">0</span>) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
            vector</span>&lt;<span style="color: #0000ff;">bool</span>&gt; dp(n + <span style="color: #800080;">1</span>, <span style="color: #0000ff;">false</span><span style="color: #000000;">);
            dp[</span><span style="color: #800080;">0</span>] = <span style="color: #0000ff;">true</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
                </span><span style="color: #0000ff;">if</span> (!dp[i]) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = i + <span style="color: #800080;">1</span>; j &lt;= n; ++<span style="color: #000000;">j) {
                    </span><span style="color: #0000ff;">if</span> (j - i &lt; n &amp;&amp; dict.count(word.substr(i, j -<span style="color: #000000;"> i))) {
                        dp[j] </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                    }
                }
                </span><span style="color: #0000ff;">if</span> (dp[n]) {res.push_back(word); <span style="color: #0000ff;">break</span><span style="color: #000000;">;}
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种方法是递归的写法，其中递归函数中的cnt表示有其他单词组成的个数，至少得由其他两个单词组成才符合题意，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; findAllConcatenatedWordsInADict(vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp;<span style="color: #000000;"> words) {
        vector</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> res;
        unordered_set</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> dict(words.begin(), words.end());
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">string</span><span style="color: #000000;"> word : words) {
            </span><span style="color: #0000ff;">if</span> (word.empty()) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> (helper(word, dict, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span><span style="color: #000000;">)) {
                res.push_back(word);
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">bool</span> helper(<span style="color: #0000ff;">string</span>&amp; word, unordered_set&lt;<span style="color: #0000ff;">string</span>&gt;&amp; dict, <span style="color: #0000ff;">int</span> pos, <span style="color: #0000ff;">int</span><span style="color: #000000;"> cnt) {
        </span><span style="color: #0000ff;">if</span> (pos &gt;= word.size() &amp;&amp; cnt &gt;= <span style="color: #800080;">2</span>) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt;= (<span style="color: #0000ff;">int</span>)word.size() - pos; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">string</span> t =<span style="color: #000000;"> word.substr(pos, i);
            </span><span style="color: #0000ff;">if</span> (dict.count(t) &amp;&amp; helper(word, dict, pos + i, cnt + <span style="color: #800080;">1</span><span style="color: #000000;">)) {
                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
            }
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4257740.html" target="_blank">Word Break</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/72393/c-772-ms-dp-solution" target="_blank">https://discuss.leetcode.com/topic/72393/c-772-ms-dp-solution</a></p>
<p><a href="https://discuss.leetcode.com/topic/72433/c-600ms-20-lines-of-code-dfs-solution-is-there-any-way-to-optimize" target="_blank">https://discuss.leetcode.com/topic/72433/c-600ms-20-lines-of-code-dfs-solution-is-there-any-way-to-optimize</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-01-05 23:59</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=6254527" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(6254527);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/6194403.html" id="cb_post_title_url">[LeetCode] Encode String with Shortest Length 最短长度编码字符串</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a <strong>non-empty</strong> string, encode the string such that its encoded length is the shortest.</p>
<p>The encoding rule is: <code>k[encoded_string]</code>, where the <em>encoded_string</em> inside the square brackets is being repeated exactly <em>k</em> times.</p>
<p><strong>Note:</strong><br/>
</p>
<ol>
<li><em>k</em> will be a positive integer and encoded string will not be empty or have extra space.</li>
<li>You may assume that the input string contains only lowercase English letters. The string's length is at most 160.</li>
<li>If an encoding process does not make the string shorter, then do not
 encode it. If there are several solutions, return any of them is fine.</li>
</ol>
<p><strong>Example 1:</strong>
</p>
<pre>Input: "aaa"
Output: "aaa"
Explanation: There is no way to encode it such that it is shorter than the input string, so we do not encode it.
</pre>
<p><strong>Example 2:</strong></p>
<pre>Input: "aaaaa"
Output: "5[a]"
Explanation: "5[a]" is shorter than "aaaaa" by 1 character.
</pre>
<p><strong>Example 3:</strong></p>
<pre>Input: "aaaaaaaaaa"
Output: "10[a]"
Explanation: "a9[a]" or "9[a]a" are also valid solutions, both of them have the same length = 5, which is the same as "10[a]".
</pre>
<p><strong>Example 4:</strong></p>
<pre>Input: "aabcaabcd"
Output: "2[aabc]d"
Explanation: "aabc" occurs twice, so one answer can be "2[aabc]d".
</pre>
<p><strong>Example 5:</strong></p>
<pre>Input: "abbbabbbcabbbabbbc"
Output: "2[2[abbb]c]"
Explanation: "abbbabbbc" occurs twice, but "abbbabbbc" can also be encoded to "2[abbb]c", so one answer can be "2[2[abbb]c]".
</pre>
<div> </div>
<div>这道题让我们压缩字符串，把相同的字符串用中括号括起来，然后在前面加上出现的次数，感觉还是一道相当有难度的题呢。参考了网上大神的帖子才弄懂该怎么做，这道题还是应该用DP来做。我们建立一个二维的DP数组，其中dp[i][j]表示s在[i, j]范围内的字符串的缩写形式(如果缩写形式长度大于子字符串，那么还是保留子字符串)，那么如果s字符串的长度是n，最终我们需要的结果就保存在dp[0][n-1]中，然后我们需要遍历s的所有子字符串，对于任意一段子字符串[i, j]，我们\\我们以中间任意位置k来拆分成两段，比较dp[i][k]加上dp[k+1][j]的总长度和dp[i][j]的长度，将长度较小的字符串赋给dp[i][j]，然后我们要做的就是在s中取出[i, j]范围内的子字符串t进行合并。合并的方法是我们在取出的字符串t后面再加上一个t，然后在这里面寻找子字符串t的第二个起始位置，如果第二个起始位置小于t的长度的话，说明t包含重复字符串，举个例子吧，比如 t = "abab", 那么t+t = "abababab"，我们在里面找第二个t出现的位置为2，小于t的长度4，说明t中有重复出现，重复的个数为t.size()/pos = 2个，那么我们就要把重复的地方放入中括号中，注意中括号里不能直接放这个子字符串，而是应该从dp中取出对应位置的字符串，因为重复的部分有可能已经写成缩写形式了，比如题目中的例子5。再看一个例子，如果t = "abc"，那么t+t = "abcabc"，我们在里面找第二个t出现的位置为3，等于t的长度3，说明t中没有重复出现，那么replace就还是t。然后我们比较我们得到的replace和dp[i][j]中的字符串长度，把长度较小的赋给dp[i][j]即可，时间复杂度为O(n<sup>3</sup>)，空间复杂度为O(n<sup>2</sup>)，参见代码如下：</div>
<div> </div>
<div>解法一：</div>
<div>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> encode(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        </span><span style="color: #0000ff;">int</span> n =<span style="color: #000000;"> s.size();
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">string</span>&gt;&gt; dp(n, vector&lt;<span style="color: #0000ff;">string</span>&gt;(n, <span style="color: #800000;">""</span><span style="color: #000000;">));
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> step = <span style="color: #800080;">1</span>; step &lt;= n; ++<span style="color: #000000;">step) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i + step - <span style="color: #800080;">1</span> &lt; n; ++<span style="color: #000000;">i) {
                </span><span style="color: #0000ff;">int</span> j = i + step - <span style="color: #800080;">1</span><span style="color: #000000;">;
                dp[i][j] </span>=<span style="color: #000000;"> s.substr(i, step);
                </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> k = i; k &lt; j; ++<span style="color: #000000;">k) {
                    </span><span style="color: #0000ff;">string</span> left = dp[i][k], right = dp[k + <span style="color: #800080;">1</span><span style="color: #000000;">][j];
                    </span><span style="color: #0000ff;">if</span> (left.size() + right.size() &lt;<span style="color: #000000;"> dp[i][j].size()) {
                        dp[i][j] </span>= left +<span style="color: #000000;"> right;
                    }
                }
                </span><span style="color: #0000ff;">string</span> t = s.substr(i, j - i + <span style="color: #800080;">1</span>), replace = <span style="color: #800000;">""</span><span style="color: #000000;">;
                auto pos </span>= (t + t).find(t, <span style="color: #800080;">1</span><span style="color: #000000;">);
                </span><span style="color: #0000ff;">if</span> (pos &gt;= t.size()) replace =<span style="color: #000000;"> t;
                </span><span style="color: #0000ff;">else</span> replace = to_string(t.size() / pos) + <span style="color: #800000;">'</span><span style="color: #800000;">[</span><span style="color: #800000;">'</span> + dp[i][i + pos - <span style="color: #800080;">1</span>] + <span style="color: #800000;">'</span><span style="color: #800000;">]</span><span style="color: #800000;">'</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">if</span> (replace.size() &lt; dp[i][j].size()) dp[i][j] =<span style="color: #000000;"> replace;
            }
        }
        </span><span style="color: #0000ff;">return</span> dp[<span style="color: #800080;">0</span>][n - <span style="color: #800080;">1</span><span style="color: #000000;">];
    }
};</span></pre>
</div>
<p> </p>
<p>根据热心网友iffalse的留言，我们可以优化上面的方法。如果t是重复的，是不是就不需要再看left.size() + right.size() &lt; dp[i][j].size()了。例如t是abcabcabcabcabc, 最终肯定是5[abc]，不需要再看3[abc]+abcabc或者abcabc+3[abc]。对于一个本身就重复的字符串，最小的长度肯定是n[REPEATED]，不会是某个left+right。所以应该把k的那个循环放在t和replace那部分代码的后面。这样的确提高了一些运算效率的，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> encode(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        </span><span style="color: #0000ff;">int</span> n =<span style="color: #000000;"> s.size();
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">string</span>&gt;&gt; dp(n, vector&lt;<span style="color: #0000ff;">string</span>&gt;(n, <span style="color: #800000;">""</span><span style="color: #000000;">));
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> step = <span style="color: #800080;">1</span>; step &lt;= n; ++<span style="color: #000000;">step) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i + step - <span style="color: #800080;">1</span> &lt; n; ++<span style="color: #000000;">i) {
                </span><span style="color: #0000ff;">int</span> j = i + step - <span style="color: #800080;">1</span><span style="color: #000000;">;
                dp[i][j] </span>=<span style="color: #000000;"> s.substr(i, step);
                </span><span style="color: #0000ff;">string</span> t = s.substr(i, j - i + <span style="color: #800080;">1</span>), replace = <span style="color: #800000;">""</span><span style="color: #000000;">;
                auto pos </span>= (t + t).find(t, <span style="color: #800080;">1</span><span style="color: #000000;">);
                </span><span style="color: #0000ff;">if</span> (pos &lt;<span style="color: #000000;"> t.size()) {
                    replace </span>= to_string(t.size() / pos) + <span style="color: #800000;">"</span><span style="color: #800000;">[</span><span style="color: #800000;">"</span> + dp[i][i + pos - <span style="color: #800080;">1</span>] + <span style="color: #800000;">"</span><span style="color: #800000;">]</span><span style="color: #800000;">"</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">if</span> (replace.size() &lt; dp[i][j].size()) dp[i][j] =<span style="color: #000000;"> replace;
                    </span><span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                }
                </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> k = i; k &lt; j; ++<span style="color: #000000;">k) {
                    </span><span style="color: #0000ff;">string</span> left = dp[i][k], right = dp[k + <span style="color: #800080;">1</span><span style="color: #000000;">][j];
                    </span><span style="color: #0000ff;">if</span> (left.size() + right.size() &lt;<span style="color: #000000;"> dp[i][j].size()) {
                        dp[i][j] </span>= left +<span style="color: #000000;"> right;
                    }
                }
            }
        }
        </span><span style="color: #0000ff;">return</span> dp[<span style="color: #800080;">0</span>][n - <span style="color: #800080;">1</span><span style="color: #000000;">];
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/5849037.html">Decode String</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/8667239.html" target="_blank">Number of Atoms</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a> </p>
</div></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-12-18 14:12</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=6194403" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(6194403);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/9727206.html" id="cb_post_title_url">[LeetCode] Implement Rand10() Using Rand7() 使用Rand7()来实现Rand10()</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a function <code>rand7</code> which generates a uniform random integer in the range 1 to 7, write a function <code>rand10</code> which generates a uniform random integer in the range 1 to 10.</p>
<p>Do NOT use system's <code>Math.random()</code>.</p>
<p> </p>
<div>
<p>Example 1:</p>
<pre>Input: <span id="example-input-1-1">1
Output: <span id="example-output-1">[7]
</span></span></pre>
<div>
<p>Example 2:</p>
<pre>Input: <span id="example-input-2-1">2
Output: <span id="example-output-2">[8,4]
</span></span></pre>
<div>
<p>Example 3:</p>
<pre>Input: <span id="example-input-3-1">3
Output: <span id="example-output-3">[8,1,10]
</span></span></pre>
<p> </p>
<p>Note:</p>
<ol>
<li><code>rand7</code> is predefined.</li>
<li>Each testcase has one argument: <code>n</code>, the number of times that <code>rand10</code> is called.</li>
</ol>
<p> </p>
<p>Follow up:</p>
<ol>
<li>What is the <a href="https://en.wikipedia.org/wiki/Expected_value" target="_blank">expected value</a> for the number of calls to <code>rand7()</code> function?</li>
<li>Could you minimize the number of calls to <code>rand7()</code>?</li>
</ol></div>
</div>
</div>
<p> </p>
<p>这道题给了我们一个随机生成 [1, 7] 内数字的函数rand7()，让我们利用其来生成一个能随机生成 [1, 10] 内数字的函数rand10()，注意这里的随机生成的意思是等概率生成范围内的数字。这是一道很有意思的题目，由于rand7()只能生成1到7之间的数字，所以8，9，10这三个没法生成，那么怎么办？大多数人可能第一个想法就是，再用一个呗，然后把两次的结果加起来，范围不就扩大了么，扩大成了 [2, 14] 之间，然后我们如果再减去1，范围不就是[1, 13]了么。想法不错，但是有个问题，这个范围内的每个数字生成的概率不是都相等的，为啥这么说呢，我们来举个简单的例子看下，就比如说rand2()，那么我们知道其可以生成两个数字1和2，且每个的概率都是1/2。那么对于 (rand2() - 1) + rand2()呢，我们看一下：</p>
<div class="cnblogs_code">
<pre>rand2() - <span style="color: #800080;">1</span> + rand()<span style="color: #800080;">2</span>  =   ?
   <span style="color: #800080;">1</span>            <span style="color: #800080;">1</span>          <span style="color: #800080;">1</span>
   <span style="color: #800080;">1</span>            <span style="color: #800080;">2</span>          <span style="color: #800080;">2</span>
   <span style="color: #800080;">2</span>            <span style="color: #800080;">1</span>          <span style="color: #800080;">2</span>
   <span style="color: #800080;">2</span>            <span style="color: #800080;">2</span>          <span style="color: #800080;">3</span></pre>
</div>
<p>我们发现，生成数字范围 [1, 3] 之间的数字并不是等概率大，其中2出现的概率为1/2，1和3分别为1/4。那么这就不随机了。问题出在哪里了呢，如果直接相加，那么不同组合可能会产生相同的数字，比如 1+2 和 2+1 都是3。所以我们需要给第一个rand2() 升一个维度，让其乘上一个数字，再相加。比如对于 (rand2() - 1) * 2 + rand2()，如下：</p>
<div class="cnblogs_code">
<pre>（rand2() - <span style="color: #800080;">1</span>） * <span style="color: #800080;">2</span> + rand()<span style="color: #800080;">2</span>  =   ?
     <span style="color: #800080;">1</span>                  <span style="color: #800080;">1</span>         <span style="color: #800080;">1</span>
     <span style="color: #800080;">1</span>                  <span style="color: #800080;">2</span>         <span style="color: #800080;">2</span>
     <span style="color: #800080;">2</span>                  <span style="color: #800080;">1</span>         <span style="color: #800080;">3</span>
     <span style="color: #800080;">2</span>                  <span style="color: #800080;">2</span>         <span style="color: #800080;">4</span></pre>
</div>
<p>这时右边生成的1，2，3，4就是等概率出现的了。这样我们就通过使用rand2()，来生成rand4()了。那么反过来想一下，我们可以通过rand4()来生成rand2()，其实更加简单，我们只需通过 rand4() % 2 + 1 即可，如下：</p>
<div class="cnblogs_code">
<pre>rand4() % <span style="color: #800080;">2</span> + <span style="color: #800080;">1</span> =  ?
   <span style="color: #800080;">1</span>               <span style="color: #800080;">2</span>
   <span style="color: #800080;">2</span>               <span style="color: #800080;">1</span>
   <span style="color: #800080;">3</span>               <span style="color: #800080;">2</span>
   <span style="color: #800080;">4</span>               <span style="color: #800080;">1</span></pre>
</div>
<p>同理，我们也可以通过 rand6() 来生成 rand2()，我们只需通过 rand6() % 2 + 1 即可，如下：</p>
<div class="cnblogs_code">
<pre> rand6() % <span style="color: #800080;">2</span> + <span style="color: #800080;">1</span> =  ?
   <span style="color: #800080;">1</span>               <span style="color: #800080;">2</span>
   <span style="color: #800080;">2</span>               <span style="color: #800080;">1</span>
   <span style="color: #800080;">3</span>               <span style="color: #800080;">2</span>
   <span style="color: #800080;">4</span>               <span style="color: #800080;">1</span>
   <span style="color: #800080;">5</span>               <span style="color: #800080;">2</span>
   <span style="color: #800080;">6</span>               <span style="color: #800080;">1</span></pre>
</div>
<p>所以，回到这道题，我们可以先凑出 rand10*N()，然后再通过 rand10*N() % 10 + 1 来获得rand10()。那么，我们只需要将rand7()转化为rand10*N()即可，根据前面的讲解，我们转化也必须要保持等概率，那么就可以变化为 (rand7() - 1) * 7 + rand7()，就转为了 rand49()。但是49不是10的倍数，不过49包括好几个10的倍数，比如40，30，20，10等。这里，我们需要把rand49() 转为 rand40()，需要用到<a href="https://en.wikipedia.org/wiki/Rejection_sampling" target="_blank">拒绝采样Rejection Sampling</a>，总感觉名字很奇怪，之前都没有听说过这个采样方法，刷题也是个不停学习新东西的过程呢。简单来说，这种采样方法就是随机到需要的数字就接受，不是需要的就拒绝，并重新采样，这样还能保持等概率，具体的证明这里就不讲解了，博主也不会，有兴趣的童鞋们可以去Google一下～ 这里我们直接用结论就好啦，当我们用 rand49() 生成一个 [1, 49] 范围内的随机数，如果其在 [1, 40] 范围内，我们就将其转为rand10()范围内的数字，直接对10去余并加1，返回即可。如果不是，则继续循环即可，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> rand10() {
        </span><span style="color: #0000ff;">while</span> (<span style="color: #0000ff;">true</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">int</span> num = (rand7() - <span style="color: #800080;">1</span>) * <span style="color: #800080;">7</span> +<span style="color: #000000;"> rand7();
            </span><span style="color: #0000ff;">if</span> (num &lt;= <span style="color: #800080;">40</span>) <span style="color: #0000ff;">return</span> num % <span style="color: #800080;">10</span> + <span style="color: #800080;">1</span><span style="color: #000000;">;
        }
    }
};</span></pre>
</div>
<p> </p>
<p>我们可以不用while循环，而采用调用递归函数，从而两行就搞定，叼不叼～</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> rand10() {
        </span><span style="color: #0000ff;">int</span> num = (rand7() - <span style="color: #800080;">1</span>) * <span style="color: #800080;">7</span> +<span style="color: #000000;"> rand7();
        </span><span style="color: #0000ff;">return</span> (num &lt;= <span style="color: #800080;">40</span>) ? (num % <span style="color: #800080;">10</span> + <span style="color: #800080;">1</span><span style="color: #000000;">) : rand10();
    }
};</span></pre>
</div>
<p> </p>
<p>我们还可以对上面的解法进行一下优化，因为说实话在 [1, 49] 的范围内随机到 [41, 49] 内的数字概率还是挺高的，我们可以做进一步的处理，就是当循环到这九个数字的时候，我们不重新采样，而是做进一步的处理，我们将采样到的数字减去40，这样就相当于有了个 rand9()，那么我们通过 (rand9() - 1) * 7 + rand7()，可以变成rand63()，对 rand63() 进行拒绝采样，得到 rand60()，从而又可以得到 rand10()了，此时还会多余出3个数字，[61, 63]，我们通过减去60，得到 rand3()，再通过变换 (rand3() - 1) * 7 + rand7() 得到 rand21()，此时再次调用拒绝采样，得到 rand20()，进而得到 rand10()，此时就只多余出一个21，重复整个循环的概率就变的很小了，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> rand10() {
        </span><span style="color: #0000ff;">while</span> (<span style="color: #0000ff;">true</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">int</span> a = rand7(), b =<span style="color: #000000;"> rand7();
            </span><span style="color: #0000ff;">int</span> num = (a - <span style="color: #800080;">1</span>) * <span style="color: #800080;">7</span> +<span style="color: #000000;"> b;
            </span><span style="color: #0000ff;">if</span> (num &lt;= <span style="color: #800080;">40</span>) <span style="color: #0000ff;">return</span> num % <span style="color: #800080;">10</span> + <span style="color: #800080;">1</span><span style="color: #000000;">;
            a </span>= num - <span style="color: #800080;">40</span>, b =<span style="color: #000000;"> rand7();
            num </span>= (a - <span style="color: #800080;">1</span>) * <span style="color: #800080;">7</span> +<span style="color: #000000;"> b;
            </span><span style="color: #0000ff;">if</span> (num &lt;= <span style="color: #800080;">60</span>) <span style="color: #0000ff;">return</span> num % <span style="color: #800080;">10</span> + <span style="color: #800080;">1</span><span style="color: #000000;">;
            a </span>= num - <span style="color: #800080;">60</span>, b =<span style="color: #000000;"> rand7();
            num </span>= (a - <span style="color: #800080;">1</span>) * <span style="color: #800080;">7</span> +<span style="color: #000000;"> b;
            </span><span style="color: #0000ff;">if</span> (num &lt;= <span style="color: #800080;">20</span>) <span style="color: #0000ff;">return</span> num % <span style="color: #800080;">10</span> + <span style="color: #800080;">1</span><span style="color: #000000;">;
        }
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/9741220.html" id="homepage1_HomePageDays_DaysList_ctl01_DayList_TitleUrl_0">Generate Random Point in a Circle</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a href="http://www.cnblogs.com/grandyang/p/4606334.html" target="_blank">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-09-30 00:00</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=9727206" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(9727206);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/6146986.html" id="cb_post_title_url">[LeetCode] Convex Polygon 凸多边形</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a list of points that form a polygon when joined sequentially, find if this polygon is convex <a href="https://en.wikipedia.org/wiki/Convex_polygon" target="_blank">(Convex polygon definition)</a>.</p>
<p><strong>Note:</strong></p>
<ol>
<li>There are at least 3 and at most 10,000 points.</li>
<li>Coordinates are in the range -10,000 to 10,000.</li>
<li>You may assume the polygon formed by given points is always a simple polygon<a href="https://en.wikipedia.org/wiki/Simple_polygon" target="_blank"> (Simple polygon definition)</a>. In other words, we ensure that exactly two edges intersect at each vertex, and that edges otherwise <strong>don't intersect each other</strong>.</li>
</ol>
<p><strong>Example 1:</strong></p>
<pre>[[0,0],[0,1],[1,1],[1,0]]

Answer: True

Explanation:</pre>
<p><img alt="" height="100" src="https://leetcode.com/static/images/problemset/polygon_convex.png" width="100"/></p>
<p><strong>Example 2:</strong></p>
<pre>[[0,0],[0,10],[10,10],[10,0],[5,5]]

Answer: False

Explanation:</pre>
<p><img alt="" height="100" src="https://leetcode.com/static/images/problemset/polygon_not_convex.png" width="100"/></p>
<p> </p>
<p>这道题让我们让我们判断一个多边形是否为凸多边形，我想关于凸多边形的性质，我大天朝的初中几何就应该有所涉猎啦吧，忘了的去面壁。就是所有的顶点角都不大于180度。那么我们该如何快速验证这一个特点呢，学过计算机图形学或者是图像处理的课应该对计算法线normal并不陌生吧，计算的curve的法向量是非常重要的手段，一段连续曲线可以离散看成许多离散点组成，而相邻的三个点就是最基本的单位，我们可以算由三个点组成的一小段曲线的法线方向，而凸多边形的每个三个相邻点的法向量方向都应该相同，要么同正，要么同负。那么我们只要遍历每个点，然后取出其周围的两个点计算法线方向，然后跟之前的方向对比，如果不一样，直接返回false。这里我们要特别注意法向量为0的情况，如果某一个点的法向量算出来为0，那么正确的pre就会被覆盖为0，后面再遇到相反的法向就无法检测出来，所以我们对计算出来法向量为0的情况直接跳过即可，参见代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> isConvex(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> points) {
        </span><span style="color: #0000ff;">long</span> <span style="color: #0000ff;">long</span> n = points.size(), pre = <span style="color: #800080;">0</span>, cur = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">int</span> dx1 = points[(i + <span style="color: #800080;">1</span>) % n][<span style="color: #800080;">0</span>] - points[i][<span style="color: #800080;">0</span><span style="color: #000000;">];
            </span><span style="color: #0000ff;">int</span> dx2 = points[(i + <span style="color: #800080;">2</span>) % n][<span style="color: #800080;">0</span>] - points[i][<span style="color: #800080;">0</span><span style="color: #000000;">];
            </span><span style="color: #0000ff;">int</span> dy1 = points[(i + <span style="color: #800080;">1</span>) % n][<span style="color: #800080;">1</span>] - points[i][<span style="color: #800080;">1</span><span style="color: #000000;">];
            </span><span style="color: #0000ff;">int</span> dy2 = points[(i + <span style="color: #800080;">2</span>) % n][<span style="color: #800080;">1</span>] - points[i][<span style="color: #800080;">1</span><span style="color: #000000;">];
            cur </span>= dx1 * dy2 - dx2 *<span style="color: #000000;"> dy1;
            </span><span style="color: #0000ff;">if</span> (cur != <span style="color: #800080;">0</span><span style="color: #000000;">) {
                </span><span style="color: #0000ff;">if</span> (cur * pre &lt; <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">else</span> pre =<span style="color: #000000;"> cur;
            }
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/70643/i-believe-this-time-it-s-far-beyond-my-ability-to-get-a-good-grade-of-the-contest" target="_blank">https://discuss.leetcode.com/topic/70643/i-believe-this-time-it-s-far-beyond-my-ability-to-get-a-good-grade-of-the-contest</a></p>
<p><a href="https://discuss.leetcode.com/topic/70664/c-7-line-o-n-solution-to-check-convexity-with-cross-product-of-adajcent-vectors-detailed-explanation/2" target="_blank">https://discuss.leetcode.com/topic/70664/c-7-line-o-n-solution-to-check-convexity-with-cross-product-of-adajcent-vectors-detailed-explanation/2</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-12-08 22:29</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=6146986" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(6146986);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/6146986.html" id="cb_post_title_url">[LeetCode] Convex Polygon 凸多边形</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a list of points that form a polygon when joined sequentially, find if this polygon is convex <a href="https://en.wikipedia.org/wiki/Convex_polygon" target="_blank">(Convex polygon definition)</a>.</p>
<p><strong>Note:</strong></p>
<ol>
<li>There are at least 3 and at most 10,000 points.</li>
<li>Coordinates are in the range -10,000 to 10,000.</li>
<li>You may assume the polygon formed by given points is always a simple polygon<a href="https://en.wikipedia.org/wiki/Simple_polygon" target="_blank"> (Simple polygon definition)</a>. In other words, we ensure that exactly two edges intersect at each vertex, and that edges otherwise <strong>don't intersect each other</strong>.</li>
</ol>
<p><strong>Example 1:</strong></p>
<pre>[[0,0],[0,1],[1,1],[1,0]]

Answer: True

Explanation:</pre>
<p><img alt="" height="100" src="https://leetcode.com/static/images/problemset/polygon_convex.png" width="100"/></p>
<p><strong>Example 2:</strong></p>
<pre>[[0,0],[0,10],[10,10],[10,0],[5,5]]

Answer: False

Explanation:</pre>
<p><img alt="" height="100" src="https://leetcode.com/static/images/problemset/polygon_not_convex.png" width="100"/></p>
<p> </p>
<p>这道题让我们让我们判断一个多边形是否为凸多边形，我想关于凸多边形的性质，我大天朝的初中几何就应该有所涉猎啦吧，忘了的去面壁。就是所有的顶点角都不大于180度。那么我们该如何快速验证这一个特点呢，学过计算机图形学或者是图像处理的课应该对计算法线normal并不陌生吧，计算的curve的法向量是非常重要的手段，一段连续曲线可以离散看成许多离散点组成，而相邻的三个点就是最基本的单位，我们可以算由三个点组成的一小段曲线的法线方向，而凸多边形的每个三个相邻点的法向量方向都应该相同，要么同正，要么同负。那么我们只要遍历每个点，然后取出其周围的两个点计算法线方向，然后跟之前的方向对比，如果不一样，直接返回false。这里我们要特别注意法向量为0的情况，如果某一个点的法向量算出来为0，那么正确的pre就会被覆盖为0，后面再遇到相反的法向就无法检测出来，所以我们对计算出来法向量为0的情况直接跳过即可，参见代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> isConvex(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> points) {
        </span><span style="color: #0000ff;">long</span> <span style="color: #0000ff;">long</span> n = points.size(), pre = <span style="color: #800080;">0</span>, cur = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">int</span> dx1 = points[(i + <span style="color: #800080;">1</span>) % n][<span style="color: #800080;">0</span>] - points[i][<span style="color: #800080;">0</span><span style="color: #000000;">];
            </span><span style="color: #0000ff;">int</span> dx2 = points[(i + <span style="color: #800080;">2</span>) % n][<span style="color: #800080;">0</span>] - points[i][<span style="color: #800080;">0</span><span style="color: #000000;">];
            </span><span style="color: #0000ff;">int</span> dy1 = points[(i + <span style="color: #800080;">1</span>) % n][<span style="color: #800080;">1</span>] - points[i][<span style="color: #800080;">1</span><span style="color: #000000;">];
            </span><span style="color: #0000ff;">int</span> dy2 = points[(i + <span style="color: #800080;">2</span>) % n][<span style="color: #800080;">1</span>] - points[i][<span style="color: #800080;">1</span><span style="color: #000000;">];
            cur </span>= dx1 * dy2 - dx2 *<span style="color: #000000;"> dy1;
            </span><span style="color: #0000ff;">if</span> (cur != <span style="color: #800080;">0</span><span style="color: #000000;">) {
                </span><span style="color: #0000ff;">if</span> (cur * pre &lt; <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">else</span> pre =<span style="color: #000000;"> cur;
            }
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/70643/i-believe-this-time-it-s-far-beyond-my-ability-to-get-a-good-grade-of-the-contest" target="_blank">https://discuss.leetcode.com/topic/70643/i-believe-this-time-it-s-far-beyond-my-ability-to-get-a-good-grade-of-the-contest</a></p>
<p><a href="https://discuss.leetcode.com/topic/70664/c-7-line-o-n-solution-to-check-convexity-with-cross-product-of-adajcent-vectors-detailed-explanation/2" target="_blank">https://discuss.leetcode.com/topic/70664/c-7-line-o-n-solution-to-check-convexity-with-cross-product-of-adajcent-vectors-detailed-explanation/2</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-12-08 22:29</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=6146986" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(6146986);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/6185339.html" id="cb_post_title_url">[LeetCode] Validate IP Address 验证IP地址</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>In this problem, your job to write a function to check whether a input string is a valid IPv4 address or IPv6 address or neither.</p>
<p>IPv4 addresses are canonically represented in dot-decimal notation, which consists of four decimal numbers, each ranging from 0 to 255, separated by dots ("."), e.g.,<code>172.16.254.1</code>;</p>
<p>Besides, you need to keep in mind that leading zeros in the IPv4 is illegal. For example, the address <code>172.16.254.01</code> is illegal.</p>
<p>IPv6 addresses are represented as eight groups of four hexadecimal digits, each group representing 16 bits. The groups are separated by colons (":"). For example, the address <code>2001:0db8:85a3:0000:0000:8a2e:0370:7334</code> is a legal one. Also, we could omit some leading zeros among four hexadecimal digits and some low-case characters in the address to upper-case ones, so <code>2001:db8:85a3:0:0:8A2E:0370:7334</code> is also a valid IPv6 address(Omit leading zeros and using upper cases).</p>
<p>However, we don't replace a consecutive group of zero value with a single empty group using two consecutive colons (::) to pursue simplicity. For example, <code>2001:0db8:85a3::8A2E:0370:7334</code> is an invalid IPv6 address.</p>
<p>Besides, you need to keep in mind that extra leading zeros in the IPv6 is also illegal. For example, the address <code>02001:0db8:85a3:0000:0000:8a2e:0370:7334</code> is also illegal.</p>
<p>Note: You could assume there is no extra space in the test cases and there may some special characters in the input string.</p>
<p>Example 1:</p>
<pre>Input: "172.16.254.1"

Output: "IPv4"

Explanation: This is a valid IPv4 address, return "IPv4".
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input: "2001:0db8:85a3:0:0:8A2E:0370:7334"

Output: "IPv6"

Explanation: This is a valid IPv6 address, return "IPv6".
</pre>
<p> </p>
<p>Example 3:</p>
<pre>Input: "256.256.256.256"

Output: "Neither"

Explanation: This is neither a IPv4 address nor a IPv6 address.</pre>
<p> </p>
<p>这道题让我们验证两种IP地址，LeetCode之前有一道关于IPv4的题<a href="http://www.cnblogs.com/grandyang/p/4305572.html" target="_blank">Restore IP Addresses</a>，给我们了一个字符串，让我们通过在中间加点来找出所有正确的IP地址，这道题给了我们中间加点或者冒号的字符串，让我们验证其是否是正确的IPv4或者IPv6，感觉要稍稍复杂一些。那么我们只有分别来验证了，那么我们怎么样能快速的区别是IPv4或者IPv6呢，当然是通过中间的点或者冒号啦，所以我们首先在字符串中找冒号(当然你想找点也可以)，如果字符串中没有冒号，那么我们来验证其是否是IPv4，如果有冒号，我们就来验证其是否是IPv6.</p>
<p>首先对于IPv4，我们使用getline函数来截取两个点之间的字符串，我们还需要一个计数器cnt来记录我们已经截取了多少段，如果cnt大于4了，说明超过了4段，说明是不是正确的地址。如果取出的字符串为空，说明两个点连在一起了，也不对。再有就是如果字符串长度大于1，且第一个字符是0，也不对。由于IPv4的地址在0到255之间，所以如果字符串长度大于3，也不正确。下面我们检查每一个字符，如果有不是数字的字符，返回Neither。最后我们再把字符串转为数字，如果不在0到255之间就是非法的。最后的最后，我们要保证cnt正好为4，而且最后一个字符不能是点，统统满足以上条件才是正确的IPv4地址。</p>
<p>然后对于IPv6，我们也使用getline函数来截取两个冒号之间的字符串，我们同样需要计数器cnt来记录我们已经截取了多少段，如果cnt大于8了，说明超过了8段，说明是不是正确的地址。如果取出的字符串为空，说明两个冒号连在一起了，也不对。面我们检查每一个字符，正确的字符应该是0到9之间的数字，或者a到f，或A到F之间的字符，如果出现了其他字符，返回Neither。最后的最后，我们要保证cnt正好为8，而且最后一个字符不能是冒号，统统满足以上条件才是正确的IPv6地址。</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> validIPAddress(<span style="color: #0000ff;">string</span><span style="color: #000000;"> IP) {
        istringstream </span><span style="color: #0000ff;">is</span><span style="color: #000000;">(IP);
        </span><span style="color: #0000ff;">string</span> t = <span style="color: #800000;">""</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> cnt = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (IP.find(<span style="color: #800000;">'</span><span style="color: #800000;">:</span><span style="color: #800000;">'</span>) == <span style="color: #0000ff;">string</span>::npos) { <span style="color: #008000;">//</span><span style="color: #008000;"> Check IPv4</span>
            <span style="color: #0000ff;">while</span> (getline(<span style="color: #0000ff;">is</span>, t, <span style="color: #800000;">'</span><span style="color: #800000;">.</span><span style="color: #800000;">'</span><span style="color: #000000;">)) {
                </span>++<span style="color: #000000;">cnt;
                </span><span style="color: #0000ff;">if</span> (cnt &gt; <span style="color: #800080;">4</span> || t.empty() || (t.size() &gt; <span style="color: #800080;">1</span> &amp;&amp; t[<span style="color: #800080;">0</span>] == <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span>) || t.size() &gt; <span style="color: #800080;">3</span>) <span style="color: #0000ff;">return</span> <span style="color: #800000;">"</span><span style="color: #800000;">Neither</span><span style="color: #800000;">"</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span><span style="color: #000000;"> c : t) {
                    </span><span style="color: #0000ff;">if</span> (c &lt; <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span> || c &gt; <span style="color: #800000;">'</span><span style="color: #800000;">9</span><span style="color: #800000;">'</span>) <span style="color: #0000ff;">return</span> <span style="color: #800000;">"</span><span style="color: #800000;">Neither</span><span style="color: #800000;">"</span><span style="color: #000000;">;
                }
                </span><span style="color: #0000ff;">int</span> val =<span style="color: #000000;"> stoi(t);
                </span><span style="color: #0000ff;">if</span> (val &lt; <span style="color: #800080;">0</span> || val &gt; <span style="color: #800080;">255</span>) <span style="color: #0000ff;">return</span> <span style="color: #800000;">"</span><span style="color: #800000;">Neither</span><span style="color: #800000;">"</span><span style="color: #000000;">;
            }
            </span><span style="color: #0000ff;">return</span> (cnt == <span style="color: #800080;">4</span> &amp;&amp; IP.back() != <span style="color: #800000;">'</span><span style="color: #800000;">.</span><span style="color: #800000;">'</span>) ? <span style="color: #800000;">"</span><span style="color: #800000;">IPv4</span><span style="color: #800000;">"</span> : <span style="color: #800000;">"</span><span style="color: #800000;">Neither</span><span style="color: #800000;">"</span><span style="color: #000000;">;
        } </span><span style="color: #0000ff;">else</span> { <span style="color: #008000;">//</span><span style="color: #008000;"> Check IPv6</span>
            <span style="color: #0000ff;">while</span> (getline(<span style="color: #0000ff;">is</span>, t, <span style="color: #800000;">'</span><span style="color: #800000;">:</span><span style="color: #800000;">'</span><span style="color: #000000;">)) {
                </span>++<span style="color: #000000;">cnt;
                </span><span style="color: #0000ff;">if</span> (cnt &gt; <span style="color: #800080;">8</span> || t.empty() || t.size() &gt; <span style="color: #800080;">4</span>) <span style="color: #0000ff;">return</span> <span style="color: #800000;">"</span><span style="color: #800000;">Neither</span><span style="color: #800000;">"</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span><span style="color: #000000;"> c : t) {
                    </span><span style="color: #0000ff;">if</span> (!(c &gt;= <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span> &amp;&amp; c &lt;= <span style="color: #800000;">'</span><span style="color: #800000;">9</span><span style="color: #800000;">'</span>) &amp;&amp; !(c &gt;= <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span> &amp;&amp; c &lt;= <span style="color: #800000;">'</span><span style="color: #800000;">f</span><span style="color: #800000;">'</span>) &amp;&amp; !(c &gt;= <span style="color: #800000;">'</span><span style="color: #800000;">A</span><span style="color: #800000;">'</span> &amp;&amp; c &lt;= <span style="color: #800000;">'</span><span style="color: #800000;">F</span><span style="color: #800000;">'</span>)) <span style="color: #0000ff;">return</span> <span style="color: #800000;">"</span><span style="color: #800000;">Neither</span><span style="color: #800000;">"</span><span style="color: #000000;">;
                }
            }
            </span><span style="color: #0000ff;">return</span> (cnt == <span style="color: #800080;">8</span> &amp;&amp; IP.back() != <span style="color: #800000;">'</span><span style="color: #800000;">:</span><span style="color: #800000;">'</span>) ? <span style="color: #800000;">"</span><span style="color: #800000;">IPv6</span><span style="color: #800000;">"</span> : <span style="color: #800000;">"</span><span style="color: #800000;">Neither</span><span style="color: #800000;">"</span><span style="color: #000000;">;
        }
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4305572.html" target="_blank">Restore IP Addresses</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/71572/java-solution" target="_blank">https://discuss.leetcode.com/topic/71572/java-solution</a></p>
<p><a href="https://discuss.leetcode.com/topic/71418/short-regexp-solution/5" target="_blank">https://discuss.leetcode.com/topic/71418/short-regexp-solution/5</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-12-15 23:53</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=6185339" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(6185339);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/6143071.html" id="cb_post_title_url">[LeetCode] Unique Substrings in Wraparound String 封装字符串中的独特子字符串</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="row">
<div class="col-md-12">
<div class="row">
<div class="col-md-12">
<div class="question-content">
<p>Consider the string <code>s</code> to be the infinite wraparound string of "abcdefghijklmnopqrstuvwxyz", so <code>s</code> will look like this: "...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd....".</p>
<p>Now we have another string <code>p</code>. Your job is to find out how many unique non-empty substrings of <code>p</code> are present in <code>s</code>. In particular, your input is the string <code>p</code> and you need to output the number of different non-empty substrings of <code>p</code> in the string <code>s</code>.</p>
<p>Note: <code>p</code> consists of only lowercase English letters and the size of p might be over 10000.</p>
<p>Example 1:</p>
<pre>Input: "a"
Output: 1

Explanation: Only the substring "a" of string "a" is in the string s.
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input: "cac"
Output: 2
Explanation: There are two substrings "a", "c" of string "cac" in the string s.
</pre>
<p> </p>
<p>Example 3:</p>
<pre>Input: "zab"
Output: 6
Explanation: There are six substrings "z", "a", "b", "za", "ab", "zab" of string "zab" in the string s.
</pre>
<p> </p>
<p>这道题说有一个无限长的封装字符串，然后又给了我们另一个字符串p，问我们p有多少非空子字符串在封装字符串中。我们通过观察题目中的例子可以发现，由于封装字符串是26个字符按顺序无限循环组成的，那么满足题意的p的子字符串要么是单一的字符，要么是按字母顺序的子字符串。这道题遍历p的所有子字符串会TLE，因为如果p很大的话，子字符串很多，会有大量的满足题意的重复子字符串，必须要用到trick，而所谓技巧就是一般来说你想不到的方法。我们看abcd这个字符串，以d结尾的子字符串有abcd, bcd, cd, d，那么我们可以发现bcd或者cd这些以d结尾的字符串的子字符串都包含在abcd中，那么我们知道以某个字符结束的最大字符串包含其他以该字符结束的字符串的所有子字符串，说起来很拗口，但是理解了我上面举的例子就行。那么题目就可以转换为分别求出以每个字符(a-z)为结束字符的最长连续字符串就行了，我们用一个数组cnt记录下来，最后在求出数组cnt的所有数字之和就是我们要的结果啦，参见代码如下：</p>
<div>
<div class="btn btn-xs btn-warning" id="company_tags"> </div>
<div class="btn btn-xs btn-warning">解法一：</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="interviewed-div">
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> findSubstringInWraproundString(<span style="color: #0000ff;">string</span><span style="color: #000000;"> p) {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; cnt(<span style="color: #800080;">26</span>, <span style="color: #800080;">0</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">int</span> len = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; p.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (i &gt; <span style="color: #800080;">0</span> &amp;&amp; (p[i] == p[i - <span style="color: #800080;">1</span>] + <span style="color: #800080;">1</span> || p[i - <span style="color: #800080;">1</span>] - p[i] == <span style="color: #800080;">25</span><span style="color: #000000;">)) {
                </span>++<span style="color: #000000;">len;
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                len </span>= <span style="color: #800080;">1</span><span style="color: #000000;">;
            }
            cnt[p[i] </span>- <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span>] = max(cnt[p[i] - <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span><span style="color: #000000;">], len);
        }
        </span><span style="color: #0000ff;">return</span> accumulate(cnt.begin(), cnt.end(), <span style="color: #800080;">0</span><span style="color: #000000;">);
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种方法跟上面的基本一样，就是在更新每个最大长度时，把差值累加到结果中，这跟最后统一加上最大值的效果一样，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> findSubstringInWraproundString(<span style="color: #0000ff;">string</span><span style="color: #000000;"> p) {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; cnt(<span style="color: #800080;">26</span>, <span style="color: #800080;">0</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, len = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; p.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">int</span> cur = p[i] - <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> (i &gt; <span style="color: #800080;">0</span> &amp;&amp; p[i - <span style="color: #800080;">1</span>] != (cur + <span style="color: #800080;">26</span> - <span style="color: #800080;">1</span>) % <span style="color: #800080;">26</span> + <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span>) len = <span style="color: #800080;">0</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> (++len &gt;<span style="color: #000000;"> cnt[cur]) {
                res </span>+= len -<span style="color: #000000;"> cnt[cur];
                cnt[cur] </span>=<span style="color: #000000;"> len;
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/70654/c-concise-solution" target="_blank">https://discuss.leetcode.com/topic/70654/c-concise-solution</a></p>
<p><a href="https://discuss.leetcode.com/topic/70658/concise-java-solution-using-dp/2" target="_blank">https://discuss.leetcode.com/topic/70658/concise-java-solution-using-dp/2</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p>
</div></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-12-07 22:25</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=6143071" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(6143071);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/6149294.html" id="cb_post_title_url">[LeetCode] Count The Repetitions 计数重复个数</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Define <code>S = [s,n]</code> as the string S which consists of n connected strings s. For example, <code>["abc", 3]</code> ="abcabcabc".</p>
<p>On the other hand, we define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1. For example, “abc” can be obtained from “abdbec” based on our definition, but it can not be obtained from “acbbe”.</p>
<p>You are given two non-empty strings s1 and s2 (each at most 100 characters long) and two integers 0 ≤ n1 ≤ 106and 1 ≤ n2 ≤ 106. Now consider the strings S1 and S2, where <code>S1=[s1,n1]</code> and <code>S2=[s2,n2]</code>. Find the maximum integer M such that <code>[S2,M]</code> can be obtained from <code>S1</code>.</p>
<p>Example:</p>
<pre>Input:
s1="acb", n1=4
s2="ab", n2=2

Return:
2</pre>
<p> </p>
<p>这道题放了好久才写，主要是因为这道题难度确实不小，光是分析研究网上大神们的帖子就搞了好久，就是现在也不能说完全理解了这道题，哎，将就着写吧，有不足的地方欢迎指正。主要参考了网上<a href="https://discuss.leetcode.com/topic/72105/c-solution-inspired-by-70664914-with-organized-explanation" target="_blank">大神lzl124631x的帖子</a>，还有<a href="https://discuss.leetcode.com/topic/70887/very-clean-and-short-7ms-java-solution-based-on-70664914-s-idea" target="_blank">大神aaaeeeo的帖子</a>。  这道题的Java版本的brute force可以通过OJ，但是C++的就不行了，我们需要使用重复模式来优化我们的方法，我们知道：</p>
<p>如果s2在S1中出现了N次，那么S2肯定在S1中出现了N/n2次，注意这里的大写表示字符串加上重复次数组成的大字符串。</p>
<p>所以我们得出结论，我们只要算出s2出现的次数，然后除以n2，就可以得出S2出现的次数了。</p>
<p>那么问题就是我们表示重复，我们遍历s1字符串n1次，表示每个s1字符串为一段，对于每段，我们有：</p>
<p>1. 出现在该段的s2字符串的累计出现次数</p>
<p>2. 一个nextIndex，其中s2[nextIndex]表示在下一段s1中你所要寻找的s2中的一个字符。(比如说s1="abc", s2="bac", 由于第一个s1中只能匹配上s2中的b，那么只有在下一段s1中才能继续匹配s2中的a，所以nextIndex=1，即a在s2中的位置为1；同理，比如s1="abca", s2="bac"，第一个s1可以匹配上s2中的ba，那么后面的c只能在下一段s1中匹配上，那么nextIndex=2，即c在s2中的位置为2)</p>
<p>表示重复关键就在于nextIndex，比如对于下面这个例子：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">Input:
s1</span>=<span style="color: #800000;">"</span><span style="color: #800000;">abacb</span><span style="color: #800000;">"</span>, n1=<span style="color: #800080;">6</span><span style="color: #000000;">
s2</span>=<span style="color: #800000;">"</span><span style="color: #800000;">bcaa</span><span style="color: #800000;">"</span>, n2=<span style="color: #800080;">1</span><span style="color: #000000;">

Return:
</span><span style="color: #800080;">3</span></pre>
</div>
<p> </p>
<div class="cnblogs_code">
<pre>j ---------------&gt;  <span style="color: #800080;">1</span> <span style="color: #800080;">2</span>    <span style="color: #800080;">3</span> <span style="color: #800080;">0</span> <span style="color: #800080;">1</span>      <span style="color: #800080;">2</span>    <span style="color: #800080;">3</span> <span style="color: #800080;">0</span> <span style="color: #800080;">1</span>      <span style="color: #800080;">2</span>    <span style="color: #800080;">3</span> <span style="color: #800080;">0</span><span style="color: #000000;">   
S1 </span>--------------&gt; a<span style="color: #ff0000;">b</span>a<span style="color: #ff0000;">c</span>b | <span style="color: #ff0000;">a</span>b<span style="color: #ff0000;">a</span>c<span style="color: #ff0000;">b</span> | aba<span style="color: #ff0000;">c</span>b | <span style="color: #ff0000;">a</span>b<span style="color: #ff0000;">a</span>c<span style="color: #ff0000;">b</span> | aba<span style="color: #ff0000;">c</span>b |<span style="color: #000000;"><span style="color: #ff0000;"> a</span>b<span style="color: #ff0000;">a</span>cb 

repeatCount </span>-----&gt;    <span style="color: #800080;">0</span>  |   <span style="color: #800080;">1</span>   |   <span style="color: #800080;">1</span>   |   <span style="color: #800080;">2</span>   |   <span style="color: #800080;">2</span>   |   <span style="color: #800080;">3</span><span style="color: #000000;">

nextIndex </span>-------&gt;    <span style="color: #ff0000;">2</span>  |   <span style="color: #800080;">1</span>   |   <span style="color: #ff0000;">2</span>   |   <span style="color: #800080;">1</span>   |   <span style="color: #800080;">2</span>   |   <span style="color: #800080;">1</span></pre>
</div>
<p> </p>
<p>nextIndex的范围从0到s2.size()-1，根据鸽巢原理(又称抽屉原理)，你一定会找到相同的两个nextIndex在遍历s1段s2.size()+1次之后。在上面的例子中，重复的nextIndex出现在第三段，和第一段一样都为2，那么重复的pattern就找到了，是第二段和第三段中的aabc，而且从第四段开始，每两段就有一个aabc，现在我们的目标就是统计出整个S1中有多少个s2。</p>
<p>由于pattern占用了两段，所以interval为2，我们然后看整个S1中有多少个这样的两段，repeat = (n1 - start) / interval。start表示pattern的起始段数，之前的不是pattern，然后我们算在整个S1中有多少个pattern出现，patternCnt = (repeatCnt[k] - repeatCnt[start]) * repeat，注意这里的repeatCnt[k] - repeatCnt[start]表示一个pattern中有多少个字符串s2，个人感觉一般来说都是1个。然后我们算出剩下的非pattern的字符串里能包含几个s2，remainCnt = repeatCnt[start + (n1 - start) % interval]，然后我们把patternCnt + remainCnt之和算出来除以n2就是需要的结果啦。如果pattern未曾出现，那么我们直接用repeatCnt[n1] / n2也能得到正确的结果，参见代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> getMaxRepetitions(<span style="color: #0000ff;">string</span> s1, <span style="color: #0000ff;">int</span> n1, <span style="color: #0000ff;">string</span> s2, <span style="color: #0000ff;">int</span><span style="color: #000000;"> n2) {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; repeatCnt(n1 + <span style="color: #800080;">1</span>, <span style="color: #800080;">0</span><span style="color: #000000;">);
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; nextIdx(n1 + <span style="color: #800080;">1</span>, <span style="color: #800080;">0</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>, cnt = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> k = <span style="color: #800080;">1</span>; k &lt;= n1; ++<span style="color: #000000;">k) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; s1.size(); ++<span style="color: #000000;">i) {
                </span><span style="color: #0000ff;">if</span> (s1[i] ==<span style="color: #000000;"> s2[j]) {
                    </span>++<span style="color: #000000;">j;
                    </span><span style="color: #0000ff;">if</span> (j ==<span style="color: #000000;"> s2.size()) {  
                        j </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
                        </span>++<span style="color: #000000;">cnt;
                    }
                }
            }
            repeatCnt[k] </span>=<span style="color: #000000;"> cnt;
            nextIdx[k] </span>=<span style="color: #000000;"> j;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> start = <span style="color: #800080;">0</span>; start &lt; k; ++<span style="color: #000000;">start) {
                </span><span style="color: #0000ff;">if</span> (nextIdx[start] ==<span style="color: #000000;"> j) {
                    </span><span style="color: #0000ff;">int</span> interval = k -<span style="color: #000000;"> start;
                    </span><span style="color: #0000ff;">int</span> repeat = (n1 - start) /<span style="color: #000000;"> interval;
                    </span><span style="color: #0000ff;">int</span> patternCnt = (repeatCnt[k] - repeatCnt[start]) *<span style="color: #000000;"> repeat;
                    </span><span style="color: #0000ff;">int</span> remainCnt = repeatCnt[start + (n1 - start) %<span style="color: #000000;"> interval];
                    </span><span style="color: #0000ff;">return</span> (patternCnt + remainCnt) /<span style="color: #000000;"> n2;
                }
            }
        }
        </span><span style="color: #0000ff;">return</span> repeatCnt[n1] /<span style="color: #000000;"> n2;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/70667/c-0ms-o-str1-length-str2-length/2" target="_blank">https://discuss.leetcode.com/topic/70667/c-0ms-o-str1-length-str2-length/2</a></p>
<p><a href="https://discuss.leetcode.com/topic/70707/ugly-java-brute-force-solution-but-accepted-1088ms" target="_blank">https://discuss.leetcode.com/topic/70707/ugly-java-brute-force-solution-but-accepted-1088ms</a></p>
<p><a href="https://discuss.leetcode.com/topic/72105/c-solution-inspired-by-70664914-with-organized-explanation" target="_blank">https://discuss.leetcode.com/topic/72105/c-solution-inspired-by-70664914-with-organized-explanation</a></p>
<p><a href="https://discuss.leetcode.com/topic/70887/very-clean-and-short-7ms-java-solution-based-on-70664914-s-idea" target="_blank">https://discuss.leetcode.com/topic/70887/very-clean-and-short-7ms-java-solution-based-on-70664914-s-idea</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-12-09 14:06</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=6149294" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(6149294);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/6108158.html" id="cb_post_title_url">[LeetCode] Optimal Account Balancing 最优账户平衡</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>A group of friends went on holiday and sometimes lent each other money. For example, Alice paid for Bill's lunch for $10. Then later Chris gave Alice $5 for a taxi ride. We can model each transaction as a tuple (x, y, z) which means person x gave person y $z. Assuming Alice, Bill, and Chris are person 0, 1, and 2 respectively (0, 1, 2 are the person's ID), the transactions can be represented as <code>[[0, 1, 10], [2, 0, 5]]</code>.</p>
<p>Given a list of transactions between a group of people, return the minimum number of transactions required to settle the debt.</p>
<p>Note:</p>
<ol>
<li>A transaction will be given as a tuple (x, y, z). Note that <code>x ≠ y</code> and <code>z &gt; 0</code>.</li>
<li>Person's IDs may not be linear, e.g. we could have the persons 0, 1, 2 or we could also have the persons 0, 2, 6.</li>
</ol>
<p> </p>
<p>Example 1:</p>
<pre>Input:
[[0,1,10], [2,0,5]]

Output:
2

Explanation:
Person #0 gave person #1 $10.
Person #2 gave person #0 $5.

Two transactions are needed. One way to settle the debt is person #1 pays person #0 and #2 $5 each.
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input:
[[0,1,10], [1,0,1], [1,2,5], [2,0,5]]

Output:
1

Explanation:
Person #0 gave person #1 $10.
Person #1 gave person #0 $1.
Person #1 gave person #2 $5.
Person #2 gave person #0 $5.

Therefore, person #1 only need to give person #0 $4, and all debt is settled.</pre>
<p> </p>
<p>这道题给了一堆某人欠某人多少钱这样的账单，问我们经过优化后最少还剩几个。其实就相当于一堆人出去玩，某些人可能帮另一些人垫付过花费，最后结算总花费的时候可能你欠着别人的钱，其他人可能也欠你的欠。我们需要找出简单的方法把所有欠账都还清就行了。这道题的思路跟之前那道<a href="http://www.cnblogs.com/grandyang/p/5880133.html">Evaluate Division</a>有些像，都需要对一组数据颠倒顺序处理。我们使用一个哈希表来建立每个人和其账户的映射，其中账户若为正数，说明其他人欠你钱；如果账户为负数，说明你欠别人钱。我们对于每份账单，前面的人就在哈希表中减去钱数，后面的人在哈希表中加上钱数。这样我们每个人就都有一个账户了，然后我们接下来要做的就是合并账户，看最少需要多少次汇款。我们先统计出账户值不为0的人数，因为如果为0了，表明你既不欠别人钱，别人也不欠你钱，如果不为0，我们把钱数放入一个数组accnt中，然后调用递归函数。在递归函数中，我们初始化结果res为整型最大值，然后我们跳过为0的账户，然后我们开始遍历之后的账户，如果当前账户和之前账户的钱数正负不同的话，我们将前一个账户的钱数加到当前账户上，这很好理解，比如前一个账户钱数是-5，表示张三欠了别人五块钱，当前账户钱数是5，表示某人欠了李四五块钱，那么张三给李四五块，这两人的账户就都清零了。然后我们调用递归函数，此时从当前改变过的账户开始找，num表示当前的转账数，需要加1，然后我们用这个递归函数返回的结果来更新res，后面别忘了复原当前账户的值。遍历结束后，我们看res的值如果还是整型的最大值，说明没有改变过，我们返回num，否则返回res即可，参见代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> minTransfers(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> transactions) {
        unordered_map</span>&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> m;
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto t : transactions) {
            m[t[</span><span style="color: #800080;">0</span>]] -= t[<span style="color: #800080;">2</span><span style="color: #000000;">];
            m[t[</span><span style="color: #800080;">1</span>]] += t[<span style="color: #800080;">2</span><span style="color: #000000;">];
        }
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> accnt(m.size());
        </span><span style="color: #0000ff;">int</span> cnt = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto a : m) {
            </span><span style="color: #0000ff;">if</span> (a.second != <span style="color: #800080;">0</span>) accnt[cnt++] =<span style="color: #000000;"> a.second;
        }
        </span><span style="color: #0000ff;">return</span> helper(accnt, <span style="color: #800080;">0</span>, cnt, <span style="color: #800080;">0</span><span style="color: #000000;">);
    }
    </span><span style="color: #0000ff;">int</span> helper(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; accnt, <span style="color: #0000ff;">int</span> start, <span style="color: #0000ff;">int</span> n, <span style="color: #0000ff;">int</span><span style="color: #000000;"> num) {
        </span><span style="color: #0000ff;">int</span> res =<span style="color: #000000;"> INT_MAX;
        </span><span style="color: #0000ff;">while</span> (start &lt; n &amp;&amp; accnt[start] == <span style="color: #800080;">0</span>) ++<span style="color: #000000;">start;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = start + <span style="color: #800080;">1</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> ((accnt[i] &lt; <span style="color: #800080;">0</span> &amp;&amp; accnt[start] &gt; <span style="color: #800080;">0</span>) || (accnt[i] &gt; <span style="color: #800080;">0</span> &amp;&amp; accnt[start] &lt; <span style="color: #800080;">0</span><span style="color: #000000;">)) {
                accnt[i] </span>+=<span style="color: #000000;"> accnt[start];
                res </span>= min(res, helper(accnt, start + <span style="color: #800080;">1</span>, n, num + <span style="color: #800080;">1</span><span style="color: #000000;">));
                accnt[i] </span>-=<span style="color: #000000;"> accnt[start];
            }
        }
        </span><span style="color: #0000ff;">return</span> res == INT_MAX ?<span style="color: #000000;"> num : res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/5880133.html">Evaluate Division</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/68755/share-my-o-n-npc-solution-tle-for-large-case/6" target="_blank">https://discuss.leetcode.com/topic/68755/share-my-o-n-npc-solution-tle-for-large-case/6</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-11-28 08:24</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=6108158" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(6108158);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/6103525.html" id="cb_post_title_url">[LeetCode] Can I Win 我能赢吗</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>In the "100 game," two players take turns adding, to a running total, any integer from 1..10. The player who first causes the running total to reach or exceed 100 wins.</p>
<p>What if we change the game so that players cannot re-use integers?</p>
<p>For example, two players might take turns drawing from a common pool of numbers of 1..15 without replacement until they reach a total &gt;= 100.</p>
<p>Given an integer <code>maxChoosableInteger</code> and another integer <code>desiredTotal</code>, determine if the first player to move can force a win, assuming both players play optimally.</p>
<p>You can always assume that <code>maxChoosableInteger</code> will not be larger than 20 and <code>desiredTotal</code> will not be larger than 300.</p>
<p>Example</p>
<pre>Input:
maxChoosableInteger = 10
desiredTotal = 11

Output:
false

Explanation:
No matter which integer the first player choose, the first player will lose.
The first player can choose an integer from 1 up to 10.
If the first player choose 1, the second player can only choose integers from 2 up to 10.
The second player will win by choosing 10 and get a total = 11, which is &gt;= desiredTotal.
Same with other integers chosen by the first player, the second player will always win.</pre>
<p> </p>
<p>这道题给了我们一堆数字，然后两个人，每人每次选一个数字，看数字总数谁先到给定值，有点像之前那道<a href="http://www.cnblogs.com/grandyang/p/4873248.html">Nim Game</a>，但是比那题难度大。我刚开始想肯定说用递归啊，结果写完发现TLE了，后来发现我们必须要优化效率，使用HashMap来记录已经计算过的结果。我们首先来看如果给定的数字范围大于等于目标值的话，直接返回true。如果给定的数字总和小于目标值的话，说明谁也没法赢，返回false。然后我们进入递归函数，首先我们查找当前情况是否在哈希表中存在，有的话直接返回即可。我们使用一个整型数按位来记录数组中的某个数字是否使用过，我们遍历所有数字，将该数字对应的mask算出来，如果其和used相与为0的话，说明该数字没有使用过，我们看如果此时的目标值小于等于当前数字，说明已经赢了，或者我们调用递归函数，如果返回false，说明也是第一个人赢了。为啥呢，因为当前我们已经选过数字了，此时就该对第二个人调用递归函数，只有他的结果是false，我们才能赢，所以此时我们标记true，返回true。如果遍历完所有数字，我们标记false，返回false，参见代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> canIWin(<span style="color: #0000ff;">int</span> maxChoosableInteger, <span style="color: #0000ff;">int</span><span style="color: #000000;"> desiredTotal) {
        </span><span style="color: #0000ff;">if</span> (maxChoosableInteger &gt;= desiredTotal) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (maxChoosableInteger * (maxChoosableInteger + <span style="color: #800080;">1</span>) / <span style="color: #800080;">2</span> &lt; desiredTotal) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        unordered_map</span>&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">bool</span>&gt;<span style="color: #000000;"> m;
        </span><span style="color: #0000ff;">return</span> canWin(maxChoosableInteger, desiredTotal, <span style="color: #800080;">0</span><span style="color: #000000;">, m);
    }
    </span><span style="color: #0000ff;">bool</span> canWin(<span style="color: #0000ff;">int</span> length, <span style="color: #0000ff;">int</span> total, <span style="color: #0000ff;">int</span> used, unordered_map&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">bool</span>&gt;&amp;<span style="color: #000000;"> m) {
        </span><span style="color: #0000ff;">if</span> (m.count(used)) <span style="color: #0000ff;">return</span><span style="color: #000000;"> m[used];
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; length; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">int</span> cur = (<span style="color: #800080;">1</span> &lt;&lt;<span style="color: #000000;"> i);
            </span><span style="color: #0000ff;">if</span> ((cur &amp; used) == <span style="color: #800080;">0</span><span style="color: #000000;">) {
                </span><span style="color: #0000ff;">if</span> (total &lt;= i + <span style="color: #800080;">1</span> || !canWin(length, total - (i + <span style="color: #800080;">1</span>), cur |<span style="color: #000000;"> used, m)) {
                    m[used] </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                }
            }
        }
        m[used] </span>= <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4873248.html">Nim Game</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/5226206.html" target="_blank">Flip Game II</a><span class="Apple-converted-space"> </span>  </p>
<p><a href="http://www.cnblogs.com/grandyang/p/5677550.html">Guess Number Higher or Lower II</a> </p>
<p><a href="http://www.cnblogs.com/grandyang/p/6369688.html">Predict the Winner</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-11-26 07:00</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=6103525" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(6103525);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/6096138.html" id="cb_post_title_url">[LeetCode] Island Perimeter 岛屿周长</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>You are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water. Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells). The island doesn't have "lakes" (water inside that isn't connected to the water around the island). One cell is a square with side length 1. The grid is rectangular, width and height don't exceed 100. Determine the perimeter of the island.</p>
<p><strong>Example:</strong></p>
<pre>[[0,1,0,0],
 [1,1,1,0],
 [0,1,0,0],
 [1,1,0,0]]

Answer: 16
Explanation: The perimeter is the 16 yellow stripes in the image below:
</pre>
<p><img alt="" src="https://leetcode.com/static/images/problemset/island.png"/></p>
<p> </p>
<p>这道题给了我们一个格子图，若干连在一起的格子形成了一个小岛，规定了图中只有一个相连的岛，且岛中没有湖，让我们求岛的周长。我们知道一个格子有四条边，但是当两个格子相邻，周围为6，若某个格子四周都有格子，那么这个格子一条边都不算在周长里。那么我们怎么统计出岛的周长呢？第一种方法，我们对于每个格子的四条边分别来处理，首先看左边的边，只有当左边的边处于第一个位置或者当前格子的左面没有岛格子的时候，左边的边计入周长。其他三条边的分析情况都跟左边的边相似，这里就不多叙述了，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> islandPerimeter(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> grid) {
        </span><span style="color: #0000ff;">if</span> (grid.empty() || grid[<span style="color: #800080;">0</span>].empty()) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> m = grid.size(), n = grid[<span style="color: #800080;">0</span>].size(), res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; m; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; n; ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> (grid[i][j] == <span style="color: #800080;">0</span>) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">if</span> (j == <span style="color: #800080;">0</span> || grid[i][j - <span style="color: #800080;">1</span>] == <span style="color: #800080;">0</span>) ++<span style="color: #000000;">res;
                </span><span style="color: #0000ff;">if</span> (i == <span style="color: #800080;">0</span> || grid[i - <span style="color: #800080;">1</span>][j] == <span style="color: #800080;">0</span>) ++<span style="color: #000000;">res;
                </span><span style="color: #0000ff;">if</span> (j == n - <span style="color: #800080;">1</span> || grid[i][j + <span style="color: #800080;">1</span>] == <span style="color: #800080;">0</span>) ++<span style="color: #000000;">res;
                </span><span style="color: #0000ff;">if</span> (i == m - <span style="color: #800080;">1</span> || grid[i + <span style="color: #800080;">1</span>][j] == <span style="color: #800080;">0</span>) ++<span style="color: #000000;">res;
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种方法对于每个岛屿格子先默认加上四条边，然后检查其左面和上面是否有岛屿格子，有的话分别减去两条边，这样也能得到正确的结果，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> islandPerimeter(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> grid) {
        </span><span style="color: #0000ff;">if</span> (grid.empty() || grid[<span style="color: #800080;">0</span>].empty()) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, m = grid.size(), n = grid[<span style="color: #800080;">0</span><span style="color: #000000;">].size();
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; m; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; n; ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> (grid[i][j] == <span style="color: #800080;">0</span>) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                res </span>+= <span style="color: #800080;">4</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">if</span> (i &gt; <span style="color: #800080;">0</span> &amp;&amp; grid[i - <span style="color: #800080;">1</span>][j] == <span style="color: #800080;">1</span>) res -= <span style="color: #800080;">2</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">if</span> (j &gt; <span style="color: #800080;">0</span> &amp;&amp; grid[i][j - <span style="color: #800080;">1</span>] == <span style="color: #800080;">1</span>) res -= <span style="color: #800080;">2</span><span style="color: #000000;">;
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/68983/java-9-line-solution-add-4-for-each-land-and-remove-2-for-each-internal-edge" target="_blank">https://discuss.leetcode.com/topic/68983/java-9-line-solution-add-4-for-each-land-and-remove-2-for-each-internal-edge</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-11-24 00:00</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=6096138" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(6096138);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/6089060.html" id="cb_post_title_url">[LeetCode] Minimum Moves to Equal Array Elements II 最少移动次数使数组元素相等之二</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a non-empty integer array, find the minimum number of moves required to make all array elements equal, where a move is incrementing a selected element by 1 or decrementing a selected element by 1.</p>
<p>You may assume the array's length is at most 10,000.</p>
<p>Example:</p>
<pre>Input:
[1,2,3]

Output:
2

Explanation:
Only two moves are needed (remember each move increments or decrements one element):

[1,2,3]  =&gt;  [2,2,3]  =&gt;  [2,2,2]</pre>
<p> </p>
<p>这道题是之前那道<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/6053827.html" id="homepage1_HomePageDays_DaysList_ctl12_DayList_TitleUrl_0">Minimum Moves to Equal Array Elements</a>的拓展，现在我们可以每次对任意一个数字加1或者减1，让我们用最少的次数让数组所有值相等。一般来说这种题目是不能用暴力方法算出所有情况，因为OJ一般是不会答应的。那么这道题是否像上面一道题一样，有巧妙的方法呢？答案是肯定的。下面这种解法实际上利用了之前一道题<a href="http://www.cnblogs.com/grandyang/p/5291058.html" target="_blank">Best Meeting Point</a>的思想，是不感觉很amazing，看似完全不相干的两道题，居然有着某种内部联系。我们首先给数组排序，那么我们最终需要变成的相等的数字就是中间的数，如果数组有奇数个，那么就是最中间的那个数字；如果是偶数个，那么就是中间两个数的区间中的任意一个数字。而两端的数字变成中间的一个数字需要的步数实际上就是两端数字的距离，讲到这里发现是不是就和这道题<a href="http://www.cnblogs.com/grandyang/p/5291058.html" target="_blank">Best Meeting Point</a>的思路是一样了。那么我们就两对两对的累加它们的差值就可以了，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> minMoves2(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, i = <span style="color: #800080;">0</span>, j = (<span style="color: #0000ff;">int</span>)nums.size() - <span style="color: #800080;">1</span><span style="color: #000000;">;
        sort(nums.begin(), nums.end());
        </span><span style="color: #0000ff;">while</span> (i &lt;<span style="color: #000000;"> j) {
            res </span>+= nums[j--] - nums[i++<span style="color: #000000;">];
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>既然有了上面的分析，我们知道实际上最后相等的数字就是数组的最中间的那个数字，那么我们在给数组排序后，直接利用坐标定位到中间的数字，然后算数组中每个数组与其的差的绝对值累加即可，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> minMoves2(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        sort(nums.begin(), nums.end());
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, mid = nums[nums.size() / <span style="color: #800080;">2</span><span style="color: #000000;">];
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span><span style="color: #000000;"> num : nums) {
            res </span>+= abs(num -<span style="color: #000000;"> mid);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>上面的两种方法都给整个数组排序了，时间复杂度是O(nlgn)，其实我们并不需要给所有的数字排序，我们只关系最中间的数字，那么这个stl中自带的函数nth_element就可以完美的发挥其作用了，我们只要给出我们想要数字的位置，它就能在O(n)的时间内返回正确的数字，然后算数组中每个数组与其的差的绝对值累加即可，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> minMoves2(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, n = nums.size(), mid = n / <span style="color: #800080;">2</span><span style="color: #000000;">;
        nth_element(nums.begin(), nums.begin() </span>+<span style="color: #000000;"> mid, nums.end());
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            res </span>+= abs(nums[i] -<span style="color: #000000;"> nums[mid]);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种方法是改进版的暴力破解法，它遍历了所有的数字，让每个数字都当作最后相等的值，然后算法出来总步数，每次和res比较，留下较小的。而这种方法叼就叼在它在O(1)的时间内完成了步数统计，那么这样整个遍历下来也只是O(n)的时间，不过由于还是要给数组排序，所以整体的时间复杂度是O(nlgn)，这已经能保证可以通过OJ啦。那么我们来看看如何快速计算总步数，首先我们给数组排序，我们假设中间某个位置有个数字k，那么此时数组就是：nums[0], nums[1], ..., k, ..., nums[n - 1], 如果i为数字k在数组中的坐标，那么有k = nums[i]，那么总步数为：</p>
<p>Y = k - nums[0] + k - nums[1] + ... + k - nums[i - 1] + nums[i] - k + nums[i + 1] - k + ... + nums[n - 1] - k</p>
<p>   = i * k - (nums[0] + nums[1] + ... + nums[i - 1]) + (nums[i] + nums[i + 1] + ... + nums[n - 1]) - (n - i) * k</p>
<p>   = 2 * i * k - n * k + sum - 2 * curSum</p>
<p>那么我们只要算出sum和curSum就可以快速得到总步数了，数组之和可以通过遍历数组计算出来，curSum可以在遍历的过程中累加，那么我们就可以算出总步数，然后每次更新结果res了，参见代码如下：</p>
<p> </p>
<p>解法四：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> minMoves2(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        sort(nums.begin(), nums.end());
        </span><span style="color: #0000ff;">long</span> <span style="color: #0000ff;">long</span> sum = accumulate(nums.begin(), nums.end(), <span style="color: #800080;">0</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">long</span> <span style="color: #0000ff;">long</span> res = LONG_MAX, curSum = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> n =<span style="color: #000000;"> nums.size();
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">long</span> <span style="color: #0000ff;">long</span> k =<span style="color: #000000;"> nums[i];
            curSum </span>+=<span style="color: #000000;"> k;
            res </span>= min(res, <span style="color: #800080;">2</span> * k * (i + <span style="color: #800080;">1</span>) - n * k + sum - <span style="color: #800080;">2</span> *<span style="color: #000000;"> curSum);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/6053827.html" id="homepage1_HomePageDays_DaysList_ctl12_DayList_TitleUrl_0">Minimum Moves to Equal Array Elements</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/5291058.html" target="_blank">Best Meeting Point</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/68764/5-line-solution-with-comment" target="_blank">https://discuss.leetcode.com/topic/68764/5-line-solution-with-comment</a></p>
<p><a href="https://discuss.leetcode.com/topic/68884/c-average-o-n-nth_element-solution" target="_blank">https://discuss.leetcode.com/topic/68884/c-average-o-n-nth_element-solution</a></p>
<p><a href="https://discuss.leetcode.com/topic/68736/java-just-like-meeting-point-problem" target="_blank">https://discuss.leetcode.com/topic/68736/java-just-like-meeting-point-problem</a></p>
<p><a href="https://discuss.leetcode.com/topic/68900/simple-c-sort-and-find-solution-with-detailed-explanation" target="_blank">https://discuss.leetcode.com/topic/68900/simple-c-sort-and-find-solution-with-detailed-explanation</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-11-22 14:09</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=6089060" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(6089060);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/6201215.html" id="cb_post_title_url">[LeetCode] Hamming Distance 汉明距离</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>The <a href="https://en.wikipedia.org/wiki/Hamming_distance" target="_blank">Hamming distance</a> between two integers is the number of positions at which the corresponding bits are different.</p>
<p>Given two integers <code>x</code> and <code>y</code>, calculate the Hamming distance.</p>
<p>Note:<br/>0 ≤ <code>x</code>, <code>y</code> &lt; 231.</p>
<p>Example:</p>
<pre>Input: x = 1, y = 4

Output: 2

Explanation:
1   (0 0 0 1)
4   (0 1 0 0)
       ↑   ↑

The above arrows point to positions where the corresponding bits are different.</pre>
<p> </p>
<p>这道题让我求两个数字之间的<a href="https://zh.wikipedia.org/wiki/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB" target="_blank">汉明距离</a>，题目中解释的很清楚了，两个数字之间的汉明距离就是其二进制数对应位不同的个数，那么最直接了当的做法就是按位分别取出两个数对应位上的数并异或，我们知道异或的性质上相同的为0，不同的为1，我们只要把为1的情况累加起来就是汉明距离了，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> hammingDistance(<span style="color: #0000ff;">int</span> x, <span style="color: #0000ff;">int</span><span style="color: #000000;"> y) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; <span style="color: #800080;">32</span>; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> ((x &amp; (<span style="color: #800080;">1</span> &lt;&lt; i)) ^ (y &amp; (<span style="color: #800080;">1</span> &lt;&lt;<span style="color: #000000;"> i))) {
                </span>++<span style="color: #000000;">res;
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>我们可以对上面的代码进行优化，我们可以一开始直接将两个数字异或起来，然后我们遍历异或结果的每一位，统计为1的个数，也能达到同样的效果，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> hammingDistance(<span style="color: #0000ff;">int</span> x, <span style="color: #0000ff;">int</span><span style="color: #000000;"> y) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, exc = x ^<span style="color: #000000;"> y;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; <span style="color: #800080;">32</span>; ++<span style="color: #000000;">i) {
            res </span>+= (exc &gt;&gt; i) &amp; <span style="color: #800080;">1</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>经过副博主@fantasywindy的提醒，上面的遍历每一位的方法并不高效，还可以进一步优化，假如数为num, num &amp; (num - 1)可以快速地移除最右边的bit 1， 一直循环到num为0, 总的循环数就是num中bit 1的个数。参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> hammingDistance(<span style="color: #0000ff;">int</span> x, <span style="color: #0000ff;">int</span><span style="color: #000000;"> y) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, exc = x ^<span style="color: #000000;"> y;
        </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> (exc) {
            </span>++<span style="color: #000000;">res;
            exc </span>&amp;= (exc - <span style="color: #800080;">1</span><span style="color: #000000;">);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>我们再来看一种递归的写法，非常的简洁，递归终止的条件是当两个数异或为0时，表明此时两个数完全相同，我们返回0，否则我们返回异或和对2取余加上对x/2和y/2调用递归的结果。异或和对2取余相当于检查最低位是否相同，而对x/2和y/2调用递归相当于将x和y分别向右移动一位，这样每一位都可以比较到，也能得到正确结果，参见代码如下：</p>
<p> </p>
<p>解法四：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> hammingDistance(<span style="color: #0000ff;">int</span> x, <span style="color: #0000ff;">int</span><span style="color: #000000;"> y) {
        </span><span style="color: #0000ff;">if</span> ((x ^ y) == <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span> (x ^ y) % <span style="color: #800080;">2</span> + hammingDistance(x / <span style="color: #800080;">2</span>, y / <span style="color: #800080;">2</span><span style="color: #000000;">);
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/72089/java-3-line-solution" target="_blank">https://discuss.leetcode.com/topic/72089/java-3-line-solution</a></p>
<p><a href="https://discuss.leetcode.com/topic/72093/java-1-line-solution-d" target="_blank">https://discuss.leetcode.com/topic/72093/java-1-line-solution-d</a></p>
<p><a href="https://discuss.leetcode.com/topic/72289/0ms-c-two-line-solution" target="_blank">https://discuss.leetcode.com/topic/72289/0ms-c-two-line-solution</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-12-20 01:05</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=6201215" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(6201215);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/6258459.html" id="cb_post_title_url">[LeetCode] LFU Cache 最近最不常用页面置换缓存器</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Design and implement a data structure for <a href="https://en.wikipedia.org/wiki/Least_frequently_used" target="_blank">Least Frequently Used (LFU)</a> cache. It should support the following operations: <code>get</code> and <code>put</code>.</p>
<p><code>get(key)</code> - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.<br/><code>put(key, value)</code> - Set or insert the value if the key is not already present. When the cache reaches its capacity, it should invalidate the least frequently used item before inserting a new item. For the purpose of this problem, when there is a tie (i.e., two or more keys that have the same frequency), the least recently used key would be evicted.</p>
<p>Follow up:<br/>Could you do both operations in O(1) time complexity?</p>
<p>Example:</p>
<pre>LFUCache cache = new LFUCache( 2 /* capacity */ );

cache.put(1, 1);
cache.put(2, 2);
cache.get(1);       // returns 1
cache.put(3, 3);    // evicts key 2
cache.get(2);       // returns -1 (not found)
cache.get(3);       // returns 3.
cache.put(4, 4);    // evicts key 1.
cache.get(1);       // returns -1 (not found)
cache.get(3);       // returns 3
cache.get(4);       // returns 4</pre>
<p> </p>
<p>这道题是让我们实现最近不常用页面置换算法LFU (Least Frequently Used), 之前我们做过一道类似的题<a href="http://www.cnblogs.com/grandyang/p/4587511.html" target="_blank">LRU Cache</a>，让我们求最近最少使用页面置换算法LRU (Least Recnetly Used)。两种算法虽然名字看起来很相似，但是其实是不同的。顾名思义，LRU算法是首先淘汰最长时间未被使用的页面，而LFU是先淘汰一定时间内被访问次数最少的页面。光说无凭，举个例子来看看，比如说我们的cache的大小为3，然后我们按顺序存入 5，4，5，4，5，7，这时候cache刚好被装满了，因为put进去之前存在的数不会占用额外地方。那么此时我们想再put进去一个8，如果使用LRU算法，应该将4删除，因为4最久未被使用，而如果使用LFU算法，则应该删除7，因为7被使用的次数最少，只使用了一次。相信这个简单的例子可以大概说明二者的区别。</p>
<p>这道题比之前那道LRU的题目还要麻烦一些，因为那道题只要用个list把数字按时间顺序存入，链表底部的位置总是最久未被使用的，每次删除底部的值即可。而这道题不一样，由于需要删除最少次数的数字，那么我们必须要统计每一个key出现的次数，所以我们用一个哈希表m来记录当前数据{key, value}和其出现次数之间的映射，这样还不够，为了方便操作，我们需要把相同频率的key都放到一个list中，那么需要另一个哈希表freq来建立频率和一个里面所有key都是当前频率的list之间的映射。由于题目中要我们在O(1)的时间内完成操作了，为了快速的定位freq中key的位置，我们再用一个哈希表iter来建立key和freq中key的位置之间的映射。最后当然我们还需要两个变量cap和minFreq，分别来保存cache的大小，和当前最小的频率。</p>
<p>为了更好的讲解思路，我们还是用例子来说明吧，我们假设cache的大小为2，假设我们已经按顺序put进去5，4，那么来看一下内部的数据是怎么保存的，由于value的值并不是很重要，为了不影响key和frequence，我们采用value#来标记：</p>
<p>m:</p>
<p>5 -&gt; {value5, 1}</p>
<p>4 -&gt; {value4, 1}</p>
<p>freq:</p>
<p>1 -&gt; {5，4}</p>
<p>iter:</p>
<p>4 -&gt; list.begin() + 1</p>
<p>5 -&gt; list.begin()</p>
<p>这应该不是很难理解，m中5对应的频率为1，4对应的频率为1，然后freq中频率为1的有4和5。iter中是key所在freq中对应链表中的位置的iterator。然后我们的下一步操作是get(5)，下面是get需要做的步骤：</p>
<p>1. 如果m中不存在5，那么返回-1</p>
<p>2. 从freq中频率为1的list中将5删除</p>
<p>3. 将m中5对应的frequence值自增1</p>
<p>4. 将5保存到freq中频率为2的list的末尾</p>
<p>5. 在iter中保存5在freq中频率为2的list中的位置</p>
<p>6. 如果freq中频率为minFreq的list为空，minFreq自增1</p>
<p>7. 返回m中5对应的value值</p>
<p>经过这些步骤后，我们再来看下此时内部数据的值：</p>
<p>m:</p>
<p>5 -&gt; {value5, 2}</p>
<p>4 -&gt; {value4, 1}</p>
<p>freq:</p>
<p>1 -&gt; {4}</p>
<p>2 -&gt; {5}</p>
<p>iter:</p>
<p>4 -&gt; list.begin()</p>
<p>5 -&gt; list.begin()</p>
<p>这应该不是很难理解，m中5对应的频率为2，4对应的频率为1，然后freq中频率为1的只有4，频率为2的只有5。iter中是key所在freq中对应链表中的位置的iterator。然后我们下一步操作是要put进去一个7，下面是put需要做的步骤：</p>
<p>1. 如果调用get(7)返回的结果不是-1，那么在将m中7对应的value更新为当前value，并返回</p>
<p>2. 如果此时m的大小大于了cap，即超过了cache的容量，则：</p>
<p>　　a）在m中移除minFreq对应的list的首元素的纪录，即移除4 -&gt; {value4, 1}</p>
<p>　　b）在iter中清除4对应的纪录，即移除4 -&gt; list.begin()</p>
<p>　　c）在freq中移除minFreq对应的list的首元素，即移除4</p>
<p>3. 在m中建立7的映射，即 7 -&gt; {value7, 1}</p>
<p>4. 在freq中频率为1的list末尾加上7</p>
<p>5. 在iter中保存7在freq中频率为1的list中的位置</p>
<p>6. minFreq重置为1</p>
<p>经过这些步骤后，我们再来看下此时内部数据的值：</p>
<p>m:</p>
<p>5 -&gt; {value5, 2}</p>
<p>7 -&gt; {value7, 1}</p>
<p>freq:</p>
<p>1 -&gt; {7}</p>
<p>2 -&gt; {5}</p>
<p>iter:</p>
<p>7 -&gt; list.begin()</p>
<p>5 -&gt; list.begin()</p>
<p>参见代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> LFUCache {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    LFUCache(</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> capacity) {
        cap </span>=<span style="color: #000000;"> capacity;
    }
    
    </span><span style="color: #0000ff;">int</span> <span style="color: #0000ff;">get</span>(<span style="color: #0000ff;">int</span><span style="color: #000000;"> key) {
        </span><span style="color: #0000ff;">if</span> (m.count(key) == <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span> -<span style="color: #800080;">1</span><span style="color: #000000;">;
        freq[m[key].second].erase(iter[key]);
        </span>++<span style="color: #000000;">m[key].second;
        freq[m[key].second].push_back(key);
        iter[key] </span>= --<span style="color: #000000;">freq[m[key].second].end();
        </span><span style="color: #0000ff;">if</span> (freq[minFreq].size() == <span style="color: #800080;">0</span>) ++<span style="color: #000000;">minFreq;
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> m[key].first;
    }
    
    </span><span style="color: #0000ff;">void</span> put(<span style="color: #0000ff;">int</span> key, <span style="color: #0000ff;">int</span><span style="color: #000000;"> value) {
        </span><span style="color: #0000ff;">if</span> (cap &lt;= <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">get</span>(key) != -<span style="color: #800080;">1</span><span style="color: #000000;">) {
            m[key].first </span>=<span style="color: #000000;"> value;
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">if</span> (m.size() &gt;=<span style="color: #000000;"> cap) {
            m.erase(freq[minFreq].front());
            iter.erase(freq[minFreq].front());
            freq[minFreq].pop_front();
        }
        m[key] </span>= {value, <span style="color: #800080;">1</span><span style="color: #000000;">};
        freq[</span><span style="color: #800080;">1</span><span style="color: #000000;">].push_back(key);
        iter[key] </span>= --freq[<span style="color: #800080;">1</span><span style="color: #000000;">].end();
        minFreq </span>= <span style="color: #800080;">1</span><span style="color: #000000;">;
    }

</span><span style="color: #0000ff;">private</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> cap, minFreq;
    unordered_map</span>&lt;<span style="color: #0000ff;">int</span>, pair&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;&gt;<span style="color: #000000;"> m;
    unordered_map</span>&lt;<span style="color: #0000ff;">int</span>, list&lt;<span style="color: #0000ff;">int</span>&gt;&gt;<span style="color: #000000;"> freq;
    unordered_map</span>&lt;<span style="color: #0000ff;">int</span>, list&lt;<span style="color: #0000ff;">int</span>&gt;::iterator&gt;<span style="color: #000000;"> iter;
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4587511.html" target="_blank">LRU Cache</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/69436/concise-c-o-1-solution-using-3-hash-maps-with-explanation" target="_blank">https://discuss.leetcode.com/topic/69436/concise-c-o-1-solution-using-3-hash-maps-with-explanation</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-01-07 03:47</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=6258459" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(6258459);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/6087347.html" id="cb_post_title_url">[LeetCode] Repeated Substring Pattern 重复子字符串模式</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="row">
<div class="col-md-12">
<div class="row">
<div class="col-md-12">
<div class="question-content">
<p>Given a non-empty string check if it can be constructed by taking a substring of it and appending multiple copies of the substring together. You may assume the given string consists of lowercase English letters only and its length will not exceed 10000.</p>
<p>Example 1:</p>
<pre>Input: "abab"

Output: True

Explanation: It's the substring "ab" twice.
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input: "aba"

Output: False
</pre>
<p> </p>
<p>Example 3:</p>
<pre>Input: "abcabcabcabc"

Output: True

Explanation: It's the substring "abc" four times. (And the substring "abcabc" twice.)
</pre>
<p> </p>
<p>这道题给了我们一个字符串，问其是否能拆成n个重复的子串。那么既然能拆分成多个子串，那么每个子串的长度肯定不能大于原字符串长度的一半，那么我们可以从原字符串长度的一半遍历到1，如果当前长度能被总长度整除，说明可以分成若干个子字符串，我们将这些子字符串拼接起来看跟原字符串是否相等。 如果拆完了都不相等，返回false。</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> repeatedSubstringPattern(<span style="color: #0000ff;">string</span><span style="color: #000000;"> str) {
        </span><span style="color: #0000ff;">int</span> n =<span style="color: #000000;"> str.size();
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = n / <span style="color: #800080;">2</span>; i &gt;= <span style="color: #800080;">1</span>; --<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (n % i == <span style="color: #800080;">0</span><span style="color: #000000;">) {
                </span><span style="color: #0000ff;">int</span> c = n /<span style="color: #000000;"> i;
                </span><span style="color: #0000ff;">string</span> t = <span style="color: #800000;">""</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; c; ++<span style="color: #000000;">j) {
                    t </span>+= str.substr(<span style="color: #800080;">0</span><span style="color: #000000;">, i); 
                }
                </span><span style="color: #0000ff;">if</span> (t == str) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
            }
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种方法是参考的<a href="https://discuss.leetcode.com/topic/67652/c-o-n-using-kmp-32ms-8-lines-of-code-with-brief-explanation" target="_blank">网上的这个帖子</a>，原作者说是用的KMP算法，LeetCode之前也有一道应用KMP算法来解的题<a href="http://www.cnblogs.com/grandyang/p/4523624.html" target="_blank">Shortest Palindrome</a>，但是感觉那道题才是KMP算法。这道题也称为KMP算法感觉怪怪的(关于KMP的详细介绍请参见<a href="http://blog.csdn.net/v_july_v/article/details/7041827" target="_blank">从头到尾彻底理解KMP</a>，也可以看博主自己写的一篇<a href="http://www.cnblogs.com/grandyang/p/6992403.html" title="发布于2017-06-12 13:08">KMP Algorithm 字符串匹配算法KMP小结</a>)，KMP算法中的next数组是找当前位置的最大相同前缀后缀的个数，而这道题维护的一位数组dp[i]表示，到位置i-1为止的重复字符串的字符个数，不包括被重复的那个字符串，什么意思呢，我们举个例子，比如"abcabc"的dp数组为[0 0 0 0 1 2 3]，dp数组长度要比原字符串长度多一个。那么我们看最后一个位置数字为3，就表示重复的字符串的字符数有3个。如果是"abcabcabc"，那么dp数组为[0 0 0 0 1 2 3 4 5 6]，我们发现最后一个数字为6，那么表示重复的字符串为“abcabc”，有6个字符。那么怎么通过最后一个数字来知道原字符串是否由重复的子字符串组成的呢，首先当然是最后一个数字不能为0，而且还要满足dp[n] % (n - dp[n]) == 0才行，因为n - dp[n]是一个子字符串的长度，那么重复字符串的长度和肯定是一个子字符串的整数倍，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> repeatedSubstringPattern(<span style="color: #0000ff;">string</span><span style="color: #000000;"> str) {
        </span><span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>, j = <span style="color: #800080;">0</span>, n =<span style="color: #000000;"> str.size();
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; dp(n + <span style="color: #800080;">1</span>, <span style="color: #800080;">0</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">while</span> (i &lt;<span style="color: #000000;"> n) {
            </span><span style="color: #0000ff;">if</span> (str[i] == str[j]) dp[++i] = ++<span style="color: #000000;">j;
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (j == <span style="color: #800080;">0</span>) ++<span style="color: #000000;">i;
            </span><span style="color: #0000ff;">else</span> j =<span style="color: #000000;"> dp[j];
        }
        </span><span style="color: #0000ff;">return</span> dp[n] &amp;&amp; (dp[n] % (n - dp[n]) == <span style="color: #800080;">0</span><span style="color: #000000;">);
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4606696.html" target="_blank">Implement strStr()</a></p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/7631434.html" id="homepage1_HomePageDays_DaysList_ctl14_DayList_TitleUrl_0">Repeated String Match</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/68498/one-line-with-regex/2" target="_blank">https://discuss.leetcode.com/topic/68498/one-line-with-regex/2</a></p>
<p><a href="https://discuss.leetcode.com/topic/67992/java-simple-solution-with-explanation" target="_blank">https://discuss.leetcode.com/topic/67992/java-simple-solution-with-explanation</a></p>
</div>
</div>
</div>
</div>
</div>
<div id="interviewed-div"><a href="https://discuss.leetcode.com/topic/67652/c-o-n-using-kmp-32ms-8-lines-of-code-with-brief-explanation" target="_blank">https://discuss.leetcode.com/topic/67652/c-o-n-using-kmp-32ms-8-lines-of-code-with-brief-explanation</a></div>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-11-21 22:37</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=6087347" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(6087347);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7664088.html" id="cb_post_title_url">[LeetCode] Poor Pigs 可怜的猪</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>There are 1000 buckets, one and only one of them contains poison, the rest are filled with water. They all look the same. If a pig drinks that poison it will die within 15 minutes. What is the minimum amount of pigs you need to figure out which bucket contains the poison within one hour.</p>
<p>Answer this question, and write an algorithm for the follow-up general case.</p>
<p>Follow-up:</p>
<p>If there are n buckets and a pig drinking poison will die within m minutes, how many pigs (x) you need to figure out the "poison" bucket within p minutes? There is exact one bucket with poison.</p>
<p> </p>
<p>这道题博主拿到以后并木有什么头绪，可是明明标的是Easy，打击甚大，于是去论坛上大神们的解法，感觉这道题应该算是一道Brain Teaser的题，对问题的分析能力要求很高。那么我们来一步一步从最简单的情况来分析吧，假设只有1只猪，只有15分钟，那么我们能测几个水桶呢？很显然是两个，因为只能测一次的话，让猪去随便喝一桶，如果毒死了，就是喝的那桶，反之则是另一桶。好，那么如果有两只猪呢，能测几桶？怎么喝呢，两只猪一猪喝一桶，再同时喝一桶，剩下一桶谁也不喝，那么如果两只猪都毒死了，说明是共同喝的那桶有毒，如果某个猪毒死了，说明该猪喝的那桶有毒，如果都没事，说明是谁也没喝的那桶。那么我们应该看出规律了吧，没错，三猪能测8桶，其实就是2的指数倍。</p>
<p>如果只能测一次的话，实际上相当一个一维数组，而如果能测两次的话，情况就不一样了，我们就可以重复利用猪了。比如还是两只猪，能测两次，功能测几个桶，答案可以测9桶，为啥，我们组个二维数组：</p>
<p>1  2  3</p>
<p>4  5  6</p>
<p>7  8  9</p>
<p>如果我们让第一头猪第一次喝1，2，3桶，第二次喝4，5，6桶，而让第二头猪第一次喝1，4，7桶，第二次喝2，5，8桶，我们可以根据猪的死亡情况来确定是哪一桶的问题，实际上就把猪被毒死的那个节点当作了二维数组的横纵坐标来定位毒桶的位置，巧妙吧～更巧妙的是，如果再增加一头猪，实际上是给数组增加一个维度，变成了一个三维数组，那么三只猪，测两次，可以测27桶，叼不叼。这道题让我们求最少用多少猪来测，那么就是求数组的维度，我们知道了数组的总个数，所以要尽量增加数组的长宽，尽量减少维度。这里，数组的长宽其实都是测试的次数+1，所以我们首先要确定能测的次数，通过总测试时间除以毒发时间，再加上1就是测试次数。有了数组长宽m，那么如果有x只猪，能测的桶数为m的x次方，现在我们给定了桶数N，要求x，就log一下就行，然后用个换底公式，就可以求出x的值了，参见代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> poorPigs(<span style="color: #0000ff;">int</span> buckets, <span style="color: #0000ff;">int</span> minutesToDie, <span style="color: #0000ff;">int</span><span style="color: #000000;"> minutesToTest) {
        </span><span style="color: #0000ff;">return</span> ceil(log(buckets) / log(minutesToTest / minutesToDie + <span style="color: #800080;">1</span><span style="color: #000000;">));
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/67666/another-explanation-and-solution">https://discuss.leetcode.com/topic/67666/another-explanation-and-solution</a></p>
<p><a href="https://discuss.leetcode.com/topic/67482/solution-with-detailed-explanation">https://discuss.leetcode.com/topic/67482/solution-with-detailed-explanation</a></p>
<p><a href="https://discuss.leetcode.com/topic/70733/1-line-solution-with-detailed-problem-clarification-math-proof-please-read-if-you-really-want-to-know-what-this-problem-means">https://discuss.leetcode.com/topic/70733/1-line-solution-with-detailed-problem-clarification-math-proof-please-read-if-you-really-want-to-know-what-this-problem-means</a></p>
<p> </p>
<div id="cnblogs_post_body">
<p><a href="http://www.cnblogs.com/grandyang/p/4606334.html" target="_blank">LeetCode All in One 题目讲解汇总(持续更新中...)</a> </p>
</div></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-10-13 23:45</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7664088" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7664088);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7658128.html" id="cb_post_title_url">[LeetCode] Circular Array Loop 环形数组循环</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>You are given an array of positive and negative integers. If a number n at an index is positive, then move forward n steps. Conversely, if it's negative (-n), move backward n steps. Assume the first element of the array is forward next to the last element, and the last element is backward next to the first element. Determine if there is a loop in this array. A loop starts and ends at a particular index with more than 1 element along the loop. The loop must be "forward" or "backward'.</p>
<p>Example 1: Given the array [2, -1, 1, 2, 2], there is a loop, from index 0 -&gt; 2 -&gt; 3 -&gt; 0.</p>
<p>Example 2: Given the array [-1, 2], there is no loop.</p>
<p>Note: The given array is guaranteed to contain no element "0".</p>
<p>Can you do it in O(n) time complexity and O(1) space complexity?</p>
<p> </p>
<p>说实话，这道题描述的并不是很清楚，比如题目中有句话说循环必须是forward或是backward的，如果不给例子说明，不太容易能get到point。所谓的循环必须是一个方向的就是说不能跳到一个数，再反方向跳回来，这不算一个loop。比如[1, -1]就不是一个loop，而[1, 1]是一个正确的loop。看到论坛中一半的帖子都是各种需要clarify和不理解test case就感觉很好笑～博主也成功踩坑了。弄清楚了题意后来考虑如何做，由于从一个位置只能跳到一个别的位置，而不是像图那样一个点可以到多个位置，所以这里我们就可以根据坐标建立一对一的映射，一旦某个达到的坐标已经有映射了，说明环存在，当然我们还需要进行一系列条件判断。首先我们需要一个visited数组，来记录访问过的数字，然后我们遍历原数组，如果当前数字已经访问过了，直接跳过，否则就以当前位置坐标为起始点开始查找，进行while循环，将当前位置在visited数组中标记true，然后计算下一个位置，计算方法是当前位置坐标加上对应的数字，由于是循环数组，所以结果可能会超出数组的长度，所以我们要对数组长度取余。当然上面的数字也可能是负数，加完以后可能也是负数，所以光取余还不够，还得再补上一个n，使其变为正数。此时我们判断，如果next和cur相等，说明此时是一个数字的循环，不符合题意，再有就是检查二者的方向，数字是正数表示forward，若是负数表示backward，在一个loop中必须同正或同负，我们只要让二者相乘，如果结果是负数的话，说明方向不同，直接break掉。此时如果next已经有映射了，说明我们找到了合法的loop，返回true，否则建立一个这样的映射，继续循环，参见代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> circularArrayLoop(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        unordered_map</span>&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> m;
        </span><span style="color: #0000ff;">int</span> n =<span style="color: #000000;"> nums.size();
        vector</span>&lt;<span style="color: #0000ff;">bool</span>&gt; visited(n, <span style="color: #0000ff;">false</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (visited[i]) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">int</span> cur =<span style="color: #000000;"> i;
            </span><span style="color: #0000ff;">while</span> (<span style="color: #0000ff;">true</span><span style="color: #000000;">) {
                visited[cur] </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">int</span> next = (cur + nums[cur]) %<span style="color: #000000;"> n;
                </span><span style="color: #0000ff;">if</span> (next &lt; <span style="color: #800080;">0</span>) next +=<span style="color: #000000;"> n;
                </span><span style="color: #0000ff;">if</span> (next == cur || nums[next] * nums[cur] &lt; <span style="color: #800080;">0</span>) <span style="color: #0000ff;">break</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">if</span> (m.count(next)) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                m[cur] </span>=<span style="color: #000000;"> next;
                cur </span>=<span style="color: #000000;"> next;
            }
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-10-12 21:09</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7658128" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7658128);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/6081984.html" id="cb_post_title_url">[LeetCode] 132 Pattern 132模式</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="row">
<div class="col-md-12">
<div class="row">
<div class="col-md-12">
<div class="question-content">
<p>Given a sequence of n integers a1, a2, ..., an, a 132 pattern is a subsequence ai, aj, ak such that i &lt; j &lt; k and ai &lt; ak &lt; aj. Design an algorithm that takes a list of n numbers as input and checks whether there is a 132 pattern in the list.</p>
<p>Note: n will be less than 15,000.</p>
<p>Example 1:</p>
<pre>Input: [1, 2, 3, 4]

Output: False

Explanation: There is no 132 pattern in the sequence.
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input: [3, 1, 4, 2]

Output: True

Explanation: There is a 132 pattern in the sequence: [1, 4, 2].
</pre>
<p> </p>
<p>Example 3:</p>
<pre>Input: [-1, 3, 2, 0]

Output: True

Explanation: There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0].
</pre>
<p> </p>
<p>这道题给我们了一个数组，让我们找到132的模式，就是第一个数小于第二第三个数，且第三个数小于第二个数。那么我们就按顺序来找这三个数，首先我们来找第一个数，这个数需要最小，那么我们如果发现当前数字大于等于后面一个数字，我们就往下继续遍历，直到当前数字小于下一个数字停止。然后我们找第二个数字，这个数字需要最大，那么如果我们发现当前数字小于等于下一个数字就继续遍历，直到当前数字大雨下一个数字停止。最后就找第三个数字，我们验证这个数字是否在之前两个数字的中间，如果没有找到，我们就从第二个数字的后面一个位置继续开始重新找这三个数字，参见代码如下：</p>
<p> </p>
<div>
<div class="btn btn-xs btn-warning" id="tags">解法一：</div>
<div class="btn btn-xs btn-warning">
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> find132pattern(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        </span><span style="color: #0000ff;">if</span> (nums.size() &lt;= <span style="color: #800080;">2</span>) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> n = nums.size(), i = <span style="color: #800080;">0</span>, j = <span style="color: #800080;">0</span>, k = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (i &lt;<span style="color: #000000;"> n) {
            </span><span style="color: #0000ff;">while</span> (i &lt; n - <span style="color: #800080;">1</span> &amp;&amp; nums[i] &gt;= nums[i + <span style="color: #800080;">1</span>]) ++<span style="color: #000000;">i;
            j </span>= i + <span style="color: #800080;">1</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">while</span> (j &lt; n - <span style="color: #800080;">1</span> &amp;&amp; nums[j] &lt;= nums[j + <span style="color: #800080;">1</span>]) ++<span style="color: #000000;">j;
            k </span>= j + <span style="color: #800080;">1</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">while</span> (k &lt;<span style="color: #000000;"> n) {
                </span><span style="color: #0000ff;">if</span> (nums[k] &gt; nums[i] &amp;&amp; nums[k] &lt; nums[j]) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                </span>++<span style="color: #000000;">k;
            }
            i </span>= j + <span style="color: #800080;">1</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
    }
};    </span></pre>
</div>
<p> </p>
<p>下面这种方法利用来栈来做，既简洁又高效，思路是我们维护一个栈和一个变量third，其中third就是第三个数字，也是pattern 132中的2，栈里面按顺序放所有大于third的数字，也是pattern 132中的3，那么我们在遍历的时候，如果当前数字小于third，即pattern 132中的1找到了，我们直接返回true即可，因为已经找到了，注意我们应该从后往前遍历数组。如果当前数字大于栈顶元素，那么我们按顺序将栈顶数字取出，赋值给third，然后将该数字压入栈，这样保证了栈里的元素仍然都是大于third的，我们想要的顺序依旧存在，进一步来说，栈里存放的都是可以维持second &gt; third的second值，其中的任何一个值都是大于当前的third值，如果有更大的值进来，那就等于形成了一个更优的second &gt; third的这样一个组合，并且这时弹出的third值比以前的third值更大，为什么要保证third值更大，因为这样才可以更容易的满足当前的值first比third值小这个条件，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> find132pattern(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        </span><span style="color: #0000ff;">int</span> third =<span style="color: #000000;"> INT_MIN;
        stack</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> s;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = nums.size() - <span style="color: #800080;">1</span>; i &gt;= <span style="color: #800080;">0</span>; --<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (nums[i] &lt; third) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">while</span> (!s.empty() &amp;&amp; nums[i] &gt;<span style="color: #000000;"> s.top()) {
                third </span>=<span style="color: #000000;"> s.top(); s.pop();
            }
            s.push(nums[i]);
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/67767/c-_ac" target="_blank">https://discuss.leetcode.com/topic/67767/c-_ac</a></p>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="interviewed-div"><a href="https://discuss.leetcode.com/topic/67881/single-pass-c-o-n-space-and-time-solution-8-lines-with-detailed-explanation/2" target="_blank">https://discuss.leetcode.com/topic/67881/single-pass-c-o-n-space-and-time-solution-8-lines-with-detailed-explanation/2</a></div>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-11-20 00:58</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=6081984" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(6081984);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/6077344.html" id="cb_post_title_url">[LeetCode] Assign Cookies 分点心</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie. Each child i has a greed factor gi, which is the minimum size of a cookie that the child will be content with; and each cookie j has a size sj. If sj &gt;= gi, we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.</p>
<p>Note:<br/>You may assume the greed factor is always positive. <br/>You cannot assign more than one cookie to one child.</p>
<p>Example 1:</p>
<pre>Input: [1,2,3], [1,1]

Output: 1

Explanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3. 
And even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.
You need to output 1.
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input: [1,2], [1,2,3]

Output: 2

Explanation: You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2. 
You have 3 cookies and their sizes are big enough to gratify all of the children, 
You need to output 2.</pre>
<p> </p>
<p>这道题给了我们一堆cookie，每个cookie的大小不同，还有一堆小朋友，每个小朋友的胃口也不同的，问我们当前的cookie最多能满足几个小朋友。这是典型的利用贪婪算法的题目，我们可以首先对两个数组进行排序，让小的在前面。然后我们先拿最小的cookie给胃口最小的小朋友，看能否满足，能的话，我们结果res自加1，然后再拿下一个cookie去满足下一位小朋友；如果当前cookie不能满足当前小朋友，那么我们就用下一块稍大一点的cookie去尝试满足当前的小朋友。当cookie发完了或者小朋友没有了我们停止遍历，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> findContentChildren(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; g, vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> s) {
         </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, p = <span style="color: #800080;">0</span><span style="color: #000000;">;
         sort(g.begin(), g.end());
         sort(s.begin(), s.end());
         </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; s.size(); ++<span style="color: #000000;">i) {
             </span><span style="color: #0000ff;">if</span> (s[i] &gt;=<span style="color: #000000;"> g[p]) {
                 </span>++<span style="color: #000000;">res;
                 </span>++<span style="color: #000000;">p;
                 </span><span style="color: #0000ff;">if</span> (p &gt;= g.size()) <span style="color: #0000ff;">break</span><span style="color: #000000;">;
             }
         }
         </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>我们可以对上述代码进行精简，我们用变量j既可以表示小朋友数组的坐标，同时又可以表示已满足的小朋友的个数，因为只有满足了当前的小朋友，才会去满足下一个胃口较大的小朋友，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> findContentChildren(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; g, vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> s) {
        </span><span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span><span style="color: #000000;">;
        sort(g.begin(), g.end());
        sort(s.begin(), s.end());
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; s.size() &amp;&amp; j &lt; g.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (s[i] &gt;= g[j]) ++<span style="color: #000000;">j;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> j;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/67676/simple-greedy-java-solution" target="_blank">https://discuss.leetcode.com/topic/67676/simple-greedy-java-solution</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-11-18 13:02</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=6077344" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(6077344);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/6073317.html" id="cb_post_title_url">[LeetCode] 4Sum II 四数之和之二</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given four lists A, B, C, D of integer values, compute how many tuples <code>(i, j, k, l)</code> there are such that <code>A[i] + B[j] + C[k] + D[l]</code> is zero.</p>
<p>To make problem a bit easier, all A, B, C, D have same length of N where 0 ≤ N ≤ 500. All integers are in the range of -228 to 228 - 1 and the result is guaranteed to be at most 231 - 1.</p>
<p>Example:</p>
<pre>Input:
A = [ 1, 2]
B = [-2,-1]
C = [-1, 2]
D = [ 0, 2]

Output:
2

Explanation:
The two tuples are:
1. (0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0
2. (1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0</pre>
<p> </p>
<p>这道题是之前那道<a href="http://www.cnblogs.com/grandyang/p/4515925.html" target="_blank">4Sum</a>的延伸，让我们在四个数组中各取一个数字，使其和为0。那么坠傻的方法就是遍历所有的情况，时间复杂度为O(n<sup>4</sup>)。但是我们想想既然<a href="http://www.cnblogs.com/grandyang/p/4130379.html" target="_blank">Two Sum</a>那道都能将时间复杂度缩小一倍，那么这道题我们使用哈希表是否也能将时间复杂度降到O(n<sup>2</sup>)呢？答案是肯定的，我们如果把A和B的两两之和都求出来，在哈希表中建立两数之和跟其出现次数之间的映射，那么我们再遍历C和D中任意两个数之和，我们只要看哈希表存不存在这两数之和的相反数就行了，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> fourSumCount(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; A, vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; B, vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; C, vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> D) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        unordered_map</span>&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> m;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; A.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; B.size(); ++<span style="color: #000000;">j) {
                </span>++m[A[i] +<span style="color: #000000;"> B[j]];
            }
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; C.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; D.size(); ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">int</span> target = -<span style="color: #800080;">1</span> * (C[i] +<span style="color: #000000;"> D[j]);
                res </span>+=<span style="color: #000000;"> m[target];
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>这种方法用了两个哈希表分别记录AB和CB的两两之和出现次数，然后遍历其中一个哈希表，并在另一个哈希表中找和的相反数出现的次数，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> fourSumCount(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; A, vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; B, vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; C, vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> D) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, n =<span style="color: #000000;"> A.size();
        unordered_map</span>&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> m1, m2;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; n; ++<span style="color: #000000;">j) {
                </span>++m1[A[i] +<span style="color: #000000;"> B[j]];
                </span>++m2[C[i] +<span style="color: #000000;"> D[j]];
            }
        }
        </span><span style="color: #0000ff;">for</span> (auto a : m1) res += a.second * m2[-<span style="color: #000000;">a.first];
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4515925.html" target="_blank">4Sum</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/67593/clean-java-solution-o-n-2" target="_blank">https://discuss.leetcode.com/topic/67593/clean-java-solution-o-n-2</a></p>
<p><a href="https://discuss.leetcode.com/topic/67729/concise-8-line-c-solution-with-hashmap-simple-and-clean/2" target="_blank">https://discuss.leetcode.com/topic/67729/concise-8-line-c-solution-with-hashmap-simple-and-clean/2</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-11-17 12:38</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=6073317" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(6073317);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/6053827.html" id="cb_post_title_url">[LeetCode] Minimum Moves to Equal Array Elements 最少移动次数使数组元素相等</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="row">
<div class="col-md-12">
<div class="row">
<div class="col-md-12">
<div class="question-content">
<p>Given a non-empty integer array of size <em>n</em>, find the minimum number of moves required to make all array elements equal, where a move is incrementing <em>n</em> - 1 elements by 1.</p>
<p>Example:</p>
<pre>Input:
[1,2,3]

Output:
3

Explanation:
Only three moves are needed (remember each move increments two elements):

[1,2,3]  =&gt;  [2,3,3]  =&gt;  [3,4,3]  =&gt;  [4,4,4]
</pre>
<p> </p>
<p>这道题给了我们一个长度为n的数组，说是我们每次可以对n-1个数字同时加1，问最少需要多少次这样的操作才能让数组中所有的数字相等。那么我们想，为了快速的缩小差距，该选择哪些数字加1呢，不难看出每次需要给除了数组最大值的所有数字加1，这样能快速的到达平衡状态。但是这道题如果我们老老实实的每次找出最大值，然后给其他数字加1，再判断是否平衡，思路是正确，但是OJ不答应。正确的解法相当的巧妙，需要换一个角度来看问题，其实给n-1个数字加1，效果等同于给那个未被选中的数字减1，比如数组[1，2，3], 给除去最大值的其他数字加1，变为[2，3，3]，我们全体减1，并不影响数字间相对差异，变为[1，2，2]，这个结果其实就是原始数组的最大值3自减1，那么问题也可能转化为，将所有数字都减小到最小值，这样难度就大大降低了，我们只要先找到最小值，然后累加每个数跟最小值之间的差值即可，参见代码如下：</p>
<div> </div>
<div>解法一：</div>
<div>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> minMoves(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        </span><span style="color: #0000ff;">int</span> mn = INT_MAX, res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> num : nums) mn =<span style="color: #000000;"> min(mn, num);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> num : nums) res += num -<span style="color: #000000;"> mn;
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>我们也可以求出数组的数字之和sum，然后用sum减去最小值和数组长度的乘积，也能得到答案：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> minMoves(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        </span><span style="color: #0000ff;">int</span> mn = INT_MAX, sum = <span style="color: #800080;">0</span>, res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span><span style="color: #000000;"> num : nums) {
            mn </span>=<span style="color: #000000;"> min(mn, num);
            sum </span>+=<span style="color: #000000;"> num;
        }
        </span><span style="color: #0000ff;">return</span> sum - mn *<span style="color: #000000;"> nums.size();
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/66562/simple-one-liners" target="_blank">https://discuss.leetcode.com/topic/66562/simple-one-liners</a></p>
<p><a href="https://discuss.leetcode.com/topic/66557/java-o-n-solution-short" target="_blank">https://discuss.leetcode.com/topic/66557/java-o-n-solution-short</a></p>
<p> </p>
</div>
<div><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a> </div>
</div>
</div>
</div>
</div>
</div></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-11-11 12:42</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=6053827" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(6053827);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/6050562.html" id="cb_post_title_url">[LeetCode] Minimum Number of Arrows to Burst Balloons 最少数量的箭引爆气球</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>There are a number of spherical balloons spread in two-dimensional space. For each balloon, provided input is the start and end coordinates of the horizontal diameter. Since it's horizontal, y-coordinates don't matter and hence the x-coordinates of start and end of the diameter suffice. Start is always smaller than end. There will be at most 10<sup>4</sup> balloons.</p>
<p>An arrow can be shot up exactly vertically from different points along the x-axis. A balloon with x<sub>start</sub> and x<sub>end</sub> bursts by an arrow shot at x if x<sub>start</sub> ≤ x ≤ x<sub>end</sub>. There is no limit to the number of arrows that can be shot. An arrow once shot keeps travelling up infinitely. The problem is to find the minimum number of arrows that must be shot to burst all balloons.</p>
<p><strong>Example:</strong></p>
<pre><strong>Input:</strong>
[[10,16], [2,8], [1,6], [7,12]]

<strong>Output:</strong>
2

<strong>Explanation:</strong>
One way is to shoot one arrow for example at x = 6 (bursting the balloons [2,8] and [1,6]) and another arrow at x = 11 (bursting the other two balloons).
</pre>
<p> </p>
<p>这道题给了我们一堆大小不等的气球，用区间范围来表示气球的大小，可能会有重叠区间。然后我们用最少的箭数来将所有的气球打爆。那么这道题是典型的用贪婪算法来做的题，因为局部最优解就等于全局最优解，我们首先给区间排序，我们不用特意去写排序比较函数，因为默认的对于pair的排序，就是按第一个数字升序排列，如果第一个数字相同，那么按第二个数字升序排列，这个就是我们需要的顺序，所以直接用即可。然后我们将res初始化为1，因为气球数量不为0，所以怎么也得先来一发啊，然后这一箭能覆盖的最远位置就是第一个气球的结束点，用变量end来表示。然后我们开始遍历剩下的气球，如果当前气球的开始点小于等于end，说明跟之前的气球有重合，之前那一箭也可以照顾到当前的气球，此时我们要更新end的位置，end更新为两个气球结束点之间较小的那个，这也是当前气球和之前气球的重合点，然后继续看后面的气球；如果某个气球的起始点大于end了，说明前面的箭无法覆盖到当前的气球，那么就得再来一发，既然又来了一发，那么我们此时就要把end设为当前气球的结束点了，这样贪婪算法遍历结束后就能得到最少的箭数了，参见代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> findMinArrowShots(vector&lt;pair&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> points) {
        </span><span style="color: #0000ff;">if</span> (points.empty()) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        sort(points.begin(), points.end());
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">1</span>, end = points[<span style="color: #800080;">0</span><span style="color: #000000;">].second;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt; points.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (points[i].first &lt;=<span style="color: #000000;"> end) {
                end </span>=<span style="color: #000000;"> min(end, points[i].second);
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                </span>++<span style="color: #000000;">res;
                end </span>=<span style="color: #000000;"> points[i].second;
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/66579/java-greedy-soution" target="_blank">https://discuss.leetcode.com/topic/66579/java-greedy-soution</a></p>
<p><a href="https://discuss.leetcode.com/topic/66548/concise-java-solution-tracking-the-end-of-overlapping-intervals" target="_blank">https://discuss.leetcode.com/topic/66548/concise-java-solution-tracking-the-end-of-overlapping-intervals</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-11-10 13:24</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=6050562" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(6050562);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/6231504.html" id="cb_post_title_url">[LeetCode] Sort Characters By Frequency 根据字符出现频率排序</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="row">
<div class="col-md-12">
<div class="row">
<div class="col-md-12">
<div class="question-content">
<p>Given a string, sort it in decreasing order based on the frequency of characters.</p>
<p>Example 1:</p>
<pre>Input:
"tree"

Output:
"eert"

Explanation:
'e' appears twice while 'r' and 't' both appear once.
So 'e' must appear before both 'r' and 't'. Therefore "eetr" is also a valid answer.
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input:
"cccaaa"

Output:
"cccaaa"

Explanation:
Both 'c' and 'a' appear three times, so "aaaccc" is also a valid answer.
Note that "cacaca" is incorrect, as the same characters must be together.
</pre>
<p> </p>
<p>Example 3:</p>
<pre>Input:
"Aabb"

Output:
"bbAa"

Explanation:
"bbaA" is also a valid answer, but "Aabb" is incorrect.
Note that 'A' and 'a' are treated as two different characters.
</pre>
<p> </p>
<p>这道题让我们给一个字符串按照字符出现的频率来排序，那么毫无疑问肯定要先统计出每个字符出现的个数，那么之后怎么做呢？我们可以利用优先队列的自动排序的特点，把个数和字符组成pair放到优先队列里排好序后，再取出来组成结果res即可，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> frequencySort(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        </span><span style="color: #0000ff;">string</span> res = <span style="color: #800000;">""</span><span style="color: #000000;">;
        priority_queue</span>&lt;pair&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">char</span>&gt;&gt;<span style="color: #000000;"> q;
        unordered_map</span>&lt;<span style="color: #0000ff;">char</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> m;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span> c : s) ++<span style="color: #000000;">m[c];
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto a : m) q.push({a.second, a.first});
        </span><span style="color: #0000ff;">while</span> (!<span style="color: #000000;">q.empty()) {
            auto t </span>=<span style="color: #000000;"> q.top(); q.pop();
            res.append(t.first, t.second);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>我们也可以使用STL自带的sort来做，关键就在于重写comparator，由于需要使用外部变量，记得中括号中放入＆，然后我们将频率大的返回，注意一定还要处理频率相等的情况，要不然两个频率相等的字符可能穿插着出现在结果res中，这样是不对的。参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> frequencySort(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        unordered_map</span>&lt;<span style="color: #0000ff;">char</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> m;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span> c : s) ++<span style="color: #000000;">m[c];
        sort(s.begin(), s.end(), [</span>&amp;](<span style="color: #0000ff;">char</span>&amp; a, <span style="color: #0000ff;">char</span>&amp;<span style="color: #000000;"> b){
            </span><span style="color: #0000ff;">return</span> m[a] &gt; m[b] || (m[a] == m[b] &amp;&amp; a &lt;<span style="color: #000000;"> b);
        });
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> s;
    }
};</span></pre>
</div>
<p> </p>
<p>我们也可以不使用优先队列，而是建立一个字符串数组，因为某个字符的出现次数不可能超过s的长度，所以我们将每个字符根据其出现次数放入数组中的对应位置，那么最后我们只要从后往前遍历数组所有位置，将不为空的位置的字符串加入结果res中即可，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> frequencySort(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        </span><span style="color: #0000ff;">string</span> res = <span style="color: #800000;">""</span><span style="color: #000000;">;
        vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; v(s.size() + <span style="color: #800080;">1</span>, <span style="color: #800000;">""</span><span style="color: #000000;">);
        unordered_map</span>&lt;<span style="color: #0000ff;">char</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> m;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span> c : s) ++<span style="color: #000000;">m[c];
        </span><span style="color: #0000ff;">for</span> (auto&amp;<span style="color: #000000;"> a : m) {
            v[a.second].append(a.second, a.first);
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = s.size(); i &gt; <span style="color: #800080;">0</span>; --<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (!<span style="color: #000000;">v[i].empty()) {
                res.append(v[i]);
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/7689927.html">Top K Frequent Words</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/5802109.html">First Unique Character in a String</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
</div>
</div>
</div>
</div>
</div>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-12-29 03:56</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=6231504" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(6231504);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/6228252.html" id="cb_post_title_url">[LeetCode] Delete Node in a BST 删除二叉搜索树中的节点</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST.</p>
<p>Basically, the deletion can be divided into two stages:</p>
<ol>
<li>Search for a node to remove.</li>
<li>If the node is found, delete the node.</li>
</ol>
<p><strong>Note:</strong> Time complexity should be O(height of tree).</p>
<p><strong>Example:</strong></p>
<pre>root = [5,3,6,2,4,null,7]
key = 3

    5
   / \
  3   6
 / \   \
2   4   7

Given key to delete is 3. So we find the node with value 3 and delete it.

One valid answer is [5,4,6,2,null,null,7], shown in the following BST.

    5
   / \
  4   6
 /     \
2       7

Another valid answer is [5,2,6,null,4,null,7].

    5
   / \
  2   6
   \   \
    4   7
</pre>
<p> </p>
<p>这道题让我们删除二叉搜索树中的一个节点，这道题的难点在于删除完节点并补上那个节点的位置后还应该是一棵二叉搜索树。被删除掉的节点位置，不一定是由其的左右子节点补上，比如下面这棵树：</p>
<p>         7<br/>        / \<br/>       4   8<br/>     /   \   <br/>    2     6<br/>     \   /<br/>      3 5</p>
<p>如果我们要删除节点4，那么应该将节点5补到4的位置，这样才能保证还是BST，那么结果是如下这棵树：</p>
<p>         7<br/>        / \<br/>       5   8<br/>     /   \   <br/>    2     6<br/>     \   <br/>      3 </p>
<p>我们先来看一种递归的解法，首先判断根节点是否为空。由于BST的左&lt;根&lt;右的性质，使得我们可以快速定位到要删除的节点，我们对于当前节点值不等于key的情况，根据大小关系对其左右子节点分别调用递归函数。若当前节点就是要删除的节点，我们首先判断是否有一个子节点不存在，那么我们就将root指向另一个节点，如果左右子节点都不存在，那么root就赋值为空了，也正确。难点就在于处理左右子节点都存在的情况，我们需要在右子树找到最小值，即右子树中最左下方的节点，然后将该最小值赋值给root，然后再在右子树中调用递归函数来删除这个值最小的节点，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    TreeNode</span>* deleteNode(TreeNode* root, <span style="color: #0000ff;">int</span><span style="color: #000000;"> key) {
        </span><span style="color: #0000ff;">if</span> (!root) <span style="color: #0000ff;">return</span><span style="color: #000000;"> NULL;
        </span><span style="color: #0000ff;">if</span> (root-&gt;val &gt;<span style="color: #000000;"> key) {
            root</span>-&gt;left = deleteNode(root-&gt;<span style="color: #000000;">left, key);
        } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (root-&gt;val &lt;<span style="color: #000000;"> key) {
            root</span>-&gt;right = deleteNode(root-&gt;<span style="color: #000000;">right, key);
        } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            </span><span style="color: #0000ff;">if</span> (!root-&gt;left || !root-&gt;<span style="color: #000000;">right) {
                root </span>= (root-&gt;left) ? root-&gt;left : root-&gt;<span style="color: #000000;">right;
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                TreeNode </span>*cur = root-&gt;<span style="color: #000000;">right;
                </span><span style="color: #0000ff;">while</span> (cur-&gt;left) cur = cur-&gt;<span style="color: #000000;">left;
                root</span>-&gt;val = cur-&gt;<span style="color: #000000;">val;
                root</span>-&gt;right = deleteNode(root-&gt;right, cur-&gt;<span style="color: #000000;">val);
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> root;
    }
};</span></pre>
</div>
<p> </p>
<p>下面我们来看迭代的写法，还是通过BST的性质来快速定位要删除的节点，如果没找到直接返回空。遍历的过程要记录上一个位置的节点pre，如果pre不存在，说明要删除的是根节点，如果要删除的节点在pre的左子树中，那么pre的左子节点连上删除后的节点，反之pre的右子节点连上删除后的节点。在删除函数中，如果左右子节点都不存在，那么返回空；如果有一个不存在，那么我们返回那个存在的；难点还是在于处理左右子节点都存在的情况，还是要找到需要删除节点的右子树中的最小值，然后把最小值赋值给要删除节点，然后就是要处理最小值可能存在的右子树的连接问题，如果要删除节点的右子节点没有左子节点了的话，那么最小值的右子树直接连到要删除节点的右子节点上即可(因为此时原本要删除的节点的值已经被最小值替换了，所以现在其实是要删掉最小值节点)。否则我们就把最小值节点的右子树连到其父节点的左子节点上。文字表述确实比较绕，请大家自行带例子一步一步观察就会很清晰明了了，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    TreeNode</span>* deleteNode(TreeNode* root, <span style="color: #0000ff;">int</span><span style="color: #000000;"> key) {
        TreeNode </span>*cur = root, *pre =<span style="color: #000000;"> NULL;
        </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> (cur) {
            </span><span style="color: #0000ff;">if</span> (cur-&gt;val == key) <span style="color: #0000ff;">break</span><span style="color: #000000;">;
            pre </span>=<span style="color: #000000;"> cur;
            </span><span style="color: #0000ff;">if</span> (cur-&gt;val &gt; key) cur = cur-&gt;<span style="color: #000000;">left;
            </span><span style="color: #0000ff;">else</span> cur = cur-&gt;<span style="color: #000000;">right;
        }
        </span><span style="color: #0000ff;">if</span> (!cur) <span style="color: #0000ff;">return</span><span style="color: #000000;"> root;
        </span><span style="color: #0000ff;">if</span> (!pre) <span style="color: #0000ff;">return</span><span style="color: #000000;"> del(cur);
        </span><span style="color: #0000ff;">if</span> (pre-&gt;left &amp;&amp; pre-&gt;left-&gt;val == key) pre-&gt;left =<span style="color: #000000;"> del(cur);
        </span><span style="color: #0000ff;">else</span> pre-&gt;right =<span style="color: #000000;"> del(cur);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> root;
    }
    TreeNode</span>* del(TreeNode*<span style="color: #000000;"> node) {
        </span><span style="color: #0000ff;">if</span> (!node-&gt;left &amp;&amp; !node-&gt;right) <span style="color: #0000ff;">return</span><span style="color: #000000;"> NULL;
        </span><span style="color: #0000ff;">if</span> (!node-&gt;left || !node-&gt;<span style="color: #000000;">right) {
            </span><span style="color: #0000ff;">return</span> (node-&gt;left) ? node-&gt;left : node-&gt;<span style="color: #000000;">right;
        }
        TreeNode </span>*pre = node, *cur = node-&gt;<span style="color: #000000;">right;
        </span><span style="color: #0000ff;">while</span> (cur-&gt;<span style="color: #000000;">left) {
            pre </span>=<span style="color: #000000;"> cur;
            cur </span>= cur-&gt;<span style="color: #000000;">left;
        }
        node</span>-&gt;val = cur-&gt;<span style="color: #000000;">val;
        (pre </span>== node ? node-&gt;right : pre-&gt;left) = cur-&gt;<span style="color: #000000;">right;
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> node;
    }
};</span></pre>
</div>
<p> </p>
<p>下面来看一种对于二叉树通用的解法，适用于所有二叉树，所以并没有利用BST的性质，而是遍历了所有的节点，然后删掉和key值相同的节点，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    TreeNode</span>* deleteNode(TreeNode* root, <span style="color: #0000ff;">int</span><span style="color: #000000;"> key) {
        </span><span style="color: #0000ff;">if</span> (!root) <span style="color: #0000ff;">return</span><span style="color: #000000;"> NULL;
        </span><span style="color: #0000ff;">if</span> (root-&gt;val ==<span style="color: #000000;"> key) {
            </span><span style="color: #0000ff;">if</span> (!root-&gt;right) <span style="color: #0000ff;">return</span> root-&gt;<span style="color: #000000;">left;
            </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                TreeNode </span>*cur = root-&gt;<span style="color: #000000;">right;
                </span><span style="color: #0000ff;">while</span> (cur-&gt;left) cur = cur-&gt;<span style="color: #000000;">left;
                swap(root</span>-&gt;val, cur-&gt;<span style="color: #000000;">val);
            }
        }
        root</span>-&gt;left = deleteNode(root-&gt;<span style="color: #000000;">left, key);
        root</span>-&gt;right = deleteNode(root-&gt;<span style="color: #000000;">right, key);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> root;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/65792/recursive-easy-to-understand-java-solution/2" target="_blank">https://discuss.leetcode.com/topic/65792/recursive-easy-to-understand-java-solution/2</a></p>
<p><a href="https://discuss.leetcode.com/topic/66165/very-concise-c-solution-for-general-binary-tree-not-only-bst" target="_blank">https://discuss.leetcode.com/topic/66165/very-concise-c-solution-for-general-binary-tree-not-only-bst</a></p>
<p><a href="https://discuss.leetcode.com/topic/69674/concise-c-iterative-solution-and-recursive-solution-with-explanations/2" target="_blank">https://discuss.leetcode.com/topic/69674/concise-c-iterative-solution-and-recursive-solution-with-explanations/2</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-12-28 09:33</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=6228252" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(6228252);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/6224510.html" id="cb_post_title_url">[LeetCode] Serialize and Deserialize BST 二叉搜索树的序列化和去序列化</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.</p>
<p>Design an algorithm to serialize and deserialize a binary search tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary search tree can be serialized to a string and this string can be deserialized to the original tree structure.</p>
<p>The encoded string should be as compact as possible.</p>
<p>Note: Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.</p>
<p> </p>
<p>这道题让我们对二叉搜索树序列化和去序列化，跟之前那道<a href="http://www.cnblogs.com/grandyang/p/4913869.html">Serialize and Deserialize Binary Tree</a>极其相似，虽然题目中说编码成的字符串要尽可能的紧凑，但是我们并没有发现跟之前那题有何不同，而且也没有看到能够利用BST性质的方法，姑且就按照之前题目的解法来写吧：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Codec {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:

    </span><span style="color: #008000;">//</span><span style="color: #008000;"> Encodes a tree to a single string.</span>
    <span style="color: #0000ff;">string</span> serialize(TreeNode*<span style="color: #000000;"> root) {
         ostringstream os;
         serialize(root, os);
         </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> os.str();
    }

    </span><span style="color: #008000;">//</span><span style="color: #008000;"> Decodes your encoded data to tree.</span>
    TreeNode* deserialize(<span style="color: #0000ff;">string</span><span style="color: #000000;"> data) {
        istringstream </span><span style="color: #0000ff;">is</span><span style="color: #000000;">(data);
        </span><span style="color: #0000ff;">return</span> deserialize(<span style="color: #0000ff;">is</span><span style="color: #000000;">);
    }
    
    </span><span style="color: #0000ff;">void</span> serialize(TreeNode* root, ostringstream&amp;<span style="color: #000000;"> os) {
        </span><span style="color: #0000ff;">if</span> (!root) os &lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;"># </span><span style="color: #800000;">"</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            os </span>&lt;&lt; root-&gt;val &lt;&lt; <span style="color: #800000;">"</span> <span style="color: #800000;">"</span><span style="color: #000000;">;
            serialize(root</span>-&gt;<span style="color: #000000;">left, os);
            serialize(root</span>-&gt;<span style="color: #000000;">right, os);
        }
    }
    
    TreeNode</span>* deserialize(istringstream&amp; <span style="color: #0000ff;">is</span><span style="color: #000000;">) {
        </span><span style="color: #0000ff;">string</span> val = <span style="color: #800000;">""</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">is</span> &gt;&gt;<span style="color: #000000;"> val;
        </span><span style="color: #0000ff;">if</span> (val == <span style="color: #800000;">"</span><span style="color: #800000;">#</span><span style="color: #800000;">"</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;"> NULL;
        TreeNode</span>* node = <span style="color: #0000ff;">new</span><span style="color: #000000;"> TreeNode(stoi(val));
        node</span>-&gt;left = deserialize(<span style="color: #0000ff;">is</span><span style="color: #000000;">);
        node</span>-&gt;right = deserialize(<span style="color: #0000ff;">is</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> node;
    }
};</span></pre>
</div>
<p> </p>
<p>另一种方法是层序遍历的非递归解法，这种方法略微复杂一些，我们需要借助queue来做，本质是BFS算法，也不是很难理解，就是BFS算法的常规套路稍作修改即可，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Codec {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:

    </span><span style="color: #008000;">//</span><span style="color: #008000;"> Encodes a tree to a single string.</span>
    <span style="color: #0000ff;">string</span> serialize(TreeNode*<span style="color: #000000;"> root) {
        </span><span style="color: #0000ff;">if</span> (!root) <span style="color: #0000ff;">return</span> <span style="color: #800000;">""</span><span style="color: #000000;">;
        ostringstream os;
        queue</span>&lt;TreeNode*&gt;<span style="color: #000000;"> q;
        q.push(root);
        </span><span style="color: #0000ff;">while</span> (!<span style="color: #000000;">q.empty()) {
            TreeNode </span>*t =<span style="color: #000000;"> q.front(); q.pop();
            </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (t) {
            os </span>&lt;&lt; t-&gt;val &lt;&lt; <span style="color: #800000;">"</span> <span style="color: #800000;">"</span><span style="color: #000000;">;
            q.push(t</span>-&gt;<span style="color: #000000;">left);
            q.push(t</span>-&gt;<span style="color: #000000;">right);
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                os </span>&lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;"># </span><span style="color: #800000;">"</span><span style="color: #000000;">;
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> os.str();
    }

    </span><span style="color: #008000;">//</span><span style="color: #008000;"> Decodes your encoded data to tree.</span>
    TreeNode* deserialize(<span style="color: #0000ff;">string</span><span style="color: #000000;"> data) {
        </span><span style="color: #0000ff;">if</span> (data.empty()) <span style="color: #0000ff;">return</span><span style="color: #000000;"> NULL;
        istringstream </span><span style="color: #0000ff;">is</span><span style="color: #000000;">(data);
        queue</span>&lt;TreeNode*&gt;<span style="color: #000000;"> q;
        </span><span style="color: #0000ff;">string</span> val = <span style="color: #800000;">""</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">is</span> &gt;&gt;<span style="color: #000000;"> val;
        TreeNode </span>*res = <span style="color: #0000ff;">new</span> TreeNode(stoi(val)), *cur =<span style="color: #000000;"> res;
        q.push(cur);
        </span><span style="color: #0000ff;">while</span> (!<span style="color: #000000;">q.empty()) {
            TreeNode </span>*t =<span style="color: #000000;"> q.front(); q.pop();
            </span><span style="color: #0000ff;">if</span> (!(<span style="color: #0000ff;">is</span> &gt;&gt; val)) <span style="color: #0000ff;">break</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> (val != <span style="color: #800000;">"</span><span style="color: #800000;">#</span><span style="color: #800000;">"</span><span style="color: #000000;">) {
                cur </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> TreeNode(stoi(val));
                q.push(cur);
                t</span>-&gt;left =<span style="color: #000000;"> cur;
            }
            </span><span style="color: #0000ff;">if</span> (!(<span style="color: #0000ff;">is</span> &gt;&gt; val)) <span style="color: #0000ff;">break</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> (val != <span style="color: #800000;">"</span><span style="color: #800000;">#</span><span style="color: #800000;">"</span><span style="color: #000000;">) {
                cur </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> TreeNode(stoi(val));
                q.push(cur);
                t</span>-&gt;right =<span style="color: #000000;"> cur;
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4913869.html">Serialize and Deserialize Binary Tree</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/7500082.html">Find Duplicate Subtrees</a></p>
<p><a class="link-post-title" href="https://www.cnblogs.com/grandyang/p/9945453.html" id="link_post_title">Serialize and Deserialize N-ary Tree</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-12-27 06:12</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=6224510" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(6224510);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/6222149.html" id="cb_post_title_url">[LeetCode] Find All Numbers Disappeared in an Array 找出数组中所有消失的数字</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given an array of integers where 1 ≤ a[i] ≤ <em>n</em> (<em>n</em> = size of array), some elements appear twice and others appear once.</p>
<p>Find all the elements of [1, <em>n</em>] inclusive that do not appear in this array.</p>
<p>Could you do it without extra space and in O(<em>n</em>) runtime? You may assume the returned list does not count as extra space.</p>
<p>Example:</p>
<pre>Input:
[4,3,2,7,8,2,3,1]

Output:
[5,6]</pre>
<p> </p>
<p>这道题让我们找出数组中所有消失的数，跟之前那道<a href="http://www.cnblogs.com/grandyang/p/6209746.html">Find All Duplicates in an Array</a>极其类似，那道题让找出所有重复的数字，这道题让找不存在的数，这类问题的一个重要条件就是1 ≤ a[i] ≤ n (n = size of array)，不然很难在O(1)空间和O(n)时间内完成。三种解法也跟之前题目的解法极其类似。首先来看第一种解法，这种解法的思路路是，对于每个数字nums[i]，如果其对应的nums[nums[i] - 1]是正数，我们就赋值为其相反数，如果已经是负数了，就不变了，那么最后我们只要把留下的整数对应的位置加入结果res中即可，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; findDisappearedNumbers(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; nums.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">int</span> idx = abs(nums[i]) - <span style="color: #800080;">1</span><span style="color: #000000;">;
            nums[idx] </span>= (nums[idx] &gt; <span style="color: #800080;">0</span>) ? -<span style="color: #000000;">nums[idx] : nums[idx];
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; nums.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (nums[i] &gt; <span style="color: #800080;">0</span><span style="color: #000000;">) {
                res.push_back(i </span>+ <span style="color: #800080;">1</span><span style="color: #000000;">);
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>第二种方法是将nums[i]置换到其对应的位置nums[nums[i]-1]上去，比如对于没有缺失项的正确的顺序应该是[1, 2, 3, 4, 5, 6, 7, 8]，而我们现在却是[4,3,2,7,8,2,3,1]，我们需要把数字移动到正确的位置上去，比如第一个4就应该和7先交换个位置，以此类推，最后得到的顺序应该是[1, 2, 3, 4, 3, 2, 7, 8]，我们最后在对应位置检验，如果nums[i]和i+1不等，那么我们将i+1存入结果res中即可，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; findDisappearedNumbers(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; nums.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (nums[i] != nums[nums[i] - <span style="color: #800080;">1</span><span style="color: #000000;">]) {
                swap(nums[i], nums[nums[i] </span>- <span style="color: #800080;">1</span><span style="color: #000000;">]);
                </span>--<span style="color: #000000;">i;
            }
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; nums.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (nums[i] != i + <span style="color: #800080;">1</span><span style="color: #000000;">) {
                res.push_back(i </span>+ <span style="color: #800080;">1</span><span style="color: #000000;">);
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种方法是在nums[nums[i]-1]位置累加数组长度n，注意nums[i]-1有可能越界，所以我们需要对n取余，最后要找出缺失的数只需要看nums[i]的值是否小于等于n即可，最后遍历完nums[i]数组为[12, 19, 18, 15, 8, 2, 11, 9]，我们发现有两个数字8和2小于等于n，那么就可以通过i+1来得到正确的结果5和6了，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; findDisappearedNumbers(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">int</span> n =<span style="color: #000000;"> nums.size();
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            nums[(nums[i] </span>- <span style="color: #800080;">1</span>) % n] +=<span style="color: #000000;"> n;            
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (nums[i] &lt;=<span style="color: #000000;"> n) {
                res.push_back(i </span>+ <span style="color: #800080;">1</span><span style="color: #000000;">);
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/6209746.html">Find All Duplicates in an Array</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4395963.html" target="_blank">First Missing Positive</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/65944/c-solution-o-1-space" target="_blank">https://discuss.leetcode.com/topic/65944/c-solution-o-1-space</a></p>
<p><a href="https://discuss.leetcode.com/topic/66063/5-line-java-easy-understanding" target="_blank">https://discuss.leetcode.com/topic/66063/5-line-java-easy-understanding</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-12-26 14:16</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=6222149" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(6222149);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/6049382.html" id="cb_post_title_url">[LeetCode] Number of Boomerangs 回旋镖的数量</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given <em>n</em> points in the plane that are all pairwise distinct, a "boomerang" is a tuple of points <code>(i, j, k)</code> such that the distance between <code>i</code> and <code>j</code> equals the distance between <code>i</code> and <code>k</code> (<strong>the order of the tuple matters</strong>).</p>
<p>Find the number of boomerangs. You may assume that <em>n</em> will be at most <strong>500</strong> and coordinates of points are all in the range <strong>[-10000, 10000]</strong> (inclusive).</p>
<p><strong>Example:</strong><br/>
</p>
<pre><strong>Input:</strong>
[[0,0],[1,0],[2,0]]

<strong>Output:</strong>
2

<strong>Explanation:</strong>
The two boomerangs are <strong>[[1,0],[0,0],[2,0]]</strong> and <strong>[[1,0],[2,0],[0,0]]</strong>
</pre>
<p> </p>
<p>这道题定义了一种类似回旋镖形状的三元组结构，要求第一个点和第二个点之间的距离跟第一个点和第三个点之间的距离相等。现在给了我们n个点，让我们找出回旋镖的个数。那么我们想，如果我们有一个点a，还有两个点b和c，如果ab和ac之间的距离相等，那么就有两种排列方法abc和acb；如果有三个点b，c，d都分别和a之间的距离相等，那么有六种排列方法，abc, acb, acd, adc, abd, adb，那么是怎么算出来的呢，很简单，如果有n个点和a距离相等，那么排列方式为n(n-1)，这属于最简单的排列组合问题了，我大天朝中学生都会做的。那么我们问题就变成了遍历所有点，让每个点都做一次点a，然后遍历其他所有点，统计和a距离相等的点有多少个，然后分别带入n(n-1)计算结果并累加到res中，只有当n大于等于2时，res值才会真正增加，参见代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> numberOfBoomerangs(vector&lt;pair&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> points) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; points.size(); ++<span style="color: #000000;">i) {
            unordered_map</span>&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> m;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; points.size(); ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">int</span> a = points[i].first -<span style="color: #000000;"> points[j].first;
                </span><span style="color: #0000ff;">int</span> b = points[i].second -<span style="color: #000000;"> points[j].second;
                </span>++m[a * a + b *<span style="color: #000000;"> b];
            }
            </span><span style="color: #0000ff;">for</span> (auto it = m.begin(); it != m.end(); ++<span style="color: #000000;">it) {
                res </span>+= it-&gt;second * (it-&gt;second - <span style="color: #800080;">1</span><span style="color: #000000;">);
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/66523/c-solution-with-explanation" target="_blank">https://discuss.leetcode.com/topic/66523/c-solution-with-explanation</a></p>
<p><a href="https://discuss.leetcode.com/topic/66521/share-my-straightforward-solution-with-hashmap-o-n-2/2" target="_blank">https://discuss.leetcode.com/topic/66521/share-my-straightforward-solution-with-hashmap-o-n-2/2</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-11-09 23:59</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=6049382" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(6049382);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/6057934.html" id="cb_post_title_url">[LeetCode] Arithmetic Slices II - Subsequence 算数切片之二 - 子序列</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>A sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.</p>
<p>For example, these are arithmetic sequences:</p>
<pre>1, 3, 5, 7, 9
7, 7, 7, 7
3, -1, -5, -9</pre>
<p>The following sequence is not arithmetic.</p>
<pre>1, 1, 2, 5, 7</pre>
<p> </p>
<p>A zero-indexed array A consisting of N numbers is given. A subsequence slice of that array is any sequence of integers (P0, P1, ..., Pk) such that 0 ≤ P0 &lt; P1 &lt; ... &lt; Pk &lt; N.</p>
<p>A subsequence slice (P0, P1, ..., Pk) of array A is called arithmetic if the sequence A[P0], A[P1], ..., A[Pk-1], A[Pk] is arithmetic. In particular, this means that k ≥ 2.</p>
<p>The function should return the number of arithmetic subsequence slices in the array A.</p>
<p>The input contains N integers. Every integer is in the range of -231 and 231-1 and 0 ≤ N ≤ 1000. The output is guaranteed to be less than 231-1.</p>
<p> </p>
<p>Example:</p>
<pre>Input: [2, 4, 6, 8, 10]

Output: 7

Explanation:
All arithmetic subsequence slices are:
[2,4,6]
[4,6,8]
[6,8,10]
[2,4,6,8]
[4,6,8,10]
[2,4,6,8,10]
[2,6,10]</pre>
<p>好，既然决定要用DP了，那么首先就要确定dp数组的定义了，刚开始我们可能会考虑使用个一维的dp数组，然后dp[i]定义为范围为[0, i]的子数组中等差数列的个数。定义的很简单，OK，但是基于这种定义的递归式却十分的难想。我们想对于(0, i)之间的任意位置j，如何让 dp[i] 和 dp[j] 产生关联呢？是不是只有 A[i] 和 A[j] 的差值diff，跟A[j]之前等差数列的差值相同，才会有关联，所以差值diff是一个很重要的隐藏信息Hidden Information，我们必须要在dp的定义中考虑进去。所以一维dp数组是罩不住的，必须升维，但是用二维dp数组的话，差值diff那一维的范围又是个问题，数字的范围是整型数，所以差值的范围也很大，为了节省空间，我们建立一个一维数组dp，数组里的元素不是数字，而是放一个HashMap，建立等差数列的差值和当前位置之前差值相同的数字个数之间的映射。我们遍历数组中的所有数字，对于当前遍历到的数字，又从开头遍历到当前数字，计算两个数字之差diff，如果越界了不做任何处理，如果没越界，我们让dp[i]中diff的差值映射自增1，因为此时A[i]前面有相差为diff的A[j]，所以映射值要加1。然后我们看dp[j]中是否有diff的映射，如果有的话，说明此时相差为diff的数字至少有三个了，已经能构成题目要求的等差数列了，将dp[j][diff]加入结果res中，然后再更新dp[i][diff]，这样等遍历完数组，res即为所求。</p>
<p>我们用题目中给的例子数组 [2，4，6，8，10] 来看，因为2之前没有数字了，所以我们从4开始，遍历前面的数字，是2，二者差值为2，那么在dp[1]的HashMap就可以建立 2-&gt;1 的映射，表示4之前有1个差值为2的数字，即数字2。那么现在i=2指向6了，遍历前面的数字，第一个数是2，二者相差4，那么在dp[2]的HashMap就可以建立 4-&gt;1 的映射，第二个数是4，二者相差2，那么先在dp[2]的HashMap建立 2-&gt;1 的映射，由于dp[1]的HashMap中也有差值为2的映射，2-&gt;1，那么说明此时至少有三个数字差值相同，即这里的 [2 4 6]，我们将dp[1]中的映射值加入结果res中，然后当前dp[2]中的映射值加上dp[1]中的映射值。这应该不难理解，比如当i=3指向数字8时，j=2指向数字6，那么二者差值为2，此时先在dp[3]建立 2-&gt;1 的映射，由于dp[2]中有 2-&gt;2 的映射，那么加上数字8其实新增了两个等差数列 [2,4,6,8] 和 [4,6,8]，所以结果res加上的值就是 dp[j][diff]，即2，并且 dp[i][diff] 也需要加上这个值，才能使得 dp[3] 中的映射变为 2-&gt;3 ，后面数字10的处理情况也相同，这里就不多赘述了，最终的各个位置的映射关系如下所示：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">2     4     6     8     10    
     2-&gt;1  4-&gt;1  6-&gt;1  8-&gt;1
           2-&gt;<span style="color: #ff0000;">2</span>  4-&gt;1  6-&gt;1 
                 2-&gt;<span style="color: #ff0000;">3</span>  4-&gt;<span style="color: #ff0000;">2</span>
                       2-&gt;<span style="color: #ff0000;">4</span></span></pre>
</div>
<p> </p>
<p>最终累计出来的结果是跟上面红色的数字相关，分别对应着如下的等差数列：</p>
<p>2-&gt;2：[2,4,6]</p>
<p>2-&gt;3：[2,4,6,8]    [4,6,8]</p>
<p>4-&gt;2：[2,6,10]</p>
<p>2-&gt;4：[2,4,6,8,10]    [4,6,8,10]    [6,8,10]</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> numberOfArithmeticSlices(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> A) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, n =<span style="color: #000000;"> A.size();
        vector</span>&lt;unordered_map&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;&gt;<span style="color: #000000;"> dp(n);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; i; ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">long</span> delta = (<span style="color: #0000ff;">long</span>)A[i] -<span style="color: #000000;"> A[j];
                </span><span style="color: #0000ff;">if</span> (delta &gt; INT_MAX || delta &lt; INT_MIN) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">int</span> diff = (<span style="color: #0000ff;">int</span><span style="color: #000000;">)delta;
                </span>++<span style="color: #000000;">dp[i][diff];
                </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (dp[j].count(diff)) {
                    res </span>+=<span style="color: #000000;"> dp[j][diff];
                    dp[i][diff] </span>+=<span style="color: #000000;"> dp[j][diff];
                }
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/5968340.html" target="_blank">Arithmetic Slices</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a> </p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-11-12 23:59</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=6057934" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(6057934);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/6216480.html" id="cb_post_title_url">[LeetCode] Add Two Numbers II 两个数字相加之二</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>You are given two linked lists representing two non-negative numbers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>
<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>
<p>Follow up:<br/>What if you cannot modify the input lists? In other words, reversing the lists is not allowed.</p>
<p>Example:</p>
<pre>Input: (7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)
Output: 7 -&gt; 8 -&gt; 0 -&gt; 7</pre>
<p> </p>
<p>这道题是之前那道<a href="http://www.cnblogs.com/grandyang/p/4129891.html" target="_blank">Add Two Numbers</a>的拓展，我们可以看到这道题的最高位在链表首位置，如果我们给链表翻转一下的话就跟之前的题目一样了，这里我们来看一些不修改链表顺序的方法。由于加法需要从最低位开始运算，而最低位在链表末尾，链表只能从前往后遍历，没法取到前面的元素，那怎么办呢？我们可以利用栈来保存所有的元素，然后利用栈的后进先出的特点就可以从后往前取数字了，我们首先遍历两个链表，将所有数字分别压入两个栈s1和s2中，我们建立一个值为0的res节点，然后开始循环，如果栈不为空，则将栈顶数字加入sum中，然后将res节点值赋为sum%10，然后新建一个进位节点head，赋值为sum/10，如果没有进位，那么就是0，然后我们head后面连上res，将res指向head，这样循环退出后，我们只要看res的值是否为0，为0返回res-&gt;next，不为0则返回res即可，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    ListNode</span>* addTwoNumbers(ListNode* l1, ListNode*<span style="color: #000000;"> l2) {
        stack</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> s1, s2;
        </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> (l1) {
            s1.push(l1</span>-&gt;<span style="color: #000000;">val);
            l1 </span>= l1-&gt;<span style="color: #000000;">next;
        }
        </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> (l2) {
            s2.push(l2</span>-&gt;<span style="color: #000000;">val);
            l2 </span>= l2-&gt;<span style="color: #000000;">next;
        }
        </span><span style="color: #0000ff;">int</span> sum = <span style="color: #800080;">0</span><span style="color: #000000;">;
        ListNode </span>*res = <span style="color: #0000ff;">new</span> ListNode(<span style="color: #800080;">0</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">while</span> (!s1.empty() || !<span style="color: #000000;">s2.empty()) {
            </span><span style="color: #0000ff;">if</span> (!s1.empty()) {sum +=<span style="color: #000000;"> s1.top(); s1.pop();}
            </span><span style="color: #0000ff;">if</span> (!s2.empty()) {sum +=<span style="color: #000000;"> s2.top(); s2.pop();}
            res</span>-&gt;val = sum % <span style="color: #800080;">10</span><span style="color: #000000;">;
            ListNode </span>*head = <span style="color: #0000ff;">new</span> ListNode(sum / <span style="color: #800080;">10</span><span style="color: #000000;">);
            head</span>-&gt;next =<span style="color: #000000;"> res;
            res </span>=<span style="color: #000000;"> head;
            sum </span>/= <span style="color: #800080;">10</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> res-&gt;val == <span style="color: #800080;">0</span> ? res-&gt;<span style="color: #000000;">next : res;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种方法使用递归来实现的，我们知道递归其实也是用栈来保存每一个状态，那么也就可以实现从后往前取数字，我们首先统计出两个链表长度，然后根据长度来调用递归函数，需要传一个参数差值，递归函数参数中的l1链表长度长于l2，在递归函数中，我们建立一个节点res，如果差值不为0，节点值为l1的值，如果为0，那么就是l1和l2的和，然后在根据差值分别调用递归函数求出节点post，然后要处理进位，如果post的值大于9，那么对10取余，且res的值自增1，然后把pos连到res后面，返回res，最后回到原函数中，我们仍要处理进位情况，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    ListNode</span>* addTwoNumbers(ListNode* l1, ListNode*<span style="color: #000000;"> l2) {
        </span><span style="color: #0000ff;">int</span> n1 = getLength(l1), n2 =<span style="color: #000000;"> getLength(l2);
        ListNode </span>*head = <span style="color: #0000ff;">new</span> ListNode(<span style="color: #800080;">1</span><span style="color: #000000;">);
        head</span>-&gt;next = (n1 &gt; n2) ? helper(l1, l2, n1 - n2) : helper(l2, l1, n2 -<span style="color: #000000;"> n1);
        </span><span style="color: #0000ff;">if</span> (head-&gt;next-&gt;val &gt; <span style="color: #800080;">9</span><span style="color: #000000;">) {
            head</span>-&gt;next-&gt;val %= <span style="color: #800080;">10</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> head;
        }
        </span><span style="color: #0000ff;">return</span> head-&gt;<span style="color: #000000;">next;
    }
    </span><span style="color: #0000ff;">int</span> getLength(ListNode*<span style="color: #000000;"> head) {
        </span><span style="color: #0000ff;">int</span> cnt = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> (head) {
            </span>++<span style="color: #000000;">cnt;
            head </span>= head-&gt;<span style="color: #000000;">next;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> cnt;
    }
    ListNode</span>* helper(ListNode* l1, ListNode* l2, <span style="color: #0000ff;">int</span><span style="color: #000000;"> diff) {
        </span><span style="color: #0000ff;">if</span> (!l1) <span style="color: #0000ff;">return</span><span style="color: #000000;"> NULL;
        ListNode </span>*res = (diff == <span style="color: #800080;">0</span>) ? <span style="color: #0000ff;">new</span> ListNode(l1-&gt;val + l2-&gt;val) : <span style="color: #0000ff;">new</span> ListNode(l1-&gt;<span style="color: #000000;">val);
        ListNode </span>*post = (diff == <span style="color: #800080;">0</span>) ? helper(l1-&gt;next, l2-&gt;next, <span style="color: #800080;">0</span>) : helper(l1-&gt;next, l2, diff - <span style="color: #800080;">1</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">if</span> (post &amp;&amp; post-&gt;val &gt; <span style="color: #800080;">9</span><span style="color: #000000;">) {
            post</span>-&gt;val %= <span style="color: #800080;">10</span><span style="color: #000000;">;
            </span>++res-&gt;<span style="color: #000000;">val;
        }
        res</span>-&gt;next =<span style="color: #000000;"> post;
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种方法借鉴了<a href="http://www.cnblogs.com/grandyang/p/5626389.html">Plus One Linked List</a>中的解法三，在处理加1问题时，我们需要找出右起第一个不等于9的位置，然后此位置值自增1，之后的全部赋为0。这里我们同样要先算出两个链表的长度，我们把其中较长的放在l1，然后我们算出两个链表长度差diff。如果diff大于0，我们用l1的值新建节点，并连在cur节点后(cur节点初始化时指向dummy节点)。并且如果l1的值不等于9，那么right节点也指向这个新建的节点，然后cur和l1都分别后移一位，diff自减1。当diff为0后，我们循环遍历，将此时l1和l2的值加起来放入变量val中，如果val大于9，那么val对10取余，right节点自增1，将right后面节点全赋值为0。在cur节点后新建节点，节点值为更新后的val，如果val的值不等于9，那么right节点也指向这个新建的节点，然后cur，l1和l2都分别后移一位。最后我们看dummy节点值若为1，返回dummy节点，如果是0，则返回dummy的下一个节点。</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    ListNode</span>* addTwoNumbers(ListNode* l1, ListNode*<span style="color: #000000;"> l2) {
        </span><span style="color: #0000ff;">int</span> n1 = getLength(l1), n2 = getLength(l2), diff = abs(n1 -<span style="color: #000000;"> n2);
        </span><span style="color: #0000ff;">if</span> (n1 &lt;<span style="color: #000000;"> n2) swap(l1, l2);
        ListNode </span>*dummy = <span style="color: #0000ff;">new</span> ListNode(<span style="color: #800080;">0</span>), *cur = dummy, *right =<span style="color: #000000;"> cur;
        </span><span style="color: #0000ff;">while</span> (diff &gt; <span style="color: #800080;">0</span><span style="color: #000000;">) {
            cur</span>-&gt;next = <span style="color: #0000ff;">new</span> ListNode(l1-&gt;<span style="color: #000000;">val);
            </span><span style="color: #0000ff;">if</span> (l1-&gt;val != <span style="color: #800080;">9</span>) right = cur-&gt;<span style="color: #000000;">next;
            cur </span>= cur-&gt;<span style="color: #000000;">next;
            l1 </span>= l1-&gt;<span style="color: #000000;">next;
            </span>--<span style="color: #000000;">diff;
        }
        </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> (l1) {
            </span><span style="color: #0000ff;">int</span> val = l1-&gt;val + l2-&gt;<span style="color: #000000;">val;
            </span><span style="color: #0000ff;">if</span> (val &gt; <span style="color: #800080;">9</span><span style="color: #000000;">) {
                val </span>%= <span style="color: #800080;">10</span><span style="color: #000000;">;
                </span>++right-&gt;<span style="color: #000000;">val;
                </span><span style="color: #0000ff;">while</span> (right-&gt;<span style="color: #000000;">next) {
                    right</span>-&gt;next-&gt;val = <span style="color: #800080;">0</span><span style="color: #000000;">;
                    right </span>= right-&gt;<span style="color: #000000;">next;
                }
                right </span>=<span style="color: #000000;"> cur;
            }
            cur</span>-&gt;next = <span style="color: #0000ff;">new</span><span style="color: #000000;"> ListNode(val);
            </span><span style="color: #0000ff;">if</span> (val != <span style="color: #800080;">9</span>) right = cur-&gt;<span style="color: #000000;">next;
            cur </span>= cur-&gt;<span style="color: #000000;">next;
            l1 </span>= l1-&gt;<span style="color: #000000;">next;
            l2 </span>= l2-&gt;<span style="color: #000000;">next;
        }
        </span><span style="color: #0000ff;">return</span> (dummy-&gt;val == <span style="color: #800080;">1</span>) ? dummy : dummy-&gt;<span style="color: #000000;">next;
    }
    </span><span style="color: #0000ff;">int</span> getLength(ListNode*<span style="color: #000000;"> head) {
        </span><span style="color: #0000ff;">int</span> cnt = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> (head) {
            </span>++<span style="color: #000000;">cnt;
            head </span>= head-&gt;<span style="color: #000000;">next;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> cnt;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4129891.html" target="_blank">Add Two Numbers</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/5626389.html">Plus One Linked List</a> </p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/67076/ac-follow-up-java" target="_blank">https://discuss.leetcode.com/topic/67076/ac-follow-up-java</a></p>
<p><a href="https://discuss.leetcode.com/topic/65279/easy-o-n-java-solution-using-stack" target="_blank">https://discuss.leetcode.com/topic/65279/easy-o-n-java-solution-using-stack</a></p>
<p><a href="https://discuss.leetcode.com/topic/65306/java-o-n-recursive-solution-by-counting-the-difference-of-length/2" target="_blank">https://discuss.leetcode.com/topic/65306/java-o-n-recursive-solution-by-counting-the-difference-of-length/2</a></p>
<p><a href="https://discuss.leetcode.com/topic/66699/java-iterative-o-1-space-lastnot9-solution-changed-from-plus-one-linked-list" target="_blank">https://discuss.leetcode.com/topic/66699/java-iterative-o-1-space-lastnot9-solution-changed-from-plus-one-linked-list</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-12-23 23:55</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=6216480" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(6216480);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/6032498.html" id="cb_post_title_url">[LeetCode] Sequence Reconstruction 序列重建</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Check whether the original sequence <code>org</code> can be uniquely reconstructed from the sequences in <code>seqs</code>. The <code>org</code> sequence is a permutation of the integers from 1 to n, with 1 ≤ n ≤ 10<sup>4</sup>. Reconstruction means building a shortest common supersequence of the sequences in <code>seqs</code> (i.e., a shortest sequence so that all sequences in <code>seqs</code> are subsequences of it). Determine whether there is only one sequence that can be reconstructed from <code>seqs</code> and it is the <code>org</code> sequence.</p>
<p><strong>Example 1:</strong></p>
<pre><strong>Input:</strong>
org: [1,2,3], seqs: [[1,2],[1,3]]

<strong>Output:</strong>
false

<strong>Explanation:</strong>
[1,2,3] is not the only one sequence that can be reconstructed, because [1,3,2] is also a valid sequence that can be reconstructed.
</pre>
<p><strong>Example 2:</strong></p>
<pre><strong>Input:</strong>
org: [1,2,3], seqs: [[1,2]]

<strong>Output:</strong>
false

<strong>Explanation:</strong>
The reconstructed sequence can only be [1,2].
</pre>
<p><strong>Example 3:</strong></p>
<pre><strong>Input:</strong>
org: [1,2,3], seqs: [[1,2],[1,3],[2,3]]

<strong>Output:</strong>
true

<strong>Explanation:</strong>
The sequences [1,2], [1,3], and [2,3] can uniquely reconstruct the original sequence [1,2,3].
</pre>
<p><strong>Example 4:</strong></p>
<pre><strong>Input:</strong>
org: [4,1,5,2,6,3], seqs: [[5,2,6,3],[4,1,5,2]]

<strong>Output:</strong>
true
</pre>
<p> </p>
<p>这道题给了我们一个序列org，又给我们了一些子序列seqs，问这些子序列能否唯一的重建出原序列。能唯一重建的意思就是任意两个数字的顺序必须是一致的，不能说在一个子序列中1在4的后面，但是在另一个子序列中1在4的前面，这样就不是唯一的了。还有一点就是，子序列seqs中不能出现其他的数字，就是说必须都是原序列中的数字。那么我们可以用了一个一维数组pos来记录org中每个数字对应的位置，然后用一个flags数字来标记当前数字和其前面一个数字是否和org中的顺序一致，用cnt来标记还需要验证顺序的数字的个数，初始化cnt为n-1，因为n个数字只需要验证n-1对顺序即可，然后我们先遍历一遍org，将每个数字的位置信息存入pos中，然后再遍历子序列中的每一个数字，还是要先判断数字是否越界，然后我们取出当前数字cur，和其前一位置上的数字pre，如果在org中，pre在cur之后，那么直接返回false。否则我们看如果cur的顺序没被验证过，而且pre是在cur的前一个，那么标记cur已验证，且cnt自减1，最后如果cnt为0了，说明所有顺序被成功验证了，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> sequenceReconstruction(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; org, vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> seqs) {
        </span><span style="color: #0000ff;">if</span> (seqs.empty()) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> n = org.size(), cnt = n - <span style="color: #800080;">1</span><span style="color: #000000;">;
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; pos(n + <span style="color: #800080;">1</span>, <span style="color: #800080;">0</span>), flags(n + <span style="color: #800080;">1</span>, <span style="color: #800080;">0</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">bool</span> existed = <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++i) pos[org[i]] =<span style="color: #000000;"> i;
        </span><span style="color: #0000ff;">for</span> (auto&amp;<span style="color: #000000;"> seq : seqs) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; seq.size(); ++<span style="color: #000000;">i) {
                existed </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">if</span> (seq[i] &lt;= <span style="color: #800080;">0</span> || seq[i] &gt; n) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">if</span> (i == <span style="color: #800080;">0</span>) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">int</span> pre = seq[i - <span style="color: #800080;">1</span>], cur =<span style="color: #000000;"> seq[i];
                </span><span style="color: #0000ff;">if</span> (pos[pre] &gt;= pos[cur]) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">if</span> (flags[cur] == <span style="color: #800080;">0</span> &amp;&amp; pos[pre] + <span style="color: #800080;">1</span> ==<span style="color: #000000;"> pos[cur]) {
                    flags[cur] </span>= <span style="color: #800080;">1</span>; --<span style="color: #000000;">cnt;
                }
            }
        }
        </span><span style="color: #0000ff;">return</span> cnt == <span style="color: #800080;">0</span> &amp;&amp;<span style="color: #000000;"> existed;
    }
};</span></pre>
</div>
<p><span style="color: #0000ff;"> </span></p>
<p>下面这种方法跟上面的方法大同小异，用两个哈希表来代替了上面的数组和变量，其中m为数字和其位置之间的映射，pre为当前数字和其前一个位置的数字在org中的位置之间的映射。跟上面的方法的不同点在于，当遍历到某一个数字的时候，我们看当前数字是否在pre中有映射，如果没有的话，我们建立该映射，注意如果是第一个位置的数字的话，其前面数字设为-1。如果该映射存在的话，我们对比前一位数字在org中的位置和当前的映射值的大小，取其中较大值。最后我们遍历一遍org，看每个数字的映射值是否是前一个数字的位置，如果有不是的返回false，全部验证成功返回true，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> sequenceReconstruction(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; org, vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> seqs) {
        unordered_map</span>&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> m, pre;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; org.size(); ++i) m[org[i]] =<span style="color: #000000;"> i;
        </span><span style="color: #0000ff;">for</span> (auto&amp;<span style="color: #000000;"> seq : seqs) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; seq.size(); ++<span style="color: #000000;">i) {
                </span><span style="color: #0000ff;">if</span> (!m.count(seq[i])) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">if</span> (i &gt; <span style="color: #800080;">0</span> &amp;&amp; m[seq[i - <span style="color: #800080;">1</span>]] &gt;= m[seq[i]]) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">if</span> (!<span style="color: #000000;">pre.count(seq[i])) {
                    pre[seq[i]] </span>= (i &gt; <span style="color: #800080;">0</span>) ? m[seq[i - <span style="color: #800080;">1</span>]] : -<span style="color: #800080;">1</span><span style="color: #000000;">;
                } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    pre[seq[i]] </span>= max(pre[seq[i]], (i &gt; <span style="color: #800080;">0</span>) ? m[seq[i - <span style="color: #800080;">1</span>]] : -<span style="color: #800080;">1</span><span style="color: #000000;">);
                }
            }
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; org.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (pre[org[i]] != i - <span style="color: #800080;">1</span>) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/65737/concise-c-solution-inspired-by-previous-great-solutions" target="_blank">https://discuss.leetcode.com/topic/65737/concise-c-solution-inspired-by-previous-great-solutions</a></p>
<p><a href="https://discuss.leetcode.com/topic/65961/simple-solution-one-pass-using-only-array-c-92ms-java-16ms" target="_blank">https://discuss.leetcode.com/topic/65961/simple-solution-one-pass-using-only-array-c-92ms-java-16ms</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-11-05 10:01</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=6032498" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(6032498);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/8742564.html" id="cb_post_title_url">[LeetCode] String Compression 字符串压缩</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given an array of characters, compress it <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank">in-place</a>.</p>
<p>The length after compression must always be smaller than or equal to the original array.</p>
<p>Every element of the array should be a character (not int) of length 1.</p>
<p>After you are done modifying the input array <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank">in-place</a>, return the new length of the array.</p>
<p> </p>
<p>Follow up:<br/>Could you solve it using only O(1) extra space?</p>
<p> </p>
<p>Example 1:</p>
<pre>Input:
["a","a","b","b","c","c","c"]

Output:
Return 6, and the first 6 characters of the input array should be: ["a","2","b","2","c","3"]

Explanation:
"aa" is replaced by "a2". "bb" is replaced by "b2". "ccc" is replaced by "c3".
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input:
["a"]

Output:
Return 1, and the first 1 characters of the input array should be: ["a"]

Explanation:
Nothing is replaced.
</pre>
<p> </p>
<p>Example 3:</p>
<pre>Input:
["a","b","b","b","b","b","b","b","b","b","b","b","b"]

Output:
Return 4, and the first 4 characters of the input array should be: ["a","b","1","2"].

Explanation:
Since the character "a" does not repeat, it is not compressed. "bbbbbbbbbbbb" is replaced by "b12".
Notice each digit has it's own entry in the array.
</pre>
<p> </p>
<p>Note:</p>
<ol>
<li>All characters have an ASCII value in <code>[35, 126]</code>.</li>
<li><code>1 &lt;= len(chars) &lt;= 1000</code>.</li>
</ol>
<p> </p>
<p>这道题给了我们一个字符串，让我们进行压缩，即相同的字符统计出个数，显示在该字符之后，根据例子分析不难理解题意。这道题要求我们进行in place操作，即不使用额外空间，最后让我们返回修改后的新数组的长度。我们首先想，数组的字符不一定是有序的，如果我们用Map来建立字符和出现次数之间的映射，不管是用HashMap还是TreeMap，一定无法保证原有的顺序。所以不能用Map，而我们有需要统计个数，那么双指针就是不二之选啦。既然双指针，其中一个指针指向重复字符串的第一个，然后另一个指针向后遍历并计数，就能得到重复的个数。我们仔细研究例子3，可以发现，当个数是两位数的时候，比如12，这里是将12拆分成1和2，然后存入数组的。那么比较简便的提取出各个位上的数字的办法就是转为字符串进行遍历。另外，由于我们需要对原数组进行修改，则需要一个指针cur来标记下一个可以修改的位置，那么最终cur的值就是新数组的长度，直接返回即可。</p>
<p>具体来看代码，我们用i和j表示双指针，开始循环后，我们用j来找重复的字符串的个数，用一个while循环，最终j指向的是第一个和i指向字符不同的地方，此时我们需要先将i位置的字符写进chars中，然后我们判断j是否比i正好大一个，因为只有一个字符的话，后面是不用加个数的，所以直接跳过。否则我们将重复个数转为字符串，然后提取出来修改chars数组即可，注意每次需要将i赋值为j，从而开始下一个字符的统计，参见代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> compress(vector&lt;<span style="color: #0000ff;">char</span>&gt;&amp;<span style="color: #000000;"> chars) {
        </span><span style="color: #0000ff;">int</span> n = chars.size(), cur = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>, j = <span style="color: #800080;">0</span>; i &lt; n; i =<span style="color: #000000;"> j) {
            </span><span style="color: #0000ff;">while</span> (j &lt; n &amp;&amp; chars[j] == chars[i]) ++<span style="color: #000000;">j;
            chars[cur</span>++] =<span style="color: #000000;"> chars[i];
            </span><span style="color: #0000ff;">if</span> (j - i == <span style="color: #800080;">1</span>) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span> c : to_string(j - i)) chars[cur++] =<span style="color: #000000;"> c;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> cur;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4086299.html" target="_blank">Count and Say</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/5265628.html" target="_blank">Encode and Decode Strings</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/7026999.html">Design Compressed String Iterator</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-04-08 05:38</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=8742564" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(8742564);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/6209746.html" id="cb_post_title_url">[LeetCode] Find All Duplicates in an Array 找出数组中所有重复项</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="row">
<div class="col-md-12">
<div class="row">
<div class="col-md-12">
<div class="question-content">
<p>Given an array of integers, 1 ≤ a[i] ≤ <em>n</em> (<em>n</em> = size of array), some elements appear twice and others appear once.</p>
<p>Find all the elements that appear twice in this array.</p>
<p>Could you do it without extra space and in O(<em>n</em>) runtime?</p>
<p> </p>
<p>Example:</p>
<pre>Input:
[4,3,2,7,8,2,3,1]

Output:
[2,3]
</pre>
<p> </p>
<div>
<div class="btn btn-xs btn-warning" id="company_tags">这道题给了我们一个数组，数组中的数字可能出现一次或两次，让我们找出所有出现两次的数字，由于之前做过一道类似的题目<a href="http://www.cnblogs.com/grandyang/p/4843654.html" target="_blank">Find the Duplicate Number</a>，所以不是完全无从下手。这类问题的一个重要条件就是1 ≤ a[i] ≤ n (n = size of array)，不然很难在O(1)空间和O(n)时间内完成。首先来看一种正负替换的方法，这类问题的核心是就是找nums[i]和nums[nums[i] - 1]的关系，我们的做法是，对于每个nums[i]，我们将其对应的nums[nums[i] - 1]取相反数，如果其已经是负数了，说明之前存在过，我们将其加入结果res中即可，参见代码如下：</div>
</div>
</div>
</div>
</div>
</div>
</div>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; findDuplicates(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; nums.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">int</span> idx = abs(nums[i]) - <span style="color: #800080;">1</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> (nums[idx] &lt; <span style="color: #800080;">0</span>) res.push_back(idx + <span style="color: #800080;">1</span><span style="color: #000000;">);
            nums[idx] </span>= -<span style="color: #000000;">nums[idx];
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种方法是将nums[i]置换到其对应的位置nums[nums[i]-1]上去，比如对于没有重复项的正确的顺序应该是[1, 2, 3, 4, 5, 6, 7, 8]，而我们现在却是[4,3,2,7,8,2,3,1]，我们需要把数字移动到正确的位置上去，比如第一个4就应该和7先交换个位置，以此类推，最后得到的顺序应该是[1, 2, 3, 4, 3, 2, 7, 8]，我们最后在对应位置检验，如果nums[i]和i+1不等，那么我们将nums[i]存入结果res中即可，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; findDuplicates(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; nums.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (nums[i] != nums[nums[i] - <span style="color: #800080;">1</span><span style="color: #000000;">]) {
                swap(nums[i], nums[nums[i] </span>- <span style="color: #800080;">1</span><span style="color: #000000;">]);
                </span>--<span style="color: #000000;">i;
            }
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; nums.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (nums[i] != i + <span style="color: #800080;">1</span><span style="color: #000000;">) res.push_back(nums[i]);
        }</span>
        <span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种方法是在nums[nums[i]-1]位置累加数组长度n，注意nums[i]-1有可能越界，所以我们需要对n取余，最后要找出现两次的数只需要看nums[i]的值是否大于2n即可，最后遍历完nums[i]数组为[12, 19, 18, 15, 8, 2, 11, 9]，我们发现有两个数字19和18大于2n，那么就可以通过i+1来得到正确的结果2和3了，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; findDuplicates(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">int</span> n =<span style="color: #000000;"> nums.size();
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            nums[(nums[i] </span>- <span style="color: #800080;">1</span>) % n] +=<span style="color: #000000;"> n;
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (nums[i] &gt; <span style="color: #800080;">2</span> * n) res.push_back(i + <span style="color: #800080;">1</span><span style="color: #000000;">);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4843654.html" target="_blank">Find the Duplicate Number</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/64759/very-simple-c-solution" target="_blank">https://discuss.leetcode.com/topic/64759/very-simple-c-solution</a></p>
<p><a href="https://discuss.leetcode.com/topic/64735/java-simple-solution/2" target="_blank">https://discuss.leetcode.com/topic/64735/java-simple-solution/2</a></p>
<p><a href="https://discuss.leetcode.com/topic/64744/2-pass-o-1-space-solution" target="_blank">https://discuss.leetcode.com/topic/64744/2-pass-o-1-space-solution</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-12-22 05:36</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=6209746" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(6209746);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/6026066.html" id="cb_post_title_url">[LeetCode] Arranging Coins 排列硬币</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>You have a total of <em>n</em> coins that you want to form in a staircase shape, where every <em>k</em>-th row must have exactly <em>k</em> coins.</p>
<p>Given <em>n</em>, find the total number of <strong>full</strong> staircase rows that can be formed.</p>
<p><em>n</em> is a non-negative integer and fits within the range of a 32-bit signed integer.</p>
<p><strong>Example 1:</strong></p>
<pre>n = 5

The coins can form the following rows:
¤
¤ ¤
¤ ¤

Because the 3rd row is incomplete, we return 2.
</pre>
<p><strong>Example 2:</strong></p>
<pre>n = 8

The coins can form the following rows:
¤
¤ ¤
¤ ¤ ¤
¤ ¤

Because the 4th row is incomplete, we return 3.
</pre>
<p> </p>
<p>这道题给了我们n个硬币，让我们按一定规律排列，第一行放1个，第二行放2个，以此类推，问我们有多少行能放满。通过分析题目中的例子可以得知最后一行只有两种情况，放满和没放满。由于是按等差数列排放的，我们可以快速计算出前i行的硬币总数。我们先来看一种O(n)的方法，非常简单粗暴，就是从第一行开始，一行一行的从n中减去，如果此时剩余的硬币没法满足下一行需要的硬币数了，我们之间返回当前行数即可，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> arrangeCoins(<span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        </span><span style="color: #0000ff;">int</span> cur = <span style="color: #800080;">1</span>, rem = n - <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (rem &gt;= cur + <span style="color: #800080;">1</span><span style="color: #000000;">) {
            </span>++<span style="color: #000000;">cur;
            rem </span>-=<span style="color: #000000;"> cur;
        }
        </span><span style="color: #0000ff;">return</span> n == <span style="color: #800080;">0</span> ? <span style="color: #800080;">0</span><span style="color: #000000;"> : cur;
    }
};</span></pre>
</div>
<p> </p>
<p>再来看一种O(lgn)的方法，用到了二分搜索法，我们搜索前i行之和刚好大于n的临界点，这样我们减一个就是能排满的行数，注意我们计算前i行之和有可能会整型溢出，所以我们需要将变量都定义成长整型，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> arrangeCoins(<span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        </span><span style="color: #0000ff;">if</span> (n &lt;= <span style="color: #800080;">1</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;"> n;
        </span><span style="color: #0000ff;">long</span> low = <span style="color: #800080;">1</span>, high =<span style="color: #000000;"> n;
        </span><span style="color: #0000ff;">while</span> (low &lt;<span style="color: #000000;"> high) {
            </span><span style="color: #0000ff;">long</span> mid = low + (high - low) / <span style="color: #800080;">2</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> (mid * (mid + <span style="color: #800080;">1</span>) / <span style="color: #800080;">2</span> &lt;= n) low = mid + <span style="color: #800080;">1</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">else</span> high =<span style="color: #000000;"> mid;
        }
        </span><span style="color: #0000ff;">return</span> low - <span style="color: #800080;">1</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>再来看一种数学解法O(1)，充分利用了等差数列的性质，我们建立等式, n = (1 + x) * x / 2, 我们用一元二次方程的求根公式可以得到 x = (-1 + sqrt(8 * n + 1)) / 2, 然后取整后就是能填满的行数，一行搞定简直丧心病狂啊：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> arrangeCoins(<span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        </span><span style="color: #0000ff;">return</span> (<span style="color: #0000ff;">int</span>)((-<span style="color: #800080;">1</span> + sqrt(<span style="color: #800080;">1</span> + <span style="color: #800080;">8</span> * (<span style="color: #0000ff;">long</span>)n)) / <span style="color: #800080;">2</span><span style="color: #000000;">);
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/65664/my-55ms-c-solution" target="_blank">https://discuss.leetcode.com/topic/65664/my-55ms-c-solution</a></p>
<p><a href="https://discuss.leetcode.com/topic/65575/java-o-1-solution-math-problem" target="_blank">https://discuss.leetcode.com/topic/65575/java-o-1-solution-math-problem</a></p>
<p><a href="https://discuss.leetcode.com/topic/65631/c-three-solutions-o-n-o-logn-o-1/2" target="_blank">https://discuss.leetcode.com/topic/65631/c-three-solutions-o-n-o-logn-o-1/2</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-11-03 12:22</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=6026066" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(6026066);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/6031787.html" id="cb_post_title_url">[LeetCode] K-th Smallest in Lexicographical Order 字典顺序的第K小数字</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given integers <code>n</code> and <code>k</code>, find the lexicographically k-th smallest integer in the range from <code>1</code> to <code>n</code>.</p>
<p>Note: 1 ≤ k ≤ n ≤ 109.</p>
<p>Example:</p>
<pre>Input:
n: 13   k: 2

Output:
10

Explanation:
The lexicographical order is [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9], so the second smallest number is 10.</pre>
<p> </p>
<p>这道题是之前那道<a href="http://www.cnblogs.com/grandyang/p/5798275.html">Lexicographical Numbers</a>的延伸，之前让按字典顺序打印数组，而这道题让我们快速定位某一个位置，那么我们就不能像之前那道题一样，一个一个的遍历，这样无法通过OJ，这也是这道题被定为Hard的原因。那么我们得找出能够快速定位的方法，我们如果仔细观察字典顺序的数组，我们可以发现，其实这是个十叉树Denary Tree，就是每个节点的子节点可以有十个，比如数字1的子节点就是10到19，数字10的子节点可以是100到109，但是由于n大小的限制，构成的并不是一个满十叉树。我们分析题目中给的例子可以知道，数字1的子节点有4个(10,11,12,13)，而后面的数字2到9都没有子节点，那么这道题实际上就变成了一个先序遍历十叉树的问题，那么难点就变成了如何计算出每个节点的子节点的个数，我们不停的用k减去子节点的个数，当k减到0的时候，当前位置的数字即为所求。现在我们来看如何求子节点个数，比如数字1和数字2，我们要求按字典遍历顺序从1到2需要经过多少个数字，首先把1本身这一个数字加到step中，然后我们把范围扩大十倍，范围变成10到20之前，但是由于我们要考虑n的大小，由于n为13，所以只有4个子节点，这样我们就知道从数字1遍历到数字2需要经过5个数字，然后我们看step是否小于等于k，如果是，我们cur自增1，k减去step；如果不是，说明要求的数字在子节点中，我们此时cur乘以10，k自减1，以此类推，直到k为0推出循环，此时cur即为所求：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> findKthNumber(<span style="color: #0000ff;">int</span> n, <span style="color: #0000ff;">int</span><span style="color: #000000;"> k) {
        </span><span style="color: #0000ff;">int</span> cur = <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span>--<span style="color: #000000;">k;
        </span><span style="color: #0000ff;">while</span> (k &gt; <span style="color: #800080;">0</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">long</span> <span style="color: #0000ff;">long</span> step = <span style="color: #800080;">0</span>, first = cur, last = cur + <span style="color: #800080;">1</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">while</span> (first &lt;=<span style="color: #000000;"> n) {
                step </span>+= min((<span style="color: #0000ff;">long</span> <span style="color: #0000ff;">long</span>)n + <span style="color: #800080;">1</span>, last) -<span style="color: #000000;"> first;
                first </span>*= <span style="color: #800080;">10</span><span style="color: #000000;">;
                last </span>*= <span style="color: #800080;">10</span><span style="color: #000000;">;
            }
            </span><span style="color: #0000ff;">if</span> (step &lt;=<span style="color: #000000;"> k) {
                </span>++<span style="color: #000000;">cur;
                k </span>-=<span style="color: #000000;"> step;
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                cur </span>*= <span style="color: #800080;">10</span><span style="color: #000000;">;
                </span>--<span style="color: #000000;">k; 
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> cur;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/5798275.html">Lexicographical Numbers</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/64624/concise-easy-to-understand-java-5ms-solution-with-explaination/2" target="_blank">https://discuss.leetcode.com/topic/64624/concise-easy-to-understand-java-5ms-solution-with-explaination/2</a></p>
<p><a href="https://discuss.leetcode.com/topic/64462/c-python-0ms-o-log-n-2-time-o-1-space-super-easy-solution-with-detailed-explanations" target="_blank">https://discuss.leetcode.com/topic/64462/c-python-0ms-o-log-n-2-time-o-1-space-super-easy-solution-with-detailed-explanations</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-11-04 21:45</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=6031787" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(6031787);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/6022498.html" id="cb_post_title_url">[LeetCode] Ternary Expression Parser 三元表达式解析器</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="row">
<div class="col-md-12">
<div class="row">
<div class="col-md-12">
<div class="question-content">
<p>Given a string representing arbitrarily nested ternary expressions, calculate the result of the expression. You can always assume that the given expression is valid and only consists of digits <code>0-9</code>, <code>?</code>, <code>:</code>, <code>T</code> and <code>F</code> (<code>T</code> and <code>F</code>represent True and False respectively).</p>
<p>Note:</p>
<ol>
<li>The length of the given string is ≤ 10000.</li>
<li>Each number will contain only one digit.</li>
<li>The conditional expressions group right-to-left (as usual in most languages).</li>
<li>The condition will always be either <code>T</code> or <code>F</code>. That is, the condition will never be a digit.</li>
<li>The result of the expression will always evaluate to either a digit <code>0-9</code>, <code>T</code> or <code>F</code>.</li>
</ol>
<p> </p>
<p>Example 1:</p>
<pre>Input: "T?2:3"

Output: "2"

Explanation: If true, then result is 2; otherwise result is 3.
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input: "F?1:T?4:5"

Output: "4"

Explanation: The conditional expressions group right-to-left. Using parenthesis, it is read/evaluated as:

             "(F ? 1 : (T ? 4 : 5))"                   "(F ? 1 : (T ? 4 : 5))"
          -&gt; "(F ? 1 : 4)"                 or       -&gt; "(T ? 4 : 5)"
          -&gt; "4"                                    -&gt; "4"
</pre>
<p> </p>
<p>Example 3:</p>
<pre>Input: "T?T?F:5:3"

Output: "F"

Explanation: The conditional expressions group right-to-left. Using parenthesis, it is read/evaluated as:

             "(T ? (T ? F : 5) : 3)"                   "(T ? (T ? F : 5) : 3)"
          -&gt; "(T ? F : 3)"                 or       -&gt; "(T ? F : 5)"
          -&gt; "F"                                    -&gt; "F"
</pre>
<p> </p>
<p> </p>
</div>
</div>
</div>
</div>
</div>
<p>这道题让我们解析一个三元表达式，我们通过分析题目中的例子可以知道，如果有多个三元表达式嵌套的情况出现，那么我们的做法是从右边开始找到第一个问号，然后先处理这个三元表达式，然后再一步一步向左推，这也符合程序是从右向左执行的特点。那么我最先想到的方法是用用一个stack来记录所有问号的位置，然后根据此问号的位置，取出当前的三元表达式，调用一个eval函数来分析得到结果，能这样做的原因是题目中限定了三元表达式每一部分只有一个字符，而且需要分析的三元表达式是合法的，然后我们把分析后的结果和前后两段拼接成一个新的字符串，继续处理之前一个问号，这样当所有问号处理完成后，所剩的一个字符就是答案，参见代码如下:</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> parseTernary(<span style="color: #0000ff;">string</span><span style="color: #000000;"> expression) {
        </span><span style="color: #0000ff;">string</span> res =<span style="color: #000000;"> expression;
        stack</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> s;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; expression.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (expression[i] == <span style="color: #800000;">'</span><span style="color: #800000;">?</span><span style="color: #800000;">'</span><span style="color: #000000;">) s.push(i);
        }
        </span><span style="color: #0000ff;">while</span> (!<span style="color: #000000;">s.empty()) {
            </span><span style="color: #0000ff;">int</span> t =<span style="color: #000000;"> s.top(); s.pop();
            res </span>= res.substr(<span style="color: #800080;">0</span>, t - <span style="color: #800080;">1</span>) + eval(res.substr(t - <span style="color: #800080;">1</span>, <span style="color: #800080;">5</span>)) + res.substr(t + <span style="color: #800080;">4</span><span style="color: #000000;">);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">string</span> eval(<span style="color: #0000ff;">string</span><span style="color: #000000;"> str) {
        </span><span style="color: #0000ff;">if</span> (str.size() != <span style="color: #800080;">5</span>) <span style="color: #0000ff;">return</span> <span style="color: #800000;">""</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span> str[<span style="color: #800080;">0</span>] == <span style="color: #800000;">'</span><span style="color: #800000;">T</span><span style="color: #800000;">'</span> ? str.substr(<span style="color: #800080;">2</span>, <span style="color: #800080;">1</span>) : str.substr(<span style="color: #800080;">4</span><span style="color: #000000;">);
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种方法也是利用栈stack的思想，但是不同之处在于不是存问号的位置，而是存所有的字符，将原数组从后往前遍历，将遍历到的字符都压入栈中，我们检测如果栈首元素是问号，说明我们当前遍历到的字符是T或F，然后我们移除问号，再取出第一部分，再移除冒号，再取出第二部分，我们根据当前字符来判断是放哪一部分进栈，这样遍历完成后，所有问号都处理完了，剩下的栈顶元素即为所求:</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> parseTernary(<span style="color: #0000ff;">string</span><span style="color: #000000;"> expression) {
        stack</span>&lt;<span style="color: #0000ff;">char</span>&gt;<span style="color: #000000;"> s;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = expression.size() - <span style="color: #800080;">1</span>; i &gt;= <span style="color: #800080;">0</span>; --<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">char</span> c =<span style="color: #000000;"> expression[i];
            </span><span style="color: #0000ff;">if</span> (!s.empty() &amp;&amp; s.top() == <span style="color: #800000;">'</span><span style="color: #800000;">?</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                s.pop();
                </span><span style="color: #0000ff;">char</span> first =<span style="color: #000000;"> s.top(); s.pop();
                s.pop();
                </span><span style="color: #0000ff;">char</span> second =<span style="color: #000000;"> s.top(); s.pop();
                s.push(c </span>== <span style="color: #800000;">'</span><span style="color: #800000;">T</span><span style="color: #800000;">'</span> ?<span style="color: #000000;"> first : second);
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                s.push(c);
            }
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">string</span>(<span style="color: #800080;">1</span><span style="color: #000000;">, s.top());
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种方法更加简洁，没有用到栈，但是用到了STL的内置函数find_last_of，用于查找字符串中最后一个目前字符串出现的位置，这里我们找最后一个问号出现的位置，刚好就是最右边的问号，我们进行跟解法一类似的处理，拼接字符串，循环处理，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> parseTernary(<span style="color: #0000ff;">string</span><span style="color: #000000;"> expression) {
        </span><span style="color: #0000ff;">string</span> res =<span style="color: #000000;"> expression;
        </span><span style="color: #0000ff;">while</span> (res.size() &gt; <span style="color: #800080;">1</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">int</span> i = res.find_last_of(<span style="color: #800000;">"</span><span style="color: #800000;">?</span><span style="color: #800000;">"</span><span style="color: #000000;">);
            res </span>= res.substr(<span style="color: #800080;">0</span>, i - <span style="color: #800080;">1</span>) + <span style="color: #0000ff;">string</span>(<span style="color: #800080;">1</span>, res[i - <span style="color: #800080;">1</span>] == <span style="color: #800000;">'</span><span style="color: #800000;">T</span><span style="color: #800000;">'</span> ? res[i + <span style="color: #800080;">1</span>] : res[i + <span style="color: #800080;">3</span>]) + res.substr(i + <span style="color: #800080;">4</span><span style="color: #000000;">);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/64389/easy-and-concise-5-lines-python-java-solution" target="_blank">https://discuss.leetcode.com/topic/64389/easy-and-concise-5-lines-python-java-solution</a></p>
<p><a href="https://discuss.leetcode.com/topic/64409/very-easy-1-pass-stack-solution-in-java-no-string-concat/2" target="_blank">https://discuss.leetcode.com/topic/64409/very-easy-1-pass-stack-solution-in-java-no-string-concat/2</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-11-02 12:20</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=6022498" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(6022498);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/6014408.html" id="cb_post_title_url">[LeetCode] Find All Anagrams in a String 找出字符串中所有的变位词</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.</p>
<p>Strings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100.</p>
<p>The order of output does not matter.</p>
<p>Example 1:</p>
<pre>Input:
s: "cbaebabacd" p: "abc"

Output:
[0, 6]

Explanation:
The substring with start index = 0 is "cba", which is an anagram of "abc".
The substring with start index = 6 is "bac", which is an anagram of "abc".
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input:
s: "abab" p: "ab"

Output:
[0, 1, 2]

Explanation:
The substring with start index = 0 is "ab", which is an anagram of "ab".
The substring with start index = 1 is "ba", which is an anagram of "ab".
The substring with start index = 2 is "ab", which is an anagram of "ab".</pre>
<p> </p>
<p>这道题给了我们两个字符串s和p，让我们在s中找字符串p的所有变位次的位置，所谓变位次就是字符种类个数均相同但是顺序可以不同的两个词，那么我们肯定首先就要统计字符串p中字符出现的次数，然后从s的开头开始，每次找p字符串长度个字符，来验证字符个数是否相同，如果不相同出现了直接break，如果一直都相同了，则将起始位置加入结果res中，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; findAnagrams(<span style="color: #0000ff;">string</span> s, <span style="color: #0000ff;">string</span><span style="color: #000000;"> p) {
        </span><span style="color: #0000ff;">if</span> (s.empty()) <span style="color: #0000ff;">return</span><span style="color: #000000;"> {};
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; res, cnt(<span style="color: #800080;">128</span>, <span style="color: #800080;">0</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">int</span> ns = s.size(), np = p.size(), i = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span> c : p) ++<span style="color: #000000;">cnt[c];
        </span><span style="color: #0000ff;">while</span> (i &lt;<span style="color: #000000;"> ns) {
            </span><span style="color: #0000ff;">bool</span> success = <span style="color: #0000ff;">true</span><span style="color: #000000;">;
            vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; tmp =<span style="color: #000000;"> cnt;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = i; j &lt; i + np; ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> (--tmp[s[j]] &lt; <span style="color: #800080;">0</span><span style="color: #000000;">) {
                    success </span>= <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                }
            }
            </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (success) {
                res.push_back(i); 
            }
            </span>++<span style="color: #000000;">i;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>我们可以将上述代码写的更加简洁一些，用两个哈希表，分别记录p的字符个数，和s中前p字符串长度的字符个数，然后比较，如果两者相同，则将0加入结果res中，然后开始遍历s中剩余的字符，每次右边加入一个新的字符，然后去掉左边的一个旧的字符，每次再比较两个哈希表是否相同即可，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; findAnagrams(<span style="color: #0000ff;">string</span> s, <span style="color: #0000ff;">string</span><span style="color: #000000;"> p) {
        </span><span style="color: #0000ff;">if</span> (s.empty()) <span style="color: #0000ff;">return</span><span style="color: #000000;"> {};
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; res, m1(<span style="color: #800080;">256</span>, <span style="color: #800080;">0</span>), m2(<span style="color: #800080;">256</span>, <span style="color: #800080;">0</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; p.size(); ++<span style="color: #000000;">i) {
            </span>++m1[s[i]]; ++<span style="color: #000000;">m2[p[i]];
        }
        </span><span style="color: #0000ff;">if</span> (m1 == m2) res.push_back(<span style="color: #800080;">0</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = p.size(); i &lt; s.size(); ++<span style="color: #000000;">i) {
            </span>++<span style="color: #000000;">m1[s[i]]; 
            </span>--m1[s[i -<span style="color: #000000;"> p.size()]];
            </span><span style="color: #0000ff;">if</span> (m1 == m2) res.push_back(i - p.size() + <span style="color: #800080;">1</span><span style="color: #000000;">);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种利用滑动窗口Sliding Window的方法也比较巧妙，首先统计字符串p的字符个数，然后用两个变量left和right表示滑动窗口的左右边界，用变量cnt表示字符串p中需要匹配的字符个数，然后开始循环，如果右边界的字符已经在哈希表中了，说明该字符在p中有出现，则cnt自减1，然后哈希表中该字符个数自减1，右边界自加1，如果此时cnt减为0了，说明p中的字符都匹配上了，那么将此时左边界加入结果res中。如果此时right和left的差为p的长度，说明此时应该去掉最左边的一个字符，我们看如果该字符在哈希表中的个数大于等于0，说明该字符是p中的字符，为啥呢，因为上面我们有让每个字符自减1，如果不是p中的字符，那么在哈希表中个数应该为0，自减1后就为-1，所以这样就知道该字符是否属于p，如果我们去掉了属于p的一个字符，cnt自增1，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; findAnagrams(<span style="color: #0000ff;">string</span> s, <span style="color: #0000ff;">string</span><span style="color: #000000;"> p) {
        </span><span style="color: #0000ff;">if</span> (s.empty()) <span style="color: #0000ff;">return</span><span style="color: #000000;"> {};
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; res, m(<span style="color: #800080;">256</span>, <span style="color: #800080;">0</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">int</span> left = <span style="color: #800080;">0</span>, right = <span style="color: #800080;">0</span>, cnt = p.size(), n =<span style="color: #000000;"> s.size();
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span> c : p) ++<span style="color: #000000;">m[c];
        </span><span style="color: #0000ff;">while</span> (right &lt;<span style="color: #000000;"> n) {
            </span><span style="color: #0000ff;">if</span> (m[s[right++]]-- &gt;= <span style="color: #800080;">1</span>) --<span style="color: #000000;">cnt;
            </span><span style="color: #0000ff;">if</span> (cnt == <span style="color: #800080;">0</span><span style="color: #000000;">) res.push_back(left);
            </span><span style="color: #0000ff;">if</span> (right - left == p.size() &amp;&amp; m[s[left++]]++ &gt;= <span style="color: #800080;">0</span>) ++<span style="color: #000000;">cnt;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4694988.html">Valid Anagram</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4385822.html" target="_blank">Anagrams</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/64390/c-o-n-solution/2" target="_blank">https://discuss.leetcode.com/topic/64390/c-o-n-solution/2</a></p>
<p><a href="https://discuss.leetcode.com/topic/64434/shortest-concise-java-o-n-sliding-window-solution" target="_blank">https://discuss.leetcode.com/topic/64434/shortest-concise-java-o-n-sliding-window-solution</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-10-30 23:17</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=6014408" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(6014408);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/6007336.html" id="cb_post_title_url">[LeetCode] Path Sum III 二叉树的路径和之三</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>You are given a binary tree in which each node contains an integer value.</p>
<p>Find the number of paths that sum to a given value.</p>
<p>The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes).</p>
<p>The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.</p>
<p>Example:</p>
<pre>root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8

      10
     /  \
    5   -3
   / \    \
  3   2   11
 / \   \
3  -2   1

Return 3. The paths that sum to 8 are:

1.  5 -&gt; 3
2.  5 -&gt; 2 -&gt; 1
3. -3 -&gt; 11</pre>
<p> </p>
<p>这道题让我们求二叉树的路径的和等于一个给定值，说明了这条路径不必要从根节点开始，可以是中间的任意一段，而且二叉树的节点值也是有正有负。那么我们可以用递归来做，相当于先序遍历二叉树，对于每一个节点都有记录了一条从根节点到当前节点到路径，同时用一个变量curSum记录路径节点总和，然后我们看curSum和sum是否相等，相等的话结果res加1，不等的话我们来继续查看子路径和有没有满足题意的，做法就是每次去掉一个节点，看路径和是否等于给定值，注意最后必须留一个节点，不能全去掉了，因为如果全去掉了，路径之和为0，而如果假如给定值刚好为0的话就会有问题，整体来说不算一道很难的题，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> pathSum(TreeNode* root, <span style="color: #0000ff;">int</span><span style="color: #000000;"> sum) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        vector</span>&lt;TreeNode*&gt; <span style="color: #0000ff;">out</span><span style="color: #000000;">;
        helper(root, sum, </span><span style="color: #800080;">0</span>, <span style="color: #0000ff;">out</span><span style="color: #000000;">, res);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">void</span> helper(TreeNode* node, <span style="color: #0000ff;">int</span> sum, <span style="color: #0000ff;">int</span> curSum, vector&lt;TreeNode*&gt;&amp; <span style="color: #0000ff;">out</span>, <span style="color: #0000ff;">int</span>&amp;<span style="color: #000000;"> res) {
        </span><span style="color: #0000ff;">if</span> (!node) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
        curSum </span>+= node-&gt;<span style="color: #000000;">val;
        </span><span style="color: #0000ff;">out</span><span style="color: #000000;">.push_back(node);
        </span><span style="color: #0000ff;">if</span> (curSum == sum) ++<span style="color: #000000;">res;
        </span><span style="color: #0000ff;">int</span> t =<span style="color: #000000;"> curSum;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; <span style="color: #0000ff;">out</span>.size() - <span style="color: #800080;">1</span>; ++<span style="color: #000000;">i) {
            t </span>-= <span style="color: #0000ff;">out</span>[i]-&gt;<span style="color: #000000;">val;
            </span><span style="color: #0000ff;">if</span> (t == sum) ++<span style="color: #000000;">res;
        }
        helper(node</span>-&gt;left, sum, curSum, <span style="color: #0000ff;">out</span><span style="color: #000000;">, res);
        helper(node</span>-&gt;right, sum, curSum, <span style="color: #0000ff;">out</span><span style="color: #000000;">, res);
        </span><span style="color: #0000ff;">out</span><span style="color: #000000;">.pop_back();
    }
};</span></pre>
</div>
<p> </p>
<p>我们还可以对上面的方法进行一些优化，来去掉一些不必要的计算，我们可以用哈希表来建立所有的前缀路径之和跟其个数之间的映射，然后看子路径之和有没有等于给定值的，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> pathSum(TreeNode* root, <span style="color: #0000ff;">int</span><span style="color: #000000;"> sum) {
        unordered_map</span>&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> m;
        m[</span><span style="color: #800080;">0</span>] = <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span> helper(root, sum, <span style="color: #800080;">0</span><span style="color: #000000;">, m);
    }
    </span><span style="color: #0000ff;">int</span> helper(TreeNode* node, <span style="color: #0000ff;">int</span> sum, <span style="color: #0000ff;">int</span> curSum, unordered_map&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> m) {
        </span><span style="color: #0000ff;">if</span> (!node) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        curSum </span>+= node-&gt;<span style="color: #000000;">val;
        </span><span style="color: #0000ff;">int</span> res = m[curSum -<span style="color: #000000;"> sum];
        </span>++<span style="color: #000000;">m[curSum];
        res </span>+= helper(node-&gt;left, sum, curSum, m) + helper(node-&gt;<span style="color: #000000;">right, sum, curSum, m);
        </span>--<span style="color: #000000;">m[curSum];
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种方法非常的简洁，也是利用了前序遍历，对于每个遍历到的节点进行处理，维护一个变量pre来记录之前路径之和，然后cur为pre加上当前节点值，如果cur等于sum，那么返回结果时要加1，然后对当前节点的左右子节点调用递归函数求解，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> pathSum(TreeNode* root, <span style="color: #0000ff;">int</span><span style="color: #000000;"> sum) {
        </span><span style="color: #0000ff;">if</span> (!root) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span> sumUp(root, <span style="color: #800080;">0</span>, sum) + pathSum(root-&gt;left, sum) + pathSum(root-&gt;<span style="color: #000000;">right, sum);
    }
    </span><span style="color: #0000ff;">int</span> sumUp(TreeNode* node, <span style="color: #0000ff;">int</span> pre, <span style="color: #0000ff;">int</span>&amp;<span style="color: #000000;"> sum) {
        </span><span style="color: #0000ff;">if</span> (!node) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> cur = pre + node-&gt;<span style="color: #000000;">val;
        </span><span style="color: #0000ff;">return</span> (cur == sum) + sumUp(node-&gt;left, cur, sum) + sumUp(node-&gt;<span style="color: #000000;">right, cur, sum);
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4280120.html" target="_blank">Binary Tree Maximum Path Sum</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4042156.html" target="_blank">Path Sum II</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4036961.html" target="_blank">Path Sum</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4353255.html" target="_blank">Minimum Path Sum</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/64388/simple-ac-java-solution-dfs/2" target="_blank">https://discuss.leetcode.com/topic/64388/simple-ac-java-solution-dfs/2</a></p>
<p><a href="https://discuss.leetcode.com/topic/64402/c-5-line-body-code-dfs-solution" target="_blank">https://discuss.leetcode.com/topic/64402/c-5-line-body-code-dfs-solution</a></p>
<p> </p>
<p><a href="http://www.cnblogs.com/grandyang/p/4606334.html" target="_blank">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-10-28 12:32</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=6007336" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(6007336);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/6018581.html" id="cb_post_title_url">[LeetCode] Find Right Interval 找右区间</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a set of intervals, for each of the interval i, check if there exists an interval j whose start point is bigger than or equal to the end point of the interval i, which can be called that j is on the "right" of i.</p>
<p>For any interval i, you need to store the minimum interval j's index, which means that the interval j has the minimum start point to build the "right" relationship for interval i. If the interval j doesn't exist, store -1 for the interval i. Finally, you need output the stored value of each interval as an array.</p>
<p>Note:</p>
<ol>
<li>You may assume the interval's end point is always bigger than its start point.</li>
<li>You may assume none of these intervals have the same start point.</li>
</ol>
<p> </p>
<p>Example 1:</p>
<pre>Input: [ [1,2] ]

Output: [-1]

Explanation: There is only one interval in the collection, so it outputs -1.
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input: [ [3,4], [2,3], [1,2] ]

Output: [-1, 0, 1]

Explanation: There is no satisfied "right" interval for [3,4].
For [2,3], the interval [3,4] has minimum-"right" start point;
For [1,2], the interval [2,3] has minimum-"right" start point.
</pre>
<p> </p>
<p>Example 3:</p>
<pre>Input: [ [1,4], [2,3], [3,4] ]

Output: [-1, 2, -1]

Explanation: There is no satisfied "right" interval for [1,4] and [3,4].
For [2,3], the interval [3,4] has minimum-"right" start point.</pre>
<p> </p>
<p>这道题给了我们一堆区间，让我们找每个区间的最近右区间，要保证右区间的start要大于等于当前区间的end，由于区间的顺序不能变，所以我们不能给区间排序，我们需要建立区间的start和该区间位置之间的映射，由于题目中限定了每个区间的start都不同，所以不用担心一对多的情况出现。然后我们把所有的区间的start都放到一个数组中，并对这个数组进行降序排序，那么start值大的就在数组前面。然后我们遍历区间集合，对于每个区间，我们在数组中找第一个小于当前区间的end值的位置，如果数组中第一个数就小于当前区间的end，那么说明该区间不存在右区间，结果res中加入-1；如果找到了第一个小于当前区间end的位置，那么往前推一个就是第一个大于等于当前区间end的start，我们在哈希表中找到该区间的坐标加入结果res中即可，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; findRightInterval(vector&lt;Interval&gt;&amp;<span style="color: #000000;"> intervals) {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> res, v;
        unordered_map</span>&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> m;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; intervals.size(); ++<span style="color: #000000;">i) {
            m[intervals[i].start] </span>=<span style="color: #000000;"> i;
            v.push_back(intervals[i].start);
        }
        sort(v.begin(), v.end(), greater</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;">());
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto a : intervals) {
            </span><span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">for</span> (; i &lt; v.size(); ++<span style="color: #000000;">i) {
                </span><span style="color: #0000ff;">if</span> (v[i] &lt; a.end) <span style="color: #0000ff;">break</span><span style="color: #000000;">;
            }
            res.push_back((i </span>&gt; <span style="color: #800080;">0</span>) ? m[v[i - <span style="color: #800080;">1</span>]] : -<span style="color: #800080;">1</span><span style="color: #000000;">);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>上面的解法可以进一步化简，我们可以利用STL的lower_bound函数来找第一个不小于目标值的位置，这样也可以达到我们的目标，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; findRightInterval(vector&lt;Interval&gt;&amp;<span style="color: #000000;"> intervals) {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> res;
        map</span>&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> m;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; intervals.size(); ++<span style="color: #000000;">i) {
            m[intervals[i].start] </span>=<span style="color: #000000;"> i;
        }
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto a : intervals) {
            auto it </span>=<span style="color: #000000;"> m.lower_bound(a.end);
            </span><span style="color: #0000ff;">if</span> (it == m.end()) res.push_back(-<span style="color: #800080;">1</span><span style="color: #000000;">);
            </span><span style="color: #0000ff;">else</span> res.push_back(it-&gt;<span style="color: #000000;">second);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/6017505.html" id="homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0">Non-overlapping Intervals</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/5548284.html">Data Stream as Disjoint Intervals</a> </p>
<p><a href="http://www.cnblogs.com/grandyang/p/4367569.html" target="_blank">Insert Interval</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4370601.html" target="_blank">Merge Intervals</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/65602/c-map-solution" target="_blank">https://discuss.leetcode.com/topic/65602/c-map-solution</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-11-01 10:46</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=6018581" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(6018581);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/6017505.html" id="cb_post_title_url">[LeetCode] Non-overlapping Intervals 非重叠区间</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a collection of intervals, find the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.</p>
<p>Note:</p>
<ol>
<li>You may assume the interval's end point is always bigger than its start point.</li>
<li>Intervals like [1,2] and [2,3] have borders "touching" but they don't overlap each other.</li>
</ol>
<p> </p>
<p>Example 1:</p>
<pre>Input: [ [1,2], [2,3], [3,4], [1,3] ]

Output: 1

Explanation: [1,3] can be removed and the rest of intervals are non-overlapping.
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input: [ [1,2], [1,2], [1,2] ]

Output: 2

Explanation: You need to remove two [1,2] to make the rest of intervals non-overlapping.
</pre>
<p> </p>
<p>Example 3:</p>
<pre>Input: [ [1,2], [2,3] ]

Output: 0

Explanation: You don't need to remove any of the intervals since they're already non-overlapping.</pre>
<p> </p>
<p>这道题给了我们一堆区间，让我们求需要至少移除多少个区间才能使剩下的区间没有重叠，那么我们首先要给区间排序，根据每个区间的start来做升序排序，然后我们开始要查找重叠区间，判断方法是看如果前一个区间的end大于后一个区间的start，那么一定是重复区间，此时我们结果res自增1，我们需要删除一个，那么此时我们究竟该删哪一个呢，为了保证我们总体去掉的区间数最小，我们去掉那个end值较大的区间，而在代码中，我们并没有真正的删掉某一个区间，而是用一个变量last指向上一个需要比较的区间，我们将last指向end值较小的那个区间；如果两个区间没有重叠，那么此时last指向当前区间，继续进行下一次遍历，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> eraseOverlapIntervals(vector&lt;Interval&gt;&amp;<span style="color: #000000;"> intervals) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, n = intervals.size(), last = <span style="color: #800080;">0</span><span style="color: #000000;">;
        sort(intervals.begin(), intervals.end(), [](Interval</span>&amp; a, Interval&amp; b){<span style="color: #0000ff;">return</span> a.start &lt;<span style="color: #000000;"> b.start;});
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (intervals[i].start &lt;<span style="color: #000000;"> intervals[last].end) {
                </span>++<span style="color: #000000;">res;
                </span><span style="color: #0000ff;">if</span> (intervals[i].end &lt; intervals[last].end) last =<span style="color: #000000;"> i;
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                last </span>=<span style="color: #000000;"> i;
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>我们也可以对上面代码进行简化，主要利用三元操作符来代替if从句，参见代码如下： </p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> eraseOverlapIntervals(vector&lt;Interval&gt;&amp;<span style="color: #000000;"> intervals) {
        </span><span style="color: #0000ff;">if</span> (intervals.empty()) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;      
        sort(intervals.begin(), intervals.end(), [](Interval</span>&amp; a, Interval&amp; b){<span style="color: #0000ff;">return</span> a.start &lt;<span style="color: #000000;"> b.start;});
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, n = intervals.size(), endLast = intervals[<span style="color: #800080;">0</span><span style="color: #000000;">].end;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">int</span> t = endLast &gt; intervals[i].start ? <span style="color: #800080;">1</span> : <span style="color: #800080;">0</span><span style="color: #000000;">;
            endLast </span>= t == <span style="color: #800080;">1</span> ?<span style="color: #000000;"> min(endLast, intervals[i].end) : intervals[i].end;
            res </span>+=<span style="color: #000000;"> t;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/6018581.html" id="homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0">Find Right Interval</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/5548284.html">Data Stream as Disjoint Intervals</a> </p>
<p><a href="http://www.cnblogs.com/grandyang/p/4367569.html" target="_blank">Insert Interval</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4370601.html" target="_blank">Merge Intervals</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/7381633.html">Maximum Length of Pair Chain</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/65629/concise-c-solution" target="_blank">https://discuss.leetcode.com/topic/65629/concise-c-solution</a></p>
<p><a href="https://discuss.leetcode.com/topic/65583/o-nlogn-java-solution" target="_blank">https://discuss.leetcode.com/topic/65583/o-nlogn-java-solution</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-10-31 21:56</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=6017505" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(6017505);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/6137386.html" id="cb_post_title_url">[LeetCode] Number of Segments in a String 字符串中的分段数量</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Count the number of segments in a string, where a segment is defined to be a contiguous sequence of non-space characters.</p>
<p>Please note that the string does not contain any <strong>non-printable</strong> characters.</p>
<p><strong>Example:</strong></p>
<pre><strong>Input:</strong> "Hello, my name is John"
<strong>Output:</strong> 5
</pre>
<div> </div>
<div>这道题跟之前那道<a href="http://www.cnblogs.com/grandyang/p/4606676.html" target="_blank">Reverse Words in a String</a>有些类似，不过比那题要简单一些，因为不用翻转单词，只要统计出单词的数量即可。那么我们的做法是遍历字符串，遇到空格直接跳过，如果不是空格，则计数器加1，然后用个while循环找到下一个空格的位置，这样就遍历完了一个单词，再重复上面的操作直至结束，就能得到正确结果：</div>
<div> </div>
<div> 解法一：</div>
<div>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> countSegments(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, n =<span style="color: #000000;"> s.size();
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (s[i] == <span style="color: #800000;">'</span> <span style="color: #800000;">'</span>) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
            </span>++<span style="color: #000000;">res;
            </span><span style="color: #0000ff;">while</span> (i &lt; n &amp;&amp; s[i] != <span style="color: #800000;">'</span> <span style="color: #800000;">'</span>) ++<span style="color: #000000;">i;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种方法是统计单词开头的第一个字符，因为每个单词的第一个字符前面一个字符一定是空格，利用这个特性也可以统计单词的个数：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> countSegments(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; s.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (s[i] != <span style="color: #800000;">'</span> <span style="color: #800000;">'</span> &amp;&amp; (i == <span style="color: #800080;">0</span> || s[i - <span style="color: #800080;">1</span>] == <span style="color: #800000;">'</span> <span style="color: #800000;">'</span><span style="color: #000000;">)) {
                </span>++<span style="color: #000000;">res;
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种方法用到了C++的字符串流操作，利用getline函数取出每两个空格符之间的字符串，由于多个空格符可能连在一起，所以有可能取出空字符串，我们要判断一下，如果取出的是非空字符串我们才累加计数器，参见代码如下：</p>
<p> </p>
</div>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> countSegments(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        istringstream </span><span style="color: #0000ff;">is</span><span style="color: #000000;">(s);
        </span><span style="color: #0000ff;">string</span> t = <span style="color: #800000;">""</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (getline(<span style="color: #0000ff;">is</span>, t, <span style="color: #800000;">'</span> <span style="color: #800000;">'</span><span style="color: #000000;">)) {
            </span><span style="color: #0000ff;">if</span> (t.empty()) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
            </span>++<span style="color: #000000;">res;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4606676.html" target="_blank">Reverse Words in a String</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/70775/c-istringstream-try" target="_blank">https://discuss.leetcode.com/topic/70775/c-istringstream-try</a></p>
<p><a href="https://discuss.leetcode.com/topic/70642/clean-java-solution-o-n" target="_blank">https://discuss.leetcode.com/topic/70642/clean-java-solution-o-n</a></p>
<p><a href="https://discuss.leetcode.com/topic/70656/ac-solution-java-with-trim-and-split" target="_blank">https://discuss.leetcode.com/topic/70656/ac-solution-java-with-trim-and-split</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-12-06 14:07</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=6137386" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(6137386);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7653006.html" id="cb_post_title_url">[LeetCode] Minimum Genetic Mutation 最小基因变化</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="question-description">
<p>A gene string can be represented by an 8-character long string, with choices from <code>"A"</code>, <code>"C"</code>, <code>"G"</code>, <code>"T"</code>.</p>
<p>Suppose we need to investigate about a mutation (mutation from "start" to "end"), where ONE mutation is defined as ONE single character changed in the gene string.</p>
<p>For example, <code>"AACCGGTT"</code> -&gt; <code>"AACCGGTA"</code> is 1 mutation.</p>
<p>Also, there is a given gene "bank", which records all the valid gene mutations. A gene must be in the bank to make it a valid gene string.</p>
<p>Now, given 3 things - start, end, bank, your task is to determine what is the minimum number of mutations needed to mutate from "start" to "end". If there is no such a mutation, return -1.</p>
<p>Note:</p>
<ol>
<li>Starting point is assumed to be valid, so it might not be included in the bank.</li>
<li>If multiple mutations are needed, all mutations during in the sequence must be valid.</li>
<li>You may assume start and end string is not the same.</li>
</ol>
<p> </p>
<p>Example 1:</p>
<pre>start: "AACCGGTT"
end:   "AACCGGTA"
bank: ["AACCGGTA"]

return: 1
</pre>
<p> </p>
<p>Example 2:</p>
<pre>start: "AACCGGTT"
end:   "AAACGGTA"
bank: ["AACCGGTA", "AACCGCTA", "AAACGGTA"]

return: 2
</pre>
<p> </p>
<p>Example 3:</p>
<pre>start: "AAAAACCC"
end:   "AACCCCCC"
bank: ["AAAACCCC", "AAACCCCC", "AACCCCCC"]

return: 3
</pre>
<p> </p>
<p>这道题跟之前的<a href="http://www.cnblogs.com/grandyang/p/4539768.html" target="_blank">Word Ladder</a>完全是一道题啊，换个故事就直接来啊，越来不走心了啊。不过博主做的时候并没有想起来是之前一样的题，而是先按照脑海里第一个浮现出的思路做的，发现也通过OJ了。博主使用的一种BFS的搜索，先建立bank数组的距离场，这里距离就是两个字符串之间不同字符的个数。然后以start字符串为起点，向周围距离为1的点扩散，采用BFS搜索，每扩散一层，level自加1，当扩散到end字符串时，返回当前level即可。注意我们要把start字符串也加入bank中，而且此时我们也知道start的坐标位置，bank的最后一个位置，然后在简历距离场的时候，调用一个count子函数，用来统计输入的两个字符串之间不同字符的个数，注意dist[i][j]和dist[j][i]是相同，所以我们只用算一次就行了。然后我们进行BFS搜索，用一个visited集合来保存遍历过的字符串，注意检测距离的时候，dist[i][j]和dist[j][i]只要有一个是1，就可以了，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> minMutation(<span style="color: #0000ff;">string</span> start, <span style="color: #0000ff;">string</span> end, vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp;<span style="color: #000000;"> bank) {
        </span><span style="color: #0000ff;">if</span> (bank.empty()) <span style="color: #0000ff;">return</span> -<span style="color: #800080;">1</span><span style="color: #000000;">;
        bank.push_back(start);
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, n =<span style="color: #000000;"> bank.size();
        queue</span>&lt;<span style="color: #0000ff;">int</span>&gt; q{{n - <span style="color: #800080;">1</span><span style="color: #000000;">}};
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; dist(n, vector&lt;<span style="color: #0000ff;">int</span>&gt;(n, <span style="color: #800080;">0</span><span style="color: #000000;">));
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = i + <span style="color: #800080;">1</span>; j &lt; n; ++<span style="color: #000000;">j) {
                dist[i][j] </span>=<span style="color: #000000;"> count(bank[i], bank[j]);
            }
        }
        unordered_set</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> visited;
        </span><span style="color: #0000ff;">while</span> (!<span style="color: #000000;">q.empty()) {
            </span><span style="color: #0000ff;">int</span> len =<span style="color: #000000;"> q.size();
            </span>++<span style="color: #000000;">res;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; len; ++<span style="color: #000000;">i) {
                </span><span style="color: #0000ff;">int</span> t =<span style="color: #000000;"> q.front(); q.pop();
                visited.insert(t);
                </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; n; ++<span style="color: #000000;">j) {
                    </span><span style="color: #0000ff;">if</span> ((dist[t][j] != <span style="color: #800080;">1</span> &amp;&amp; dist[j][t] != <span style="color: #800080;">1</span>) || visited.count(j)) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">if</span> (bank[j] == end) <span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
                    q.push(j);
                }
            }
        }
        </span><span style="color: #0000ff;">return</span> -<span style="color: #800080;">1</span><span style="color: #000000;">;
    }
    </span><span style="color: #0000ff;">int</span> count(<span style="color: #0000ff;">string</span> word1, <span style="color: #0000ff;">string</span><span style="color: #000000;"> word2) {
        </span><span style="color: #0000ff;">int</span> cnt = <span style="color: #800080;">0</span>, n =<span style="color: #000000;"> word1.size();
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (word1[i] != word2[i]) ++<span style="color: #000000;">cnt;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> cnt;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种解法跟之前的那道<a href="http://www.cnblogs.com/grandyang/p/4539768.html" target="_blank">Word Ladder</a>是一样的，也是用的BFS搜索。跟上面的解法不同之处在于，对于遍历到的字符串，我们不再有距离场，而是对于每个字符，我们都尝试将其换为一个新的字符，每次只换一个，这样会得到一个新的字符串，如果这个字符串在bank中存在，说明这样变换是合法的，加入visited集合和queue中等待下一次遍历，记得在下次置换字符的时候要将之前的还原。我们在queue中取字符串出来遍历的时候，先检测其是否和end相等，相等的话返回level，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> minMutation(<span style="color: #0000ff;">string</span> start, <span style="color: #0000ff;">string</span> end, vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp;<span style="color: #000000;"> bank) {
        </span><span style="color: #0000ff;">if</span> (bank.empty()) <span style="color: #0000ff;">return</span> -<span style="color: #800080;">1</span><span style="color: #000000;">;
        vector</span>&lt;<span style="color: #0000ff;">char</span>&gt; gens{<span style="color: #800000;">'</span><span style="color: #800000;">A</span><span style="color: #800000;">'</span>,<span style="color: #800000;">'</span><span style="color: #800000;">C</span><span style="color: #800000;">'</span>,<span style="color: #800000;">'</span><span style="color: #800000;">G</span><span style="color: #800000;">'</span>,<span style="color: #800000;">'</span><span style="color: #800000;">T</span><span style="color: #800000;">'</span><span style="color: #000000;">};
        unordered_set</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> s{bank.begin(), bank.end()};
        unordered_set</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> visited;
        queue</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> q{{start}};
        </span><span style="color: #0000ff;">int</span> level = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (!<span style="color: #000000;">q.empty()) {
            </span><span style="color: #0000ff;">int</span> len =<span style="color: #000000;"> q.size();
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; len; ++<span style="color: #000000;">i) {
                </span><span style="color: #0000ff;">string</span> t =<span style="color: #000000;"> q.front(); q.pop();
                </span><span style="color: #0000ff;">if</span> (t == end) <span style="color: #0000ff;">return</span><span style="color: #000000;"> level;
                </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; t.size(); ++<span style="color: #000000;">j) {
                    </span><span style="color: #0000ff;">char</span> old =<span style="color: #000000;"> t[j];
                    </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span><span style="color: #000000;"> c : gens) {
                        t[j] </span>=<span style="color: #000000;"> c;
                        </span><span style="color: #0000ff;">if</span> (s.count(t) &amp;&amp; !<span style="color: #000000;">visited.count(t)) {
                            visited.insert(t);
                            q.push(t);
                        }
                    }
                    t[j] </span>=<span style="color: #000000;"> old;
                }
            }
            </span>++<span style="color: #000000;">level;
        }
        </span><span style="color: #0000ff;">return</span> -<span style="color: #800080;">1</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>博主一直想找种递归的解法，于是在论坛上找到了<a href="https://discuss.leetcode.com/topic/101351/dfs-java" target="_blank">这个帖子</a>，是Java版的递归写法，博主将其改写成C++版本，但是无法通过OJ，百思不得其解啊，明明一模一样啊，连变量名都起的一样，为啥Java版的就是对的，博主的这个改写版就不对呢，各位看官大神们帮忙解答一下呀～</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> Why this not passing OJ ? Exactly the same as this Java version: </span><span style="color: #008000; text-decoration: underline;">https://discuss.leetcode.com/topic/101351/dfs-java</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> minMutation(<span style="color: #0000ff;">string</span> start, <span style="color: #0000ff;">string</span> end, vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp;<span style="color: #000000;"> bank) {
        vector</span>&lt;<span style="color: #0000ff;">bool</span>&gt; explored(bank.size(), <span style="color: #0000ff;">false</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">if</span> (bank.empty()) <span style="color: #0000ff;">return</span> -<span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> minMutation(explored, start, end,  bank);
    }
    </span><span style="color: #0000ff;">bool</span> minMutation(vector&lt;<span style="color: #0000ff;">bool</span>&gt;&amp; explored , <span style="color: #0000ff;">string</span> start, <span style="color: #0000ff;">string</span> end, vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp;<span style="color: #000000;"> bank) {
        </span><span style="color: #0000ff;">if</span> (start == end) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> step = bank.size() + <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; bank.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (diffOne(start, bank[i]) &amp;&amp;<span style="color: #000000;"> explored[i]) {
                explored[i] </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">int</span> temp =<span style="color: #000000;"> minMutation(explored, bank[i], end, bank);
                </span><span style="color: #0000ff;">if</span> (temp != -<span style="color: #800080;">1</span><span style="color: #000000;">) {
                    step </span>=<span style="color: #000000;"> min(step, temp);
                }
                explored[i] </span>= <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            }
        }
        </span><span style="color: #0000ff;">return</span> step == bank.size() + <span style="color: #800080;">1</span> ? -<span style="color: #800080;">1</span> : <span style="color: #800080;">1</span> +<span style="color: #000000;"> step;
    }
    </span><span style="color: #0000ff;">bool</span> diffOne(<span style="color: #0000ff;">string</span>&amp; s1, <span style="color: #0000ff;">string</span>&amp;<span style="color: #000000;"> s2) {
        </span><span style="color: #0000ff;">int</span> count = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; s1.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (s1[i] != s2[i]) ++<span style="color: #000000;">count;
            </span><span style="color: #0000ff;">if</span> (count &gt;= <span style="color: #800080;">2</span>) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> count == <span style="color: #800080;">1</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4539768.html" target="_blank">Word Ladder</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4548184.html" target="_blank">Word Ladder II</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/101351/dfs-java" target="_blank">https://discuss.leetcode.com/topic/101351/dfs-java</a></p>
<p><a href="https://discuss.leetcode.com/topic/65780/java-solution-using-bfs" target="_blank">https://discuss.leetcode.com/topic/65780/java-solution-using-bfs</a></p>
</div>
<div id="interviewed-div"> </div>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-10-11 21:40</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7653006" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7653006);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/6012229.html" id="cb_post_title_url">[LeetCode] All O`one Data Structure 全O(1)的数据结构</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Implement a data structure supporting the following operations:</p>
<p> </p>
<ol>
<li>Inc(Key) - Inserts a new key with value 1. Or increments an existing key by 1. Key is guaranteed to be a non-empty string.</li>
<li>Dec(Key) - If Key's value is 1, remove it from the data structure. Otherwise decrements an existing key by 1. If the key does not exist, this function does nothing. Key is guaranteed to be a non-empty string.</li>
<li>GetMaxKey() - Returns one of the keys with maximal value. If no element exists, return an empty string <code>""</code>.</li>
<li>GetMinKey() - Returns one of the keys with minimal value. If no element exists, return an empty string <code>""</code>.</li>
</ol>
<p> </p>
<p>Challenge: Perform all these in O(1) time complexity.</p>
<p> </p>
<p>这道题让我们实现一个全是O(1)复杂度的数据结构，包括了增加key，减少key，获取最大key，获取最小key，这几个函数。由于需要常数级的时间复杂度，我们首先第一反应就是要用哈希表来做，不仅如此，我们肯定还需要用list来保存所有的key，那么哈希表就是建立key和list中位置迭代器之间的映射，这不由得令人想到了之前那道<a href="http://www.cnblogs.com/grandyang/p/4587511.html" target="_blank">LRU Cache</a>，也是用了类似的方法来解，但是感觉此题还要更加复杂一些。由于每个key还要对应一个次数，所以list中不能只放key，而且相同的次数可能会对应多个key值，所以我们用unordered_set来保存次数相同的所有key值，我们建立一个Bucket的结构体来保存次数val，和保存key值的集合keys。解题思路主要参考了<a href="https://discuss.leetcode.com/topic/63683/0ms-all-in-o-1-with-detailed-explantation" target="_blank">网友ivancjw的帖子</a>，数据结构参考了<a href="https://discuss.leetcode.com/topic/63827/c-solution-with-comments" target="_blank">史蒂芬大神的帖子</a>，思路是，我们建立一个次数分层的结构，次数多的在顶层，每一层放相同次数的key值，例如下面这个例子：</p>
<p>"A": 4, "B": 4, "C": 2, "D": 1</p>
<p>那么用我们设计的结构保存出来就是：</p>
<p>row0: val = 4, keys = {"A", "B"}<br/>row1: val = 2, keys = {"C"}<br/>row2: val = 1, keys = {"D"}</p>
<p>好，我们现在来分析如何实现inc函数，我们来想，如果我们插入一个新的key，跟我们插入一个已经存在的key，情况是完全不一样的，那么我们就需要分情况来讨论:</p>
<p>- 如果我们插入一个新的key，那么由于该key没有出现过，所以加入后次数一定为1，那么就有两种情况了，如果list中没有val为1的这一行，那么我们需要插入该行，如果已经有了val为1的这行，我们直接将key加入集合keys中即可。</p>
<p>- 如果我们插入了一个已存在的key，那么由于个数增加了1个，所以该key值肯定不能在当前行继续待下去了，要往上升职啊，那么这里就有两种情况了，如果该key要升职到的那行不存在，我们需要手动添加那一行；如果那一行存在，我们之间将key加入集合keys中，记得都要将原来行中的key值删掉。</p>
<p>下面我们再来看dec函数如何实现，其实理解了上面的inc函数，那么dec函数也就没什么难度了：</p>
<p>- 如果我们要删除的key不存在，那么直接返回即可。</p>
<p>- 如果我们要删除的key存在，那么我们看其val值是否为1，如果为1的话，那么直接在keys中删除该key即可，然后还需要判断如果该key是集合中的唯一一个，那么该行也需要删除。如果key的次数val不为1的话，我们要考虑降级问题，跟之前的升职很类似，如果要降级的行不存在，我们手动添加上，如果存在，则直接将key值添加到keys集合中即可。</p>
<p>当我们搞懂了inc和dec的实现方法，那么getMaxKey()和getMinKey()简直就是福利啊，不要太简单啊，直接返回首层和尾层的key值即可，参见代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> AllOne {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">* Initialize your data structure here. </span><span style="color: #008000;">*/</span><span style="color: #000000;">
    AllOne() {}
    
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">* Inserts a new key &lt;Key&gt; with value 1. Or increments an existing key by 1. </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">void</span> inc(<span style="color: #0000ff;">string</span><span style="color: #000000;"> key) {
        </span><span style="color: #0000ff;">if</span> (!<span style="color: #000000;">m.count(key)) {
            </span><span style="color: #0000ff;">if</span> (buckets.empty() || buckets.back().val != <span style="color: #800080;">1</span><span style="color: #000000;">) {
                auto newBucket </span>= buckets.insert(buckets.end(), {<span style="color: #800080;">1</span><span style="color: #000000;">, {key}});
                m[key] </span>=<span style="color: #000000;"> newBucket;
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                auto newBucket </span>= --<span style="color: #000000;">buckets.end();
                newBucket</span>-&gt;<span style="color: #000000;">keys.insert(key);
                m[key] </span>=<span style="color: #000000;"> newBucket;
            }
        } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            auto curBucket </span>= m[key], lastBucket = (--<span style="color: #000000;">m[key]);
            </span><span style="color: #0000ff;">if</span> (lastBucket == buckets.end() || lastBucket-&gt;val != curBucket-&gt;val + <span style="color: #800080;">1</span><span style="color: #000000;">) {
                auto newBucket </span>= buckets.insert(curBucket, {curBucket-&gt;val + <span style="color: #800080;">1</span><span style="color: #000000;">, {key}});
                m[key] </span>=<span style="color: #000000;"> newBucket;
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                lastBucket</span>-&gt;<span style="color: #000000;">keys.insert(key);
                m[key] </span>=<span style="color: #000000;"> lastBucket;
            }
            curBucket</span>-&gt;<span style="color: #000000;">keys.erase(key);
            </span><span style="color: #0000ff;">if</span> (curBucket-&gt;<span style="color: #000000;">keys.empty()) buckets.erase(curBucket);
        }
    }
    
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">* Decrements an existing key by 1. If Key's value is 1, remove it from the data structure. </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">void</span> dec(<span style="color: #0000ff;">string</span><span style="color: #000000;"> key) {
        </span><span style="color: #0000ff;">if</span> (!m.count(key)) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
        auto curBucket </span>=<span style="color: #000000;"> m[key];
        </span><span style="color: #0000ff;">if</span> (curBucket-&gt;val == <span style="color: #800080;">1</span><span style="color: #000000;">) {
            curBucket</span>-&gt;<span style="color: #000000;">keys.erase(key);
            </span><span style="color: #0000ff;">if</span> (curBucket-&gt;<span style="color: #000000;">keys.empty()) buckets.erase(curBucket);
            m.erase(key);
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;">;
        }
        auto nextBucket </span>= ++<span style="color: #000000;">m[key];
        </span><span style="color: #0000ff;">if</span> (nextBucket == buckets.end() || nextBucket-&gt;val != curBucket-&gt;val - <span style="color: #800080;">1</span><span style="color: #000000;">) {
            auto newBucket </span>= buckets.insert(nextBucket, {curBucket-&gt;val - <span style="color: #800080;">1</span><span style="color: #000000;">, {key}});
            m[key] </span>=<span style="color: #000000;"> newBucket;
        } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            nextBucket</span>-&gt;<span style="color: #000000;">keys.insert(key);
            m[key] </span>=<span style="color: #000000;"> nextBucket;
        }
        curBucket</span>-&gt;<span style="color: #000000;">keys.erase(key);
        </span><span style="color: #0000ff;">if</span> (curBucket-&gt;<span style="color: #000000;">keys.empty()) buckets.erase(curBucket);
    }
    
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">* Returns one of the keys with maximal value. </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">string</span><span style="color: #000000;"> getMaxKey() {
        </span><span style="color: #0000ff;">return</span> buckets.empty() ? <span style="color: #800000;">""</span> : *(buckets.begin()-&gt;<span style="color: #000000;">keys.begin());
    }
    
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">* Returns one of the keys with Minimal value. </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">string</span><span style="color: #000000;"> getMinKey() {
        </span><span style="color: #0000ff;">return</span> buckets.empty() ? <span style="color: #800000;">""</span> : *(buckets.rbegin()-&gt;<span style="color: #000000;">keys.begin());
    }
</span><span style="color: #0000ff;">private</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">struct</span> Bucket { <span style="color: #0000ff;">int</span> val; unordered_set&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> keys; };
    list</span>&lt;Bucket&gt;<span style="color: #000000;"> buckets;
    unordered_map</span>&lt;<span style="color: #0000ff;">string</span>, list&lt;Bucket&gt;::iterator&gt;<span style="color: #000000;"> m;
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4587511.html" target="_blank">LRU Cache</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/63827/c-solution-with-comments" target="_blank">https://discuss.leetcode.com/topic/63827/c-solution-with-comments</a></p>
<p><a href="https://discuss.leetcode.com/topic/63683/0ms-all-in-o-1-with-detailed-explantation" target="_blank">https://discuss.leetcode.com/topic/63683/0ms-all-in-o-1-with-detailed-explantation</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-10-29 23:51</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=6012229" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(6012229);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/9688522.html" id="cb_post_title_url">[LeetCode] Flatten a Multilevel Doubly Linked List 压平一个多层的双向链表</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>You are given a doubly linked list which in addition to the next and previous pointers, it could have a child pointer, which may or may not point to a separate doubly linked list. These child lists may have one or more children of their own, and so on, to produce a multilevel data structure, as shown in the example below.</p>
<p>Flatten the list so that all the nodes appear in a single-level, doubly linked list. You are given the head of the first level of the list.</p>
<p>Example:</p>
<pre>Input:
 1---2---3---4---5---6--NULL
         |
         7---8---9---10--NULL
             |
             11--12--NULL

Output:
1-2-3-7-8-11-12-9-10-4-5-6-NULL
</pre>
<p>Explanation for the above example:</p>
<p>Given the following multilevel doubly linked list:</p>
<p><img alt="" height="322" src="https://leetcode.com/static/images/problemset/MultilevelLinkedList.png" width="567"/></p>
<p>We should return the following flattened doubly linked list:</p>
<p><img alt="" height="75" src="https://leetcode.com/static/images/problemset/MultilevelLinkedListFlattened.png" width="1038"/></p>
<p> </p>
<p>这道题给了我们一个多层的双向链表，让我们压平成为一层的双向链表，题目中给了形象的图例，不难理解题意。根据题目中给的例子，我们可以看出如果某个结点有下一层双向链表，那么下一层双向链表中的结点就要先加入进去，如果下一层链表中某个结点还有下一层，那么还是优先加入下一层的结点，整个加入的机制是DFS的，就是有岔路先走岔路，走到没路了后再返回，这就是深度优先遍历的机制。好，那么既然是DFS，肯定优先考虑递归啦。方法有了，再来看具体怎么递归。由于给定的多层链表本身就是双向的，所以我们只需要把下一层的结点移到第一层即可，那么没有子结点的结点就保持原状，不作处理。只有对于那些有子结点的，我们需要做一些处理，由于子结点链接的双向链表要加到后面，所以当前结点之后要断开，再断开之前，我们用变量next指向下一个链表，然后我们对子结点调用递归函数，我们suppose返回的结点已经压平了，那么就只有一层，那么就相当于要把这一层的结点加到断开的地方，所以我们需要知道这层的最后一个结点的位置，我们用一个变量last，来遍历到压平的这一层的末结点。现在我们就可以开始链接了，首先把子结点链到cur的next，然后把反向指针prev也链上。此时cur的子结点child可以清空，然后压平的这一层的末节点last链上之前保存的next结点，如果next非空，那么链上反向结点prev。这些操作完成后，我们就已经将压平的这一层完整的加入了之前层断开的地方，我们继续在之前层往下遍历即可，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    Node</span>* flatten(Node*<span style="color: #000000;"> head) {
        Node </span>*cur =<span style="color: #000000;"> head;
        </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> (cur) {
            </span><span style="color: #0000ff;">if</span> (cur-&gt;<span style="color: #000000;">child) {
                Node </span>*next = cur-&gt;<span style="color: #000000;">next;
                cur</span>-&gt;child = flatten(cur-&gt;<span style="color: #000000;">child);
                Node </span>*last = cur-&gt;<span style="color: #000000;">child;
                </span><span style="color: #0000ff;">while</span> (last-&gt;next) last = last-&gt;<span style="color: #000000;">next;
                cur</span>-&gt;next = cur-&gt;<span style="color: #000000;">child;
                cur</span>-&gt;next-&gt;prev =<span style="color: #000000;"> cur;
                cur</span>-&gt;child =<span style="color: #000000;"> NULL;
                last</span>-&gt;next =<span style="color: #000000;"> next;
                </span><span style="color: #0000ff;">if</span> (next) next-&gt;prev =<span style="color: #000000;"> last;
            }
            cur </span>= cur-&gt;<span style="color: #000000;">next;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> head;
    }
};</span></pre>
</div>
<p> </p>
<p>我们其实也可以不用递归，链表的题不像树的题，对于树的题使用递归可以很简洁，而链表递归和迭代可能差的并不多。如果你仔细对比两种方法的代码，你会发现迭代的写法刚好比递归的写法少了调用递归的那一行，给人一种完全没有必要使用递归的感觉，其实两种解法的操作顺序不同的，递归写法是从最底层开始操作，先把最底层加入倒数第二层，再把混合后的层加入倒数第三层，依此类推，直到都融合到第一层为止。而迭代的写法却是反过来的，先把第二层加入第一层，此时第二层底下可能还有很多层，不必理会，之后等遍历到的时候，再一层一层的加入第一层中，不管哪种方法，最终都可以压平，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    Node</span>* flatten(Node*<span style="color: #000000;"> head) {
        Node </span>*cur =<span style="color: #000000;"> head;
        </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> (cur) {
            </span><span style="color: #0000ff;">if</span> (cur-&gt;<span style="color: #000000;">child) {
                Node </span>*next = cur-&gt;<span style="color: #000000;">next;
                Node </span>*last = cur-&gt;<span style="color: #000000;">child;
                </span><span style="color: #0000ff;">while</span> (last-&gt;next) last = last-&gt;<span style="color: #000000;">next;
                cur</span>-&gt;next = cur-&gt;<span style="color: #000000;">child;
                cur</span>-&gt;next-&gt;prev =<span style="color: #000000;"> cur;
                cur</span>-&gt;child =<span style="color: #000000;"> NULL;
                last</span>-&gt;next =<span style="color: #000000;"> next;
                </span><span style="color: #0000ff;">if</span> (next) next-&gt;prev =<span style="color: #000000;"> last;    
            }
            cur </span>= cur-&gt;<span style="color: #000000;">next;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> head;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4293853.html" target="_blank">Flatten Binary Tree to Linked List</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a href="http://www.cnblogs.com/grandyang/p/4606334.html" target="_blank">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-09-21 21:24</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=9688522" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(9688522);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/6006000.html" id="cb_post_title_url">[LeetCode] Word Squares 单词平方</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="row">
<div class="col-md-12">
<div class="row">
<div class="col-md-12">
<div class="question-content">
<p>Given a set of words (without duplicates), find all <a href="https://en.wikipedia.org/wiki/Word_square" target="_blank">word squares</a> you can build from them.</p>
<p>A sequence of words forms a valid word square if the <em>k</em>th row and column read the exact same string, where 0 ≤ <em>k</em> &lt; max(numRows, numColumns).</p>
<p>For example, the word sequence <code>["ball","area","lead","lady"]</code> forms a word square because each word reads the same both horizontally and vertically.</p>
<pre>b a l l
a r e a
l e a d
l a d y
</pre>
<p>Note:</p>
<ol>
<li>There are at least 1 and at most 1000 words.</li>
<li>All words will have the exact same length.</li>
<li>Word length is at least 1 and at most 5.</li>
<li>Each word contains only lowercase English alphabet <code>a-z</code>.</li>
</ol>
<p> </p>
<p>Example 1:</p>
<pre>Input:
["area","lead","wall","lady","ball"]

Output:
[
  [ "wall",
    "area",
    "lead",
    "lady"
  ],
  [ "ball",
    "area",
    "lead",
    "lady"
  ]
]

Explanation:
The output consists of two word squares. The order of output does not matter (just the order of words in each word square matters).
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input:
["abat","baba","atan","atal"]

Output:
[
  [ "baba",
    "abat",
    "baba",
    "atan"
  ],
  [ "baba",
    "abat",
    "baba",
    "atal"
  ]
]

Explanation:
The output consists of two word squares. The order of output does not matter (just the order of words in each word square matters).
</pre>
<p> </p>
<p>这道题是之前那道<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/5991673.html" id="homepage1_HomePageDays_DaysList_ctl03_DayList_TitleUrl_0">Valid Word Square</a>的延伸，由于要求出所有满足要求的单词平方，所以难度大大的增加了，不要幻想着可以利用之前那题的解法来暴力破解，OJ不会答应的。那么根据以往的经验，对于这种要打印出所有情况的题的解法大多都是用递归来解，那么这题的关键是根据前缀来找单词，我们如果能利用合适的数据结构来建立前缀跟单词之间的映射，使得我们能快速的通过前缀来判断某个单词是否存在，这是解题的关键。对于建立这种映射，这里主要有两种方法，一种是利用哈希表来建立前缀和所有包含此前缀单词的集合之前的映射，第二种方法是建立前缀树Trie，顾名思义，前缀树专门就是为这种问题设计的。那么我们首先来看第一种方法，用哈希表来建立映射的方法，我们就是取出每个单词的所有前缀，然后将该单词加入该前缀对应的集合中去，然后我们建立一个空的nxn的char矩阵，其中n为单词的长度，我们的目标就是来把这个矩阵填满，我们从0开始遍历，我们先取出长度为0的前缀，即空字符串，由于我们在建立映射的时候，空字符串也和每个单词的集合建立了映射，然后我们遍历这个集合，用遍历到的单词的i位置字符，填充矩阵mat[i][i]，然后j从i+1出开始遍历，对应填充矩阵mat[i][j]和mat[j][i]，然后我们根据第j行填充得到的前缀，到哈希表中查看有没单词，如果没有，就break掉，如果有，则继续填充下一个位置。最后如果j==n了，说明第0行和第0列都被填好了，我们再调用递归函数，开始填充第一行和第一列，依次类推，直至填充完成，参见代码如下：</p>
<div>
<div class="btn btn-xs btn-warning" id="company_tags"> </div>
</div>
</div>
</div>
</div>
</div>
</div>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;vector&lt;<span style="color: #0000ff;">string</span>&gt;&gt; wordSquares(vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp;<span style="color: #000000;"> words) {
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">string</span>&gt;&gt;<span style="color: #000000;"> res;
        unordered_map</span>&lt;<span style="color: #0000ff;">string</span>, <span style="color: #0000ff;">set</span>&lt;<span style="color: #0000ff;">string</span>&gt;&gt;<span style="color: #000000;"> m;
        </span><span style="color: #0000ff;">int</span> n = words[<span style="color: #800080;">0</span><span style="color: #000000;">].size();
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">string</span><span style="color: #000000;"> word : words) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
                </span><span style="color: #0000ff;">string</span> key = word.substr(<span style="color: #800080;">0</span><span style="color: #000000;">, i);
                m[key].insert(word);
            }
        }
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">char</span>&gt;&gt; mat(n, vector&lt;<span style="color: #0000ff;">char</span>&gt;<span style="color: #000000;">(n));
        helper(</span><span style="color: #800080;">0</span><span style="color: #000000;">, n, mat, m, res);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
      </span><span style="color: #0000ff;">void</span> helper(<span style="color: #0000ff;">int</span> i, <span style="color: #0000ff;">int</span> n, vector&lt;vector&lt;<span style="color: #0000ff;">char</span>&gt;&gt;&amp; mat, unordered_map&lt;<span style="color: #0000ff;">string</span>, <span style="color: #0000ff;">set</span>&lt;<span style="color: #0000ff;">string</span>&gt;&gt;&amp; m, vector&lt;vector&lt;<span style="color: #0000ff;">string</span>&gt;&gt;&amp;<span style="color: #000000;"> res) {
            </span><span style="color: #0000ff;">if</span> (i ==<span style="color: #000000;"> n) {
                vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; <span style="color: #0000ff;">out</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; n; ++j) <span style="color: #0000ff;">out</span>.push_back(<span style="color: #0000ff;">string</span><span style="color: #000000;">(mat[j].begin(), mat[j].end()));
                res.push_back(</span><span style="color: #0000ff;">out</span><span style="color: #000000;">);
                </span><span style="color: #0000ff;">return</span><span style="color: #000000;">;
            }
            </span><span style="color: #0000ff;">string</span> key = <span style="color: #0000ff;">string</span>(mat[i].begin(), mat[i].begin() +<span style="color: #000000;"> i);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">string</span><span style="color: #000000;"> str : m[key]) { 
            mat[i][i] </span>=<span style="color: #000000;"> str[i];
            </span><span style="color: #0000ff;">int</span> j = i + <span style="color: #800080;">1</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">for</span> (; j &lt; n; ++<span style="color: #000000;">j) {
                mat[i][j] </span>=<span style="color: #000000;"> str[j];
                mat[j][i] </span>=<span style="color: #000000;"> str[j];
                </span><span style="color: #0000ff;">if</span> (!m.count(<span style="color: #0000ff;">string</span>(mat[j].begin(), mat[j].begin() + i + <span style="color: #800080;">1</span>))) <span style="color: #0000ff;">break</span><span style="color: #000000;">;
            }
            </span><span style="color: #0000ff;">if</span> (j == n) helper(i + <span style="color: #800080;">1</span><span style="color: #000000;">, n, mat, m, res);
        }
    }
};</span></pre>
</div>
<p> </p>
<p>下面来看建立前缀树Trie的方法，这种方法的难点是看能不能熟练的写出Trie的定义，还有构建过程，以及后面在递归函数中，如果利用前缀树来快速查找单词的前缀，总之，这道题是前缀树的一种经典的应用，能白板写出来就说明基本上已经掌握了前缀树了，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">struct</span><span style="color: #000000;"> TrieNode {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> indexs;
        vector</span>&lt;TrieNode*&gt;<span style="color: #000000;"> children;
        TrieNode(): children(</span><span style="color: #800080;">26</span><span style="color: #000000;">, nullptr) {}
    };
    TrieNode</span>* buildTrie(vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp;<span style="color: #000000;"> words) {
        TrieNode </span>*root = <span style="color: #0000ff;">new</span><span style="color: #000000;"> TrieNode();
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; words.size(); ++<span style="color: #000000;">i) {
            TrieNode </span>*t =<span style="color: #000000;"> root;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; words[i].size(); ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> (!t-&gt;children[words[i][j] - <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span><span style="color: #000000;">]) {
                    t</span>-&gt;children[words[i][j] - <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span>] = <span style="color: #0000ff;">new</span><span style="color: #000000;"> TrieNode();
                }
                t </span>= t-&gt;children[words[i][j] - <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span><span style="color: #000000;">];
                t</span>-&gt;<span style="color: #000000;">indexs.push_back(i);
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> root;
    }
    vector</span>&lt;vector&lt;<span style="color: #0000ff;">string</span>&gt;&gt; wordSquares(vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp;<span style="color: #000000;"> words) {
        TrieNode </span>*root =<span style="color: #000000;"> buildTrie(words);
        vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; <span style="color: #0000ff;">out</span>(words[<span style="color: #800080;">0</span><span style="color: #000000;">].size());
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">string</span>&gt;&gt;<span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">string</span><span style="color: #000000;"> word : words) {
            </span><span style="color: #0000ff;">out</span>[<span style="color: #800080;">0</span>] =<span style="color: #000000;"> word;
            helper(words, </span><span style="color: #800080;">1</span>, root, <span style="color: #0000ff;">out</span><span style="color: #000000;">, res);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">void</span> helper(vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp; words, <span style="color: #0000ff;">int</span> level, TrieNode* root, vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp; <span style="color: #0000ff;">out</span>, vector&lt;vector&lt;<span style="color: #0000ff;">string</span>&gt;&gt;&amp;<span style="color: #000000;"> res) {
        </span><span style="color: #0000ff;">if</span> (level &gt;= words[<span style="color: #800080;">0</span><span style="color: #000000;">].size()) {
            res.push_back(</span><span style="color: #0000ff;">out</span><span style="color: #000000;">);
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">string</span> str = <span style="color: #800000;">""</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; level; ++<span style="color: #000000;">i) {
            str </span>+= <span style="color: #0000ff;">out</span><span style="color: #000000;">[i][level];
        }
        TrieNode </span>*t =<span style="color: #000000;"> root;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; str.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (!t-&gt;children[str[i] - <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span>]) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
            t </span>= t-&gt;children[str[i] - <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span><span style="color: #000000;">];
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> idx : t-&gt;<span style="color: #000000;">indexs) {
            </span><span style="color: #0000ff;">out</span>[level] =<span style="color: #000000;"> words[idx];
            helper(words, level </span>+ <span style="color: #800080;">1</span>, root, <span style="color: #0000ff;">out</span><span style="color: #000000;">, res);
        }
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/5991673.html" id="homepage1_HomePageDays_DaysList_ctl03_DayList_TitleUrl_0">Valid Word Square</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/63646/java-53ms-dfs-hashmap" target="_blank">https://discuss.leetcode.com/topic/63646/java-53ms-dfs-hashmap</a></p>
<p><a href="https://discuss.leetcode.com/topic/63390/70ms-concise-c-solution-using-trie-and-backtracking" target="_blank">https://discuss.leetcode.com/topic/63390/70ms-concise-c-solution-using-trie-and-backtracking</a></p>
<p><a href="https://discuss.leetcode.com/topic/63516/explained-my-java-solution-using-trie-126ms-16-16/2" target="_blank">https://discuss.leetcode.com/topic/63516/explained-my-java-solution-using-trie-126ms-16-16/2</a></p>
<p> </p>
<p><a href="http://www.cnblogs.com/grandyang/p/4606334.html" target="_blank">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-10-27 22:57</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=6006000" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(6006000);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/9672233.html" id="cb_post_title_url">[LeetCode] N-ary Tree Level Order Traversal N叉树层序遍历</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given an n-ary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).</p>
<p>For example, given a <code>3-ary</code> tree:</p>
<p> </p>
<p><img alt="" height="40%" src="https://leetcode.com/static/images/problemset/NaryTreeExample.png" width="40%"/></p>
<p> </p>
<p>We should return its level order traversal:</p>
<p> </p>
<p> </p>
<pre>[
     [1],
     [3,2,4],
     [5,6]
]
</pre>
<p> </p>
<p>Note:</p>
<ol>
<li>The depth of the tree is at most <code>1000</code>.</li>
<li>The total number of nodes is at most <code>5000</code>.</li>
</ol>
<p> </p>
<p>这道题给了我们一棵N叉树，让我们对其进行层序遍历。我们做过之前二叉树的层序遍历的那道题的话<a href="http://www.cnblogs.com/grandyang/p/4051321.html" target="_blank">Binary Tree Level Order Traversal</a>，那么这道题也就不难了。虽说现在每一个结点可能有很多个子结点，但其实处理的思路的都是一样的。子结点放到了一个children数组中，我们访问的时候只要遍历数组就行了。先来看迭代的写法，用到了队列queue来辅助，首先判断root是否为空，为空直接返回空数组，否则加入queue中。然后遍历queue，这里用的trick就是，要加个for循环，要将当前queue中的结点的个数统计下来，因为再加入下一层的结点时，queue的结点个数会增加，而在加入下一层结点之前，当前queue中的结点个数全都属于一层，所以我们要把层与层区分开来，将同一层的结点都放到一个数组out中，之后再放入结果res中，这种层序遍历的思想在迷宫遍历找最短路径的时候应用的也很多，是个必须要掌握的方法呢，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; levelOrder(Node*<span style="color: #000000;"> root) {
        </span><span style="color: #0000ff;">if</span> (!root) <span style="color: #0000ff;">return</span><span style="color: #000000;"> {};
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;<span style="color: #000000;"> res;
        queue</span>&lt;Node*&gt;<span style="color: #000000;"> q{{root}};
        </span><span style="color: #0000ff;">while</span> (!<span style="color: #000000;">q.empty()) {
            vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; <span style="color: #0000ff;">out</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = q.size(); i &gt; <span style="color: #800080;">0</span>; --<span style="color: #000000;">i) {
                auto t </span>=<span style="color: #000000;"> q.front(); q.pop();
                </span><span style="color: #0000ff;">out</span>.push_back(t-&gt;<span style="color: #000000;">val);
                </span><span style="color: #0000ff;">if</span> (!t-&gt;<span style="color: #000000;">children.empty()) {
                    </span><span style="color: #0000ff;">for</span> (auto a : t-&gt;<span style="color: #000000;">children) q.push(a);
                }
            }
            res.push_back(</span><span style="color: #0000ff;">out</span><span style="color: #000000;">);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>下面再来看递归的写法，其实层序遍历天然适合迭代的写法，但我们强行递归也是可以的，就是有点秀。由于递归DFS的设定是一条路走到黑再返回，那么必然会跨越不同的层数，所以为了区别当前的层，我们需要一个变量level来标记当前的层数，根结点root就是第0层，依此类推往上加。然后还有个trick就是关于结果res的大小，由于我们并不知道树的深度，所以一旦我们遍历的层数超过了当前res的大小，我们需要resize一下，这样才不会出错。之后，我们将当前遍历到的结点加到res中的第level层中，然后遍历子结点数组，对每一个子结点调用递归函数即可，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; levelOrder(Node*<span style="color: #000000;"> root) {
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;<span style="color: #000000;"> res;
        helper(root, </span><span style="color: #800080;">0</span><span style="color: #000000;">, res);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">void</span> helper(Node* node, <span style="color: #0000ff;">int</span> level, vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> res) {
        </span><span style="color: #0000ff;">if</span> (!node) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (res.size() &lt;= level) res.resize(res.size() + <span style="color: #800080;">1</span><span style="color: #000000;">);
        res[level].push_back(node</span>-&gt;<span style="color: #000000;">val);
        </span><span style="color: #0000ff;">for</span> (auto a : node-&gt;<span style="color: #000000;">children) {
            helper(a, level </span>+ <span style="color: #800080;">1</span><span style="color: #000000;">, res);
        }
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4051321.html" target="_blank">Binary Tree Level Order Traversal</a></p>
<p>N-ary Tree Preorder Traversal</p>
<p>N-ary Tree Postorder Traversal</p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a href="http://www.cnblogs.com/grandyang/p/4606334.html" target="_blank">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-09-18 23:59</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=9672233" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(9672233);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/9649348.html" id="cb_post_title_url">[LeetCode] Construct Quad Tree 建立四叉树</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>We want to use quad trees to store an <code>N x N</code> boolean grid. Each cell in the grid can only be true or false. The root node represents the whole grid. For each node, it will be subdivided into four children nodes until the values in the region it represents are all the same.</p>
<p>Each node has another two boolean attributes : <code>isLeaf</code> and <code>val</code>. <code>isLeaf</code> is true if and only if the node is a leaf node. The <code>val</code> attribute for a leaf node contains the value of the region it represents.</p>
<p>Your task is to use a quad tree to represent a given grid. The following example may help you understand the problem better:</p>
<p>Given the <code>8 x 8</code> grid below, we want to construct the corresponding quad tree:</p>
<p><img alt="" height="200" src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/02/01/962_grid.png" width="199"/></p>
<p>It can be divided according to the definition above:</p>
<p><img alt="" height="199" src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/02/01/962_grid_divided.png" width="734"/></p>
<p> </p>
<p>The corresponding quad tree should be as following, where each node is represented as a <code>(isLeaf, val)</code>pair.</p>
<p>For the non-leaf nodes, <code>val</code> can be arbitrary, so it is represented as <code>*</code>.</p>
<p><img alt="" height="267" src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/02/01/962_quad_tree.png" width="745"/></p>
<p>Note:</p>
<ol>
<li><code>N</code> is less than <code>1000</code> and guaranteened to be a power of 2.</li>
<li>If you want to know more about the quad tree, you can refer to its <a href="https://en.wikipedia.org/wiki/Quadtree">wiki</a>.</li>
</ol>
<p> </p>
<p>这道题让我们根据一个二维数组来建立一棵四叉树，关于四叉树的介绍题目中也了给了<a href="https://zh.wikipedia.org/wiki/%E5%9B%9B%E5%8F%89%E6%A0%91" target="_blank">wiki百科的链接</a>。但是博主开始看到题目中给的那个例子，没怎么看懂。后来分析大神们的代码，才略微弄明白了一些。原来叶结点表示的是值相同的一片区域，比如我们看二维数组图示那行的第三个图，首先整个数组被分成了四等份，左上，左下，和右下部分内的值均相同，那么他们都是一个叶结点，而右上只有再四等分一下，才能使各自部分内的值相同，所以其就不是叶结点，而四等分后的每个区间才是叶结点。题目中限定了N的值一定是2的指数，就是说其如果可分的话，一定可以四等分，而之前说了，只有区间内的值不同时，才需要四等分，否则整体就当作一个叶结点。所以我们需要check四等分区间内的值是否相同，当然，我们可以将二维数组拆分为四个二维数组，但是那样可能不太高效，而且还占用额外空间，一个比较好的选择是用坐标变量来控制等分数组的范围，我们只需要一个起始点坐标，和区间的长度，就可以精确定位一个区间了。比如说对于例子中的整个二维数组数组来说，知道起始点坐标 (0, 0)，还有长度8，就知道表示的是哪个区间。我们可以遍历这个区间上的其他所有的点，跟起点对比，只要有任何点跟起点不相同，则说明该区间是可分的，因为我们前面说了，只有一个区间上所有的值均相同，才能当作一个叶结点。只要有不同，就表示可以四分，那么我们就新建一个结点，这里的左上，左下，右上，和右下四个子结点就需要用过调用递归函数来实现了，实现原理都一样，重要的地方就是确定每个四分区间的起点和长度，长度好确定，都是当前长度的一半，然后就是把各个区间的起点确定好，这个也不难，就是细心一点，不要写错了就可以了，另外，对于非叶结点，结点值可以是true或者false都没问题。如果某个区间上所有值均相同，那么就生成一个叶结点，结点值就跟区间值相同，isLeaf是true，四个子结点均为NULL即可，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    Node</span>* construct(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> grid) {
        </span><span style="color: #0000ff;">return</span> build(grid, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span><span style="color: #000000;">, grid.size());
    }
    Node</span>* build(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp; grid, <span style="color: #0000ff;">int</span> x, <span style="color: #0000ff;">int</span> y, <span style="color: #0000ff;">int</span><span style="color: #000000;"> len) {
        </span><span style="color: #0000ff;">if</span> (len &lt;= <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;"> NULL;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = x; i &lt; x + len; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = y; j &lt; y + len; ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> (grid[i][j] !=<span style="color: #000000;"> grid[x][y]) {
                    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span> Node(<span style="color: #0000ff;">true</span>, <span style="color: #0000ff;">false</span><span style="color: #000000;">,
                           build(grid, x, y, len </span>/ <span style="color: #800080;">2</span><span style="color: #000000;">),
                           build(grid, x, y </span>+ len / <span style="color: #800080;">2</span>, len / <span style="color: #800080;">2</span><span style="color: #000000;">),
                           build(grid, x </span>+ len/ <span style="color: #800080;">2</span>, y, len / <span style="color: #800080;">2</span><span style="color: #000000;">),
                           build(grid, x </span>+ len / <span style="color: #800080;">2</span>, y + len / <span style="color: #800080;">2</span>, len / <span style="color: #800080;">2</span><span style="color: #000000;">));
                }
            }
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span> Node(grid[x][y] == <span style="color: #800080;">1</span>, <span style="color: #0000ff;">true</span><span style="color: #000000;">, NULL, NULL, NULL, NULL);
    }
};</span></pre>
</div>
<p> </p>
<p>还有一种写法，记录了区间的左上点和右下点，知道这两个点也可以确定一个区间的位置，整体思路和上面的方法并没有什么太大的区别，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    Node</span>* construct(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> grid) {
        </span><span style="color: #0000ff;">return</span> build(grid, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, grid.size() - <span style="color: #800080;">1</span>, grid.size() - <span style="color: #800080;">1</span><span style="color: #000000;">);
    }
    Node</span>* build(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp; grid, <span style="color: #0000ff;">int</span> r1, <span style="color: #0000ff;">int</span> c1, <span style="color: #0000ff;">int</span> r2, <span style="color: #0000ff;">int</span><span style="color: #000000;"> c2) {
        </span><span style="color: #0000ff;">if</span> (r1 &gt; r2 || c1 &gt; c2) <span style="color: #0000ff;">return</span><span style="color: #000000;"> NULL;
        </span><span style="color: #0000ff;">bool</span> isLeaf = <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> val = grid[r1][c1], rowMid = (r1 + r2) / <span style="color: #800080;">2</span>, colMid = (c1 + c2) / <span style="color: #800080;">2</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = r1; i &lt;= r2; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = c1; j &lt;= c2; ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> (grid[i][j] !=<span style="color: #000000;"> val) {
                    isLeaf </span>= <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                }
            }
        }
        </span><span style="color: #0000ff;">if</span> (isLeaf) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span> Node(val == <span style="color: #800080;">1</span>, <span style="color: #0000ff;">true</span><span style="color: #000000;">, NULL, NULL, NULL, NULL);
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span> Node(<span style="color: #0000ff;">false</span>, <span style="color: #0000ff;">false</span><span style="color: #000000;">, 
               build(grid, r1, c1, rowMid, colMid),
               build(grid, r1, colMid </span>+ <span style="color: #800080;">1</span><span style="color: #000000;">, rowMid, c2),
               build(grid, rowMid </span>+ <span style="color: #800080;">1</span><span style="color: #000000;">, c1, r2, colMid),
               build(grid, rowMid </span>+ <span style="color: #800080;">1</span>, colMid + <span style="color: #800080;">1</span><span style="color: #000000;">, r2, c2));
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a href="http://www.cnblogs.com/grandyang/p/4606334.html" target="_blank">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-09-14 22:46</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=9649348" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(9649348);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/9615871.html" id="cb_post_title_url">[LeetCode] Convert Binary Search Tree to Sorted Doubly Linked List 将二叉搜索树转为有序双向链表</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="question-description__3U1T">
<p>Convert a BST to a sorted circular doubly-linked list in-place. Think of the left and right pointers as synonymous to the previous and next pointers in a doubly-linked list.</p>
<p>Let's take the following BST as an example, it may help you understand the problem better:</p>
 
<p><img alt="" height="30%" src="https://leetcode.com/static/images/problemset/BSTDLLOriginalBST.png" width="30%"/></p>
 
<p>We want to transform this BST into a circular doubly linked list. Each node in a doubly linked list has a predecessor and successor. For a circular doubly linked list, the predecessor of the first element is the last element, and the successor of the last element is the first element.</p>
<p>The figure below shows the circular doubly linked list for the BST above. The "head" symbol means the node it points to is the smallest element of the linked list.</p>
 
<p><img alt="" height="40%" src="https://leetcode.com/static/images/problemset/BSTDLLReturnDLL.png" width="40%"/></p>
 
<p>Specifically, we want to do the transformation in place. After the transformation, the left pointer of the tree node should point to its predecessor, and the right pointer should point to its successor. We should return the pointer to the first element of the linked list.</p>
<p>The figure below shows the transformed BST. The solid line indicates the successor relationship, while the dashed line means the predecessor relationship.</p>
 
<p><img alt="" height="30%" src="https://leetcode.com/static/images/problemset/BSTDLLReturnBST.png" width="30%"/></p>
<p> </p>
</div>
<p>这道题给了我们一个二叉搜索树，让我们将其转化为双向链表。并且题目中给了我们一个带图的例子，帮助我们来理解。题目本身并不难理解，我们需要仔细观察下给的示例图。首先，转化成双向链表的每个结点都有left和right指针指向左右两个结点，不管其原来是否是叶结点还是根结点，转换后统统没有区别。其次，我们发现这是个循环双向链表，即首尾结点是相连的，原先的二叉搜索树中的最左结点和最右结点，现在也互相连接起来了。最后，我们发现返回的结点不再是原二叉搜索树的根结点root了，而是最左结点，即最小值结点。</p>
<p>好，发现了上述规律后，我们来考虑如何破题。根据博主多年经验，跟二叉搜索树有关的题，肯定要利用其性质，即左&lt;根&lt;右，即左子结点值小于根结点值小于右子结点值。而且十有八九都得用中序遍历来解，因为中序遍历的顺序就是左根右啊，跟性质吻合。我们观察原二叉搜索树中结点4连接着结点2和结点5，而在双向链表中，连接的是结点3和结点5，这就是为啥我们要用中序遍历了，因为只有中序遍历，结点3之后才会遍历到结点4，这时候我们可以将结点3和结点4串起来。决定了用中序遍历之后，就要考虑是迭代还是递归的写法，博主建议写递归的，一般写起来都比较简洁，而且递归是解树类问题的神器啊，十有八九都是用递归，一定要熟练掌握。再写中序遍历之前，其实还有难点，因为我们需要把相邻的结点连接起来，所以我们需要知道上一个遍历到的结点是什么，所以用一个变量pre，来记录上一个遍历到的结点。还需要一个变量head，来记录最左结点，这样的话，在递归函数中，先判空，之后对左子结点调用递归，这样会先一直递归到最左结点，此时如果head为空的话，说明当前就是最左结点，赋值给head和pre，对于之后的遍历到的结点，那么可以和pre相互连接上，然后pre赋值为当前结点node，再对右子结点调用递归即可，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    Node</span>* treeToDoublyList(Node*<span style="color: #000000;"> root) {
        </span><span style="color: #0000ff;">if</span> (!root) <span style="color: #0000ff;">return</span><span style="color: #000000;"> NULL;
        Node </span>*head = NULL, *pre =<span style="color: #000000;"> NULL;
        inorder(root, pre, head);
        pre</span>-&gt;right =<span style="color: #000000;"> head;
        head</span>-&gt;left =<span style="color: #000000;"> pre;
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> head;
    }
    </span><span style="color: #0000ff;">void</span> inorder(Node* node, Node*&amp; pre, Node*&amp;<span style="color: #000000;"> head) {
        </span><span style="color: #0000ff;">if</span> (!node) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
        inorder(node</span>-&gt;<span style="color: #000000;">left, pre, head);
        </span><span style="color: #0000ff;">if</span> (!<span style="color: #000000;">head) {
            head </span>=<span style="color: #000000;"> node;
            pre </span>=<span style="color: #000000;"> node;
        } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            pre</span>-&gt;right =<span style="color: #000000;"> node;
            node</span>-&gt;left =<span style="color: #000000;"> pre;
            pre </span>=<span style="color: #000000;"> node;
        }
        inorder(node</span>-&gt;<span style="color: #000000;">right, pre, head);
    }
};</span></pre>
</div>
<p> </p>
<p>虽然说树类问题首推递归解法，但是中序遍历是可以用迭代来写的，可以参见博主之前的博客<a href="http://www.cnblogs.com/grandyang/p/4297300.html" target="_blank">Binary Tree Inorder Traversal</a>。迭代写法借用了栈，其实整体思路和递归解法没有太大的区别，递归的本质也是将断点存入栈中，以便之后可以返回，这里就不多讲解了，可以参见上面的讲解，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    Node</span>* treeToDoublyList(Node*<span style="color: #000000;"> root) {
        </span><span style="color: #0000ff;">if</span> (!root) <span style="color: #0000ff;">return</span><span style="color: #000000;"> NULL;
        Node </span>*head = NULL, *pre =<span style="color: #000000;"> NULL;
        stack</span>&lt;Node*&gt;<span style="color: #000000;"> st;
        </span><span style="color: #0000ff;">while</span> (root || !<span style="color: #000000;">st.empty()) {
            </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> (root) {
                st.push(root);
                root </span>= root-&gt;<span style="color: #000000;">left;
            }
            root </span>=<span style="color: #000000;"> st.top(); st.pop();
            </span><span style="color: #0000ff;">if</span> (!head) head =<span style="color: #000000;"> root;
            </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (pre) {
                pre</span>-&gt;right =<span style="color: #000000;"> root;
                root</span>-&gt;left =<span style="color: #000000;"> pre;
            }
            pre </span>=<span style="color: #000000;"> root;
            root </span>= root-&gt;<span style="color: #000000;">right;
        }
        head</span>-&gt;left =<span style="color: #000000;"> pre;
        pre</span>-&gt;right =<span style="color: #000000;"> head;
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> head;
    }
};</span></pre>
</div>
<p> </p>
<p>这道题还有一种使用分治法Divide and Conquer来做的方法。分治法，顾名思义，就是把一项任务分成两半，用相同的逻辑去分别处理，之后再粘合起来。混合排序Merge Sort用的也是这种思路。那么我们可以对左右子结点调用递归函数，suppose我们得到了两个各自循环的有序双向链表，然后我们把根结点跟左右子结点断开，将其左右指针均指向自己，这样就形成了一个单个结点的有序双向链表，虽然只是个光杆司令，但人家仍然是有序双向链表，不是沙雕，就问你叼不叼。那么此时我们只要再写一个连接两个有序双向链表的子函数，就可以将这三个有序双向链表按顺序链接起来了。</p>
<p>而链接两个有序双向链表的子函数也简单，首先判空，若一个为空，则返回另一个。如果两个都不为空，则把第一个链表的尾结点的右指针链上第二个链表的首结点，同时第二个链表的首结点的左指针链上第一个链表的尾结点。同理，把第二个链表的尾结点的右指针链上第一个链表的首结点，同时第一个链表的首结点的左指针链上第二个链表的尾结点。有木有读晕，可以自己画图，其实很好理解的诶，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    Node</span>* treeToDoublyList(Node*<span style="color: #000000;"> root) {
        </span><span style="color: #0000ff;">if</span> (!root) <span style="color: #0000ff;">return</span><span style="color: #000000;"> NULL;
        Node </span>*leftHead = treeToDoublyList(root-&gt;<span style="color: #000000;">left);
        Node </span>*rightHead = treeToDoublyList(root-&gt;<span style="color: #000000;">right);
        root</span>-&gt;left =<span style="color: #000000;"> root;
        root</span>-&gt;right =<span style="color: #000000;"> root;
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> connect(connect(leftHead, root), rightHead);
    }
    Node</span>* connect(Node* node1, Node*<span style="color: #000000;"> node2) {
        </span><span style="color: #0000ff;">if</span> (!node1) <span style="color: #0000ff;">return</span><span style="color: #000000;"> node2;
        </span><span style="color: #0000ff;">if</span> (!node2) <span style="color: #0000ff;">return</span><span style="color: #000000;"> node1;
        Node </span>*tail1 = node1-&gt;left, *tail2 = node2-&gt;<span style="color: #000000;">left;
        tail1</span>-&gt;right =<span style="color: #000000;"> node2;
        node2</span>-&gt;left =<span style="color: #000000;"> tail1;
        tail2</span>-&gt;right =<span style="color: #000000;"> node1;
        node1</span>-&gt;left =<span style="color: #000000;"> tail2;
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> node1;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4297300.html" target="_blank">Binary Tree Inorder Traversal</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a href="http://www.cnblogs.com/grandyang/p/4606334.html" target="_blank">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-09-09 23:34</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=9615871" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(9615871);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/6006000.html" id="cb_post_title_url">[LeetCode] Word Squares 单词平方</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="row">
<div class="col-md-12">
<div class="row">
<div class="col-md-12">
<div class="question-content">
<p>Given a set of words (without duplicates), find all <a href="https://en.wikipedia.org/wiki/Word_square" target="_blank">word squares</a> you can build from them.</p>
<p>A sequence of words forms a valid word square if the <em>k</em>th row and column read the exact same string, where 0 ≤ <em>k</em> &lt; max(numRows, numColumns).</p>
<p>For example, the word sequence <code>["ball","area","lead","lady"]</code> forms a word square because each word reads the same both horizontally and vertically.</p>
<pre>b a l l
a r e a
l e a d
l a d y
</pre>
<p>Note:</p>
<ol>
<li>There are at least 1 and at most 1000 words.</li>
<li>All words will have the exact same length.</li>
<li>Word length is at least 1 and at most 5.</li>
<li>Each word contains only lowercase English alphabet <code>a-z</code>.</li>
</ol>
<p> </p>
<p>Example 1:</p>
<pre>Input:
["area","lead","wall","lady","ball"]

Output:
[
  [ "wall",
    "area",
    "lead",
    "lady"
  ],
  [ "ball",
    "area",
    "lead",
    "lady"
  ]
]

Explanation:
The output consists of two word squares. The order of output does not matter (just the order of words in each word square matters).
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input:
["abat","baba","atan","atal"]

Output:
[
  [ "baba",
    "abat",
    "baba",
    "atan"
  ],
  [ "baba",
    "abat",
    "baba",
    "atal"
  ]
]

Explanation:
The output consists of two word squares. The order of output does not matter (just the order of words in each word square matters).
</pre>
<p> </p>
<p>这道题是之前那道<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/5991673.html" id="homepage1_HomePageDays_DaysList_ctl03_DayList_TitleUrl_0">Valid Word Square</a>的延伸，由于要求出所有满足要求的单词平方，所以难度大大的增加了，不要幻想着可以利用之前那题的解法来暴力破解，OJ不会答应的。那么根据以往的经验，对于这种要打印出所有情况的题的解法大多都是用递归来解，那么这题的关键是根据前缀来找单词，我们如果能利用合适的数据结构来建立前缀跟单词之间的映射，使得我们能快速的通过前缀来判断某个单词是否存在，这是解题的关键。对于建立这种映射，这里主要有两种方法，一种是利用哈希表来建立前缀和所有包含此前缀单词的集合之前的映射，第二种方法是建立前缀树Trie，顾名思义，前缀树专门就是为这种问题设计的。那么我们首先来看第一种方法，用哈希表来建立映射的方法，我们就是取出每个单词的所有前缀，然后将该单词加入该前缀对应的集合中去，然后我们建立一个空的nxn的char矩阵，其中n为单词的长度，我们的目标就是来把这个矩阵填满，我们从0开始遍历，我们先取出长度为0的前缀，即空字符串，由于我们在建立映射的时候，空字符串也和每个单词的集合建立了映射，然后我们遍历这个集合，用遍历到的单词的i位置字符，填充矩阵mat[i][i]，然后j从i+1出开始遍历，对应填充矩阵mat[i][j]和mat[j][i]，然后我们根据第j行填充得到的前缀，到哈希表中查看有没单词，如果没有，就break掉，如果有，则继续填充下一个位置。最后如果j==n了，说明第0行和第0列都被填好了，我们再调用递归函数，开始填充第一行和第一列，依次类推，直至填充完成，参见代码如下：</p>
<div>
<div class="btn btn-xs btn-warning" id="company_tags"> </div>
</div>
</div>
</div>
</div>
</div>
</div>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;vector&lt;<span style="color: #0000ff;">string</span>&gt;&gt; wordSquares(vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp;<span style="color: #000000;"> words) {
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">string</span>&gt;&gt;<span style="color: #000000;"> res;
        unordered_map</span>&lt;<span style="color: #0000ff;">string</span>, <span style="color: #0000ff;">set</span>&lt;<span style="color: #0000ff;">string</span>&gt;&gt;<span style="color: #000000;"> m;
        </span><span style="color: #0000ff;">int</span> n = words[<span style="color: #800080;">0</span><span style="color: #000000;">].size();
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">string</span><span style="color: #000000;"> word : words) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
                </span><span style="color: #0000ff;">string</span> key = word.substr(<span style="color: #800080;">0</span><span style="color: #000000;">, i);
                m[key].insert(word);
            }
        }
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">char</span>&gt;&gt; mat(n, vector&lt;<span style="color: #0000ff;">char</span>&gt;<span style="color: #000000;">(n));
        helper(</span><span style="color: #800080;">0</span><span style="color: #000000;">, n, mat, m, res);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
      </span><span style="color: #0000ff;">void</span> helper(<span style="color: #0000ff;">int</span> i, <span style="color: #0000ff;">int</span> n, vector&lt;vector&lt;<span style="color: #0000ff;">char</span>&gt;&gt;&amp; mat, unordered_map&lt;<span style="color: #0000ff;">string</span>, <span style="color: #0000ff;">set</span>&lt;<span style="color: #0000ff;">string</span>&gt;&gt;&amp; m, vector&lt;vector&lt;<span style="color: #0000ff;">string</span>&gt;&gt;&amp;<span style="color: #000000;"> res) {
            </span><span style="color: #0000ff;">if</span> (i ==<span style="color: #000000;"> n) {
                vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; <span style="color: #0000ff;">out</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; n; ++j) <span style="color: #0000ff;">out</span>.push_back(<span style="color: #0000ff;">string</span><span style="color: #000000;">(mat[j].begin(), mat[j].end()));
                res.push_back(</span><span style="color: #0000ff;">out</span><span style="color: #000000;">);
                </span><span style="color: #0000ff;">return</span><span style="color: #000000;">;
            }
            </span><span style="color: #0000ff;">string</span> key = <span style="color: #0000ff;">string</span>(mat[i].begin(), mat[i].begin() +<span style="color: #000000;"> i);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">string</span><span style="color: #000000;"> str : m[key]) { 
            mat[i][i] </span>=<span style="color: #000000;"> str[i];
            </span><span style="color: #0000ff;">int</span> j = i + <span style="color: #800080;">1</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">for</span> (; j &lt; n; ++<span style="color: #000000;">j) {
                mat[i][j] </span>=<span style="color: #000000;"> str[j];
                mat[j][i] </span>=<span style="color: #000000;"> str[j];
                </span><span style="color: #0000ff;">if</span> (!m.count(<span style="color: #0000ff;">string</span>(mat[j].begin(), mat[j].begin() + i + <span style="color: #800080;">1</span>))) <span style="color: #0000ff;">break</span><span style="color: #000000;">;
            }
            </span><span style="color: #0000ff;">if</span> (j == n) helper(i + <span style="color: #800080;">1</span><span style="color: #000000;">, n, mat, m, res);
        }
    }
};</span></pre>
</div>
<p> </p>
<p>下面来看建立前缀树Trie的方法，这种方法的难点是看能不能熟练的写出Trie的定义，还有构建过程，以及后面在递归函数中，如果利用前缀树来快速查找单词的前缀，总之，这道题是前缀树的一种经典的应用，能白板写出来就说明基本上已经掌握了前缀树了，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">struct</span><span style="color: #000000;"> TrieNode {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> indexs;
        vector</span>&lt;TrieNode*&gt;<span style="color: #000000;"> children;
        TrieNode(): children(</span><span style="color: #800080;">26</span><span style="color: #000000;">, nullptr) {}
    };
    TrieNode</span>* buildTrie(vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp;<span style="color: #000000;"> words) {
        TrieNode </span>*root = <span style="color: #0000ff;">new</span><span style="color: #000000;"> TrieNode();
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; words.size(); ++<span style="color: #000000;">i) {
            TrieNode </span>*t =<span style="color: #000000;"> root;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; words[i].size(); ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> (!t-&gt;children[words[i][j] - <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span><span style="color: #000000;">]) {
                    t</span>-&gt;children[words[i][j] - <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span>] = <span style="color: #0000ff;">new</span><span style="color: #000000;"> TrieNode();
                }
                t </span>= t-&gt;children[words[i][j] - <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span><span style="color: #000000;">];
                t</span>-&gt;<span style="color: #000000;">indexs.push_back(i);
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> root;
    }
    vector</span>&lt;vector&lt;<span style="color: #0000ff;">string</span>&gt;&gt; wordSquares(vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp;<span style="color: #000000;"> words) {
        TrieNode </span>*root =<span style="color: #000000;"> buildTrie(words);
        vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; <span style="color: #0000ff;">out</span>(words[<span style="color: #800080;">0</span><span style="color: #000000;">].size());
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">string</span>&gt;&gt;<span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">string</span><span style="color: #000000;"> word : words) {
            </span><span style="color: #0000ff;">out</span>[<span style="color: #800080;">0</span>] =<span style="color: #000000;"> word;
            helper(words, </span><span style="color: #800080;">1</span>, root, <span style="color: #0000ff;">out</span><span style="color: #000000;">, res);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">void</span> helper(vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp; words, <span style="color: #0000ff;">int</span> level, TrieNode* root, vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp; <span style="color: #0000ff;">out</span>, vector&lt;vector&lt;<span style="color: #0000ff;">string</span>&gt;&gt;&amp;<span style="color: #000000;"> res) {
        </span><span style="color: #0000ff;">if</span> (level &gt;= words[<span style="color: #800080;">0</span><span style="color: #000000;">].size()) {
            res.push_back(</span><span style="color: #0000ff;">out</span><span style="color: #000000;">);
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">string</span> str = <span style="color: #800000;">""</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; level; ++<span style="color: #000000;">i) {
            str </span>+= <span style="color: #0000ff;">out</span><span style="color: #000000;">[i][level];
        }
        TrieNode </span>*t =<span style="color: #000000;"> root;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; str.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (!t-&gt;children[str[i] - <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span>]) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
            t </span>= t-&gt;children[str[i] - <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span><span style="color: #000000;">];
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> idx : t-&gt;<span style="color: #000000;">indexs) {
            </span><span style="color: #0000ff;">out</span>[level] =<span style="color: #000000;"> words[idx];
            helper(words, level </span>+ <span style="color: #800080;">1</span>, root, <span style="color: #0000ff;">out</span><span style="color: #000000;">, res);
        }
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/5991673.html" id="homepage1_HomePageDays_DaysList_ctl03_DayList_TitleUrl_0">Valid Word Square</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/63646/java-53ms-dfs-hashmap" target="_blank">https://discuss.leetcode.com/topic/63646/java-53ms-dfs-hashmap</a></p>
<p><a href="https://discuss.leetcode.com/topic/63390/70ms-concise-c-solution-using-trie-and-backtracking" target="_blank">https://discuss.leetcode.com/topic/63390/70ms-concise-c-solution-using-trie-and-backtracking</a></p>
<p><a href="https://discuss.leetcode.com/topic/63516/explained-my-java-solution-using-trie-126ms-16-16/2" target="_blank">https://discuss.leetcode.com/topic/63516/explained-my-java-solution-using-trie-126ms-16-16/2</a></p>
<p> </p>
<p><a href="http://www.cnblogs.com/grandyang/p/4606334.html" target="_blank">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-10-27 22:57</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=6006000" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(6006000);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5999050.html" id="cb_post_title_url">[LeetCode] Longest Repeating Character Replacement 最长重复字符置换</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a string that consists of only uppercase English letters, you can replace any letter in the string with another letter at most <em>k</em> times. Find the length of a longest substring containing all repeating letters you can get after performing the above operations.</p>
<p><strong>Note:</strong><br/>
Both the string's length and <em>k</em> will not exceed 10<sup>4</sup>.
</p>
<p>
<strong>Example 1:</strong>
</p>
<pre><strong>Input:</strong>
s = "ABAB", k = 2

<strong>Output:</strong>
4

<strong>Explanation:</strong>
Replace the two 'A's with two 'B's or vice versa.
</pre>
<p><strong>Example 2:</strong></p>
<pre><strong>Input:</strong>
s = "AABABBA", k = 1

<strong>Output:</strong>
4

<strong>Explanation:</strong>
Replace the one 'A' in the middle with 'B' and form "AABBBBA".
The substring "BBBB" has the longest repeating letters, which is 4.
</pre>
<p> </p>
<p>这道题给我们了一个字符串，说我们有k次随意置换任意字符的机会，让我们找出最长的重复字符的字符串。这道题跟之前那道<a href="http://www.cnblogs.com/grandyang/p/5351347.html" target="_blank">Longest Substring with At Most K Distinct Characters</a>很像，都需要用滑动窗口Sliding Window来解。我们首先来想，如果没有k的限制，让我们求把字符串变成只有一个字符重复的字符串需要的最小置换次数，那么就是字符串的总长度减去出现次数最多的字符的个数。如果加上k的限制，我们其实就是求满足(子字符串的长度减去出现次数最多的字符个数)&lt;=k的最大子字符串长度即可，搞清了这一点，我们也就应该知道怎么用滑动窗口来解了吧我们用一个变量start记录滑动窗口左边界，初始化为0，然后我们遍历字符串，每次累加出现字符的个数，然后更新出现最多字符的个数，然后我们判断当前滑动窗口是否满足之前说的那个条件，如果不满足，我们就把滑动窗口左边界向右移动一个，并注意去掉的字符要在counts里减一，直到满足条件，我们更新结果res即可，参见代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> characterReplacement(<span style="color: #0000ff;">string</span> s, <span style="color: #0000ff;">int</span><span style="color: #000000;"> k) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, maxCnt = <span style="color: #800080;">0</span>, start = <span style="color: #800080;">0</span><span style="color: #000000;">;
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; counts(<span style="color: #800080;">26</span>, <span style="color: #800080;">0</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; s.size(); ++<span style="color: #000000;">i) {
            maxCnt </span>= max(maxCnt, ++counts[s[i] - <span style="color: #800000;">'</span><span style="color: #800000;">A</span><span style="color: #800000;">'</span><span style="color: #000000;">]);
            </span><span style="color: #0000ff;">while</span> (i - start + <span style="color: #800080;">1</span> - maxCnt &gt;<span style="color: #000000;"> k) {
                </span>--counts[s[start] - <span style="color: #800000;">'</span><span style="color: #800000;">A</span><span style="color: #800000;">'</span><span style="color: #000000;">];
                </span>++<span style="color: #000000;">start;
            }
            res </span>= max(res, i - start + <span style="color: #800080;">1</span><span style="color: #000000;">);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/5852352.html">Longest Substring with At Least K Repeating Characters</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/5351347.html" target="_blank">Longest Substring with At Most K Distinct Characters</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/5185561.html" target="_blank">Longest Substring with At Most Two Distinct Characters</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4480780.html" target="_blank">Longest Substring Without Repeating Characters</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/63494/java-12-lines-o-n-sliding-window-solution-with-explanation/2" target="_blank">https://discuss.leetcode.com/topic/63494/java-12-lines-o-n-sliding-window-solution-with-explanation/2</a></p>
<p><a href="https://discuss.leetcode.com/topic/63416/sliding-window-similar-to-finding-longest-substring-with-k-distinct-characters/2" target="_blank">https://discuss.leetcode.com/topic/63416/sliding-window-similar-to-finding-longest-substring-with-k-distinct-characters/2</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-10-26 09:06</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5999050" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5999050);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5996239.html" id="cb_post_title_url">[LeetCode] Reconstruct Original Digits from English 从英文中重建数字</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a non-empty string containing an out-of-order English representation of digits <code>0-9</code>, output the digits in ascending order.</p>
<p>Note:</p>
<ol>
<li>Input contains only lowercase English letters.</li>
<li>Input is guaranteed to be valid and can be transformed to its original digits. That means invalid inputs such as "abc" or "zerone" are not permitted.</li>
<li>Input length is less than 50,000.</li>
</ol>
<p> </p>
<p>Example 1:</p>
<pre>Input: "owoztneoer"

Output: "012"
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input: "fviefuro"

Output: "45"</pre>
<p> </p>
<p>这道题给了我们一串英文字符串，是由表示数字的英文单词组成的，不过字符顺序是打乱的，让我们重建出数字。那么这道题的思路是先要统计出各个字符出现的次数，然后算出每个单词出现的次数，然后就可以重建了。由于题目中限定了输入的字符串一定是有效的，那么不会出现无法成功重建的情况，这里需要用个trick。我们仔细观察这些表示数字的单词"zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"，我们可以发现有些的单词的字符是独一无二的，比如z，只出现在zero中，还有w，u，x，g这四个单词，分别只出现在two，four，six，eight中，那么这五个数字的个数就可以被确定了，由于含有o的单词有zero，two，four，one，其中前三个都被确定了，那么one的个数也就知道了；由于含有h的单词有eight，three，其中eight个数已知，那么three的个数就知道了；由于含有f的单词有four，five，其中four个数已知，那么five的个数就知道了；由于含有s的单词有six，seven，其中six个数已知，那么seven的个数就知道了；由于含有i的单词有six，eight，five，nine，其中前三个都被确定了，那么nine的个数就知道了，知道了这些问题就变的容易多了，我们按这个顺序"zero", "two", "four", "six", "eight", "one", "three", "five", "seven", "nine"就能找出所有的个数了，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> originalDigits(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        </span><span style="color: #0000ff;">string</span> res = <span style="color: #800000;">""</span><span style="color: #000000;">;
        vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; words{<span style="color: #800000;">"</span><span style="color: #800000;">zero</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">two</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">four</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">six</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">eight</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">one</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">three</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">five</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">seven</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">nine</span><span style="color: #800000;">"</span><span style="color: #000000;">};
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; nums{<span style="color: #800080;">0</span>, <span style="color: #800080;">2</span>, <span style="color: #800080;">4</span>, <span style="color: #800080;">6</span>, <span style="color: #800080;">8</span>, <span style="color: #800080;">1</span>, <span style="color: #800080;">3</span>, <span style="color: #800080;">5</span>, <span style="color: #800080;">7</span>, <span style="color: #800080;">9</span>}, counts(<span style="color: #800080;">26</span>, <span style="color: #800080;">0</span><span style="color: #000000;">);
        vector</span>&lt;<span style="color: #0000ff;">char</span>&gt; chars{<span style="color: #800000;">'</span><span style="color: #800000;">z</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">w</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">u</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">x</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">g</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">o</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">h</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">f</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">s</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">i</span><span style="color: #800000;">'</span><span style="color: #000000;">};
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span> c : s) ++counts[c - <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span><span style="color: #000000;">];
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; <span style="color: #800080;">10</span>; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">int</span> cnt = counts[chars[i] - <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span><span style="color: #000000;">];
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; words[i].size(); ++<span style="color: #000000;">j) {
                counts[words[i][j] </span>- <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span>] -=<span style="color: #000000;"> cnt;
            }
            </span><span style="color: #0000ff;">while</span> (cnt--) res += (nums[i] + <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span><span style="color: #000000;">);
        }
        sort(res.begin(), res.end());
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>另外我们也可以用更加简洁易懂的方法来快速的找出各个数字的个数，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> originalDigits(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        </span><span style="color: #0000ff;">string</span> res = <span style="color: #800000;">""</span><span style="color: #000000;">;
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; counts(<span style="color: #800080;">128</span>, <span style="color: #800080;">0</span>), nums(<span style="color: #800080;">10</span>, <span style="color: #800080;">0</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span> c : s) ++<span style="color: #000000;">counts[c];
        nums[</span><span style="color: #800080;">0</span>] = counts[<span style="color: #800000;">'</span><span style="color: #800000;">z</span><span style="color: #800000;">'</span><span style="color: #000000;">];
        nums[</span><span style="color: #800080;">2</span>] = counts[<span style="color: #800000;">'</span><span style="color: #800000;">w</span><span style="color: #800000;">'</span><span style="color: #000000;">];
        nums[</span><span style="color: #800080;">4</span>] = counts[<span style="color: #800000;">'</span><span style="color: #800000;">u</span><span style="color: #800000;">'</span><span style="color: #000000;">];
        nums[</span><span style="color: #800080;">6</span>] = counts[<span style="color: #800000;">'</span><span style="color: #800000;">x</span><span style="color: #800000;">'</span><span style="color: #000000;">];
        nums[</span><span style="color: #800080;">8</span>] = counts[<span style="color: #800000;">'</span><span style="color: #800000;">g</span><span style="color: #800000;">'</span><span style="color: #000000;">];
        nums[</span><span style="color: #800080;">1</span>] = counts[<span style="color: #800000;">'</span><span style="color: #800000;">o</span><span style="color: #800000;">'</span>] - nums[<span style="color: #800080;">0</span>] - nums[<span style="color: #800080;">2</span>] - nums[<span style="color: #800080;">4</span><span style="color: #000000;">];
        nums[</span><span style="color: #800080;">3</span>] = counts[<span style="color: #800000;">'</span><span style="color: #800000;">h</span><span style="color: #800000;">'</span>] - nums[<span style="color: #800080;">8</span><span style="color: #000000;">];
        nums[</span><span style="color: #800080;">5</span>] = counts[<span style="color: #800000;">'</span><span style="color: #800000;">f</span><span style="color: #800000;">'</span>] - nums[<span style="color: #800080;">4</span><span style="color: #000000;">];
        nums[</span><span style="color: #800080;">7</span>] = counts[<span style="color: #800000;">'</span><span style="color: #800000;">s</span><span style="color: #800000;">'</span>] - nums[<span style="color: #800080;">6</span><span style="color: #000000;">];
        nums[</span><span style="color: #800080;">9</span>] = counts[<span style="color: #800000;">'</span><span style="color: #800000;">i</span><span style="color: #800000;">'</span>] - nums[<span style="color: #800080;">6</span>] - nums[<span style="color: #800080;">8</span>] - nums[<span style="color: #800080;">5</span><span style="color: #000000;">];
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; nums.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; nums[i]; ++<span style="color: #000000;">j) {
                res </span>+= (i + <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span><span style="color: #000000;">);
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/64150/straightforward-c-accepted-solution" target="_blank">https://discuss.leetcode.com/topic/64150/straightforward-c-accepted-solution</a></p>
<p><a href="https://discuss.leetcode.com/topic/63382/share-my-simple-and-easy-o-n-solution" target="_blank">https://discuss.leetcode.com/topic/63382/share-my-simple-and-easy-o-n-solution</a></p>
<p> </p>
<p><a href="http://www.cnblogs.com/grandyang/p/4606334.html" target="_blank">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-10-25 12:16</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5996239" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5996239);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5991673.html" id="cb_post_title_url">[LeetCode] Valid Word Square 验证单词平方</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a sequence of words, check whether it forms a valid word square.</p>
<p>A sequence of words forms a valid word square if the <em>k</em>th row and column read the exact same string, where 0 ≤<em>k</em> &lt; max(numRows, numColumns).</p>
<p>Note:</p>
<ol>
<li>The number of words given is at least 1 and does not exceed 500.</li>
<li>Word length will be at least 1 and does not exceed 500.</li>
<li>Each word contains only lowercase English alphabet <code>a-z</code>.</li>
</ol>
<p> </p>
<p>Example 1:</p>
<pre>Input:
[
  "abcd",
  "bnrt",
  "crmy",
  "dtye"
]

Output:
true

Explanation:
The first row and first column both read "abcd".
The second row and second column both read "bnrt".
The third row and third column both read "crmy".
The fourth row and fourth column both read "dtye".

Therefore, it is a valid word square.
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input:
[
  "abcd",
  "bnrt",
  "crm",
  "dt"
]

Output:
true

Explanation:
The first row and first column both read "abcd".
The second row and second column both read "bnrt".
The third row and third column both read "crm".
The fourth row and fourth column both read "dt".

Therefore, it is a valid word square.
</pre>
<p> </p>
<p>Example 3:</p>
<pre>Input:
[
  "ball",
  "area",
  "read",
  "lady"
]

Output:
false

Explanation:
The third row reads "read" while the third column reads "lead".

Therefore, it is NOT a valid word square.</pre>
<p> </p>
<p>这道题给了我们一个二位数组，每行每列都是一个单词，需要满足第k行的单词和第k列的单词要相等，这里不要求每一个单词的长度都一样，只要对应位置的单词一样即可。那么这里实际上也就是一个遍历二维数组，然后验证对应位上的字符是否相等的问题，由于各行的单词长度不一定相等，所以我们在找对应位置的字符时，要先判断是否越界，即对应位置是否有字符存在，遇到不符合要求的地方直接返回false，全部遍历结束后返回true，参见代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> validWordSquare(vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp;<span style="color: #000000;"> words) {
        </span><span style="color: #0000ff;">if</span> (words.empty()) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (words.size() != words[<span style="color: #800080;">0</span>].size()) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; words.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; words[i].size(); ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> (j &gt;= words.size() || i &gt;= words[j].size() || words[i][j] !=<span style="color: #000000;"> words[j][i]) {
                    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                }
            }
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/63387/java-ac-solution-easy-to-understand" target="_blank">https://discuss.leetcode.com/topic/63387/java-ac-solution-easy-to-understand</a></p>
<p> </p>
<p><a href="http://www.cnblogs.com/grandyang/p/4606334.html" target="_blank">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-10-24 06:26</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5991673" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5991673);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5991530.html" id="cb_post_title_url">[LeetCode] Maximum XOR of Two Numbers in an Array 数组中异或值最大的两个数字</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a non-empty array of numbers, a0, a1, a2, … , an-1, where 0 ≤ ai &lt; 231.</p>
<p>Find the maximum result of ai XOR aj, where 0 ≤ <em>i</em>, <em>j</em> &lt; <em>n</em>.</p>
<p>Could you do this in O(<em>n</em>) runtime?</p>
<p>Example:</p>
<pre>Input: [3, 10, 5, 25, 2, 8]

Output: 28

Explanation: The maximum result is 5 ^ 25 = 28.</pre>
<p> </p>
<p>这道题是一道典型的位操作Bit Manipulation的题目，我开始以为异或值最大的两个数一定包括数组的最大值，但是OJ给了另一个例子{10,23,20,18,28}，这个数组的异或最大值是10和20异或，得到30。那么只能另辟蹊径，正确的做法是按位遍历，题目中给定了数字的返回不会超过2<sup>31</sup>,那么最多只能有32位，我们用一个从左往右的mask，用来提取数字的前缀，然后将其都存入HashSet中，我们用一个变量t，用来验证当前位为1再或上之前结果res，看结果和HashSet中的前缀异或之后在不在HashSet中，这里用到了一个性质，若a^b=c，那么a=b^c，因为t是我们要验证的当前最大值，所以我们遍历HashSet中的数时，和t异或后的结果仍在HashSet中，说明两个前缀可以异或出t的值，所以我们更新res为t，继续遍历，如果上述讲解不容易理解，那么建议自己带个例子一步一步试试，并把每次循环中HashSet中所有的数字都打印出来，基本应该就能理解了，算了，还是博主带着大家来看题目中给的例子吧：</p>
<p>3        10        5        25        2        8</p>
<p>11      1010     101     <span style="color: #ff0000;">1</span>1001     10      1000</p>
<p>我们观察这些数字最大的为25，其二进制最高位在 i=4 时为1，那么我们的循环[31, 5]之间是取不到任何数字的，所以不会对结果res有任何影响。</p>
<p>当 i=4 时，我们此时mask为前28位为‘1’的二进制数，跟除25以外的任何数相‘与’，都会得到0。 然后跟25的二进制数10101相‘与’，得到二进制数10000，存入HashSet中，那么此时HashSet中就有0和16两个数字。此时我们的t为结果res（此时为0）‘或’上二进制数10000，得到二进制数10000。然后我们遍历HashSet，由于HashSet是无序的，所以我们会取出0和16中的其中一个，如果prefix取出的是0，那么t=16‘异或’上0，还等于16，而16是在HashSet中存在的，所以此时结果res更新为16，然后break掉遍历HashSet的循环。实际上prefix先取16的话也一样，那么t=16‘异或’上16，等于0，而0是在HashSet中存在的，所以此时结果res更新为16，然后break掉遍历HashSet的循环。</p>
<p>3        10        5        25        2        8</p>
<p>11      <span style="color: #ff0000;">1</span>010     101     <span style="color: #ff0000;">11</span>001     10      <span style="color: #ff0000;">1</span>000</p>
<p>当 i=3 时，我们此时mask为前29位为‘1’的二进制数，如上所示，跟数字3，5，2中任何一个相‘与’，都会得到0。然后跟10的二进制数1010，或跟8的二进制数1000相‘与’，都会得到二进制数1000，即8。跟25的二进制数11001相‘与’，会得到二进数11000，即24，存入HashSet中，那么此时HashSet中就有0，8，和24三个数字。此时我们的t为结果res（此时为16）‘或’上二进制数1000，得到二进制数11000，即24。此时遍历HashSet中的数，当prefix取出0，那么t=24‘异或’上0，还等于24，而24是在HashSet中存在的，所以此时结果res更新为24，然后break掉遍历HashSet的循环。大家可以尝试其他的数，当prefix取出24，其实也可以更新结果res为24的。但是8就不行啦，因为HashSet中没有16。不过无所谓了，我们只要有一个能更新结果res就可以了。</p>
<p>3        10        5        25        2        8</p>
<p>11      <span style="color: #ff0000;">10</span>10     <span style="color: #ff0000;">1</span>01     <span style="color: #ff0000;">110</span>01     10      <span style="color: #ff0000;">10</span>00</p>
<p>当 i=2 时，我们此时mask为前30位为‘1’的二进制数，如上所示，跟3的二进制数11相‘与’，会得到二进制数0，即0。然后跟10的二进制数1010相‘与’，会得到二进制数1000，即8。然后跟5的二进制数101相‘与’，会得到二进制数100，即4。然后跟25的二进制数11001相‘与’，会得到二进制数11000，即24。跟数字2和8相‘与’，分别会得到0和8，跟前面重复了。所以最终HashSet中就有0，4，8，和24这四个数字。此时我们的t为结果res（此时为24）‘或’上二进制数100，得到二进制数11100，即28。那么就要验证结果res能否取到28。我们遍历HashSet，当prefix取出0，那么t=28‘异或’上0，还等于28，但是HashSet中没有28，所以不行。当prefix取出4，那么t=28‘异或’上二进制数100，等于24，在HashSet中存在，Bingo！结果res更新为28。其他的数可以不用试了。</p>
<p>3        10        5        25        2        8</p>
<p><span style="color: #ff0000;">1</span>1      <span style="color: #ff0000;">101</span>0     <span style="color: #ff0000;">10</span>1     <span style="color: #ff0000;">1100</span>1     <span style="color: #ff0000;">1</span>0      <span style="color: #ff0000;">100</span>0</p>
<p>当 i=1 时，我们此时mask为前31位为‘1’的二进制数，如上所示，每个数与mask相‘与’后，我们HashSet中会有2，4，8，10，24这五个数。此时我们的t为结果res（此时为28）‘或’上二进制数10，得到二进制数11110，即30。那么就要验证结果res能否取到30。我们遍历HashSet，当prefix取出2，那么t=30‘异或’上2，等于28，但是HashSet中没有28，所以不行。当prefix取出4，那么t=30‘异或’上4，等于26，但是HashSet中没有26，所以不行。当prefix取出8，那么t=30‘异或’上8，等于22，但是HashSet中没有22，所以不行。当prefix取出10，那么t=30‘异或’上10，等于20，但是HashSet中没有20，所以不行。当prefix取出24，那么t=30‘异或’上24，等于6，但是HashSet中没有6，所以不行。遍历完了HashSet所有的数，结果res没有被更新，还是28。</p>
<p>3        10        5        25        2        8</p>
<p><span style="color: #ff0000;">11      1010     101     11001     10      1000</span></p>
<p>当 i=0 时，我们此时mask为前32位为‘1’的二进制数，如上所示，每个数与mask相‘与’后，我们HashSet中会有2，3，5，8，10，25这六个数。此时我们的t为结果res（此时为28）‘或’上二进制数1，得到二进制数11101，即29。那么就要验证结果res能否取到29。取出HashSet中每一个数字来验证，跟上面的验证方法相同，这里博主偷懒就不写了，最终可以发现，结果res无法被更新，还是28，所以最终的结果就是28。</p>
<p>综上所述，我们来分析一下这道题的核心。我们希望用二进制来拼出结果的数，最终结果28的二进制数为11100，里面有三个‘1’，我们来找一下都是谁贡献了这三个‘1’？在 i=4 时，数字25贡献了最高位的‘1’，在 i=3 时，数字25贡献了次高位的‘1’，在 i=2 时，数字5贡献了第三位的‘1’。而一旦某个数贡献了‘1’，那么之后在需要贡献‘1’的时候，此数就可以再继续贡献‘1’。而一旦有两个数贡献了‘1’后，那么之后的‘1’就基本上只跟这两个数有关了，其他数字有‘1’也贡献不出来。验证方法里使用了前面提到的性质，a ^ b = t，如果t是所求结果话，我们可以先假定一个t，然后验证，如果a ^ t = b成立，说明该t可以通过a和b‘异或’得到。参见代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> findMaximumXOR(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, mask = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">31</span>; i &gt;= <span style="color: #800080;">0</span>; --<span style="color: #000000;">i) {
            mask </span>|= (<span style="color: #800080;">1</span> &lt;&lt;<span style="color: #000000;"> i);
            unordered_set</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> s;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span><span style="color: #000000;"> num : nums) {
                s.insert(num </span>&amp;<span style="color: #000000;"> mask);
            }
            </span><span style="color: #0000ff;">int</span> t = res | (<span style="color: #800080;">1</span> &lt;&lt;<span style="color: #000000;"> i);
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span><span style="color: #000000;"> prefix : s) {
                </span><span style="color: #0000ff;">if</span> (s.count(t ^<span style="color: #000000;"> prefix)) {
                    res </span>=<span style="color: #000000;"> t;
                    </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                }
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/63213/java-o-n-solution-using-bit-manipulation-and-hashmap" target="_blank">https://discuss.leetcode.com/topic/63213/java-o-n-solution-using-bit-manipulation-and-hashmap</a></p>
<p> </p>
<p><a href="http://www.cnblogs.com/grandyang/p/4606334.html" target="_blank">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-10-23 23:57</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5991530" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5991530);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5988792.html" id="cb_post_title_url">[LeetCode] Strong Password Checker 密码强度检查器</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>A password is considered strong if below conditions are all met:</p>
<ol>
<li>It has at least 6 characters and at most 20 characters.</li>
<li>It must contain at least one lowercase letter, at least one uppercase letter, and at least one digit.</li>
<li>It must NOT contain three repeating characters in a row ("...aaa..." is weak, but "...aa...a..." is strong, assuming other conditions are met).</li>
</ol>
<p>Write a function strongPasswordChecker(s), that takes a string s as input, and return the MINIMUM change required to make s a strong password. If s is already strong, return 0.</p>
<p>Insertion, deletion or replace of any one character are all considered as one change.</p>
<p> </p>
<p>这道题给了我们一个密码串，让我们判断其需要多少步修改能变成一个强密码串，然后给定了强密码串的条件，长度为6到20之间，必须含有至少一个的小写字母，大写字母，数字，而且不能有连续三个相同的字符，给了我们三种修改方法，任意一个位置加入字符，删除字符，或者是置换任意一个字符，让我们修改最小的次数变成强密码串。这道题定义为Hard真是名副其实，博主光是看大神的帖子都看了好久，这里主要是参考了<a href="https://discuss.leetcode.com/topic/63854/o-n-java-solution-by-analyzing-changes-allowed-to-fix-each-condition" target="_blank">大神fun4LeetCode的帖子</a>，个人感觉这个算是讲的十分清楚的了，这里就照搬过来吧。首先我们来看非强密码串主要有的三个问题：</p>
<p>1. 长度问题，当长度小于6的时候，我们要通过插入字符来补充长度，当长度超过20时，我们要删除字符。</p>
<p>2. 缺失字符或数字，当我们缺少大写，小写和数字的时候，我们可以通过插入字符或者替换字符的方式来补全。</p>
<p>3. 重复字符，这个也是本题最大的难点，因为插入，删除，或者置换都可以解决重复字符的问题，比如有一个字符串"aaaaa"，我们可以用一次置换，比如换掉中间的字符'a'；或者两次插入字符，在第二个a和第四个a后面分别插入一个非a字符；或者可以删除3个a来解决重复字符的问题。由于题目要求我们要用最少的步骤，那么显而易见置换是最高效的去重复字符的方法。</p>
<p>我们通过举例观察可以知道这三种情况并不是相互独立的，一个操作有时候可以解决多个问题，比如字符串"aaa1a"，我们在第二个a后面增加一个'B'，变为"aaBa1a",这样同时解决了三个问题，即增加了长度，又补充了缺失的大写字母，又去掉了重复，所以我们的目标就是尽可能的找出这种能解决多种问题的操作。由于情况三(重复字符)可以用三种操作来解决，所以我们分别来看能同时解决情况一和情况三，跟同时解决情况二和情况三的操作。对于同时解决情况一和情况二的操作如果原密码串长度小于6会有重叠出现，所以我们要分情况讨论：</p>
<p>当密码串长度小于6时，情况一和情况二的操作步骤可以完全覆盖情况三，这个不难理解，因为这种情况下重复字符个数的范围为[3,5]，如果有三个重复字符，那么增加三个字符的操作可以同时解决重复字符问题("aaa" -&gt; "a1BCaa"；如果有四个重复字符，那么增加二个字符的操作也可以解决重复问题("aaaa" -&gt; "aa1Baa")；如果有五个重复字符，那么增加和置换操作也同时解决重复问题("aaaaa" -&gt; "aa1aaB")。所以我们就专心看最少多少步能同时解决情况一和情况二，首先我们计算出当前密码串需要补几个字符才能到6，补充字符的方法只能用插入字符操作，而插入字符操作也可以解决情况二，所以当情况二的缺失种类个数小于等于diff时，我们不用再增加操作，当diff不能完全覆盖缺失种类个数时，我们还应加上二者的差值。</p>
<p>当密码串长度大于等于6个的时候，这种情况就比较复杂了，由于目前字符串的长度只可能超标不可能不达标，所以我们尽量不要用插入字符操作，因为这有可能会使长度超过限制。由于长度的不确定性，所以可能会有大量的重复字符，那么解决情况三就变得很重要了，由于前面的分析，替换字符是最高效的解法，但是这种方法没法解决情况一，因为长度超标了的话，再怎么替换字符，也不会让长度减少，但是我们也不能无脑删除字符，这样不一定能保证是最少步骤，所以在解决情况三的时候还要综合考虑到情况一，这里用到了一个trick (很膜拜大神能想的出来)，对于重复字符个数k大于等于3的情况，我们并不是直接将其删除到2个，而是先将其删除到最近的(3m+2)个，那么如果k正好被3整除，那么我们直接变为k-1，如果k除以3余1，那么变为k-2。这样做的好处是3m+2个重复字符可以最高效的用替换m个字符来去除重复。那么下面我们来看具体的步骤，首先我们算出超过20个的个数over，我们先把over加到结果res中，因为无论如何这over个删除操作都是要做的。如果没超过，over就是0，用变量left表示解决重复字符最少需要替换的个数，初始化为0。然后我们遍历之前统计字符出现个数的数组，如果某个字符出现个数大于等于3，且此时over大于0，那么我们将个数减为最近的3m+2个，over也对应的减少，注意，一旦over小于等于0，不要再进行删除操作。如果所有重复个数都减为3m+2了，但是over仍大于0，那么我们还要进一步的进行删除操作，这回每次直接删除3m个，直到over小于等于0为止，剩下的如果还有重复个数大于3的字符，我们算出置换字符需要的个数直接加到left中即可，最后我们比较left和missing，取其中较大值加入结果res中即可，参见代码如下：</p>
<p>                                                                                                     </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> strongPasswordChecker(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, n = s.size(), lower = <span style="color: #800080;">1</span>, upper = <span style="color: #800080;">1</span>, digit = <span style="color: #800080;">1</span><span style="color: #000000;">;
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; v(n, <span style="color: #800080;">0</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt;<span style="color: #000000;"> n;) {
            </span><span style="color: #0000ff;">if</span> (s[i] &gt;= <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span> &amp;&amp; s[i] &lt;= <span style="color: #800000;">'</span><span style="color: #800000;">z</span><span style="color: #800000;">'</span>) lower = <span style="color: #800080;">0</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> (s[i] &gt;= <span style="color: #800000;">'</span><span style="color: #800000;">A</span><span style="color: #800000;">'</span> &amp;&amp; s[i] &lt;= <span style="color: #800000;">'</span><span style="color: #800000;">Z</span><span style="color: #800000;">'</span>) upper = <span style="color: #800080;">0</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> (s[i] &gt;= <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span> &amp;&amp; s[i] &lt;= <span style="color: #800000;">'</span><span style="color: #800000;">9</span><span style="color: #800000;">'</span>) digit = <span style="color: #800080;">0</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">int</span> j =<span style="color: #000000;"> i;
            </span><span style="color: #0000ff;">while</span> (i &lt; n &amp;&amp; s[i] == s[j]) ++<span style="color: #000000;">i;
            v[j] </span>= i -<span style="color: #000000;"> j;
        }
        </span><span style="color: #0000ff;">int</span> missing = (lower + upper +<span style="color: #000000;"> digit);
        </span><span style="color: #0000ff;">if</span> (n &lt; <span style="color: #800080;">6</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">int</span> diff = <span style="color: #800080;">6</span> -<span style="color: #000000;"> n;
            res </span>+= diff + max(<span style="color: #800080;">0</span>, missing -<span style="color: #000000;"> diff);
        } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            </span><span style="color: #0000ff;">int</span> over = max(n - <span style="color: #800080;">20</span>, <span style="color: #800080;">0</span>), left = <span style="color: #800080;">0</span><span style="color: #000000;">;
            res </span>+=<span style="color: #000000;"> over;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> k = <span style="color: #800080;">1</span>; k &lt; <span style="color: #800080;">3</span>; ++<span style="color: #000000;">k) {
                </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n &amp;&amp; over &gt; <span style="color: #800080;">0</span>; ++<span style="color: #000000;">i) {
                    </span><span style="color: #0000ff;">if</span> (v[i] &lt; <span style="color: #800080;">3</span> || v[i] % <span style="color: #800080;">3</span> != (k - <span style="color: #800080;">1</span>)) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                    v[i] </span>-=<span style="color: #000000;"> k;
                    over </span>-=<span style="color: #000000;">k;
                }
            }
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
                </span><span style="color: #0000ff;">if</span> (v[i] &gt;= <span style="color: #800080;">3</span> &amp;&amp; over &gt; <span style="color: #800080;">0</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">int</span> need = v[i] - <span style="color: #800080;">2</span><span style="color: #000000;">;
                    v[i] </span>-=<span style="color: #000000;"> over;
                    over </span>-=<span style="color: #000000;"> need;
                }
                </span><span style="color: #0000ff;">if</span> (v[i] &gt;= <span style="color: #800080;">3</span>) left += v[i] / <span style="color: #800080;">3</span><span style="color: #000000;">;
            }
            res </span>+=<span style="color: #000000;"> max(missing, left);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/63854/o-n-java-solution-by-analyzing-changes-allowed-to-fix-each-condition/2" target="_blank">https://discuss.leetcode.com/topic/63854/o-n-java-solution-by-analyzing-changes-allowed-to-fix-each-condition/2</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-10-22 23:54</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5988792" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5988792);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5979207.html" id="cb_post_title_url">[LeetCode] Battleships in a Board 平板上的战船</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given an 2D board, count how many different battleships are in it. The battleships are represented with <code>'X'</code>s, empty slots are represented with <code>'.'</code>s. You may assume the following rules:</p>
<ul>
<li>You receive a valid board, made of only battleships or empty slots.</li>
<li>Battleships can only be placed horizontally or vertically. In other words, they can only be made of the shape <code>1xN</code> (1 row, N columns) or <code>Nx1</code> (N rows, 1 column), where N can be of any size.</li>
<li>At least one horizontal or vertical cell separates between two battleships - there are no adjacent battleships.</li>
</ul>
<p>Example:</p>
<pre>X..X
...X
...X
</pre>
<p>In the above board there are 2 battleships.</p>
<p>Invalid Example:</p>
<pre>...X
XXXX
...X
</pre>
<p>This is not a valid board - as battleships will always have a cell separating between them.</p>
<p>Your algorithm should not modify the value of the board.</p>
<p> </p>
<p>这道题好像之前在地里面见过，忘了是哪家公司的面试题了，现在被LeetCode收录了，感觉现在LeetCode更新越来越快了，感觉要成为第一大题库了，赞一个👍。这道题让我们求战舰的个数，所谓的战舰就是只能是一行或者一列，不能有拐弯。这道题降低了难度的做法是限定了不会有相邻的两个战舰的存在，有了这一点限制，那么我们只需要遍历一次二维数组就行了，只要找出战舰的起始点。所谓的战舰起始点，就是为X的点，而且该点的上方和左边的点不能为X，所以我们只要找出所有满足这个条件的点即可，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> countBattleships(vector&lt;vector&lt;<span style="color: #0000ff;">char</span>&gt;&gt;&amp;<span style="color: #000000;"> board) {
        </span><span style="color: #0000ff;">if</span> (board.empty() || board[<span style="color: #800080;">0</span>].empty()) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, m = board.size(), n = board[<span style="color: #800080;">0</span><span style="color: #000000;">].size();
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; m; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; n; ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> (board[i][j] == <span style="color: #800000;">'</span><span style="color: #800000;">.</span><span style="color: #800000;">'</span> || (i &gt; <span style="color: #800080;">0</span> &amp;&amp; board[i - <span style="color: #800080;">1</span>][j] == <span style="color: #800000;">'</span><span style="color: #800000;">X</span><span style="color: #800000;">'</span>) || (j &gt; <span style="color: #800080;">0</span> &amp;&amp; board[i][j - <span style="color: #800080;">1</span>] == <span style="color: #800000;">'</span><span style="color: #800000;">X</span><span style="color: #800000;">'</span>)) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                </span>++<span style="color: #000000;">res;
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>然而我自己在做的时候并没有注意到题目中限制了两艘战舰不能相邻的情况，我加上了处理方法，首先我算出来了所有连续X的区域的个数，方法跟之前那道<a href="http://www.cnblogs.com/grandyang/p/4402656.html" target="_blank">Number of Islands</a>一样，稍有不同的是，我分别记录下来每一个连续区域的i和j，把所有的点的横纵坐标分别或了起来，这样做的好处是如果是在一条直线上的战舰，那么所有点肯定是要么横坐标都相同，要么纵坐标都相同，所以最后我们检测如果横纵坐标的累积或都跟之前的i和j不同的话，那么一定不是题目中定义的战舰，那么我们就不累加结果res，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> countBattleships(vector&lt;vector&lt;<span style="color: #0000ff;">char</span>&gt;&gt;&amp;<span style="color: #000000;"> board) {
        </span><span style="color: #0000ff;">if</span> (board.empty() || board[<span style="color: #800080;">0</span>].empty()) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> m = board.size(), n = board[<span style="color: #800080;">0</span>].size(), res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">bool</span>&gt;&gt; visited(m, vector&lt;<span style="color: #0000ff;">bool</span>&gt;(n, <span style="color: #0000ff;">false</span><span style="color: #000000;">));
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; m; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; n; ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> (board[i][j] == <span style="color: #800000;">'</span><span style="color: #800000;">X</span><span style="color: #800000;">'</span> &amp;&amp; !<span style="color: #000000;">visited[i][j]) {
                    </span><span style="color: #0000ff;">int</span> vertical = <span style="color: #800080;">0</span>, horizontal = <span style="color: #800080;">0</span><span style="color: #000000;">;
                    dfs(board, visited, vertical, horizontal, i, j);
                    </span><span style="color: #0000ff;">if</span> (vertical == i || horizontal == j) ++<span style="color: #000000;">res;
                }
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">void</span> dfs(vector&lt;vector&lt;<span style="color: #0000ff;">char</span>&gt;&gt;&amp; board, vector&lt;vector&lt;<span style="color: #0000ff;">bool</span>&gt;&gt;&amp; visited, <span style="color: #0000ff;">int</span>&amp; vertical, <span style="color: #0000ff;">int</span>&amp; horizontal, <span style="color: #0000ff;">int</span> i, <span style="color: #0000ff;">int</span><span style="color: #000000;"> j) {
        </span><span style="color: #0000ff;">int</span> m = board.size(), n = board[<span style="color: #800080;">0</span><span style="color: #000000;">].size();
        </span><span style="color: #0000ff;">if</span> (i &lt; <span style="color: #800080;">0</span> || i &gt;= m || j &lt; <span style="color: #800080;">0</span> || j &gt;= n || visited[i][j] || board[i][j] == <span style="color: #800000;">'</span><span style="color: #800000;">.</span><span style="color: #800000;">'</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
        vertical </span>|= i; horizontal |=<span style="color: #000000;"> j;
        visited[i][j] </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        dfs(board, visited, vertical, horizontal, i </span>- <span style="color: #800080;">1</span><span style="color: #000000;">, j);
        dfs(board, visited, vertical, horizontal, i </span>+ <span style="color: #800080;">1</span><span style="color: #000000;">, j);
        dfs(board, visited, vertical, horizontal, i, j </span>- <span style="color: #800080;">1</span><span style="color: #000000;">);
        dfs(board, visited, vertical, horizontal, i, j </span>+ <span style="color: #800080;">1</span><span style="color: #000000;">);
    }
};</span></pre>
</div>
<p> </p>
<p>既然DFS能实现，那么BFS就应该没啥问题，这里完全按题目的要求，默认两个战舰不会相邻，并没有添加解法二中的过滤条件，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> countBattleships(vector&lt;vector&lt;<span style="color: #0000ff;">char</span>&gt;&gt;&amp;<span style="color: #000000;"> board) {
        </span><span style="color: #0000ff;">if</span> (board.empty() || board[<span style="color: #800080;">0</span>].empty()) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, m = board.size(), n = board[<span style="color: #800080;">0</span><span style="color: #000000;">].size();
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">bool</span>&gt;&gt; visited(m, vector&lt;<span style="color: #0000ff;">bool</span>&gt;(n, <span style="color: #0000ff;">false</span><span style="color: #000000;">));
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; dirs{{<span style="color: #800080;">0</span>,-<span style="color: #800080;">1</span>},{-<span style="color: #800080;">1</span>,<span style="color: #800080;">0</span>},{<span style="color: #800080;">0</span>,<span style="color: #800080;">1</span>},{<span style="color: #800080;">1</span>,<span style="color: #800080;">0</span><span style="color: #000000;">}};
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; m; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; n; ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> (board[i][j] == <span style="color: #800000;">'</span><span style="color: #800000;">X</span><span style="color: #800000;">'</span> &amp;&amp; !<span style="color: #000000;">visited[i][j]) {
                    </span>++<span style="color: #000000;">res;
                    queue</span>&lt;pair&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;&gt;<span style="color: #000000;"> q;
                    q.push({i, j});
                    </span><span style="color: #0000ff;">while</span> (!<span style="color: #000000;">q.empty()) {
                        auto t </span>=<span style="color: #000000;"> q.front(); q.pop();
                        visited[t.first][t.second] </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto dir : dirs) {
                            </span><span style="color: #0000ff;">int</span> x = t.first + dir[<span style="color: #800080;">0</span>], y = t.second + dir[<span style="color: #800080;">1</span><span style="color: #000000;">];
                            </span><span style="color: #0000ff;">if</span> (x &lt; <span style="color: #800080;">0</span> || x &gt;= m || y &lt; <span style="color: #800080;">0</span> || y &gt;= n || visited[x][y] || board[x][y] == <span style="color: #800000;">'</span><span style="color: #800000;">.</span><span style="color: #800000;">'</span>) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                            q.push({x, y});
                        }
                    }
                }
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/62970/simple-java-solution" target="_blank">https://discuss.leetcode.com/topic/62970/simple-java-solution</a></p>
<p><a href="https://discuss.leetcode.com/topic/62997/dfs-bfs-flood-fill-algorithm-with-c/2" target="_blank">https://discuss.leetcode.com/topic/62997/dfs-bfs-flood-fill-algorithm-with-c/2</a></p>
<p> </p>
<p><a href="http://www.cnblogs.com/grandyang/p/4606334.html" target="_blank">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-10-19 23:39</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5979207" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5979207);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5975426.html" id="cb_post_title_url">[LeetCode] Sentence Screen Fitting 调整屏幕上的句子</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a <code>rows x cols</code> screen and a sentence represented by a list of words, find how many times the given sentence can be fitted on the screen.</p>
<p>Note:</p>
<ol>
<li>A word cannot be split into two lines.</li>
<li>The order of words in the sentence must remain unchanged.</li>
<li>Two consecutive words in a line must be separated by a single space.</li>
<li>Total words in the sentence won't exceed 100.</li>
<li>Length of each word won't exceed 10.</li>
<li>1 ≤ rows, cols ≤ 20,000.</li>
</ol>
<p> </p>
<p>Example 1:</p>
<pre>Input:
rows = 2, cols = 8, sentence = ["hello", "world"]

Output: 
1

Explanation:
hello---
world---

The character '-' signifies an empty space on the screen.
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input:
rows = 3, cols = 6, sentence = ["a", "bcd", "e"]

Output: 
2

Explanation:
a-bcd- 
e-a---
bcd-e-

The character '-' signifies an empty space on the screen.
</pre>
<p> </p>
<p>Example 3:</p>
<pre>Input:
rows = 4, cols = 5, sentence = ["I", "had", "apple", "pie"]

Output: 
1

Explanation:
I-had
apple
pie-I
had--

The character '-' signifies an empty space on the screen.</pre>
<p> </p>
<p>这道题给我们了一个句子，由若干个单词组成，然后给我们了一个空白屏幕区域，让我们填充单词，前提是单词和单词之间需要一个空格隔开，而且单词不能断开，如果当前行剩余位置放下不下某个单词，则必须将该单词整个移动到下一行。我刚开始想的是便利句子，每个单词分别处理，但是这种做法很不高效，因为有可能屏幕的宽度特别大，而单词可能就一两个，那么我们这样遍历的话就太浪费时间了，应该直接用宽度除以句子加上空格的长度之和，可以快速的得到能装下的个数。下面这种方法设计的很巧妙，思路是用start变量来记录下能装下的句子的总长度，最后除以一个句子的长度，就可以得到个数。而句子的总长度的求法时要在每个单词后面加上一个空格(包括最后一个单词)，我们遍历屏幕的每一行，然后每次start都加上宽度，然后看all[start%len]是否为空格，是的话就start加1，这样做的好处是可以处理末尾是没有空格的情况，比如宽度为1，只有一个单词a，那么我们都知道是这样放的 <span style="text-decoration: underline;">a</span> ，start变为1，len是2，all[start%len]是空格，所以start自增1，变成2，这样我们用start/len就知道能放下几个了。对于all[start%len]不为空格的情况，如果all[(start-1)%len]也不为空格，那么start就自减1，进行while循环，直至其为空格为止。大家可以自己带例子尝试，个人觉得想出此方法的人真是太聪明了：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> wordsTyping(vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp; sentence, <span style="color: #0000ff;">int</span> rows, <span style="color: #0000ff;">int</span><span style="color: #000000;"> cols) {
        </span><span style="color: #0000ff;">string</span> all = <span style="color: #800000;">""</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">string</span> word : sentence) all += (word + <span style="color: #800000;">"</span> <span style="color: #800000;">"</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">int</span> start = <span style="color: #800080;">0</span>, len =<span style="color: #000000;"> all.size();
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; rows; ++<span style="color: #000000;">i) {
            start </span>+=<span style="color: #000000;"> cols;
            </span><span style="color: #0000ff;">if</span> (all[start % len] == <span style="color: #800000;">'</span> <span style="color: #800000;">'</span><span style="color: #000000;">) {
                </span>++<span style="color: #000000;">start;
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                </span><span style="color: #0000ff;">while</span> (start &gt; <span style="color: #800080;">0</span> &amp;&amp; all[(start - <span style="color: #800080;">1</span>) % len] != <span style="color: #800000;">'</span> <span style="color: #800000;">'</span><span style="color: #000000;">) {
                    </span>--<span style="color: #000000;">start;
                }
            }
        }
        </span><span style="color: #0000ff;">return</span> start /<span style="color: #000000;"> len;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种方法也是很棒，同样也需要统计加空格的句子总长度，然后遍历每一行，初始化colsRemaining为cols，然后还需要一个变量idx，来记录当前单词的位置，如果colsRemaining大于0，就进行while循环，如果当前单词的长度小于等于colsRemaining，说明可以放下该单词，那么就减去该单词的长度就是剩余的空间，然后如果此时colsRemaining仍然大于0，则减去空格的长度1，然后idx自增1，如果idx此时超过单词个数的范围了，说明一整句可以放下，那么就有可能出现宽度远大于句子长度的情况，所以我们加上之前放好的一句之外，还要加上colsRemaining/len的个数，然后colsRemaining%len是剩余的位置，此时idx重置为0，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> wordsTyping(vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp; sentence, <span style="color: #0000ff;">int</span> rows, <span style="color: #0000ff;">int</span><span style="color: #000000;"> cols) {
        </span><span style="color: #0000ff;">string</span> all = <span style="color: #800000;">""</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">string</span> word : sentence) all += (word + <span style="color: #800000;">"</span> <span style="color: #800000;">"</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, idx = <span style="color: #800080;">0</span>, n = sentence.size(), len =<span style="color: #000000;"> all.size();
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; rows; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">int</span> colsRemaining =<span style="color: #000000;"> cols;
            </span><span style="color: #0000ff;">while</span> (colsRemaining &gt; <span style="color: #800080;">0</span><span style="color: #000000;">) {
                </span><span style="color: #0000ff;">if</span> (sentence[idx].size() &lt;=<span style="color: #000000;"> colsRemaining) {
                    colsRemaining </span>-=<span style="color: #000000;"> sentence[idx].size();
                    </span><span style="color: #0000ff;">if</span> (colsRemaining &gt; <span style="color: #800080;">0</span>) colsRemaining -= <span style="color: #800080;">1</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">if</span> (++idx &gt;=<span style="color: #000000;"> n) {
                        res </span>+= (<span style="color: #800080;">1</span> + colsRemaining /<span style="color: #000000;"> len);
                        colsRemaining </span>%=<span style="color: #000000;"> len;
                        idx </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
                    }
                } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                }
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/62509/accepted-java-solution" target="_blank">https://discuss.leetcode.com/topic/62509/accepted-java-solution</a></p>
<p><a href="https://discuss.leetcode.com/topic/62455/21ms-18-lines-java-solution" target="_blank">https://discuss.leetcode.com/topic/62455/21ms-18-lines-java-solution</a></p>
<p><br class="Apple-interchange-newline"/><a href="http://www.cnblogs.com/grandyang/p/4606334.html" target="_blank">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-10-18 22:53</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5975426" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5975426);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5962508.html" id="cb_post_title_url">[LeetCode] Pacific Atlantic Water Flow 太平洋大西洋水流</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given an <code>m x n</code> matrix of non-negative integers representing the height of each unit cell in a continent, the "Pacific ocean" touches the left and top edges of the matrix and the "Atlantic ocean" touches the right and bottom edges.</p>
<p>Water can only flow in four directions (up, down, left, or right) from a cell to another one with height equal or lower.</p>
<p>Find the list of grid coordinates where water can flow to both the Pacific and Atlantic ocean.</p>
<p><strong>Note:</strong><br/>
</p>
<ol>
<li>The order of returned grid coordinates does not matter.</li>
<li>Both <em>m</em> and <em>n</em> are less than 150.</li>
</ol>
<p><strong>Example:</strong>
</p>
<pre>Given the following 5x5 matrix:

  Pacific ~   ~   ~   ~   ~ 
       ~  1   2   2   3  (5) *
       ~  3   2   3  (4) (4) *
       ~  2   4  (5)  3   1  *
       ~ (6) (7)  1   4   5  *
       ~ (5)  1   1   2   4  *
          *   *   *   *   * Atlantic

Return:

[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (positions with parentheses in above matrix).
</pre>
<p> </p>
<p>这道题给了我们一个二维数组，说是数组的左边和上边是太平洋，右边和下边是大西洋，假设水能从高处向低处流，问我们所有能流向两大洋的点的集合。刚开始我们没有理解题意，以为加括号的点是一条路径，连通两大洋的，但是看来看去感觉也不太对，后来终于明白了，是每一个点单独都路径来通向两大洋。那么就是典型的搜索问题，那么我最开始想的是对于每个点来搜索是否能到达边缘，只不过搜索的目标点不在是一个单点，而是所有的边缘点，找这种思路写出的代码无法通过OJ大数据集，那么我们就要想办法来优化我们的代码，优化的方法跟之前那道<a href="http://www.cnblogs.com/grandyang/p/4555831.html" target="_blank">Surrounded Regions</a>很类似，都是换一个方向考虑问题，既然从每个点像中间扩散会TLE，那么我们从边缘当作起点开始遍历搜索，然后标记能到达的点位true，分别标记出pacific和atlantic能到达的点，那么最终能返回的点就是二者均为true的点。我们可以先用DFS来遍历二维数组，参见代码如下：</p>
<p>s</p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;pair&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;&gt; pacificAtlantic(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> matrix) {
        </span><span style="color: #0000ff;">if</span> (matrix.empty() || matrix[<span style="color: #800080;">0</span>].empty()) <span style="color: #0000ff;">return</span><span style="color: #000000;"> {};
        vector</span>&lt;pair&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;&gt;<span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">int</span> m = matrix.size(), n = matrix[<span style="color: #800080;">0</span><span style="color: #000000;">].size();
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">bool</span>&gt;&gt; pacific(m, vector&lt;<span style="color: #0000ff;">bool</span>&gt;(n, <span style="color: #0000ff;">false</span><span style="color: #000000;">));
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">bool</span>&gt;&gt; atlantic(m, vector&lt;<span style="color: #0000ff;">bool</span>&gt;(n, <span style="color: #0000ff;">false</span><span style="color: #000000;">));
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; m; ++<span style="color: #000000;">i) {
            dfs(matrix, pacific, INT_MIN, i, </span><span style="color: #800080;">0</span><span style="color: #000000;">);
            dfs(matrix, atlantic, INT_MIN, i, n </span>- <span style="color: #800080;">1</span><span style="color: #000000;">);
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            dfs(matrix, pacific, INT_MIN, </span><span style="color: #800080;">0</span><span style="color: #000000;">, i);
            dfs(matrix, atlantic, INT_MIN, m </span>- <span style="color: #800080;">1</span><span style="color: #000000;">, i);
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; m; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; n; ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> (pacific[i][j] &amp;&amp;<span style="color: #000000;"> atlantic[i][j]) {
                    res.push_back({i, j});
                }
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">void</span> dfs(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp; matrix, vector&lt;vector&lt;<span style="color: #0000ff;">bool</span>&gt;&gt;&amp; visited, <span style="color: #0000ff;">int</span> pre, <span style="color: #0000ff;">int</span> i, <span style="color: #0000ff;">int</span><span style="color: #000000;"> j) {
        </span><span style="color: #0000ff;">int</span> m = matrix.size(), n = matrix[<span style="color: #800080;">0</span><span style="color: #000000;">].size();
        </span><span style="color: #0000ff;">if</span> (i &lt; <span style="color: #800080;">0</span> || i &gt;= m || j &lt; <span style="color: #800080;">0</span> || j &gt;= n || visited[i][j] || matrix[i][j] &lt; pre) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
        visited[i][j] </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        dfs(matrix, visited, matrix[i][j], i </span>+ <span style="color: #800080;">1</span><span style="color: #000000;">, j);
        dfs(matrix, visited, matrix[i][j], i </span>- <span style="color: #800080;">1</span><span style="color: #000000;">, j);
        dfs(matrix, visited, matrix[i][j], i, j </span>+ <span style="color: #800080;">1</span><span style="color: #000000;">);
        dfs(matrix, visited, matrix[i][j], i, j </span>- <span style="color: #800080;">1</span><span style="color: #000000;">);
    }
};</span></pre>
</div>
<p> </p>
<p>那么BFS的解法也可以做，用queue来辅助，开始把边上的点分别存入queue中，然后对应的map标记true，然后开始BFS遍历，遍历结束后还是找pacific和atlantic均标记为true的点加入res中返回即可，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;pair&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;&gt; pacificAtlantic(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> matrix) {
        </span><span style="color: #0000ff;">if</span> (matrix.empty() || matrix[<span style="color: #800080;">0</span>].empty()) <span style="color: #0000ff;">return</span><span style="color: #000000;"> {};
        vector</span>&lt;pair&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;&gt;<span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">int</span> m = matrix.size(), n = matrix[<span style="color: #800080;">0</span><span style="color: #000000;">].size();
        queue</span>&lt;pair&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;&gt;<span style="color: #000000;"> q1, q2;
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">bool</span>&gt;&gt; pacific(m, vector&lt;<span style="color: #0000ff;">bool</span>&gt;(n, <span style="color: #0000ff;">false</span>)), atlantic =<span style="color: #000000;"> pacific;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; m; ++<span style="color: #000000;">i) {
            q1.push({i, </span><span style="color: #800080;">0</span><span style="color: #000000;">}); 
            q2.push({i, n </span>- <span style="color: #800080;">1</span><span style="color: #000000;">});
            pacific[i][</span><span style="color: #800080;">0</span>] = <span style="color: #0000ff;">true</span><span style="color: #000000;">;
            atlantic[i][n </span>- <span style="color: #800080;">1</span>] = <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            q1.push({</span><span style="color: #800080;">0</span><span style="color: #000000;">, i});
            q2.push({m </span>- <span style="color: #800080;">1</span><span style="color: #000000;">, i});
            pacific[</span><span style="color: #800080;">0</span>][i] = <span style="color: #0000ff;">true</span><span style="color: #000000;">;
            atlantic[m </span>- <span style="color: #800080;">1</span>][i] = <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        }
        bfs(matrix, pacific, q1);
        bfs(matrix, atlantic, q2);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; m; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; n; ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> (pacific[i][j] &amp;&amp;<span style="color: #000000;"> atlantic[i][j]) {
                    res.push_back({i, j});
                }
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">void</span> bfs(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp; matrix, vector&lt;vector&lt;<span style="color: #0000ff;">bool</span>&gt;&gt;&amp; visited, queue&lt;pair&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> q) {
        </span><span style="color: #0000ff;">int</span> m = matrix.size(), n = matrix[<span style="color: #800080;">0</span><span style="color: #000000;">].size();
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; dirs{{<span style="color: #800080;">0</span>,-<span style="color: #800080;">1</span>},{-<span style="color: #800080;">1</span>,<span style="color: #800080;">0</span>},{<span style="color: #800080;">0</span>,<span style="color: #800080;">1</span>},{<span style="color: #800080;">1</span>,<span style="color: #800080;">0</span><span style="color: #000000;">}};
        </span><span style="color: #0000ff;">while</span> (!<span style="color: #000000;">q.empty()) {
            auto t </span>=<span style="color: #000000;"> q.front(); q.pop();
            </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto dir : dirs) {
                </span><span style="color: #0000ff;">int</span> x = t.first + dir[<span style="color: #800080;">0</span>], y = t.second + dir[<span style="color: #800080;">1</span><span style="color: #000000;">];
                </span><span style="color: #0000ff;">if</span> (x &lt; <span style="color: #800080;">0</span> || x &gt;= m || y &lt; <span style="color: #800080;">0</span> || y &gt;= n || visited[x][y] || matrix[x][y] &lt; matrix[t.first][t.second]) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                visited[x][y] </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                q.push({x, y});
            }
        }
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/62379/java-bfs-dfs-from-ocean/2" target="_blank">https://discuss.leetcode.com/topic/62379/java-bfs-dfs-from-ocean/2</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-10-14 23:33</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5962508" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5962508);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5951422.html" id="cb_post_title_url">[LeetCode] Partition Equal Subset Sum 相同子集和分割</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a <strong>non-empty</strong> array containing <strong>only positive integers</strong>, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.</p>
<p><strong>Note:</strong><br/>
Both the array size and each of the array element will not exceed 100.
</p>
<p><strong>Example 1:</strong>
</p>
<pre>Input: [1, 5, 11, 5]

Output: true

Explanation: The array can be partitioned as [1, 5, 5] and [11].
</pre>
<p><strong>Example 2:</strong></p>
<pre>Input: [1, 2, 3, 5]

Output: false

Explanation: The array cannot be partitioned into equal sum subsets.
</pre>
<p> </p>
<p>这道题给了我们一个数组，问我们这个数组能不能分成两个非空子集合，使得两个子集合的元素之和相同。那么我们想，原数组所有数字和一定是偶数，不然根本无法拆成两个和相同的子集合，那么我们只需要算出原数组的数字之和，然后除以2，就是我们的target，那么问题就转换为能不能找到一个非空子集合，使得其数字之和为target。开始我想的是遍历所有子集合，算和，但是这种方法无法通过OJ的大数据集合。于是乎，动态规划 Dynamic Programming 就是我们的不二之选。我们定义一个一维的dp数组，其中dp[i]表示数字i是否是原数组的任意个子集合之和，那么我们我们最后只需要返回dp[target]就行了。我们初始化dp[0]为true，由于题目中限制了所有数字为正数，那么我们就不用担心会出现和为0或者负数的情况。那么关键问题就是要找出状态转移方程了，我们需要遍历原数组中的数字，对于遍历到的每个数字nums[i]，我们需要更新dp数组，要更新[nums[i], target]之间的值，那么对于这个区间中的任意一个数字j，如果dp[j - nums[i]]为true的话，那么dp[j]就一定为true，于是状态转移方程如下：</p>
<p>dp[j] = dp[j] || dp[j - nums[i]]         (nums[i] &lt;= j &lt;= target)</p>
<p>有了状态转移方程，那么我们就可以写出代码了，这里需要特别注意的是，第二个for循环一定要从target遍历到nums[i]，而不能反过来，想想为什么呢？因为如果我们从nums[i]遍历到target的话，假如nums[i]=1的话，那么[1, target]中所有的dp值都是true，因为dp[0]是true，dp[1]会或上dp[0]，为true，dp[2]会或上dp[1]，为true，依此类推，完全使我们的dp数组失效了，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> canPartition(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        </span><span style="color: #0000ff;">int</span> sum = accumulate(nums.begin(), nums.end(), <span style="color: #800080;">0</span>), target = sum &gt;&gt; <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (sum &amp; <span style="color: #800080;">1</span>) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        vector</span>&lt;<span style="color: #0000ff;">bool</span>&gt; dp(target + <span style="color: #800080;">1</span>, <span style="color: #0000ff;">false</span><span style="color: #000000;">);
        dp[</span><span style="color: #800080;">0</span>] = <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span><span style="color: #000000;"> num : nums) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = target; i &gt;= num; --<span style="color: #000000;">i) {
                dp[i] </span>= dp[i] || dp[i -<span style="color: #000000;"> num];
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> dp[target];
    }
};</span></pre>
</div>
<p> </p>
<p>这道题还可以用bitset来做，感觉也十分的巧妙，bisets的大小设为5001，为啥呢，因为题目中说了数组的长度和每个数字的大小都不会超过100，那么最大的和为10000，那么一半就是5000，前面再加上个0，就是5001了。我们初始化把最低位赋值为1，然后我们算出数组之和，然后我们遍历数字，对于遍历到的数字num，我们把bits向左平移num位，然后再或上原来的bits，这样所有的可能出现的和位置上都为1。举个例子来说吧，比如对于数组[2,3]来说，初始化bits为1，然后对于数字2，bits变为101，我们可以看出来bits[2]标记为了1，然后遍历到3，bits变为了101101，我们看到bits[5],bits[3],bits[2]都分别为1了，正好代表了可能的和2，3，5，这样我们遍历玩整个数组后，去看bits[sum &gt;&gt; 1]是否为1即可，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> canPartition(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        bitset</span>&lt;<span style="color: #800080;">5001</span>&gt; bits(<span style="color: #800080;">1</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">int</span> sum = accumulate(nums.begin(), nums.end(), <span style="color: #800080;">0</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> num : nums) bits |= bits &lt;&lt;<span style="color: #000000;"> num;
        </span><span style="color: #0000ff;">return</span> (sum % <span style="color: #800080;">2</span> == <span style="color: #800080;">0</span>) &amp;&amp; bits[sum &gt;&gt; <span style="color: #800080;">1</span><span style="color: #000000;">];
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/7733098.html">Partition to K Equal Sum Subset</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-10-12 07:42</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5951422" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5951422);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5944311.html" id="cb_post_title_url">[LeetCode] Add Strings 字符串相加</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given two non-negative numbers <code>num1</code> and <code>num2</code> represented as string, return the sum of <code>num1</code> and <code>num2</code>.</p>
<p><strong>Note:</strong></p>
<ol>
<li>The length of both <code>num1</code> and <code>num2</code> is &lt; 5100.</li>
<li>Both <code>num1</code> and <code>num2</code> contains only digits <code>0-9</code>.</li>
<li>Both <code>num1</code> and <code>num2</code> does not contain any leading zero.</li>
<li>You <strong>must not use any built-in BigInteger library</strong> or <strong>convert the inputs to integer</strong> directly.</li>
</ol>
<p> </p>
<p>这道题让我们求两个字符串的相加，之前LeetCode出过几道类似的题目，比如二进制数相加，还有链表相加，或是字符串加1，基本思路很类似，都是一位一位相加，然后算和算进位，最后根据进位情况看需不需要补一个高位，难度不大，参见代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> addStrings(<span style="color: #0000ff;">string</span> num1, <span style="color: #0000ff;">string</span><span style="color: #000000;"> num2) {
        </span><span style="color: #0000ff;">string</span> res = <span style="color: #800000;">""</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> m = num1.size(), n = num2.size(), i = m - <span style="color: #800080;">1</span>, j = n - <span style="color: #800080;">1</span>, carry = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (i &gt;= <span style="color: #800080;">0</span> || j &gt;= <span style="color: #800080;">0</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">int</span> a = i &gt;= <span style="color: #800080;">0</span> ? num1[i--] - <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span> : <span style="color: #800080;">0</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">int</span> b = j &gt;= <span style="color: #800080;">0</span> ? num2[j--] - <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span> : <span style="color: #800080;">0</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">int</span> sum = a + b +<span style="color: #000000;"> carry;
            res.insert(res.begin(), sum </span>% <span style="color: #800080;">10</span> + <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span><span style="color: #000000;">);
            carry </span>= sum / <span style="color: #800080;">10</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> carry ? <span style="color: #800000;">"</span><span style="color: #800000;">1</span><span style="color: #800000;">"</span> +<span style="color: #000000;"> res : res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4741028.html" target="_blank">Add Digits</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4084971.html" target="_blank">Add Binary</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4129891.html" target="_blank">Add Two Numbers</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-10-09 23:59</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5944311" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5944311);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5983113.html" id="cb_post_title_url">[LeetCode] Third Maximum Number 第三大的数</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a non-empty array of integers, return the third maximum number in this array. If it does not exist, return the maximum number. The time complexity must be in O(n).</p>
<p>Example 1:</p>
<pre>Input: [3, 2, 1]

Output: 1

Explanation: The third maximum is 1.
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input: [1, 2]

Output: 2

Explanation: The third maximum does not exist, so the maximum (2) is returned instead.
</pre>
<p> </p>
<p>Example 3:</p>
<pre>Input: [2, 2, 3, 1]

Output: 1

Explanation: Note that the third maximum here means the third maximum distinct number.
Both numbers with value 2 are both considered as second maximum.</pre>
<p> </p>
<p>这道题让我们求数组中第三大的数，如果不存在的话那么就返回最大的数，题目中说明了这里的第三大不能和第二大相同，必须是严格的小于，而并非小于等于。这道题并不是很难，如果知道怎么求第二大的数，那么求第三大的数的思路都是一样的。那么我们用三个变量first, second, third来分别保存第一大，第二大，和第三大的数，然后我们遍历数组，如果遍历到的数字大于当前第一大的数first，那么三个变量各自错位赋值，如果当前数字大于second，小于first，那么就更新second和third，如果当前数字大于third，小于second，那就只更新third，注意这里有个坑，就是初始化要用长整型long的最小值，否则当数组中有INT_MIN存在时，程序就不知道该返回INT_MIN还是最大值first了，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> thirdMax(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        </span><span style="color: #0000ff;">long</span> first = LONG_MIN, second = LONG_MIN, third =<span style="color: #000000;"> LONG_MIN;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span><span style="color: #000000;"> num : nums) {
            </span><span style="color: #0000ff;">if</span> (num &gt;<span style="color: #000000;"> first) {
                third </span>=<span style="color: #000000;"> second;
                second </span>=<span style="color: #000000;"> first;
                first </span>=<span style="color: #000000;"> num;
            } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (num &gt; second &amp;&amp; num &lt;<span style="color: #000000;"> first) {
                third </span>=<span style="color: #000000;"> second;
                second </span>=<span style="color: #000000;"> num;
            } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (num &gt; third &amp;&amp; num &lt;<span style="color: #000000;"> second) {
                third </span>=<span style="color: #000000;"> num;
            }
        }
        </span><span style="color: #0000ff;">return</span> (third == LONG_MIN || third == second) ?<span style="color: #000000;"> first : third;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种方法的时间复杂度是O(nlgn)，不符合题目要求，纯粹是拓宽下思路哈，利用了set的自动排序和自动去重复项的特性，很好的解决了问题，对于遍历到的数字，加入set中，重复项就自动去掉了，如果此时set大小大于3个了，那么我们把set的第一个元素去掉，也就是将第四大的数字去掉，那么就可以看出set始终维护的是最大的三个不同的数字，最后遍历结束后，我们看set的大小是否为3，是的话就返回首元素，不是的话就返回尾元素，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> thirdMax(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        </span><span style="color: #0000ff;">set</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> s;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span><span style="color: #000000;"> num : nums) {
            s.insert(num);
            </span><span style="color: #0000ff;">if</span> (s.size() &gt; <span style="color: #800080;">3</span><span style="color: #000000;">) {
                s.erase(s.begin());
            }
        }
        </span><span style="color: #0000ff;">return</span> s.size() == <span style="color: #800080;">3</span> ? *s.begin() : *<span style="color: #000000;">s.rbegin();
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/63903/short-easy-c-using-set" target="_blank">https://discuss.leetcode.com/topic/63903/short-easy-c-using-set</a></p>
<p> </p>
<p><a href="http://www.cnblogs.com/grandyang/p/4606334.html" target="_blank">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-10-20 23:47</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5983113" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5983113);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5968340.html" id="cb_post_title_url">[LeetCode] Arithmetic Slices 算数切片</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="row">
<div class="col-md-12">
<div class="row">
<div class="col-md-12">
<div class="question-content">
<p>A sequence of number is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.</p>
<p>For example, these are arithmetic sequence:</p>
<pre>1, 3, 5, 7, 9
7, 7, 7, 7
3, -1, -5, -9</pre>
<p>The following sequence is not arithmetic.</p>
<pre>1, 1, 2, 5, 7</pre>
<br/>
<p>A zero-indexed array A consisting of N numbers is given. A slice of that array is any pair of integers (P, Q) such that 0 &lt;= P &lt; Q &lt; N.</p>
<p>A slice (P, Q) of array A is called arithmetic if the sequence:<br/>A[P], A[p + 1], ..., A[Q - 1], A[Q] is arithmetic. In particular, this means that P + 1 &lt; Q.</p>
<p>The function should return the number of arithmetic slices in the array A.</p>
<br/>
<p>Example:</p>
<pre>A = [1, 2, 3, 4]

return: 3, for 3 arithmetic slices in A: [1, 2, 3], [2, 3, 4] and [1, 2, 3, 4] itself.
</pre>
<p> </p>
<div>
<div class="btn btn-xs btn-warning" id="company_tags">这道题让我们算一种算数切片，说白了就是找等差数列，限定了等差数列的长度至少为3，那么[1,2,3,4]含有3个长度至少为3的算数切片，我们再来看[1,2,3,4,5]有多少个呢:</div>
<div class="btn btn-xs btn-warning">len = 3: [1,2,3], [2,3,4], [3,4,5]</div>
<div class="btn btn-xs btn-warning">len = 4: [1,2,3,4], [2,3,4,5]</div>
<div class="btn btn-xs btn-warning">len = 5: [1,2,3,4,5]</div>
<div class="btn btn-xs btn-warning">那么我们可以找出递推式，长度为n的等差数列中含有长度至少为3的算数切片的个数为(n-1)(n-2)/2，那么题目就变成了找原数组中等差数列的长度，然后带入公式去算个数即可，参见代码如下：</div>
<div class="btn btn-xs btn-warning"> </div>
<div class="btn btn-xs btn-warning">解法一：</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="interviewed-div">
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> numberOfArithmeticSlices(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> A) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, len = <span style="color: #800080;">2</span>, n =<span style="color: #000000;"> A.size();
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">2</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (A[i] - A[i - <span style="color: #800080;">1</span>] == A[i - <span style="color: #800080;">1</span>] - A[i - <span style="color: #800080;">2</span><span style="color: #000000;">]) {
                </span>++<span style="color: #000000;">len;
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                </span><span style="color: #0000ff;">if</span> (len &gt; <span style="color: #800080;">2</span>) res += (len - <span style="color: #800080;">1</span>) * (len - <span style="color: #800080;">2</span>) * <span style="color: #800080;">0.5</span><span style="color: #000000;">;
                len </span>= <span style="color: #800080;">2</span><span style="color: #000000;">;
            }
        }
        </span><span style="color: #0000ff;">if</span> (len &gt; <span style="color: #800080;">2</span>) res += (len - <span style="color: #800080;">1</span>) * (len - <span style="color: #800080;">2</span>) * <span style="color: #800080;">0.5</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>我们还可以用DP来做，定义一个一维dp数组，其中dp[i]表示，到i位置为止的算数切片的个数，那么我们从第三个数字开始遍历，如果当前数字和之前两个数字构成算数切片，那么我们更新dp[i]为dp[i-1]+1，然后res累加上dp[i]的值即可：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> numberOfArithmeticSlices(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> A) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, n =<span style="color: #000000;"> A.size();
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; dp(n, <span style="color: #800080;">0</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">2</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (A[i] - A[i - <span style="color: #800080;">1</span>] == A[i - <span style="color: #800080;">1</span>] - A[i - <span style="color: #800080;">2</span><span style="color: #000000;">]) {
                dp[i] </span>= dp[i - <span style="color: #800080;">1</span>] + <span style="color: #800080;">1</span><span style="color: #000000;">;
            }
            res </span>+=<span style="color: #000000;"> dp[i];
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>我们还可以进一步优化空间，用一个变量来代替上面的数组，原理都一样，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> numberOfArithmeticSlices(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> A) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, cur = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">2</span>; i &lt; A.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (A[i] - A[i - <span style="color: #800080;">1</span>] == A[i - <span style="color: #800080;">1</span>] - A[i - <span style="color: #800080;">2</span><span style="color: #000000;">]) {
                cur </span>+= <span style="color: #800080;">1</span><span style="color: #000000;">;
                res </span>+=<span style="color: #000000;"> cur;
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                cur </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/63302/simple-java-solution-9-lines-2ms" target="_blank">https://discuss.leetcode.com/topic/63302/simple-java-solution-9-lines-2ms</a></p>
<p><a href="https://discuss.leetcode.com/topic/62992/3ms-c-standard-dp-solution-with-very-detailed-explanation" target="_blank">https://discuss.leetcode.com/topic/62992/3ms-c-standard-dp-solution-with-very-detailed-explanation</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p>
</div></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-10-17 01:27</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5968340" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5968340);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5966473.html" id="cb_post_title_url">[LeetCode] Fizz Buzz 嘶嘶嗡嗡</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Write a program that outputs the string representation of numbers from 1 to <em>n</em>.</p>
<p>But for multiples of three it should output “Fizz” instead of the number and for the multiples of five output “Buzz”. For numbers which are multiples of both three and five output “FizzBuzz”.</p>
<p>Example:</p>
<pre>n = 15,

Return:
[
    "1",
    "2",
    "Fizz",
    "4",
    "Buzz",
    "Fizz",
    "7",
    "8",
    "Fizz",
    "Buzz",
    "11",
    "Fizz",
    "13",
    "14",
    "FizzBuzz"
]</pre>
<p> </p>
<p>这道题真心没有什么可讲的，就是分情况处理就行了。</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; fizzBuzz(<span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        vector</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt;= n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (i % <span style="color: #800080;">15</span> == <span style="color: #800080;">0</span>) res.push_back(<span style="color: #800000;">"</span><span style="color: #800000;">FizzBuzz</span><span style="color: #800000;">"</span><span style="color: #000000;">);
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (i % <span style="color: #800080;">3</span> == <span style="color: #800080;">0</span>) res.push_back(<span style="color: #800000;">"</span><span style="color: #800000;">Fizz</span><span style="color: #800000;">"</span><span style="color: #000000;">);
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (i % <span style="color: #800080;">5</span> == <span style="color: #800080;">0</span>) res.push_back(<span style="color: #800000;">"</span><span style="color: #800000;">Buzz</span><span style="color: #800000;">"</span><span style="color: #000000;">);
            </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> res.push_back(to_string(i));
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-10-16 13:25</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5966473" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5966473);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5935836.html" id="cb_post_title_url">[LeetCode] Minimum Unique Word Abbreviation 最短的独一无二的单词缩写</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="row">
<div class="col-md-12">
<div class="row">
<div class="col-md-12">
<div class="question-content">
<p>A string such as <code>"word"</code> contains the following abbreviations:</p>
<pre>["word", "1ord", "w1rd", "wo1d", "wor1", "2rd", "w2d", "wo2", "1o1d", "1or1", "w1r1", "1o2", "2r1", "3d", "w3", "4"]
</pre>
<p>Given a target string and a set of strings in a dictionary, find an abbreviation of this target string with the<em>smallest possible</em> length such that it does not conflict with abbreviations of the strings in the dictionary.</p>
<p>Each number or letter in the abbreviation is considered length = 1. For example, the abbreviation "a32bc" has length = 4.</p>
<p>Note:</p>
<ul>
<li>In the case of multiple answers as shown in the second example below, you may return any one of them.</li>
<li>Assume length of target string = m, and dictionary size = n. You may assume that m ≤ 21, n ≤ 1000, and log2(n) + m ≤ 20.</li>
</ul>
<p> </p>
<p>Examples:</p>
<pre>"apple", ["blade"] -&gt; "a4" (because "5" or "4e" conflicts with "blade")

"apple", ["plain", "amber", "blade"] -&gt; "1p3" (other valid answers include "ap3", "a3e", "2p2", "3le", "3l1").
</pre>
<p> </p>
<p>这道题实际上是之前那两道<a href="http://www.cnblogs.com/grandyang/p/5930369.html">Valid Word Abbreviation</a>和<a href="http://www.cnblogs.com/grandyang/p/5261569.html" target="_blank">Generalized Abbreviation</a>的合体，我们的思路其实很简单，首先找出target的所有的单词缩写的形式，然后按照长度来排序，小的排前面，我们用优先队列来自动排序，里面存一个pair，保存单词缩写及其长度，然后我们从最短的单词缩写开始，跟dictionary中所有的单词一一进行验证，利用<a href="http://www.cnblogs.com/grandyang/p/5930369.html">Valid Word Abbreviation</a>中的方法，看其是否是合法的单词的缩写，如果是，说明有冲突，直接break，进行下一个单词缩写的验证，参见代码如下：</p>
<div> </div>
</div>
</div>
</div>
</div>
</div>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> minAbbreviation(<span style="color: #0000ff;">string</span> target, vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp;<span style="color: #000000;"> dictionary) {
        </span><span style="color: #0000ff;">if</span> (dictionary.empty()) <span style="color: #0000ff;">return</span> to_string((<span style="color: #0000ff;">int</span><span style="color: #000000;">)target.size());
        priority_queue</span>&lt;pair&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">string</span>&gt;, vector&lt;pair&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">string</span>&gt;&gt;, greater&lt;pair&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">string</span>&gt;&gt;&gt;<span style="color: #000000;"> q;
        q </span>=<span style="color: #000000;"> generate(target);
        </span><span style="color: #0000ff;">while</span> (!<span style="color: #000000;">q.empty()) {
            auto t </span>=<span style="color: #000000;"> q.top(); q.pop();
            </span><span style="color: #0000ff;">bool</span> no_conflict = <span style="color: #0000ff;">true</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">string</span><span style="color: #000000;"> word : dictionary) {
                </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (valid(word, t.second)) {
                    no_conflict </span>= <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                }
            }
            </span><span style="color: #0000ff;">if</span> (no_conflict) <span style="color: #0000ff;">return</span><span style="color: #000000;"> t.second;
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #800000;">""</span><span style="color: #000000;">;
    }
    priority_queue</span>&lt;pair&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">string</span>&gt;, vector&lt;pair&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">string</span>&gt;&gt;, greater&lt;pair&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">string</span>&gt;&gt;&gt; generate(<span style="color: #0000ff;">string</span><span style="color: #000000;"> target) {
        priority_queue</span>&lt;pair&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">string</span>&gt;, vector&lt;pair&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">string</span>&gt;&gt;, greater&lt;pair&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">string</span>&gt;&gt;&gt;<span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; pow(<span style="color: #800080;">2</span>, target.size()); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">string</span> <span style="color: #0000ff;">out</span> = <span style="color: #800000;">""</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">int</span> cnt = <span style="color: #800080;">0</span>, size = <span style="color: #800080;">0</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; target.size(); ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> ((i &gt;&gt; j) &amp; <span style="color: #800080;">1</span>) ++<span style="color: #000000;">cnt;
                </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    </span><span style="color: #0000ff;">if</span> (cnt != <span style="color: #800080;">0</span><span style="color: #000000;">) {
                        </span><span style="color: #0000ff;">out</span> +=<span style="color: #000000;"> to_string(cnt);
                        cnt </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
                        </span>++<span style="color: #000000;">size;
                    }
                    </span><span style="color: #0000ff;">out</span> +=<span style="color: #000000;"> target[j];
                    </span>++<span style="color: #000000;">size;
                }
            }
            </span><span style="color: #0000ff;">if</span> (cnt &gt; <span style="color: #800080;">0</span><span style="color: #000000;">) {
                </span><span style="color: #0000ff;">out</span> +=<span style="color: #000000;"> to_string(cnt);
                </span>++<span style="color: #000000;">size;
            }
            res.push({size, </span><span style="color: #0000ff;">out</span><span style="color: #000000;">});
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">bool</span> valid(<span style="color: #0000ff;">string</span> word, <span style="color: #0000ff;">string</span><span style="color: #000000;"> abbr) {
        </span><span style="color: #0000ff;">int</span> m = word.size(), n = abbr.size(), p = <span style="color: #800080;">0</span>, cnt = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; abbr.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (abbr[i] &gt;= <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span> &amp;&amp; abbr[i] &lt;= <span style="color: #800000;">'</span><span style="color: #800000;">9</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                </span><span style="color: #0000ff;">if</span> (cnt == <span style="color: #800080;">0</span> &amp;&amp; abbr[i] == <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span>) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                cnt </span>= <span style="color: #800080;">10</span> * cnt + abbr[i] - <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span><span style="color: #000000;">;
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                p </span>+=<span style="color: #000000;"> cnt;
                </span><span style="color: #0000ff;">if</span> (p &gt;= m || word[p++] != abbr[i]) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                cnt </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
            }
        }
        </span><span style="color: #0000ff;">return</span> p + cnt ==<span style="color: #000000;"> m;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/5930369.html">Valid Word Abbreviation</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/5261569.html" target="_blank">Generalized Abbreviation</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/5220589.html" target="_blank">Unique Word Abbreviation</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/61457/c-bit-manipulation-dfs-solution" target="_blank">https://discuss.leetcode.com/topic/61457/c-bit-manipulation-dfs-solution</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-10-07 13:27</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5935836" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5935836);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5933787.html" id="cb_post_title_url">[LeetCode] Split Array Largest Sum 分割数组的最大值</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given an array which consists of non-negative integers and an integer <em>m</em>, you can split the array into <em>m</em> non-empty continuous subarrays. Write an algorithm to minimize the largest sum among these <em>m</em> subarrays.</p>
<p>Note:<br/>Given <em>m</em> satisfies the following constraint: 1 ≤ m ≤ length(nums) ≤ 14,000.</p>
<p>Examples:</p>
<pre>Input:
nums = [7,2,5,10,8]
m = 2

Output:
18

Explanation:
There are four ways to split nums into two subarrays.
The best way is to split it into [7,2,5] and [10,8],
where the largest sum among the two subarrays is only 18.</pre>
<p> </p>
<p>这道题给了我们一个非负数的数组nums和一个整数m，让我们把数组分割成m个非空的连续子数组，让我们最小化m个子数组中的最大值。开始以为要用博弈论中的最小最大化算法，可是想了半天发现并不会做，于是后面决定采用无脑暴力破解，在nums中取出所有的m个子数组的情况都找一遍最大值，为了加快求子数组和的运算，还建立了累计和数组，可以还是TLE了，所以博主就没有办法了，只能上网参考大神们的解法，发现大家普遍使用了二分搜索法来做，感觉特别巧妙，原来二分搜索法还能这么用，厉害了我的哥。我们首先来分析，如果m和数组nums的个数相等，那么每个数组都是一个子数组，所以返回nums中最大的数字即可，如果m为1，那么整个nums数组就是一个子数组，返回nums所有数字之和，所以对于其他有效的m值，返回的值必定在上面两个值之间，所以我们可以用二分搜索法来做。我们用一个例子来分析，nums = [1, 2, 3, 4, 5], m = 3，我们将left设为数组中的最大值5，right设为数字之和15，然后我们算出中间数为10，我们接下来要做的是找出和最大且小于等于10的子数组的个数，[1, 2, 3, 4], [5]，可以看到我们无法分为3组，说明mid偏大，所以我们让right=mid，然后我们再次进行二分查找哦啊，算出mid=7，再次找出和最大且小于等于7的子数组的个数，[1,2,3], [4], [5]，我们成功的找出了三组，说明mid还可以进一步降低，我们让right=mid，然后我们再次进行二分查找哦啊，算出mid=6，再次找出和最大且小于等于6的子数组的个数，[1,2,3], [4], [5]，我们成功的找出了三组，我们尝试着继续降低mid，我们让right=mid，然后我们再次进行二分查找哦啊，算出mid=5，再次找出和最大且小于等于5的子数组的个数，[1,2], [3], [4], [5]，发现有4组，此时我们的mid太小了，应该增大mid，我们让left=mid+1，此时left=6，right=5，循环退出了，我们返回left即可，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> splitArray(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; nums, <span style="color: #0000ff;">int</span><span style="color: #000000;"> m) {
        </span><span style="color: #0000ff;">long</span> <span style="color: #0000ff;">long</span> left = <span style="color: #800080;">0</span>, right = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; nums.size(); ++<span style="color: #000000;">i) {
            left </span>= max((<span style="color: #0000ff;">int</span><span style="color: #000000;">)left, nums[i]);
            right </span>+=<span style="color: #000000;"> nums[i];
        }
        </span><span style="color: #0000ff;">while</span> (left &lt;<span style="color: #000000;"> right) {
            </span><span style="color: #0000ff;">long</span> <span style="color: #0000ff;">long</span> mid = left + (right - left) / <span style="color: #800080;">2</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> (can_split(nums, m, mid)) right =<span style="color: #000000;"> mid;
            </span><span style="color: #0000ff;">else</span> left = mid + <span style="color: #800080;">1</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> left;
    }
    </span><span style="color: #0000ff;">bool</span> can_split(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; nums, <span style="color: #0000ff;">int</span> m, <span style="color: #0000ff;">int</span><span style="color: #000000;"> sum) {
        </span><span style="color: #0000ff;">int</span> cnt = <span style="color: #800080;">1</span>, curSum = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; nums.size(); ++<span style="color: #000000;">i) {
            curSum </span>+=<span style="color: #000000;"> nums[i];
            </span><span style="color: #0000ff;">if</span> (curSum &gt;<span style="color: #000000;"> sum) {
                curSum </span>=<span style="color: #000000;"> nums[i];
                </span>++<span style="color: #000000;">cnt;
                </span><span style="color: #0000ff;">if</span> (cnt &gt; m) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            }
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>上面的解法相对来说比较难想，在热心网友<a href="http://www.cnblogs.com/perthblank/" id="a_comment_author_3613213" target="_blank">perthblank</a>的提醒下，我们再来看一种DP的解法，相对来说，这种方法应该更容易理解一些。我们建立一个二维数组dp，其中dp[i][j]表示将数组中前j个数字分成i组所能得到的最小的各个子数组中最大值，初始化为整型最大值，如果无法分为i组，那么还是保持为整型最大值。为了能快速的算出子数组之和，我们还是要建立累计和数组，难点就是在于要求递推公式了。我们来分析，如果前j个数字要分成i组，那么i的范围是什么，由于只有j个数字，如果每个数字都是单独的一组，那么最多有j组；如果将整个数组看为一个整体，那么最少有1组，所以i的范围是[1, j]，所以我们要遍历这中间所有的情况，假如中间任意一个位置k，dp[i-1][k]表示数组中前k个数字分成i-1组所能得到的最小的各个子数组中最大值，而sums[j]-sums[k]就是后面的数字之和，我们取二者之间的较大值，然后和dp[i][j]原有值进行对比，更新dp[i][j]为二者之中的较小值，这样k在[1, j]的范围内扫过一遍，dp[i][j]就能更新到最小值，我们最终返回dp[m][n]即可，博主认为这道题所用的思想应该是之前那道题<a href="http://www.cnblogs.com/grandyang/p/6657956.html" target="_blank">Reverse Pairs</a>中解法二中总结的分割重现关系(Partition Recurrence Relation)，由此看来很多问题的本质都是一样，但是披上华丽的外衣，难免会让人有些眼花缭乱了，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> splitArray(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; nums, <span style="color: #0000ff;">int</span><span style="color: #000000;"> m) {
        </span><span style="color: #0000ff;">int</span> n =<span style="color: #000000;"> nums.size();
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; sums(n + <span style="color: #800080;">1</span>, <span style="color: #800080;">0</span><span style="color: #000000;">);
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; dp(m + <span style="color: #800080;">1</span>, vector&lt;<span style="color: #0000ff;">int</span>&gt;(n + <span style="color: #800080;">1</span><span style="color: #000000;">, INT_MAX));
        dp[</span><span style="color: #800080;">0</span>][<span style="color: #800080;">0</span>] = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt;= n; ++<span style="color: #000000;">i) {
            sums[i] </span>= sums[i - <span style="color: #800080;">1</span>] + nums[i - <span style="color: #800080;">1</span><span style="color: #000000;">];
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt;= m; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">1</span>; j &lt;= n; ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> k = i - <span style="color: #800080;">1</span>; k &lt; j; ++<span style="color: #000000;">k) {
                    </span><span style="color: #0000ff;">int</span> val = max(dp[i - <span style="color: #800080;">1</span>][k], sums[j] -<span style="color: #000000;"> sums[k]);
                    dp[i][j] </span>=<span style="color: #000000;"> min(dp[i][j], val);
                }
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> dp[m][n];
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/61405/dp-java/2" target="_blank">https://discuss.leetcode.com/topic/61405/dp-java/2</a></p>
<p><a href="https://discuss.leetcode.com/topic/61314/binary-search-c-solution" target="_blank">https://discuss.leetcode.com/topic/61314/binary-search-c-solution</a></p>
<p><a href="https://discuss.leetcode.com/topic/61324/clear-explanation-8ms-binary-search-java" target="_blank">https://discuss.leetcode.com/topic/61324/clear-explanation-8ms-binary-search-java</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-10-06 14:11</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5933787" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5933787);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5931874.html" id="cb_post_title_url">[LeetCode] Longest Palindrome 最长回文串</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a string which consists of lowercase or uppercase letters, find the length of the longest palindromes that can be built with those letters.</p>
<p>This is case sensitive, for example <code>"Aa"</code> is not considered a palindrome here.</p>
<p><strong>Note:</strong><br/>
Assume the length of given string will not exceed 1,010.
</p>
<p><strong>Example: </strong>
</p>
<pre>Input:
"abccccdd"

Output:
7

Explanation:
One longest palindrome that can be built is "dccaccd", whose length is 7.
</pre>
<p> </p>
<p>这又是一道关于回文字符串的问题，LeetCode上关于回文串的题有十来道呢，也算一个比较重要的知识点。但是这道题确实不算一道难题，给了我们一个字符串，让我们找出可以组成的最长的回文串的长度，由于字符顺序可以打乱，所以问题就转化为了求偶数个字符的个数，我们了解回文串的都知道，回文串主要有两种形式，一个是左右完全对称的，比如noon, 还有一种是以中间字符为中心，左右对称，比如bob，level等，那么我们统计出来所有偶数个字符的出现总和，然后如果有奇数个字符的话，我们取取出其最大偶数，然后最后结果加1即可，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> longestPalindrome(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">bool</span> mid = <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        unordered_map</span>&lt;<span style="color: #0000ff;">char</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> m;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span> c : s) ++<span style="color: #000000;">m[c];
        </span><span style="color: #0000ff;">for</span> (auto it = m.begin(); it != m.end(); ++<span style="color: #000000;">it) {
            res </span>+= it-&gt;<span style="color: #000000;">second;
            </span><span style="color: #0000ff;">if</span> (it-&gt;second % <span style="color: #800080;">2</span> == <span style="color: #800080;">1</span><span style="color: #000000;">) {
                res </span>-= <span style="color: #800080;">1</span><span style="color: #000000;">;
                mid </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
            } 
        }
        </span><span style="color: #0000ff;">return</span> mid ? res + <span style="color: #800080;">1</span><span style="color: #000000;"> : res;
    }
};</span></pre>
</div>
<p> </p>
<p>上面那种方法是通过哈希表来建立字符串和其出现次数的映射，这里我们可以换一种思路，来找出搜有奇数个的字符，我们采用的方法是使用一个set集合，如果遍历到的字符不在set中，那么就将其加入set，如果已经在set里了，就将其从set中删去，这样遍历完成后set中就是所有出现个数是奇数个的字符了，那么我们最后只要用s的长度减去0和set长度减一之间的较大值即可，为啥这样呢，我们想，如果没有出现个数是奇数个的字符，那么t的长度就是0，减1成了-1，那么s的长度只要减去0即可；如果有奇数个的字符，那么字符个数减1，就是不能组成回文串的字符，因为回文串最多允许一个不成对出现的字符，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> longestPalindrome(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        unordered_set</span>&lt;<span style="color: #0000ff;">char</span>&gt;<span style="color: #000000;"> t;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span><span style="color: #000000;"> c : s) {
            </span><span style="color: #0000ff;">if</span> (!<span style="color: #000000;">t.count(c)) t.insert(c);
            </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> t.erase(c);
        }
        </span><span style="color: #0000ff;">return</span> s.size() - max(<span style="color: #800080;">0</span>, (<span style="color: #0000ff;">int</span>)t.size() - <span style="color: #800080;">1</span><span style="color: #000000;">);
    }
};</span></pre>
</div>
<p> </p>
<p>最后这种方法利用到了STL中的count函数，就是找字符串中某个字符出现的个数，那么我们和1相与，就可以知道该个数是奇数还是偶数了，返回的写法和上面那种方法相同，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> longestPalindrome(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        </span><span style="color: #0000ff;">int</span> odds = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span> c = <span style="color: #800000;">'</span><span style="color: #800000;">A</span><span style="color: #800000;">'</span>; c &lt;= <span style="color: #800000;">'</span><span style="color: #800000;">z</span><span style="color: #800000;">'</span>; ++<span style="color: #000000;">c) {
            odds </span>+= count(s.begin(), s.end(), c) &amp; <span style="color: #800080;">1</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> s.size() - max(<span style="color: #800080;">0</span>, odds - <span style="color: #800080;">1</span><span style="color: #000000;">);
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/5272039.html" target="_blank">Palindrome Pairs</a> </p>
<p><a href="http://www.cnblogs.com/grandyang/p/5315227.html" target="_blank">Palindrome Permutation II</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/5223238.html" target="_blank">Palindrome Permutation</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4635425.html">Palindrome Linked List</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4523624.html" target="_blank">Shortest Palindrome</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4271456.html" target="_blank">Palindrome Partitioning II</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4270008.html" target="_blank">Palindrome Partitioning</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4030114.html" target="_blank">Valid Palindrome</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4125510.html" target="_blank">Palindrome Number</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4464476.html" target="_blank">Longest Palindromic Substring</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/61338/what-are-the-odds-python-c" target="_blank">https://discuss.leetcode.com/topic/61338/what-are-the-odds-python-c</a></p>
<p><a href="https://discuss.leetcode.com/topic/61574/very-easy-to-understand-java-solution" target="_blank">https://discuss.leetcode.com/topic/61574/very-easy-to-understand-java-solution</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-10-05 10:45</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5931874" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5931874);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5930369.html" id="cb_post_title_url">[LeetCode] Valid Word Abbreviation 验证单词缩写</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a non-empty string <code>s</code> and an abbreviation <code>abbr</code>, return whether the string matches with the given abbreviation.</p>
<p>A string such as <code>"word"</code> contains only the following valid abbreviations:</p>
<pre>["word", "1ord", "w1rd", "wo1d", "wor1", "2rd", "w2d", "wo2", "1o1d", "1or1", "w1r1", "1o2", "2r1", "3d", "w3", "4"]
</pre>
<p>Notice that only the above abbreviations are valid abbreviations of the string <code>"word"</code>. Any other string is not a valid abbreviation of <code>"word"</code>.</p>
<p>Note:<br/>Assume <code>s</code> contains only lowercase letters and <code>abbr</code> contains only lowercase letters and digits.</p>
<p>Example 1:</p>
<pre>Given s = "internationalization", abbr = "i12iz4n":

Return true.
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Given s = "apple", abbr = "a2e":

Return false.</pre>
<p> </p>
<p>这道题让我们验证单词缩写，关于单词缩写LeetCode上还有两道相类似的题目<a href="http://www.cnblogs.com/grandyang/p/5220589.html" target="_blank">Unique Word Abbreviation</a>和<a href="http://www.cnblogs.com/grandyang/p/5261569.html" target="_blank">Generalized Abbreviation</a>。这道题给了我们一个单词和一个缩写形式，让我们验证这个缩写形式是否是正确的，由于题目中限定了单词中只有小写字母和数字，所以我们只要对这两种情况分别处理即可。我们使用双指针分别指向两个单词的开头，循环的条件是两个指针都没有到各自的末尾，如果指向缩写单词的指针指的是一个数字的话，如果当前数字是0，返回false，因为数字不能以0开头，然后我们要把该数字整体取出来，所以我们用一个while循环将数字整体取出来，然后指向原单词的指针也要对应的向后移动这么多位数。如果指向缩写单词的指针指的是一个字母的话，那么我们只要比两个指针指向的字母是否相同，不同则返回false，相同则两个指针均向后移动一位，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> validWordAbbreviation(<span style="color: #0000ff;">string</span> word, <span style="color: #0000ff;">string</span><span style="color: #000000;"> abbr) {
        </span><span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>, j = <span style="color: #800080;">0</span>, m = word.size(), n =<span style="color: #000000;"> abbr.size();
        </span><span style="color: #0000ff;">while</span> (i &lt; m &amp;&amp; j &lt;<span style="color: #000000;"> n) {
            </span><span style="color: #0000ff;">if</span> (abbr[j] &gt;= <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span> &amp;&amp; abbr[j] &lt;= <span style="color: #800000;">'</span><span style="color: #800000;">9</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                </span><span style="color: #0000ff;">if</span> (abbr[j] == <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span>) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">int</span> val = <span style="color: #800080;">0</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">while</span> (j &lt; n &amp;&amp; abbr[j] &gt;= <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span> &amp;&amp; abbr[j] &lt;= <span style="color: #800000;">'</span><span style="color: #800000;">9</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                    val </span>= val * <span style="color: #800080;">10</span> + abbr[j++] - <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span><span style="color: #000000;">;
                }
                i </span>+=<span style="color: #000000;"> val;
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                </span><span style="color: #0000ff;">if</span> (word[i++] != abbr[j++]) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            }
        }
        </span><span style="color: #0000ff;">return</span> i == m &amp;&amp; j ==<span style="color: #000000;"> n;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种方法和上面的方法稍有不同，这里是用了一个for循环来遍历缩写单词的所有字符，然后用一个指针p来指向与其对应的原单词的位置，然后cnt表示当前读取查出来的数字，如果读取的是数字，我们先排除首位是0的情况，然后cnt做累加；如果读取的是字母，那么指针p向后移动cnt位，如果p到超过范围了，或者p指向的字符和当前遍历到的缩写单词的字符不相等，则返回false，反之则给cnt置零继续循环，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> validWordAbbreviation(<span style="color: #0000ff;">string</span> word, <span style="color: #0000ff;">string</span><span style="color: #000000;"> abbr) {
        </span><span style="color: #0000ff;">int</span> m = word.size(), n = abbr.size(), p = <span style="color: #800080;">0</span>, cnt = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; abbr.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (abbr[i] &gt;= <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span> &amp;&amp; abbr[i] &lt;= <span style="color: #800000;">'</span><span style="color: #800000;">9</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                </span><span style="color: #0000ff;">if</span> (cnt == <span style="color: #800080;">0</span> &amp;&amp; abbr[i] == <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span>) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                cnt </span>= <span style="color: #800080;">10</span> * cnt + abbr[i] - <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span><span style="color: #000000;">;
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                p </span>+=<span style="color: #000000;"> cnt;
                </span><span style="color: #0000ff;">if</span> (p &gt;= m || word[p++] != abbr[i]) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                cnt </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
            }
        }
        </span><span style="color: #0000ff;">return</span> p + cnt ==<span style="color: #000000;"> m;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/5220589.html" target="_blank">Unique Word Abbreviation</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/5261569.html" target="_blank">Generalized Abbreviation</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/61404/concise-c-solution" target="_blank">https://discuss.leetcode.com/topic/61404/concise-c-solution</a></p>
<p><a href="https://discuss.leetcode.com/topic/61430/java-2-pointers-15-lines" target="_blank">https://discuss.leetcode.com/topic/61430/java-2-pointers-15-lines</a></p>
<p><a href="https://discuss.leetcode.com/topic/61353/simple-regex-one-liner-java-python" target="_blank">https://discuss.leetcode.com/topic/61353/simple-regex-one-liner-java-python</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-10-04 13:09</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5930369" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5930369);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5928987.html" id="cb_post_title_url">[LeetCode] Trapping Rain Water II 收集雨水之二</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given an <code>m x n</code> matrix of positive integers representing the height of each unit cell in a 2D elevation map, compute the volume of water it is able to trap after raining.</p>
<p><strong>Note:</strong><br/>
Both <em>m</em> and <em>n</em> are less than 110. The height of each unit cell is greater than 0 and is less than 20,000.
</p>
<p><strong>Example:</strong>
</p>
<pre>Given the following 3x6 height map:
[
  [1,4,3,1,3,2],
  [3,2,1,3,2,4],
  [2,3,3,2,3,1]
]

Return 4.
</pre>
<p> <img alt="" src="https://leetcode.com/static/images/problemset/rainwater_empty.png"/><br/>
The above image represents the elevation map <code>[[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]]</code> before the rain.
</p>
<p>
<img alt="" src="https://leetcode.com/static/images/problemset/rainwater_fill.png"/><br/>
After the rain, water are trapped between the blocks. The total volume of water trapped is 4.
</p>
<p> </p>
<p>这道题是之前那道<a href="http://www.cnblogs.com/grandyang/p/4402392.html" target="_blank">Trapping Rain Water</a>的拓展，由2D变3D了，感觉很叼。但其实解法跟之前的完全不同了，之前那道题由于是二维的，我们可以用双指针来做，而这道三维的，我们需要用BFS来做，解法思路很巧妙，下面我们就以题目中的例子来进行分析讲解，多图预警，手机流量党慎入：</p>
<p>首先我们应该能分析出，能装水的底面肯定不能在边界上，因为边界上的点无法封闭，那么所有边界上的点都可以加入queue，当作BFS的启动点，同时我们需要一个二维数组来标记访问过的点，访问过的点我们用红色来表示，那么如下图所示：</p>
<p><img alt="" height="326" src="https://images2015.cnblogs.com/blog/391947/201610/391947-20161003120051785-2137527353.jpg" width="481"/></p>
<p>我们再想想，怎么样可以成功的装进去水呢，是不是周围的高度都应该比当前的高度高，形成一个凹槽才能装水，而且装水量取决于周围最小的那个高度，有点像木桶原理的感觉，那么为了模拟这种方法，我们采用模拟海平面上升的方法来做，我们维护一个海平面高度mx，初始化为最小值，从1开始往上升，那么我们BFS遍历的时候就需要从高度最小的格子开始遍历，那么我们的queue就不能使用普通队列了，而是使用优先级队列，将高度小的放在队首，最先取出，这样我们就可以遍历高度为1的三个格子，用绿色标记出来了，如下图所示：</p>
<p><img alt="" height="326" src="https://images2015.cnblogs.com/blog/391947/201610/391947-20161003120900692-314831597.jpg" width="481"/></p>
<p>如上图所示，向周围BFS搜索的条件是不能越界，且周围格子未被访问，那么可以看出上面的第一个和最后一个绿格子无法进一步搜索，只有第一行中间那个绿格子可以搜索，其周围有一个灰格子未被访问过，将其加入优先队列queue中，然后标记为红色，如下图所示：</p>
<p><img alt="" height="327" src="https://images2015.cnblogs.com/blog/391947/201610/391947-20161003121601785-791353712.jpg" width="483"/></p>
<p>那么优先队列queue中高度为1的格子遍历完了，此时海平面上升1，变为2，此时我们遍历优先队列queue中高度为2的格子，有3个，如下图绿色标记所示：</p>
<p><img alt="" height="328" src="https://images2015.cnblogs.com/blog/391947/201610/391947-20161003121753379-2129390635.jpg" width="484"/></p>
<p>我们发现这三个绿格子周围的格子均已被访问过了，所以不做任何操作，海平面继续上升，变为4，遍历所有高度为4的格子，如下图绿色标记所示：</p>
<p><img alt="" height="326" src="https://images2015.cnblogs.com/blog/391947/201610/391947-20161003121905207-4147516.jpg" width="481"/></p>
<p>由于我们没有特别声明高度相同的格子在优先队列queue中的顺序，所以应该是随机的，其实谁先遍历到都一样，对结果没啥影响，我们就假设第一行的两个绿格子先遍历到，那么那么周围各有一个灰格子可以遍历，这两个灰格子比海平面低了，可以存水了，把存水量算出来加入结果res中，如下图所示：</p>
<p><img alt="" height="329" src="https://images2015.cnblogs.com/blog/391947/201610/391947-20161003122502614-299103818.jpg" width="486"/></p>
<p>上图中这两个遍历到的蓝格子会被加入优先队列queue中，由于它们的高度小，所以下一次从优先队列queue中取格子时，它们会被优先遍历到，那么左边的那个蓝格子进行BFS搜索，就会遍历到其左边的那个灰格子，由于其高度小于海平面，也可以存水，将存水量算出来加入结果res中，如下图所示：</p>
<p><img alt="" height="329" src="https://images2015.cnblogs.com/blog/391947/201610/391947-20161003122735129-1777610725.jpg" width="486"/></p>
<p>等两个绿格子遍历结束了，它们会被标记为红色，蓝格子遍历会先被标记红色，然后加入优先队列queue中，由于其周围格子全变成红色了，所有不会有任何操作，如下图所示：</p>
<p><img alt="" height="330" src="https://images2015.cnblogs.com/blog/391947/201610/391947-20161003122909770-1492433975.jpg" width="488"/></p>
<p>此时所有的格子都标记为红色了，海平面继续上升，继续遍历完优先队列queue中的格子，不过已经不会对结果有任何影响了，因为所有的格子都已经访问过了，此时等循环结束后返回res即可，参见代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> trapRainWater(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> heightMap) {
        </span><span style="color: #0000ff;">if</span> (heightMap.empty()) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> m = heightMap.size(), n = heightMap[<span style="color: #800080;">0</span>].size(), res = <span style="color: #800080;">0</span>, mx =<span style="color: #000000;"> INT_MIN;
        priority_queue</span>&lt;pair&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;, vector&lt;pair&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;&gt;, greater&lt;pair&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;&gt;&gt;<span style="color: #000000;"> q;
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">bool</span>&gt;&gt; visited(m, vector&lt;<span style="color: #0000ff;">bool</span>&gt;(n, <span style="color: #0000ff;">false</span><span style="color: #000000;">));
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; dir{{<span style="color: #800080;">0</span>,-<span style="color: #800080;">1</span>},{-<span style="color: #800080;">1</span>,<span style="color: #800080;">0</span>},{<span style="color: #800080;">0</span>,<span style="color: #800080;">1</span>},{<span style="color: #800080;">1</span>,<span style="color: #800080;">0</span><span style="color: #000000;">}};
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; m; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; n; ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> (i == <span style="color: #800080;">0</span> || i == m - <span style="color: #800080;">1</span> || j == <span style="color: #800080;">0</span> || j == n - <span style="color: #800080;">1</span><span style="color: #000000;">) {
                    q.push({heightMap[i][j], i </span>* n +<span style="color: #000000;"> j});
                    visited[i][j] </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                }
            }
        }
        </span><span style="color: #0000ff;">while</span> (!<span style="color: #000000;">q.empty()) {
            auto t </span>=<span style="color: #000000;"> q.top(); q.pop();
            </span><span style="color: #0000ff;">int</span> h = t.first, r = t.second / n, c = t.second %<span style="color: #000000;"> n;
            mx </span>=<span style="color: #000000;"> max(mx, h);
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; dir.size(); ++<span style="color: #000000;">i) {
                </span><span style="color: #0000ff;">int</span> x = r + dir[i][<span style="color: #800080;">0</span>], y = c + dir[i][<span style="color: #800080;">1</span><span style="color: #000000;">];
                </span><span style="color: #0000ff;">if</span> (x &lt; <span style="color: #800080;">0</span> || x &gt;= m || y &lt; <span style="color: #800080;">0</span> || y &gt;= n || visited[x][y]) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                visited[x][y] </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">if</span> (heightMap[x][y] &lt; mx) res += mx -<span style="color: #000000;"> heightMap[x][y];
                q.push({heightMap[x][y], x </span>* n +<span style="color: #000000;"> y});
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4402392.html" target="_blank">Trapping Rain Water</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/60914/concise-c-priority_queue-solution" target="_blank">https://discuss.leetcode.com/topic/60914/concise-c-priority_queue-solution</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-10-03 12:32</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5928987" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5928987);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5928417.html" id="cb_post_title_url">[LeetCode] Queue Reconstruction by Height 根据高度重建队列</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Suppose you have a random list of people standing in a queue. Each person is described by a pair of integers<code>(h, k)</code>, where <code>h</code> is the height of the person and <code>k</code> is the number of people in front of this person who have a height greater than or equal to <code>h</code>. Write an algorithm to reconstruct the queue.</p>
<p>Note:<br/>The number of people is less than 1,100.</p>
<p>Example</p>
<pre>Input:
[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]

Output:
[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]</pre>
<p> </p>
<p>这道题给了我们一个队列，队列中的每个元素是一个pair，分别为身高和前面身高不低于当前身高的人的个数，让我们重新排列队列，使得每个pair的第二个参数都满足题意。首先我们来看一种超级简洁的方法，不得不膜拜想出这种解法的大神。首先我们给队列先排个序，按照身高高的排前面，如果身高相同，则第二个数小的排前面。然后我们新建一个空的数组，遍历之前排好序的数组，然后根据每个元素的第二个数字，将其插入到res数组中对应的位置，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;pair&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;&gt; reconstructQueue(vector&lt;pair&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> people) {
        sort(people.begin(), people.end(), [](</span><span style="color: #0000ff;">const</span> pair&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;&amp; a, <span style="color: #0000ff;">const</span> pair&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> b) {
            </span><span style="color: #0000ff;">return</span> a.first &gt; b.first || (a.first == b.first &amp;&amp; a.second &lt;<span style="color: #000000;"> b.second);
        });
        vector</span>&lt;pair&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;&gt;<span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto a : people) {
            res.insert(res.begin() </span>+<span style="color: #000000;"> a.second, a);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>上面那种方法是简洁，但是用到了额外空间，我们来看一种不使用额外空间的解法，这种方法没有没有使用vector自带的insert或者erase函数，而是通过一个变量cnt和k的关系来将元素向前移动到正确位置，移动到方法是通过每次跟前面的元素交换位置，使用题目中给的例子来演示过程：</p>
<p>[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]</p>
<p>排序后：</p>
<p>[[7,0], [7,1], [6,1], [5,0], [5,2], [4,4]]</p>
<p>交换顺序：</p>
<p>[[7,0], <span style="color: #ff0000;">[6,1]</span>, <span style="color: #000000;">[7,1]</span>, [5,0], [5,2], [4,4]]</p>
<p>[<span style="color: #ff0000;">[5,0],</span> [7,0], [6,1],<span style="color: #000000;"> [7,1],</span> [5,2], [4,4]]</p>
<p>[[5,0], [7,0], <span style="color: #ff0000;">[5,2]</span>, [6,1], [7,1], [4,4]]</p>
<p>[[5,0], [7,0], [5,2], [6,1], <span style="color: #ff0000;">[4,4]</span>, [7,1]]</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;pair&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;&gt; reconstructQueue(vector&lt;pair&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> people) {
        sort(people.begin(), people.end(), [](</span><span style="color: #0000ff;">const</span> pair&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;&amp; a, <span style="color: #0000ff;">const</span> pair&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> b) {
            </span><span style="color: #0000ff;">return</span> a.first &gt; b.first || (a.first == b.first &amp;&amp; a.second &lt;<span style="color: #000000;"> b.second);
        });
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt; people.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">int</span> cnt = <span style="color: #800080;">0</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; i; ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> (cnt ==<span style="color: #000000;"> people[i].second) {
                    pair</span>&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt; t =<span style="color: #000000;"> people[i];
                    </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> k = i - <span style="color: #800080;">1</span>; k &gt;= j; --<span style="color: #000000;">k) {
                        people[k </span>+ <span style="color: #800080;">1</span>] =<span style="color: #000000;"> people[k];
                    }
                    people[j] </span>=<span style="color: #000000;"> t;
                    </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                }
                </span><span style="color: #0000ff;">if</span> (people[j].first &gt;= people[i].first) ++<span style="color: #000000;">cnt;
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> people;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种解法跟解法一很相似，只不过没有使用额外空间，而是直接把位置不对的元素从原数组中删除，直接加入到正确的位置上，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;pair&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;&gt; reconstructQueue(vector&lt;pair&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> people) {
        sort(people.begin(), people.end(), [](</span><span style="color: #0000ff;">const</span> pair&lt;<span style="color: #0000ff;">int</span>,<span style="color: #0000ff;">int</span>&gt; &amp;a, <span style="color: #0000ff;">const</span> pair&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt; &amp;<span style="color: #000000;">b) {
            </span><span style="color: #0000ff;">return</span> a.first &gt; b.first || (a.first == b.first &amp;&amp; a.second &lt;<span style="color: #000000;"> b.second);
        });
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; people.size(); i++<span style="color: #000000;">) {
            auto p </span>=<span style="color: #000000;"> people[i];
            </span><span style="color: #0000ff;">if</span> (p.second !=<span style="color: #000000;"> i) {
                people.erase(people.begin() </span>+<span style="color: #000000;"> i);
                people.insert(people.begin() </span>+<span style="color: #000000;"> p.second, p);
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> people;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/5078490.html">Count of Smaller Numbers After Self</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/60394/easy-concept-with-python-c-java-solution/3" target="_blank">https://discuss.leetcode.com/topic/60394/easy-concept-with-python-c-java-solution/3</a></p>
<p><a href="https://discuss.leetcode.com/topic/60413/short-java-solution-without-using-extra-space" target="_blank">https://discuss.leetcode.com/topic/60413/short-java-solution-without-using-extra-space</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-10-02 23:58</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5928417" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5928417);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5926674.html" id="cb_post_title_url">[LeetCode] Convert a Number to Hexadecimal 数字转为十六进制</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given an integer, write an algorithm to convert it to hexadecimal. For negative integer, <a href="https://en.wikipedia.org/wiki/Two%27s_complement" target="_blank">two’s complement</a> method is used.</p>
<p>Note:</p>
<ol>
<li>All letters in hexadecimal (<code>a-f</code>) must be in lowercase.</li>
<li>The hexadecimal string must not contain extra leading <code>0</code>s. If the number is zero, it is represented by a single zero character <code>'0'</code>; otherwise, the first character in the hexadecimal string will not be the zero character.</li>
<li>The given number is guaranteed to fit within the range of a 32-bit signed integer.</li>
<li>You must not use <em>any</em> method provided by the library which converts/formats the number to hex directly.</li>
</ol>
<p> </p>
<p>Example 1:</p>
<pre>Input:
26

Output:
"1a"
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input:
-1

Output:
"ffffffff"</pre>
<p> </p>
<p>这道题给了我们一个数字，让我们转化为十六进制，抛开题目，我们应该都会把一个十进制数转为十六进制数，比如50，转为十六进制数，我们先对50除以16，商3余2，那么转为十六进制数就是32。所以我们就按照这个思路来写代码，由于输入数字的大小限制为int型，我们对于负数的处理方法是用其补码来运算，那么数字范围就是0到UINT_MAX，即为16^8-1，那么最高位就是16^7，我们首先除以这个数字，如果商大于等于10，我们用字母代替，否则就是用数字代替，然后对其余数进行同样的处理，一直到当前数字为0停止，最后我们还要补齐末尾的0，方法根据n的值，比-1大多少就补多少个0。由于题目中说明了最高位不能有多余的0，所以我们将起始0移除，如果res为空了，我们就返回0即可，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> toHex(<span style="color: #0000ff;">int</span><span style="color: #000000;"> num) {
        </span><span style="color: #0000ff;">string</span> res = <span style="color: #800000;">""</span><span style="color: #000000;">;
        vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; v{<span style="color: #800000;">"</span><span style="color: #800000;">a</span><span style="color: #800000;">"</span>,<span style="color: #800000;">"</span><span style="color: #800000;">b</span><span style="color: #800000;">"</span>,<span style="color: #800000;">"</span><span style="color: #800000;">c</span><span style="color: #800000;">"</span>,<span style="color: #800000;">"</span><span style="color: #800000;">d</span><span style="color: #800000;">"</span>,<span style="color: #800000;">"</span><span style="color: #800000;">e</span><span style="color: #800000;">"</span>,<span style="color: #800000;">"</span><span style="color: #800000;">f</span><span style="color: #800000;">"</span><span style="color: #000000;">};
        </span><span style="color: #0000ff;">int</span> n = <span style="color: #800080;">7</span><span style="color: #000000;">;
        unsigned </span><span style="color: #0000ff;">int</span> x =<span style="color: #000000;"> num;
        </span><span style="color: #0000ff;">if</span> (num &lt; <span style="color: #800080;">0</span>) x = UINT_MAX + num + <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (x &gt; <span style="color: #800080;">0</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">int</span> t = pow(<span style="color: #800080;">16</span><span style="color: #000000;">, n);
            </span><span style="color: #0000ff;">int</span> d = x /<span style="color: #000000;"> t;
            </span><span style="color: #0000ff;">if</span> (d &gt;= <span style="color: #800080;">10</span>) res += v[d - <span style="color: #800080;">10</span><span style="color: #000000;">];
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (d &gt;= <span style="color: #800080;">0</span>) res +=<span style="color: #000000;"> to_string(d);
            x </span>%=<span style="color: #000000;"> t;
            </span>--<span style="color: #000000;">n;
        }
        </span><span style="color: #0000ff;">while</span> (n-- &gt;= <span style="color: #800080;">0</span>) res += to_string(<span style="color: #800080;">0</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">while</span> (!res.empty() &amp;&amp; res[<span style="color: #800080;">0</span>] == <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span><span style="color: #000000;">) res.erase(res.begin());
        </span><span style="color: #0000ff;">return</span> res.empty() ? <span style="color: #800000;">"</span><span style="color: #800000;">0</span><span style="color: #800000;">"</span><span style="color: #000000;"> : res;
    }
};</span></pre>
</div>
<p> </p>
<p>上述方法稍稍复杂一些，我们来看一种更简洁的方法，我们采取位操作的思路，每次取出最右边四位，如果其大于等于10，找到对应的字母加入结果，反之则将对应的数字加入结果，然后num像右平移四位，循环停止的条件是num为0，或者是已经循环了7次，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> toHex(<span style="color: #0000ff;">int</span><span style="color: #000000;"> num) {
        </span><span style="color: #0000ff;">string</span> res = <span style="color: #800000;">""</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; num &amp;&amp; i &lt; <span style="color: #800080;">8</span>; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">int</span> t = num &amp; <span style="color: #800080;">0xf</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> (t &gt;= <span style="color: #800080;">10</span>) res = <span style="color: #0000ff;">char</span>(<span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span> + t - <span style="color: #800080;">10</span>) +<span style="color: #000000;"> res;
            </span><span style="color: #0000ff;">else</span> res = <span style="color: #0000ff;">char</span>(<span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span> + t) +<span style="color: #000000;"> res;
            num </span>&gt;&gt;= <span style="color: #800080;">4</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> res.empty() ? <span style="color: #800000;">"</span><span style="color: #800000;">0</span><span style="color: #800000;">"</span><span style="color: #000000;"> : res;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种写法更加简洁一些，虽然思路跟解法二并没有什么区别，但是我们把要转换的十六进制的数字字母都放在一个字符串中，按位置直接取就可以了，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> toHex(<span style="color: #0000ff;">int</span><span style="color: #000000;"> num) {
        </span><span style="color: #0000ff;">string</span> res = <span style="color: #800000;">""</span>, str = <span style="color: #800000;">"</span><span style="color: #800000;">0123456789abcdef</span><span style="color: #800000;">"</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> cnt = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (num != <span style="color: #800080;">0</span> &amp;&amp; cnt++ &lt; <span style="color: #800080;">8</span><span style="color: #000000;">) {
            res </span>= str[(num &amp; <span style="color: #800080;">0xf</span>)] +<span style="color: #000000;"> res;
            num </span>&gt;&gt;= <span style="color: #800080;">4</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> res.empty() ? <span style="color: #800000;">"</span><span style="color: #800000;">0</span><span style="color: #800000;">"</span><span style="color: #000000;"> : res;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/60431/concise-c-solution" target="_blank">https://discuss.leetcode.com/topic/60431/concise-c-solution</a></p>
<p><a href="https://discuss.leetcode.com/topic/60365/simple-java-solution-with-comment" target="_blank">https://discuss.leetcode.com/topic/60365/simple-java-solution-with-comment</a></p>
<p><a href="https://discuss.leetcode.com/topic/60412/concise-10-line-c-solution-for-both-positive-and-negative-input" target="_blank">https://discuss.leetcode.com/topic/60412/concise-10-line-c-solution-for-both-positive-and-negative-input</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-10-01 23:53</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5926674" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5926674);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5923559.html" id="cb_post_title_url">[LeetCode] Sum of Left Leaves 左子叶之和</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Find the sum of all left leaves in a given binary tree.</p>
<p>Example:</p>
<pre>    3
   / \
  9  20
    /  \
   15   7

There are two left leaves in the binary tree, with values 9 and 15 respectively. Return 24.</pre>
<p> </p>
<p>这道题让我们求一棵二叉树的所有左子叶的和，那么看到这道题我们知道这肯定是考二叉树的遍历问题，那么最简洁的写法肯定是用递归，由于我们只需要累加左子叶之和，那么我们在进入递归函数的时候需要知道当前结点是否是左子节点，如果是左子节点，而且该左子节点再没有子节点了说明其是左子叶，那么我们将其值加入结果res中，我们用一个bool型的变量，如果为true说明当前结点是左子节点，若为false则说明是右子节点，不做特殊处理，整个来说就是个递归的先序遍历的写法，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> sumOfLeftLeaves(TreeNode*<span style="color: #000000;"> root) {
        </span><span style="color: #0000ff;">if</span> (!root || (!root-&gt;left &amp;&amp; !root-&gt;right)) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        helper(root</span>-&gt;left, <span style="color: #0000ff;">true</span><span style="color: #000000;">, res);
        helper(root</span>-&gt;right, <span style="color: #0000ff;">false</span><span style="color: #000000;">, res);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">void</span> helper(TreeNode* node, <span style="color: #0000ff;">bool</span> left, <span style="color: #0000ff;">int</span>&amp;<span style="color: #000000;"> res) {
        </span><span style="color: #0000ff;">if</span> (!node) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (!node-&gt;left &amp;&amp; !node-&gt;right &amp;&amp; left) res += node-&gt;<span style="color: #000000;">val;
        helper(node</span>-&gt;left, <span style="color: #0000ff;">true</span><span style="color: #000000;">, res);
        helper(node</span>-&gt;right, <span style="color: #0000ff;">false</span><span style="color: #000000;">, res);
    }
};</span></pre>
</div>
<p> </p>
<p>我们还可以写的更简洁一些，不需要写其他的函数，直接在原函数中检查当前节点的左子节点是否是左子叶，如果是的话，则返回左子叶的值加上对当前结点的右子节点调用递归的结果；如果不是的话，我们对左右子节点分别调用递归函数，返回二者之和，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> sumOfLeftLeaves(TreeNode*<span style="color: #000000;"> root) {
        </span><span style="color: #0000ff;">if</span> (!root) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (root-&gt;left &amp;&amp; !root-&gt;left-&gt;left &amp;&amp; !root-&gt;left-&gt;<span style="color: #000000;">right) {
            </span><span style="color: #0000ff;">return</span> root-&gt;left-&gt;val + sumOfLeftLeaves(root-&gt;<span style="color: #000000;">right);
        }
        </span><span style="color: #0000ff;">return</span> sumOfLeftLeaves(root-&gt;left) + sumOfLeftLeaves(root-&gt;<span style="color: #000000;">right);
    }
};</span></pre>
</div>
<p> </p>
<p>我们也可以使用迭代来解，因为这道题的本质是遍历二叉树，所以我们可以用层序遍历的迭代写法，利用queue来辅助，注意对左子叶的判断和处理，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> sumOfLeftLeaves(TreeNode*<span style="color: #000000;"> root) {
        </span><span style="color: #0000ff;">if</span> (!root || (!root-&gt;left &amp;&amp; !root-&gt;right)) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        queue</span>&lt;TreeNode*&gt;<span style="color: #000000;"> q;
        q.push(root);
        </span><span style="color: #0000ff;">while</span> (!<span style="color: #000000;">q.empty()) {
            TreeNode </span>*t =<span style="color: #000000;"> q.front(); q.pop();
            </span><span style="color: #0000ff;">if</span> (t-&gt;left &amp;&amp; !t-&gt;left-&gt;left &amp;&amp; !t-&gt;left-&gt;right) res += t-&gt;left-&gt;<span style="color: #000000;">val;
            </span><span style="color: #0000ff;">if</span> (t-&gt;left) q.push(t-&gt;<span style="color: #000000;">left);
            </span><span style="color: #0000ff;">if</span> (t-&gt;right) q.push(t-&gt;<span style="color: #000000;">right);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>我们也可以用stack来辅助，对比上面的解法，我们发现几乎一模一样，只是把queue换成了stack，但实际上遍历的顺序不同，这种方法是先序遍历的迭代写法，参见代码如下：</p>
<p> </p>
<p>解法四：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> sumOfLeftLeaves(TreeNode*<span style="color: #000000;"> root) {
        </span><span style="color: #0000ff;">if</span> (!root || (!root-&gt;left &amp;&amp; !root-&gt;right)) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        stack</span>&lt;TreeNode*&gt;<span style="color: #000000;"> s;
        s.push(root);
        </span><span style="color: #0000ff;">while</span> (!<span style="color: #000000;">s.empty()) {
            TreeNode </span>*t =<span style="color: #000000;"> s.top(); s.pop();
            </span><span style="color: #0000ff;">if</span> (t-&gt;left &amp;&amp; !t-&gt;left-&gt;left &amp;&amp; !t-&gt;left-&gt;right) res += t-&gt;left-&gt;<span style="color: #000000;">val;
            </span><span style="color: #0000ff;">if</span> (t-&gt;left) s.push(t-&gt;<span style="color: #000000;">left);
            </span><span style="color: #0000ff;">if</span> (t-&gt;right) s.push(t-&gt;<span style="color: #000000;">right);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/60467/3-line-c-solution" target="_blank">https://discuss.leetcode.com/topic/60467/3-line-c-solution</a></p>
<p><a href="https://discuss.leetcode.com/topic/60381/java-solution-using-bfs" target="_blank">https://discuss.leetcode.com/topic/60381/java-solution-using-bfs</a></p>
<p><a href="https://discuss.leetcode.com/topic/60415/java-solution-with-stack" target="_blank">https://discuss.leetcode.com/topic/60415/java-solution-with-stack</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-09-30 13:40</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5923559" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5923559);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5888439.html" id="cb_post_title_url">[LeetCode] Frog Jump 青蛙过河</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>A frog is crossing a river. The river is divided into x units and at each unit there may or may not exist a stone. The frog can jump on a stone, but it must not jump into the water.</p>
<p>Given a list of stones' positions (in units) in sorted ascending order, determine if the frog is able to cross the river by landing on the last stone. Initially, the frog is on the first stone and assume the first jump must be 1 unit.</p>
<p>If the frog's last jump was <em>k</em> units, then its next jump must be either <em>k</em> - 1, <em>k</em>, or <em>k</em> + 1 units. Note that the frog can only jump in the forward direction.</p>
<p>Note:</p>
<ul>
<li>The number of stones is ≥ 2 and is &lt; 1,100.</li>
<li>Each stone's position will be a non-negative integer &lt; 231.</li>
<li>The first stone's position is always 0.</li>
</ul>
<p> </p>
<p>Example 1:</p>
<pre>[0,1,3,5,6,8,12,17]

There are a total of 8 stones.
The first stone at the 0th unit, second stone at the 1st unit,
third stone at the 3rd unit, and so on...
The last stone at the 17th unit.

Return true. The frog can jump to the last stone by jumping 
1 unit to the 2nd stone, then 2 units to the 3rd stone, then 
2 units to the 4th stone, then 3 units to the 6th stone, 
4 units to the 7th stone, and 5 units to the 8th stone.
</pre>
<p> </p>
<p>Example 2:</p>
<pre>[0,1,2,3,4,8,9,11]

Return false. There is no way to jump to the last stone as 
the gap between the 5th and 6th stone is too large.</pre>
<p> </p>
<p>终于等到青蛙过河问题了，一颗赛艇。题目中说青蛙如果上一次跳了k距离，那么下一次只能跳k-1, k, 或k+1的距离，那么青蛙跳到某个石头上可能有多种跳法，由于这道题只是让我们判断青蛙是否能跳到最后一个石头上，并没有让我们返回所有的路径，这样就降低了一些难度。我们可以用递归来做，我们维护一个哈希表，建立青蛙在pos位置和拥有jump跳跃能力时是否能跳到对岸。为了能用一个变量同时表示pos和jump，我们可以将jump左移很多位并或上pos，由于题目中对于位置大小有限制，所以不会产生冲突。我们还是首先判断pos是否已经到最后一个石头了，是的话直接返回true；然后看当前这种情况是否已经出现在哈希表中，是的话直接从哈希表中取结果。如果没有，我们就遍历余下的所有石头，对于遍历到的石头，我们计算到当前石头的距离dist，如果距离小于jump-1，我们接着遍历下一块石头；如果dist大于jump+1，说明无法跳到下一块石头，m[key]赋值为false，并返回false；如果在青蛙能跳到的范围中，我们调用递归函数，以新位置i为pos，距离dist为jump，如果返回true了，我们给m[key]赋值为true，并返回true。如果结束遍历我们给m[key]赋值为false，并返回false，参加代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> canCross(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> stones) {
        unordered_map</span>&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">bool</span>&gt;<span style="color: #000000;"> m;
        </span><span style="color: #0000ff;">return</span> helper(stones, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span><span style="color: #000000;">, m);
    }
    </span><span style="color: #0000ff;">bool</span> helper(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; stones, <span style="color: #0000ff;">int</span> pos, <span style="color: #0000ff;">int</span> jump, unordered_map&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">bool</span>&gt;&amp;<span style="color: #000000;"> m) {
        </span><span style="color: #0000ff;">int</span> n = stones.size(), key = pos | jump &lt;&lt; <span style="color: #800080;">11</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (pos &gt;= n - <span style="color: #800080;">1</span>) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (m.count(key)) <span style="color: #0000ff;">return</span><span style="color: #000000;"> m[key];
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = pos + <span style="color: #800080;">1</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">int</span> dist = stones[i] -<span style="color: #000000;"> stones[pos];
            </span><span style="color: #0000ff;">if</span> (dist &lt; jump - <span style="color: #800080;">1</span>) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> (dist &gt; jump + <span style="color: #800080;">1</span>) <span style="color: #0000ff;">return</span> m[key] = <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> (helper(stones, i, dist, m)) <span style="color: #0000ff;">return</span> m[key] = <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> m[key] = <span style="color: #0000ff;">false</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>我们也可以用迭代的方法来解，用一个哈希表来建立每个石头和在该位置上能跳的距离之间的映射，建立一个一维dp数组，其中dp[i]表示在位置为i的石头青蛙的弹跳力(只有青蛙能跳到该石头上，dp[i]才大于0)，由于题目中规定了第一个石头上青蛙跳的距离必须是1，为了跟后面的统一，我们对青蛙在第一块石头上的弹跳力初始化为0(虽然为0，但是由于题目上说青蛙最远能到其弹跳力+1的距离，所以仍然可以到达第二块石头)。我们用变量k表示当前石头，然后开始遍历剩余的石头，对于遍历到的石头i，我们来找到刚好能跳到i上的石头k，如果i和k的距离大于青蛙在k上的弹跳力+1，则说明青蛙在k上到不了i，则k自增1。我们从k遍历到i，如果青蛙能从中间某个石头上跳到i上，我们更新石头i上的弹跳力和最大弹跳力。这样当循环完成后，我们只要检查最后一个石头上青蛙的最大弹跳力是否大于0即可，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> canCross(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> stones) {
        unordered_map</span>&lt;<span style="color: #0000ff;">int</span>, unordered_set&lt;<span style="color: #0000ff;">int</span>&gt;&gt;<span style="color: #000000;"> m;
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; dp(stones.size(), <span style="color: #800080;">0</span><span style="color: #000000;">);
        m[</span><span style="color: #800080;">0</span>].insert(<span style="color: #800080;">0</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">int</span> k = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt; stones.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">while</span> (dp[k] + <span style="color: #800080;">1</span> &lt; stones[i] - stones[k]) ++<span style="color: #000000;">k;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = k; j &lt; i; ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">int</span> t = stones[i] -<span style="color: #000000;"> stones[j];
                </span><span style="color: #0000ff;">if</span> (m[j].count(t - <span style="color: #800080;">1</span>) || m[j].count(t) || m[j].count(t + <span style="color: #800080;">1</span><span style="color: #000000;">)) {
                    m[i].insert(t);
                    dp[i] </span>=<span style="color: #000000;"> max(dp[i], t);</span><span style="color: #000000;">
                }
            }
        }
        </span><span style="color: #0000ff;">return</span> dp.back() &gt; <span style="color: #800080;">0</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/59337/easy-version-java" target="_blank">https://discuss.leetcode.com/topic/59337/easy-version-java</a></p>
<p><a href="https://discuss.leetcode.com/topic/59427/share-my-non-recursive-c-solution-with-simple-comments" target="_blank">https://discuss.leetcode.com/topic/59427/share-my-non-recursive-c-solution-with-simple-comments</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-09-20 13:16</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5888439" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5888439);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5883736.html" id="cb_post_title_url">[LeetCode] Remove K Digits 去掉K位数字</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="row">
<div class="col-md-12">
<div class="row">
<div class="col-md-12">
<div class="question-content">
<p>Given a non-negative integer <em>num</em> represented as a string, remove <em>k</em> digits from the number so that the new number is the smallest possible.</p>
<p>Note:</p>
<ul>
<li>The length of <em>num</em> is less than 10002 and will be ≥ <em>k</em>.</li>
<li>The given <em>num</em> does not contain any leading zero.</li>
</ul>
<p> </p>
<p>Example 1:</p>
<pre>Input: num = "1432219", k = 3
Output: "1219"
Explanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input: num = "10200", k = 1
Output: "200"
Explanation: Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes.
</pre>
<p> </p>
<p>Example 3:</p>
<pre>Input: num = "10", k = 2
Output: "0"
Explanation: Remove all the digits from the number and it is left with nothing which is 0.
</pre>
<p> </p>
<p>这道题让我们将给定的数字去掉k位，要使得留下来的数字最小，这题跟LeetCode上之前那道<a href="http://www.cnblogs.com/grandyang/p/5136749.html">Create Maximum Number</a>有些类似，可以借鉴其中的思路，如果n是num的长度，我们要去除k个，那么需要剩下n-k个，我们开始遍历给定数字num的每一位，对于当前遍历到的数字c，进行如下while循环，如果res不为空，且k大于0，且res的最后一位大于c，那么我们应该将res的最后一位移去，且k自减1。当跳出while循环后，我们将c加入res中，最后我们将res的大小重设为n-k。根据题目中的描述，可能会出现"0200"这样不符合要求的情况，所以我们用一个while循环来去掉前面的所有0，然后返回时判断是否为空，为空则返回“0”，参见代码如下：</p>
<p> </p>
<div>
<div class="btn btn-xs btn-warning" id="company_tags">
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> removeKdigits(<span style="color: #0000ff;">string</span> num, <span style="color: #0000ff;">int</span><span style="color: #000000;"> k) {
        </span><span style="color: #0000ff;">string</span> res = <span style="color: #800000;">""</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> n = num.size(), keep = n -<span style="color: #000000;"> k;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span><span style="color: #000000;"> c : num) {
            </span><span style="color: #0000ff;">while</span> (k &amp;&amp; res.size() &amp;&amp; res.back() &gt;<span style="color: #000000;"> c) {
                res.pop_back();
                </span>--<span style="color: #000000;">k;
            }
            res.push_back(c);
        }
        res.resize(keep);
        </span><span style="color: #0000ff;">while</span> (!res.empty() &amp;&amp; res[<span style="color: #800080;">0</span>] == <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span><span style="color: #000000;">) res.erase(res.begin());
        </span><span style="color: #0000ff;">return</span> res.empty() ? <span style="color: #800000;">"</span><span style="color: #800000;">0</span><span style="color: #800000;">"</span><span style="color: #000000;"> : res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/5136749.html">Create Maximum Number</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/5085379.html">Remove Duplicate Letters</a></p>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<p> </p>
<p><a href="http://www.cnblogs.com/grandyang/p/4606334.html" target="_blank">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-09-19 04:04</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5883736" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5883736);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5896454.html" id="cb_post_title_url">[LeetCode] Binary Watch 二进制表</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="row">
<div class="col-md-12">
<div class="row">
<div class="col-md-12">
<div class="question-content">
<p>A binary watch has 4 LEDs on the top which represent the hours (0-11), and the 6 LEDs on the bottom represent the minutes (0-59).</p>
<p>Each LED represents a zero or one, with the least significant bit on the right.</p>
<img alt="" height="137" src="https://upload.wikimedia.org/wikipedia/commons/8/8b/Binary_clock_samui_moon.jpg" width="183"/>
<p>For example, the above binary watch reads "3:25".</p>
<p>Given a non-negative integer <em>n</em> which represents the number of LEDs that are currently on, return all possible times the watch could represent.</p>
<p>Example:</p>
<pre>Input: n = 1<br/>Return: ["1:00", "2:00", "4:00", "8:00", "0:01", "0:02", "0:04", "0:08", "0:16", "0:32"]</pre>
<p> </p>
<p>Note:</p>
<ul>
<li>The order of output does not matter.</li>
<li>The hour must not contain a leading zero, for example "01:00" is not valid, it should be "1:00".</li>
<li>The minute must be consist of two digits and may contain a leading zero, for example "10:2" is not valid, it should be "10:02".</li>
</ul>
<p> </p>
<p>这道题考察我们二进制表，说实话，博主对二进制表无感，感觉除了装b没啥其他的作用，谁会看个时间还要算半天啊，但是这并不影响我们做题，我们首先来看一种写法很简洁的解法，这种解法利用到了bitset这个类，可以将任意进制数转为二进制，而且又用到了count函数，用来统计1的个数。那么时针从0遍历到11，分针从0遍历到59，然后我们把时针的数组左移6位加上分针的数值，然后统计1的个数，即为亮灯的个数，我们遍历所有的情况，当其等于num的时候，存入结果res中，参见代码如下： </p>
<p> </p>
<div>
<div class="btn btn-xs btn-warning" id="company_tags">解法一：</div>
<div class="btn btn-xs btn-warning">
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; readBinaryWatch(<span style="color: #0000ff;">int</span><span style="color: #000000;"> num) {
        vector</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> h = <span style="color: #800080;">0</span>; h &lt; <span style="color: #800080;">12</span>; ++<span style="color: #000000;">h) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> m = <span style="color: #800080;">0</span>; m &lt; <span style="color: #800080;">60</span>; ++<span style="color: #000000;">m) {
                </span><span style="color: #0000ff;">if</span> (bitset&lt;<span style="color: #800080;">10</span>&gt;((h &lt;&lt; <span style="color: #800080;">6</span>) + m).count() ==<span style="color: #000000;"> num) {
                    res.push_back(to_string(h) </span>+ (m &lt; <span style="color: #800080;">10</span> ? <span style="color: #800000;">"</span><span style="color: #800000;">:0</span><span style="color: #800000;">"</span> : <span style="color: #800000;">"</span><span style="color: #800000;">:</span><span style="color: #800000;">"</span>) +<span style="color: #000000;"> to_string(m));
                }
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>上面的方法之所以那么简洁是因为用了bitset这个类，如果我们不用这个类，那么应该怎么做呢？这个灯亮问题的本质其实就是在n个数字中取出k个，那么就跟之前的那道<a href="http://www.cnblogs.com/grandyang/p/4332522.html" target="_blank">Combinations</a>一样，我们可以借鉴那道题的解法，那么思路是，如果总共要取num个，我们在小时集合里取i个，算出和，然后在分钟集合里去num-i个求和，如果两个都符合题意，那么加入结果中即可，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; readBinaryWatch(<span style="color: #0000ff;">int</span><span style="color: #000000;"> num) {
        vector</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> res;
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; hour{<span style="color: #800080;">8</span>, <span style="color: #800080;">4</span>, <span style="color: #800080;">2</span>, <span style="color: #800080;">1</span>}, minute{<span style="color: #800080;">32</span>, <span style="color: #800080;">16</span>, <span style="color: #800080;">8</span>, <span style="color: #800080;">4</span>, <span style="color: #800080;">2</span>, <span style="color: #800080;">1</span><span style="color: #000000;">};
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt;= num; ++<span style="color: #000000;">i) {
            vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; hours =<span style="color: #000000;"> generate(hour, i);
            vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; minutes = generate(minute, num -<span style="color: #000000;"> i);
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span><span style="color: #000000;"> h : hours) {
                </span><span style="color: #0000ff;">if</span> (h &gt; <span style="color: #800080;">11</span>) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span><span style="color: #000000;"> m : minutes) {
                    </span><span style="color: #0000ff;">if</span> (m &gt; <span style="color: #800080;">59</span>) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                    res.push_back(to_string(h) </span>+ (m &lt; <span style="color: #800080;">10</span> ? <span style="color: #800000;">"</span><span style="color: #800000;">:0</span><span style="color: #800000;">"</span> : <span style="color: #800000;">"</span><span style="color: #800000;">:</span><span style="color: #800000;">"</span>) +<span style="color: #000000;"> to_string(m));
                }
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; generate(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; nums, <span style="color: #0000ff;">int</span><span style="color: #000000;"> cnt) {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> res;
        helper(nums, cnt, </span><span style="color: #800080;">0</span>, <span style="color: #800080;">0</span><span style="color: #000000;">, res);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">void</span> helper(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; nums, <span style="color: #0000ff;">int</span> cnt, <span style="color: #0000ff;">int</span> pos, <span style="color: #0000ff;">int</span> <span style="color: #0000ff;">out</span>, vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> res) {
        </span><span style="color: #0000ff;">if</span> (cnt == <span style="color: #800080;">0</span><span style="color: #000000;">) {
            res.push_back(</span><span style="color: #0000ff;">out</span><span style="color: #000000;">);
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = pos; i &lt; nums.size(); ++<span style="color: #000000;">i) {
            helper(nums, cnt </span>- <span style="color: #800080;">1</span>, i + <span style="color: #800080;">1</span>, <span style="color: #0000ff;">out</span> +<span style="color: #000000;"> nums[i], res);
        }
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种方法就比较搞笑了，是博主在没法想出上面两种方法的情况下万般无奈使用的，你个二进制表再叼也就72种情况，全给你列出来，然后采用跟上面那种解法相同的思路，时针集合取k个，分针集合取num-k个，然后存入结果中即可，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; readBinaryWatch(<span style="color: #0000ff;">int</span><span style="color: #000000;"> num) {
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; hours{{<span style="color: #800080;">0</span>},{<span style="color: #800080;">1</span>,<span style="color: #800080;">2</span>,<span style="color: #800080;">4</span>,<span style="color: #800080;">8</span>},{<span style="color: #800080;">3</span>,<span style="color: #800080;">5</span>,<span style="color: #800080;">9</span>,<span style="color: #800080;">6</span>,<span style="color: #800080;">10</span>},{<span style="color: #800080;">7</span>,<span style="color: #800080;">11</span><span style="color: #000000;">}};
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; minutes{{<span style="color: #800080;">0</span>},{<span style="color: #800080;">1</span>,<span style="color: #800080;">2</span>,<span style="color: #800080;">4</span>,<span style="color: #800080;">8</span>,<span style="color: #800080;">16</span>,<span style="color: #800080;">32</span>},{<span style="color: #800080;">3</span>,<span style="color: #800080;">5</span>,<span style="color: #800080;">9</span>,<span style="color: #800080;">17</span>,<span style="color: #800080;">33</span>,<span style="color: #800080;">6</span>,<span style="color: #800080;">10</span>,<span style="color: #800080;">18</span>,<span style="color: #800080;">34</span>,<span style="color: #800080;">12</span>,<span style="color: #800080;">20</span>,<span style="color: #800080;">36</span>,<span style="color: #800080;">24</span>,<span style="color: #800080;">40</span>,<span style="color: #800080;">48</span>},{<span style="color: #800080;">7</span>,<span style="color: #800080;">11</span>,<span style="color: #800080;">19</span>,<span style="color: #800080;">35</span>,<span style="color: #800080;">13</span>,<span style="color: #800080;">21</span>,<span style="color: #800080;">37</span>,<span style="color: #800080;">25</span>,<span style="color: #800080;">41</span>,<span style="color: #800080;">49</span>,<span style="color: #800080;">14</span>,<span style="color: #800080;">22</span>,<span style="color: #800080;">38</span>,<span style="color: #800080;">26</span>,<span style="color: #800080;">42</span>,<span style="color: #800080;">50</span>,<span style="color: #800080;">28</span>,<span style="color: #800080;">44</span>,<span style="color: #800080;">52</span>,<span style="color: #800080;">56</span>},{<span style="color: #800080;">15</span>,<span style="color: #800080;">23</span>,<span style="color: #800080;">39</span>,<span style="color: #800080;">27</span>,<span style="color: #800080;">43</span>,<span style="color: #800080;">51</span>,<span style="color: #800080;">29</span>,<span style="color: #800080;">45</span>,<span style="color: #800080;">53</span>,<span style="color: #800080;">57</span>,<span style="color: #800080;">30</span>,<span style="color: #800080;">46</span>,<span style="color: #800080;">54</span>,<span style="color: #800080;">58</span>},{<span style="color: #800080;">31</span>,<span style="color: #800080;">47</span>,<span style="color: #800080;">55</span>,<span style="color: #800080;">59</span><span style="color: #000000;">}};
        vector</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> k = <span style="color: #800080;">0</span>; k &lt;= num; ++<span style="color: #000000;">k) {
            </span><span style="color: #0000ff;">int</span> t = num -<span style="color: #000000;"> k;
            </span><span style="color: #0000ff;">if</span> (k &gt; <span style="color: #800080;">3</span> || t &gt; <span style="color: #800080;">5</span>) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; hours[k].size(); ++<span style="color: #000000;">i) {
                </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; minutes[t].size(); ++<span style="color: #000000;">j) {
                    </span><span style="color: #0000ff;">string</span> str = minutes[t][j] &lt; <span style="color: #800080;">10</span> ? <span style="color: #800000;">"</span><span style="color: #800000;">0</span><span style="color: #800000;">"</span> +<span style="color: #000000;"> to_string(minutes[t][j]) : to_string(minutes[t][j]);
                    res.push_back(to_string(hours[k][i]) </span>+ <span style="color: #800000;">"</span><span style="color: #800000;">:</span><span style="color: #800000;">"</span> +<span style="color: #000000;"> str);
                }
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/59374/simple-python-java" target="_blank">https://discuss.leetcode.com/topic/59374/simple-python-java</a></p>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<p><a href="https://discuss.leetcode.com/topic/59401/straight-forward-6-line-c-solution-no-need-to-explain" target="_blank">https://discuss.leetcode.com/topic/59401/straight-forward-6-line-c-solution-no-need-to-explain</a></p>
<p><a href="https://discuss.leetcode.com/topic/59494/3ms-java-solution-using-backtracking-and-idea-of-permutation-and-combination/2" target="_blank">https://discuss.leetcode.com/topic/59494/3ms-java-solution-using-backtracking-and-idea-of-permutation-and-combination/2</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-09-22 15:10</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5896454" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5896454);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5891871.html" id="cb_post_title_url">[LeetCode] Nth Digit 第N位</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Find the <em>n</em><sup>th</sup> digit of the infinite integer sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ...</p>
<p><strong>Note:</strong><br/>
<em>n</em> is positive and will fit within the range of a 32-bit signed integer (<em>n</em> &lt; 2<sup>31</sup>).
</p>
<p><strong>Example 1:</strong>
</p>
<pre><strong>Input:</strong>
3

<strong>Output:</strong>
3
</pre>
<p><strong>Example 2:</strong></p>
<pre><strong>Input:</strong>
11

<strong>Output:</strong>
0

<strong>Explanation:</strong>
The 11th digit of the sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... is a 0, which is part of the number 10.
</pre>
<div> </div>
<div>这道题还是蛮有创意的一道题，是说自然数序列看成一个长字符串，问我们第N位上的数字是什么。那么这道题的关键就是要找出第N位所在的数字，然后可以把数字转为字符串，这样直接可以访问任何一位。那么我们首先来分析自然数序列和其位数的关系，前九个数都是1位的，然后10到99总共90个数字都是两位的，100到999这900个数都是三位的，那么这就很有规律了，我们可以定义个变量cnt，初始化为9，然后每次循环扩大10倍，再用一个变量len记录当前循环区间数字的位数，另外再需要一个变量start用来记录当前循环区间的第一个数字，我们n每次循环都减去len*cnt (区间总位数)，当n落到某一个确定的区间里了，那么(n-1)/len就是目标数字在该区间里的坐标，加上start就是得到了目标数字，然后我们将目标数字start转为字符串，(n-1)%len就是所要求的目标位，最后别忘了考虑int溢出问题，我们干脆把所有变量都申请为长整型的好了，参见代码如下：</div>
<div> </div>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> findNthDigit(<span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        </span><span style="color: #0000ff;">long</span> <span style="color: #0000ff;">long</span> len = <span style="color: #800080;">1</span>, cnt = <span style="color: #800080;">9</span>, start = <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (n &gt; len *<span style="color: #000000;"> cnt) {
            n </span>-= len *<span style="color: #000000;"> cnt;
            </span>++<span style="color: #000000;">len;
            cnt </span>*= <span style="color: #800080;">10</span><span style="color: #000000;">;
            start </span>*= <span style="color: #800080;">10</span><span style="color: #000000;">;
        }
        start </span>+= (n - <span style="color: #800080;">1</span>) /<span style="color: #000000;"> len;
        </span><span style="color: #0000ff;">string</span> t =<span style="color: #000000;"> to_string(start);
        </span><span style="color: #0000ff;">return</span> t[(n - <span style="color: #800080;">1</span>) % len] - <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/59314/java-solution" target="_blank">https://discuss.leetcode.com/topic/59314/java-solution</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-09-21 10:59</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5891871" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5891871);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5880133.html" id="cb_post_title_url">[LeetCode] Evaluate Division 求除法表达式的值</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Equations are given in the format <code>A / B = k</code>, where <code>A</code> and <code>B</code> are variables represented as strings, and <code>k</code> is a real number (floating point number). Given some queries, return the answers. If the answer does not exist, return <code>-1.0</code>.</p>
<p>Example:<br/>Given <code>a / b = 2.0, b / c = 3.0.</code> <br/>queries are: <code>a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ? .</code> <br/>return <code>[6.0, 0.5, -1.0, 1.0, -1.0 ].</code></p>
<p>The input is: <code>vector&lt;pair&lt;string, string&gt;&gt; equations, vector&lt;double&gt;&amp; values, vector&lt;pair&lt;string, string&gt;&gt; queries </code>, where<code>equations.size() == values.size()</code>, and the values are positive. This represents the equations. Return <code>vector&lt;double&gt;</code>.</p>
<p>According to the example above:</p>
<pre>equations = [ ["a", "b"], ["b", "c"] ],
values = [2.0, 3.0],
queries = [ ["a", "c"], ["b", "a"], ["a", "e"], ["a", "a"], ["x", "x"] ]. </pre>
<p> </p>
<p>The input is always valid. You may assume that evaluating the queries will result in no division by zero and there is no contradiction.</p>
<p> </p>
<p>这道题作为第四次编程比赛的压轴题，感觉还是挺有难度的，个人感觉难度应该设为hard比较合理。这道题已知条件中给了一些除法等式，然后给了另外一些除法等式，问我们能不能根据已知条件求出结果，不能的用-1表示。问题本身是很简单的数学问题，但是写代码来自动实现就需要我们用正确的数据结构和算法，通过观察题目中的例子，我们可以看出如果需要分析的除法式的除数和被除数如果其中任意一个没有在已知条件中出现过，那么返回结果-1，所以我们在分析已知条件的时候，可以使用set来记录所有出现过的字符串，然后我们在分析其他除法式的时候，可以使用递归来做。通过分析得出，不能直接由已知条件得到的情况主要有下面三种：</p>
<p>1) 已知: a / b = 2, b / c = 3， 求 a / c<br/>2) 已知: a / c = 2, b / c = 3， 求 a / b<br/>3) 已知: a / b = 2, a / c = 3， 求 b / c</p>
<p>在递归函数中，我们有一个需要分析的除法表达式，我们遍历所有的已知条件，如果跟某一个已知表达式相等，直接返回结果，或者跟某一个已知表达式正好相反，那么返回已知表达式结果的倒数即可。如果都没有的话，那么就需要间接寻找了，我们需要一个vector来记录已经访问过的表达式，我们先看待求表达式的被除数和当前遍历到的已知表达式的被除数是否相同如果相同，那么就是上面的第一种情况，我们就可以把待求表达式的被输出换成已知表达式的除数，比如要求a/c就换成了求b/c，而求b/c的过程就可以调用递归函数来求解，结果要乘以a/b的值。如果算出来是正数我们直接返回，如果是非正数说明没有找到。对于上面的第一种情况，如果我们要求c/a，那么上面的方法就没法开始查找，所以我们同时也要看待求表达式的除数和当前遍历到的已知表达式的被除数是否相同，后面的处理方法都相同，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">double</span>&gt; calcEquation(vector&lt;pair&lt;<span style="color: #0000ff;">string</span>, <span style="color: #0000ff;">string</span>&gt;&gt; equations, vector&lt;<span style="color: #0000ff;">double</span>&gt;&amp; values, vector&lt;pair&lt;<span style="color: #0000ff;">string</span>, <span style="color: #0000ff;">string</span>&gt;&gt;<span style="color: #000000;"> queries) {
        vector</span>&lt;<span style="color: #0000ff;">double</span>&gt; res(queries.size(), -<span style="color: #800080;">1</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">set</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> s;
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto a : equations) {
            s.insert(a.first);
            s.insert(a.second);
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; queries.size(); ++<span style="color: #000000;">i) {
            vector</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> query{queries[i].first, queries[i].second};
            </span><span style="color: #0000ff;">if</span> (s.count(query[<span style="color: #800080;">0</span>]) &amp;&amp; s.count(query[<span style="color: #800080;">1</span><span style="color: #000000;">])) {
                vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> v;
                res[i] </span>=<span style="color: #000000;"> helper(equations, values, query, v);
            }   
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">double</span> helper(vector&lt;pair&lt;<span style="color: #0000ff;">string</span>, <span style="color: #0000ff;">string</span>&gt;&gt; equations, vector&lt;<span style="color: #0000ff;">double</span>&gt;&amp; values, vector&lt;<span style="color: #0000ff;">string</span>&gt; query, vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> v) {
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; equations.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (equations[i].first == query[<span style="color: #800080;">0</span>] &amp;&amp; equations[i].second == query[<span style="color: #800080;">1</span>]) <span style="color: #0000ff;">return</span><span style="color: #000000;"> values[i];
            </span><span style="color: #0000ff;">if</span> (equations[i].first == query[<span style="color: #800080;">1</span>] &amp;&amp; equations[i].second == query[<span style="color: #800080;">0</span>]) <span style="color: #0000ff;">return</span> <span style="color: #800080;">1.0</span> /<span style="color: #000000;"> values[i];
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; equations.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (find(v.begin(), v.end(), i) == v.end() &amp;&amp; equations[i].first == query[<span style="color: #800080;">0</span><span style="color: #000000;">]) {
                v.push_back(i);
                </span><span style="color: #0000ff;">double</span> t = values[i] * helper(equations, values, {equations[i].second, query[<span style="color: #800080;">1</span><span style="color: #000000;">]}, v);
                </span><span style="color: #0000ff;">if</span> (t &gt; <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;"> t;
                </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> v.pop_back();
            }
            </span><span style="color: #0000ff;">if</span> (find(v.begin(), v.end(), i) == v.end() &amp;&amp; equations[i].second == query[<span style="color: #800080;">0</span><span style="color: #000000;">]) {
                v.push_back(i);
                </span><span style="color: #0000ff;">double</span> t = helper(equations, values, {equations[i].first, query[<span style="color: #800080;">1</span>]}, v) /<span style="color: #000000;"> values[i];
                </span><span style="color: #0000ff;">if</span> (t &gt; <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;"> t;
                </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> v.pop_back();
            }
        }
        </span><span style="color: #0000ff;">return</span> -<span style="color: #800080;">1.0</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>此题还有迭代的写法，用邻接列表的表示方法建立了一个图，然后进行bfs搜索，需要用queue来辅助运算，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">double</span>&gt; calcEquation(vector&lt;pair&lt;<span style="color: #0000ff;">string</span>, <span style="color: #0000ff;">string</span>&gt;&gt; equations, vector&lt;<span style="color: #0000ff;">double</span>&gt;&amp; values, vector&lt;pair&lt;<span style="color: #0000ff;">string</span>, <span style="color: #0000ff;">string</span>&gt;&gt;<span style="color: #000000;"> queries) {
        vector</span>&lt;<span style="color: #0000ff;">double</span>&gt;<span style="color: #000000;"> res;
        unordered_map</span>&lt;<span style="color: #0000ff;">string</span>, unordered_map&lt;<span style="color: #0000ff;">string</span>, <span style="color: #0000ff;">double</span>&gt;&gt;<span style="color: #000000;"> g;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; equations.size(); ++<span style="color: #000000;">i) {
            g[equations[i].first].emplace(equations[i].second, values[i]);
            g[equations[i].first].emplace(equations[i].first, </span><span style="color: #800080;">1.0</span><span style="color: #000000;">);
            g[equations[i].second].emplace(equations[i].first, </span><span style="color: #800080;">1.0</span> /<span style="color: #000000;"> values[i]);
            g[equations[i].second].emplace(equations[i].second, </span><span style="color: #800080;">1.0</span><span style="color: #000000;">);
        }
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto query : queries) {
            </span><span style="color: #0000ff;">if</span> (!g.count(query.first) || !g.count(query.second)) res.push_back(-<span style="color: #800080;">1.0</span><span style="color: #000000;">);
            </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                queue</span>&lt;pair&lt;<span style="color: #0000ff;">string</span>, <span style="color: #0000ff;">double</span>&gt;&gt;<span style="color: #000000;"> q;
                unordered_set</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> used{query.first};
                </span><span style="color: #0000ff;">bool</span> find = <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                q.push({query.first, </span><span style="color: #800080;">1.0</span><span style="color: #000000;">});
                </span><span style="color: #0000ff;">while</span> (!q.empty() &amp;&amp; !<span style="color: #000000;">find) {
                    queue</span>&lt;pair&lt;<span style="color: #0000ff;">string</span>, <span style="color: #0000ff;">double</span>&gt;&gt;<span style="color: #000000;"> next;
                    </span><span style="color: #0000ff;">while</span> (!q.empty() &amp;&amp; !<span style="color: #000000;">find) {
                        pair</span>&lt;<span style="color: #0000ff;">string</span>, <span style="color: #0000ff;">double</span>&gt; t =<span style="color: #000000;"> q.front(); q.pop();
                        </span><span style="color: #0000ff;">if</span> (t.first ==<span style="color: #000000;"> query.second) {
                            find </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                            res.push_back(t.second);
                            </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                        }
                        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto a : g[t.first]) {
                            </span><span style="color: #0000ff;">if</span> (!<span style="color: #000000;">used.count(a.first)) {
                                a.second </span>*=<span style="color: #000000;"> t.second;
                                next.push(a);
                                used.insert(a.first);
                            }
                        }
                    }
                    q </span>=<span style="color: #000000;"> next;
                }
                </span><span style="color: #0000ff;">if</span> (!find) res.push_back(-<span style="color: #800080;">1.0</span><span style="color: #000000;">);
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/58444/c-bfs-solution-easy-to-understand" target="_blank">https://discuss.leetcode.com/topic/58444/c-bfs-solution-easy-to-understand</a></p>
<p><a href="https://discuss.leetcode.com/topic/58355/esay-understand-java-solution-3ms" target="_blank">https://discuss.leetcode.com/topic/58355/esay-understand-java-solution-3ms</a></p>
<p><a href="https://discuss.leetcode.com/topic/58444/c-bfs-solution-easy-to-understand" target="_blank"> </a></p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-09-17 23:59</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5880133" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5880133);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5875509.html" id="cb_post_title_url">[LeetCode] Random Pick Index 随机拾取序列</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given an array of integers with possible duplicates, randomly output the index of a given target number. You can assume that the given target number must exist in the array.</p>
<p> <strong>Note:</strong><br/>
The array size can be very large. Solution that uses too much extra space will not pass the judge.
</p>
<p><strong>Example:</strong>
</p>
<pre>int[] nums = new int[] {1,2,3,3,3};
Solution solution = new Solution(nums);

// pick(3) should return either index 2, 3, or 4 randomly. Each index should have equal probability of returning.
solution.pick(3);

// pick(1) should return 0. Since in the array only nums[0] is equal to 1.
solution.pick(1);
</pre>
<div> </div>
<div>这道题指明了我们不能用太多的空间，那么省空间的随机方法只有<a href="https://zh.wikipedia.org/wiki/%E6%B0%B4%E5%A1%98%E6%8A%BD%E6%A8%A3" target="_blank">水塘抽样Reservoir Sampling</a>了，LeetCode之前有过两道需要用这种方法的题目<a href="http://www.cnblogs.com/grandyang/p/5783392.html">Shuffle an Array</a>和<a href="http://www.cnblogs.com/grandyang/p/5759926.html">Linked List Random Node</a>。那么如果了解了水塘抽样，这道题就不算一道难题了，我们定义两个变量，计数器cnt和返回结果res，我们遍历整个数组，如果数组的值不等于target，直接跳过；如果等于target，计数器加1，然后我们在[0,cnt)范围内随机生成一个数字，如果这个数字是0，我们将res赋值为i即可，参见代码如下：</div>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    Solution(vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> nums): v(nums) {}
    
    </span><span style="color: #0000ff;">int</span> pick(<span style="color: #0000ff;">int</span><span style="color: #000000;"> target) {
        </span><span style="color: #0000ff;">int</span> cnt = <span style="color: #800080;">0</span>, res = -<span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; v.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (v[i] != target) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
            </span>++<span style="color: #000000;">cnt;
            </span><span style="color: #0000ff;">if</span> (rand() % cnt == <span style="color: #800080;">0</span>) res =<span style="color: #000000;"> i;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
</span><span style="color: #0000ff;">private</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> v;
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/5783392.html">Shuffle an Array</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/5759926.html">Linked List Random Node</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/58371/c-o-n-solution/2" target="_blank">https://discuss.leetcode.com/topic/58371/c-o-n-solution/2</a></p>
<p><a href="https://discuss.leetcode.com/topic/58297/share-c-o-n-time-solution/2" target="_blank">https://discuss.leetcode.com/topic/58297/share-c-o-n-time-solution/2</a></p>
<p><a href="https://discuss.leetcode.com/topic/58403/bruce-force-java-with-o-n-time-o-1-space" target="_blank">https://discuss.leetcode.com/topic/58403/bruce-force-java-with-o-n-time-o-1-space</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-09-15 21:45</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5875509" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5875509);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5873525.html" id="cb_post_title_url">[LeetCode] Integer Replacement 整数替换</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a positive integer <em>n</em> and you can do operations as follow:</p>
<p> </p>
<ol>
<li>If <em>n</em> is even, replace <em>n</em> with <code><em>n</em>/2</code>.</li>
<li>If <em>n</em> is odd, you can replace <em>n</em> with either <code><em>n</em> + 1</code> or <code><em>n</em> - 1</code>.</li>
</ol>
<p> </p>
<p>What is the minimum number of replacements needed for <em>n</em> to become 1?</p>
<p> </p>
<p>Example 1:</p>
<pre>Input:
8

Output:
3

Explanation:
8 -&gt; 4 -&gt; 2 -&gt; 1
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input:
7

Output:
4

Explanation:
7 -&gt; 8 -&gt; 4 -&gt; 2 -&gt; 1
or
7 -&gt; 6 -&gt; 3 -&gt; 2 -&gt; 1</pre>
<p> </p>
<p>这道题给了我们一个整数n，然后让我们通过变换变为1，如果n是偶数，我们变为n/2，如果是奇数，我们可以变为n+1或n-1，让我们求变为1的最少步骤。那么一看道题的要求，就会感觉应该用递归很合适，我们直接按照规则写出递归即可，注意由于有n+1的操作，所以当n为INT_MAX的时候，就有可能溢出，所以我们可以先将n转为长整型，然后再进行运算，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> integerReplacement(<span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        </span><span style="color: #0000ff;">if</span> (n == <span style="color: #800080;">1</span>) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (n % <span style="color: #800080;">2</span> == <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span> <span style="color: #800080;">1</span> + integerReplacement(n / <span style="color: #800080;">2</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            </span><span style="color: #0000ff;">long</span> <span style="color: #0000ff;">long</span> t =<span style="color: #000000;"> n;
            </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">2</span> + min(integerReplacement((t + <span style="color: #800080;">1</span>) / <span style="color: #800080;">2</span>), integerReplacement((t - <span style="color: #800080;">1</span>) / <span style="color: #800080;">2</span><span style="color: #000000;">));
        }
    }
}; </span></pre>
</div>
<p> </p>
<p>我们也可以使用迭代的解法，那么这里就有小技巧了，当n为奇数的时候，我们什么时候应该加1，什么时候应该减1呢，通过观察来说，除了3和7意外，所有加1就变成4的倍数的奇数，适合加1运算，比如15:</p>
<p>15 -&gt; 16 -&gt; 8 -&gt; 4 -&gt; 2 -&gt; 1</p>
<p>15 -&gt; 14 -&gt; 7 -&gt; 6 -&gt; 3 -&gt; 2 -&gt; 1</p>
<p>对于7来说，加1和减1的结果相同，我们可以不用管，对于3来说，减1的步骤小，所以我们需要去掉这种情况。那么我们如何知道某个数字加1后是否是4的倍数呢，我们可以用个小技巧，由于我们之前判定其是奇数了，那么最右边一位肯定是1，如果其右边第二位也是1的话，那么进行加1运算，进位后右边肯定会出现两个0，则一定是4的倍数，搞定。如果之前判定是偶数，那么除以2即可，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> integerReplacement(<span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        </span><span style="color: #0000ff;">long</span> <span style="color: #0000ff;">long</span> t =<span style="color: #000000;"> n;
        </span><span style="color: #0000ff;">int</span> cnt = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (t &gt; <span style="color: #800080;">1</span><span style="color: #000000;">) {
            </span>++<span style="color: #000000;">cnt;
            </span><span style="color: #0000ff;">if</span> (t &amp; <span style="color: #800080;">1</span><span style="color: #000000;">) {
                </span><span style="color: #0000ff;">if</span> ((t &amp; <span style="color: #800080;">2</span>) &amp;&amp; (t != <span style="color: #800080;">3</span>)) ++<span style="color: #000000;">t;
                </span><span style="color: #0000ff;">else</span> --<span style="color: #000000;">t;
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                t </span>&gt;&gt;= <span style="color: #800080;">1</span><span style="color: #000000;">;
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> cnt;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/58655/0ms-cpp-solution" target="_blank">https://discuss.leetcode.com/topic/58655/0ms-cpp-solution</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-09-14 20:57</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5873525" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5873525);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5869791.html" id="cb_post_title_url">[LeetCode] Rotate Function 旋转函数</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given an array of integers <code>A</code> and let <em>n</em> to be its length.</p>
<p>Assume <code>Bk</code> to be an array obtained by rotating the array <code>A</code> <em>k</em> positions clock-wise, we define a "rotation function" <code>F</code> on <code>A</code> as follow:</p>
<p><code>F(k) = 0 * Bk[0] + 1 * Bk[1] + ... + (n-1) * Bk[n-1]</code>.</p>
<p>Calculate the maximum value of <code>F(0), F(1), ..., F(n-1)</code>.</p>
<p>Note:<br/><em>n</em> is guaranteed to be less than 105.</p>
<p>Example:</p>
<pre>A = [4, 3, 2, 6]

F(0) = (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6) = 0 + 3 + 4 + 18 = 25
F(1) = (0 * 6) + (1 * 4) + (2 * 3) + (3 * 2) = 0 + 4 + 6 + 6 = 16
F(2) = (0 * 2) + (1 * 6) + (2 * 4) + (3 * 3) = 0 + 6 + 8 + 9 = 23
F(3) = (0 * 3) + (1 * 2) + (2 * 6) + (3 * 4) = 0 + 2 + 12 + 12 = 26

So the maximum value of F(0), F(1), F(2), F(3) is F(3) = 26.</pre>
<p> </p>
<p>这道题是LeetCode第四次比赛的第一道题，博主第一道题就没有做出来，博主写了个O(n<sup>2</sup>)的方法并不能通过OJ的大数据集合，后来网上看大家的解法都是很好的找到了规律，可以在O(n)时间内完成。现在想想找规律的能力真的挺重要，比如之前那道<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/5860706.html" id="homepage1_HomePageDays_DaysList_ctl02_DayList_TitleUrl_0">Elimination Game</a>也靠找规律，而用傻方法肯定超时，然后博主发现自己脑子不够活，很难想到正确的方法，说出来全是泪啊T.T。好了，来解题吧，我们为了找规律，先把具体的数字抽象为A,B,C,D，那么我们可以得到：</p>
<p>F(0) = 0A + 1B + 2C +3D</p>
<p>F(1) = 0D + 1A + 2B +3C</p>
<p>F(2) = 0C + 1D + 2A +3B</p>
<p>F(3) = 0B + 1C + 2D +3A</p>
<p>那么，我们通过仔细观察，我们可以得出下面的规律：</p>
<p>F(1) = F(0) + sum - 4D</p>
<p>F(2) = F(1) + sum - 4C</p>
<p>F(3) = F(2) + sum - 4B</p>
<p>那么我们就找到规律了, F(i) = F(i-1) + sum - n*A[n-i]，可以写出代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> maxRotateFunction(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> A) {
        </span><span style="color: #0000ff;">int</span> t = <span style="color: #800080;">0</span>, sum = <span style="color: #800080;">0</span>, n =<span style="color: #000000;"> A.size();
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            sum </span>+=<span style="color: #000000;"> A[i];
            t </span>+= i *<span style="color: #000000;"> A[i];
        }
        </span><span style="color: #0000ff;">int</span> res =<span style="color: #000000;"> t;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt; n; ++<span style="color: #000000;">i) {
            t </span>= t + sum - n * A[n -<span style="color: #000000;"> i];
            res </span>=<span style="color: #000000;"> max(res, t);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/58389/java-solution" target="_blank">https://discuss.leetcode.com/topic/58389/java-solution</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-09-13 21:02</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5869791" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5869791);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5852352.html" id="cb_post_title_url">[LeetCode] Longest Substring with At Least K Repeating Characters 至少有K个重复字符的最长子字符串</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Find the length of the longest substring <strong><em>T</em></strong> of a given string (consists of lowercase letters only) such that every character in <strong><em>T</em></strong> appears no less than <em>k</em> times.</p>
<p><strong>Example 1:</strong></p>
<pre>Input:
s = "aaabb", k = 3

Output:
3

The longest substring is "aaa", as 'a' is repeated 3 times.
</pre>
<p><strong>Example 2:</strong></p>
<pre>Input:
s = "ababbc", k = 2

Output:
5

The longest substring is "ababb", as 'a' is repeated 2 times and 'b' is repeated 3 times.
</pre>
<p> </p>
<p>这道题给了我们一个字符串s和一个正整数k，让我们求一个最大子字符串并且每个字符必须至少出现k次。作为LeetCode第三次编程比赛的压轴题目，博主再一次没有做出来，虽然难度标识只是Medium。后来在网上膜拜学习了大神们的解法，发现我当时的没做出来的原因主要是卡在了如何快速的判断某一个字符串是否所有的元素都已经满足了至少出现k次这个条件，虽然我也用哈希表建立了字符和其出现次数之间的映射，但是如果每一次都要遍历哈希表中的所有字符看其出现次数是否大于k，未免有些不高效。而用mask就很好的解决了这个问题，由于字母只有26个，而整型mask有32位，足够用了，每一位代表一个字母，如果为1，表示该字母不够k次，如果为0就表示已经出现了k次，这种思路真是太聪明了，隐约记得这种用法在之前的题目中也用过，但是博主并不能举一反三(沮丧脸:()，还得继续努力啊。我们遍历字符串，对于每一个字符，我们都将其视为起点，然后遍历到末尾，我们增加哈希表中字母的出现次数，如果其小于k，我们将mask的对应位改为1，如果大于等于k，将mask对应位改为0。然后看mask是否为0，是的话就更新res结果，然后把当前满足要求的子字符串的起始位置j保存到max_idx中，等内层循环结束后，将外层循环变量i赋值为max_idx+1，继续循环直至结束，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> longestSubstring(<span style="color: #0000ff;">string</span> s, <span style="color: #0000ff;">int</span><span style="color: #000000;"> k) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, i = <span style="color: #800080;">0</span>, n =<span style="color: #000000;"> s.size();
        </span><span style="color: #0000ff;">while</span> (i + k &lt;=<span style="color: #000000;"> n) {
            </span><span style="color: #0000ff;">int</span> m[<span style="color: #800080;">26</span>] = {<span style="color: #800080;">0</span>}, mask = <span style="color: #800080;">0</span>, max_idx =<span style="color: #000000;"> i;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = i; j &lt; n; ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">int</span> t = s[j] - <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span><span style="color: #000000;">;
                </span>++<span style="color: #000000;">m[t];
                </span><span style="color: #0000ff;">if</span> (m[t] &lt; k) mask |= (<span style="color: #800080;">1</span> &lt;&lt;<span style="color: #000000;"> t);
                </span><span style="color: #0000ff;">else</span> mask &amp;= (~(<span style="color: #800080;">1</span> &lt;&lt;<span style="color: #000000;"> t));
                </span><span style="color: #0000ff;">if</span> (mask == <span style="color: #800080;">0</span><span style="color: #000000;">) {
                    res </span>= max(res, j - i + <span style="color: #800080;">1</span><span style="color: #000000;">);
                    max_idx </span>=<span style="color: #000000;"> j;
                }
            }
            i </span>= max_idx + <span style="color: #800080;">1</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种写法是上面的解法的递归写法，看起来简洁了不少，但是个人感觉比较难想，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> longestSubstring(<span style="color: #0000ff;">string</span> s, <span style="color: #0000ff;">int</span><span style="color: #000000;"> k) {
        </span><span style="color: #0000ff;">int</span> n = s.size(), max_idx = <span style="color: #800080;">0</span>, res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> m[<span style="color: #800080;">128</span>] = {<span style="color: #800080;">0</span><span style="color: #000000;">};
        </span><span style="color: #0000ff;">bool</span> ok = <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span> c : s) ++<span style="color: #000000;">m[c];
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (m[s[i]] &lt;<span style="color: #000000;"> k) {
                res </span>= max(res, longestSubstring(s.substr(max_idx, i -<span style="color: #000000;"> max_idx), k));
                ok </span>= <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                max_idx </span>= i + <span style="color: #800080;">1</span><span style="color: #000000;">;
            }
        }
        </span><span style="color: #0000ff;">return</span> ok ? n : max(res, longestSubstring(s.substr(max_idx, n -<span style="color: #000000;"> max_idx), k));
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/5351347.html" target="_blank">Longest Substring with At Most K Distinct Characters</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/5185561.html" target="_blank">Longest Substring with At Most Two Distinct Characters</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4480780.html" target="_blank">Longest Substring Without Repeating Characters</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/57272/o-nlogn-recursive-cpp-solution" target="_blank">https://discuss.leetcode.com/topic/57272/o-nlogn-recursive-cpp-solution</a></p>
<p><a href="https://discuss.leetcode.com/topic/57134/two-short-c-solutions-3ms-and-6ms/2" target="_blank">https://discuss.leetcode.com/topic/57134/two-short-c-solutions-3ms-and-6ms/2</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-09-08 11:13</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5852352" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5852352);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5849037.html" id="cb_post_title_url">[LeetCode] Decode String 解码字符串</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given an encoded string, return it's decoded string.</p>
<p>The encoding rule is: <code>k[encoded_string]</code>, where the <em>encoded_string</em> inside the square brackets is being repeated exactly <em>k</em> times. Note that <em>k</em> is guaranteed to be a positive integer.</p>
<p>You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc.</p>
<p>Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, <em>k</em>. For example, there won't be input like <code>3a</code> or <code>2[4]</code>.</p>
<p>Examples:</p>
<pre>s = "3[a]2[bc]", return "aaabcbc".
s = "3[a2[c]]", return "accaccacc".
s = "2[abc]3[cd]ef", return "abcabccdcdcdef".</pre>
<p> </p>
<p>这道题让我们把一个按一定规则编码后的字符串解码成其原来的模样，编码的方法很简单，就是把重复的字符串放在一个中括号里，把重复的次数放在中括号的前面，注意中括号里面有可能会嵌套中括号，这题可以用递归和迭代两种方法来解，我们首先来看递归的解法，我们把一个中括号中的所有内容看做一个整体，一次递归函数返回一对中括号中解码后的字符串。给定的编码字符串实际上只有四种字符，数字，字母，左中括号，和右中括号。那么我们开始用一个变量i从0开始遍历到字符串的末尾，由于左中括号都是跟在数字后面，所以我们首先遇到的字符只能是数字或者字母，如果是字母，我们直接存入结果中，如果是数字，我们循环读入所有的数字，并正确转换，那么下一位非数字的字符一定是左中括号，我们指针右移跳过左中括号，对之后的内容调用递归函数求解，注意我们循环的停止条件是遍历到末尾和遇到右中括号，由于递归调用的函数返回了子中括号里解码后的字符串，而我们之前把次数也已经求出来了，那么循环添加到结果中即可，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> decodeString(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        </span><span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> decode(s, i);
    }
    </span><span style="color: #0000ff;">string</span> decode(<span style="color: #0000ff;">string</span> s, <span style="color: #0000ff;">int</span>&amp;<span style="color: #000000;"> i) {
        </span><span style="color: #0000ff;">string</span> res = <span style="color: #800000;">""</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> n =<span style="color: #000000;"> s.size();
        </span><span style="color: #0000ff;">while</span> (i &lt; n &amp;&amp; s[i] != <span style="color: #800000;">'</span><span style="color: #800000;">]</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">if</span> (s[i] &lt; <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span> || s[i] &gt; <span style="color: #800000;">'</span><span style="color: #800000;">9</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                res </span>+= s[i++<span style="color: #000000;">];
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                </span><span style="color: #0000ff;">int</span> cnt = <span style="color: #800080;">0</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">while</span> (i &lt; n &amp;&amp; s[i] &gt;= <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span> &amp;&amp; s[i] &lt;= <span style="color: #800000;">'</span><span style="color: #800000;">9</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                    cnt </span>= cnt * <span style="color: #800080;">10</span> + s[i++] - <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span><span style="color: #000000;">;
                }
                </span>++<span style="color: #000000;">i;
                </span><span style="color: #0000ff;">string</span> t =<span style="color: #000000;"> decode(s, i);
                </span>++<span style="color: #000000;">i;
                </span><span style="color: #0000ff;">while</span> (cnt-- &gt; <span style="color: #800080;">0</span><span style="color: #000000;">) {
                    res </span>+=<span style="color: #000000;"> t;
                }
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>我们也可以用迭代的方法写出来，当然需要用stack来辅助运算，我们用两个stack，一个用来保存个数，一个用来保存字符串，我们遍历输入字符串，如果遇到数字，我们更新计数变量cnt；如果遇到左中括号，我们把当前cnt压入数字栈中，把当前t压入字符串栈中；如果遇到右中括号时，我们取出数字栈中顶元素，存入变量k，然后给字符串栈的顶元素循环加上k个t字符串，然后取出顶元素存入字符串t中；如果遇到字母，我们直接加入字符串t中即可，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> decodeString(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        </span><span style="color: #0000ff;">string</span> res = <span style="color: #800000;">""</span>, t = <span style="color: #800000;">""</span><span style="color: #000000;">;
        stack</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> s_num;
        stack</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> s_str;
        </span><span style="color: #0000ff;">int</span> cnt = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; s.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (s[i] &gt;= <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span> &amp;&amp; s[i] &lt;= <span style="color: #800000;">'</span><span style="color: #800000;">9</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                cnt </span>= <span style="color: #800080;">10</span> * cnt + s[i] - <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span><span style="color: #000000;">;
            } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (s[i] == <span style="color: #800000;">'</span><span style="color: #800000;">[</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                s_num.push(cnt);
                s_str.push(t);
                cnt </span>= <span style="color: #800080;">0</span><span style="color: #000000;">; t.clear();
            } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (s[i] == <span style="color: #800000;">'</span><span style="color: #800000;">]</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                </span><span style="color: #0000ff;">int</span> k =<span style="color: #000000;"> s_num.top(); s_num.pop();
                </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; k; ++j) s_str.top() +=<span style="color: #000000;"> t;
                t </span>=<span style="color: #000000;"> s_str.top(); s_str.pop();
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                t </span>+=<span style="color: #000000;"> s[i];
            }
        }
        </span><span style="color: #0000ff;">return</span> s_str.empty() ?<span style="color: #000000;"> t : s_str.top();
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/57232/share-my-c-solution" target="_blank">https://discuss.leetcode.com/topic/57232/share-my-c-solution</a></p>
<p><a href="https://discuss.leetcode.com/topic/57228/0ms-simple-c-solution" target="_blank">https://discuss.leetcode.com/topic/57228/0ms-simple-c-solution</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-09-07 13:01</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5849037" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5849037);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5847597.html" id="cb_post_title_url">[LeetCode] UTF-8 Validation 编码验证</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>A character in UTF8 can be from 1 to 4 bytes long, subjected to the following rules:</p>
<ol>
<li>For 1-byte character, the first bit is a 0, followed by its unicode code.</li>
<li>For n-bytes character, the first n-bits are all one's, the n+1 bit is 0, followed by n-1 bytes with most significant 2 bits being 10.</li>
</ol>
<p>This is how the UTF-8 encoding would work:</p>
<pre><code>   Char. number range  |        UTF-8 octet sequence
      (hexadecimal)    |              (binary)
   --------------------+---------------------------------------------
   0000 0000-0000 007F | 0xxxxxxx
   0000 0080-0000 07FF | 110xxxxx 10xxxxxx
   0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx
   0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
</code></pre>
<p>Given an array of integers representing the data, return whether it is a valid utf-8 encoding.</p>
<p> <strong>Note:</strong><br/>
The input is an array of integers. Only the <strong>least significant 8 bits</strong> of each integer is used to store the data. This means each integer represents only 1 byte of data.
</p>
<p>
<strong>Example 1:</strong>
</p>
<pre>data = [197, 130, 1], which represents the octet sequence: <strong>11000101 10000010 00000001</strong>.

Return <strong>true</strong>.
It is a valid utf-8 encoding for a 2-bytes character followed by a 1-byte character.
</pre>
<p><strong>Example 2:</strong></p>
<pre>data = [235, 140, 4], which represented the octet sequence: <strong>11101011 10001100 00000100</strong>.+

Return <strong>false</strong>.
The first 3 bits are all one's and the 4th bit is 0 means it is a 3-bytes character.
The next byte is a continuation byte which starts with 10 and that's correct.
But the second continuation byte does not start with 10, so it is invalid.
</pre>
<p> </p>
<p>这道题考察我们UTF-8编码，这种互联网所采用的通用的编码格式的产生是为了解决ASCII只能表示英文字符的局限性，和统一Unicode的实现方式。下面这段摘自维基百科<a href="https://zh.wikipedia.org/wiki/UTF-8" target="_blank">UTF-8编码</a>：</p>
<p>对于UTF-8编码中的任意字节B，如果B的第一位为0，则B独立的表示一个字符(ASCII码)；<br/>如果B的第一位为1，第二位为0，则B为一个多字节字符中的一个字节(非ASCII字符)；<br/>如果B的前两位为1，第三位为0，则B为两个字节表示的字符中的第一个字节；<br/>如果B的前三位为1，第四位为0，则B为三个字节表示的字符中的第一个字节；<br/>如果B的前四位为1，第五位为0，则B为四个字节表示的字符中的第一个字节；<br/>因此，对UTF-8编码中的任意字节，根据第一位，可判断是否为ASCII字符；根据前二位，可判断该字节是否为一个字符编码的第一个字节；根据前四位（如果前两位均为1），可确定该字节为字符编码的第一个字节，并且可判断对应的字符由几个字节表示；根据前五位（如果前四位为1），可判断编码是否有错误或数据传输过程中是否有错误。</p>
<p>那么根据上面的描述，我们可以先来判断第一位，如果是0的话，则说明是ASCII码，我们直接跳过，判断方法是只要比二进制数10000000小的数第一位肯定是0，然后我们来处理第一位是1的情况，由于第一位的1只是个标识符，后面连续跟的1的个数才是表示后面的字节的个数，我们可以统一从第一位开始连续1的个数，然后减去1就是后面的字节的个数，我想的办法是如果该数字大于等于128，则表示第一位是1，然后减去128，如果得到的数大于等于64，则表示第二位是1，依次类推就可以得到连续的个数，我们要注意10000000这个数是不合法的，遇到了直接返回false。我们得到了cnt的个数，只要验证后面的字节是否是以10开头的数即可，验证方法也很简单，只要这个数在10000000 ~ 10111111范围之间，则一定是10开头的，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> validUtf8(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> data) {
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; data.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (data[i] &lt;<span style="color: #000000;"> 0b10000000) {
                </span><span style="color: #0000ff;">continue</span><span style="color: #000000;">;
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                </span><span style="color: #0000ff;">int</span> cnt = <span style="color: #800080;">0</span>, val =<span style="color: #000000;"> data[i];
                </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">7</span>; j &gt;= <span style="color: #800080;">1</span>; --<span style="color: #000000;">j) {
                    </span><span style="color: #0000ff;">if</span> (val &gt;= pow(<span style="color: #800080;">2</span>, j)) ++<span style="color: #000000;">cnt;
                    </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    val </span>-= pow(<span style="color: #800080;">2</span><span style="color: #000000;">, j);
                }
                </span><span style="color: #0000ff;">if</span> (cnt == <span style="color: #800080;">1</span>) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = i + <span style="color: #800080;">1</span>; j &lt; i + cnt; ++<span style="color: #000000;">j) {
                    </span><span style="color: #0000ff;">if</span> (data[j] &gt; 0b10111111 || data[j] &lt; 0b10000000) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                } 
                i </span>+= cnt - <span style="color: #800080;">1</span><span style="color: #000000;">;
            }
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>在论坛里看到了一种非常简洁的方法，大神就是大神啊，这种方法也是要记连续1的个数，如果是标识字节，先将其向右平移五位，如果得到110，则说明后面跟了一个字节，否则向右平移四位，如果得到1110，则说明后面跟了两个字节，否则向右平移三位，如果得到11110，则说明后面跟了三个字节，否则向右平移七位，如果为1的话，说明是10000000这种情况，不能当标识字节，直接返回false。在非标识字节中，向右平移六位，如果得到的不是10，则说明不是以10开头的，直接返回false，否则cnt自减1，成功完成遍历返回true，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> validUtf8(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> data) {
        </span><span style="color: #0000ff;">int</span> cnt = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span><span style="color: #000000;"> d : data) {
            </span><span style="color: #0000ff;">if</span> (cnt == <span style="color: #800080;">0</span><span style="color: #000000;">) {
                </span><span style="color: #0000ff;">if</span> ((d &gt;&gt; <span style="color: #800080;">5</span>) == 0b110) cnt = <span style="color: #800080;">1</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> ((d &gt;&gt; <span style="color: #800080;">4</span>) == 0b1110) cnt = <span style="color: #800080;">2</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> ((d &gt;&gt; <span style="color: #800080;">3</span>) == 0b11110) cnt = <span style="color: #800080;">3</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (d &gt;&gt; <span style="color: #800080;">7</span>) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                </span><span style="color: #0000ff;">if</span> ((d &gt;&gt; <span style="color: #800080;">6</span>) != 0b10) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                </span>--<span style="color: #000000;">cnt;
            }
        }
        </span><span style="color: #0000ff;">return</span> cnt == <span style="color: #800080;">0</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/57195/concise-c-implementation" target="_blank">https://discuss.leetcode.com/topic/57195/concise-c-implementation</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-09-06 23:22</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5847597" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5847597);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5842033.html" id="cb_post_title_url">[LeetCode] Is Subsequence 是子序列</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a string s and a string t, check if s is subsequence of t.</p>
<p>You may assume that there is only lower case English letters in both s and t. t is potentially a very long (length ~= 500,000) string, and s is a short string (&lt;=100).</p>
<p>A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, <code>"ace"</code> is a subsequence of <code>"abcde"</code> while <code>"aec"</code> is not).</p>
<p>Example 1:<br/>s = <code>"abc"</code>, t = <code>"ahbgdc"</code></p>
<p>Return <code>true</code>.</p>
<p>Example 2:<br/>s = <code>"axc"</code>, t = <code>"ahbgdc"</code></p>
<p>Return <code>false</code>.</p>
<p> </p>
<p>这道题算比较简单的一种，我们可以用两个指针分别指向字符串s和t，然后如果字符相等，则i和j自增1，反之只有j自增1，最后看i是否等于s的长度，等于说明s已经遍历完了，而且字符都有在t中出现过，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> isSubsequence(<span style="color: #0000ff;">string</span> s, <span style="color: #0000ff;">string</span><span style="color: #000000;"> t) {
        </span><span style="color: #0000ff;">if</span> (s.empty()) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>, j = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (i &lt; s.size() &amp;&amp; j &lt;<span style="color: #000000;"> t.size()) {
            </span><span style="color: #0000ff;">if</span> (s[i] ==<span style="color: #000000;"> t[j]) {
                </span>++i; ++<span style="color: #000000;">j;
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                </span>++<span style="color: #000000;">j;
            }
        }
        </span><span style="color: #0000ff;">return</span> i ==<span style="color: #000000;"> s.size();
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种写法稍稍简洁了一些，但是思路并没有什么不同，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> isSubsequence(<span style="color: #0000ff;">string</span> s, <span style="color: #0000ff;">string</span><span style="color: #000000;"> t) {
        </span><span style="color: #0000ff;">if</span> (s.empty()) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>, j = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (i &lt; s.size() &amp;&amp; j &lt;<span style="color: #000000;"> t.size()) {
            </span><span style="color: #0000ff;">if</span> (s[i] == t[j]) ++<span style="color: #000000;">i;
            </span>++<span style="color: #000000;">j;
        }
        </span><span style="color: #0000ff;">return</span> i ==<span style="color: #000000;"> s.size();
    }
};</span></pre>
</div>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-09-05 13:57</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5842033" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5842033);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5825619.html" id="cb_post_title_url">[LeetCode] Perfect Rectangle 完美矩形</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given N axis-aligned rectangles where N &gt; 0, determine if they all together form an exact cover of a rectangular region.</p>
<p>Each rectangle is represented as a bottom-left point and a top-right point. For example, a unit square is represented as [1,1,2,2]. (coordinate of bottom-left point is (1, 1) and top-right point is (2, 2)).</p>
<div><img alt="" src="https://leetcode.com/static/images/problemset/rectangle_perfect.gif"/></div>
<p>Example 1:</p>
<pre>rectangles = [
  [1,1,3,3],
  [3,1,4,2],
  [3,2,4,4],
  [1,3,2,4],
  [2,3,3,4]
]

Return true. All 5 rectangles together form an exact cover of a rectangular region.
</pre>
<p><span style="line-height: 1.5;"> </span><img alt="" src="https://leetcode.com/static/images/problemset/rectangle_separated.gif"/></p>
<p>Example 2:</p>
<pre>rectangles = [
  [1,1,2,3],
  [1,3,2,4],
  [3,1,4,2],
  [3,2,4,4]
]

Return false. Because there is a gap between the two rectangular regions.</pre>
<div><img alt="" src="https://leetcode.com/static/images/problemset/rectangle_hole.gif"/></div>
<p>Example 3:</p>
<pre>rectangles = [
  [1,1,3,3],
  [3,1,4,2],
  [1,3,2,4],
  [3,2,4,4]
]

Return false. Because there is a gap in the top center.</pre>
<div><img alt="" src="https://leetcode.com/static/images/problemset/rectangle_intersect.gif"/></div>
<p>Example 4:</p>
<pre>rectangles = [
  [1,1,3,3],
  [3,1,4,2],
  [1,3,2,4],
  [2,2,4,4]
]

Return false. Because two of the rectangles overlap with each other.</pre>
<p> </p>
<p>这道题是LeetCode第二周编程比赛的压轴题目，然而我并没有做出来，我想了两种方法都无法通过OJ的大数据集合，第一种方法是对于每一个矩形，我将其拆分为多个面积为1的单位矩形，然后以其左下方的点为标记，用一个哈希表建立每一个单位矩形和遍历到的矩形的映射，因为每个单位矩形只能属于一个矩形，否则就会有重叠，我感觉这种思路应该没错，但是由于把每一个遍历到的矩形拆分为单位矩形再建立映射很费时间，尤其是当矩形很大的时候，TLE就很正常了，后来我试的第二种方法是对于遍历到的每个矩形都和其他所有矩形检测一遍是否重叠，这种方法也是毫无悬念的TLE。</p>
<p>博主能力有限，只能去论坛中找各位大神的解法，发现下面两种方法比较fancy，也比较好理解。首先来看第一种方法，这种方法的设计思路很巧妙，利用了mask，也就是位操作Bit Manipulation的一些技巧，下面这张图来自<a href="https://discuss.leetcode.com/topic/55923/o-n-solution-by-counting-corners-with-detailed-explaination" target="_blank">这个帖子</a>：</p>
<p><img alt="" height="148" src="https://images2015.cnblogs.com/blog/391947/201608/391947-20160831131136496-283743152.jpg" width="527"/></p>
<p>所有的矩形的四个顶点只会有下面蓝，绿，红三种情况，其中蓝表示该顶点周围没有其他矩形，T型的绿点表示两个矩形并排相邻，红点表示四个矩形相邻，那么在一个完美矩形中，蓝色的点只能有四个，这是个很重要的判断条件。我们再来看矩形的四个顶点，我们按照左下，左上，右上，右下的顺序来给顶点标号为1，2，4，8，为啥不是1，2，3，4呢，我们注意它们的二进制1(0001)，2(0010)，4(0100)，8(1000)，这样便于我们与和或的操作，我们还需要知道的一个判定条件是，当一个点是某一个矩形的左下顶点时，这个点就不能是其他矩形的左下顶点了，这个条件对于这四种顶点都要成立，那么对于每一个点，如果它是某个矩形的四个顶点之一，我们记录下来，如果在别的矩形中它又是相同的顶点，那么直接返回false即可，这样就体现了我们标记为1，2，4，8的好处，我们可以按位检查1。如果每个点的属性没有冲突，那么我们来验证每个点的mask是否合理，通过上面的分析，我们知道每个点只能是蓝，绿，红三种情况的一种，其中蓝的情况是mask的四位中只有一个1，分别就是1(0001)，2(0010)，4(0100)，8(1000)，而且蓝点只能有四个；那么对于T型的绿点，mask的四位中有两个1，那么就有六种情况，分别是12(1100), 10(1010), 9(1001), 6(0110), 5(0101), 3(0011)；而对于红点，mask的四位都是1，只有一种情况15(1111)，那么我们可以通过直接找mask是1，2，4，8的个数，也可以间接通过找不是绿点和红点的个数，看是否是四个。最后一个判定条件是每个矩形面积累加和要等于最后的大矩形的面积，那么大矩形的面积我们通过计算最小左下点和最大右上点来计算出来即可， 参见代码如下：</p>
<p><span style="line-height: 1.5;"> </span></p>
<p><span style="line-height: 1.5;">解法一：</span></p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> isRectangleCover(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> rectangles) {
        unordered_map</span>&lt;<span style="color: #0000ff;">string</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> m;
        </span><span style="color: #0000ff;">int</span> min_x = INT_MAX, min_y = INT_MAX, max_x = INT_MIN, max_y = INT_MIN, area = <span style="color: #800080;">0</span>, cnt = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto rect : rectangles) {
            min_x </span>= min(min_x, rect[<span style="color: #800080;">0</span><span style="color: #000000;">]);
            min_y </span>= min(min_y, rect[<span style="color: #800080;">1</span><span style="color: #000000;">]);
            max_x </span>= max(max_x, rect[<span style="color: #800080;">2</span><span style="color: #000000;">]);
            max_y </span>= max(max_y, rect[<span style="color: #800080;">3</span><span style="color: #000000;">]);
            area </span>+= (rect[<span style="color: #800080;">2</span>] - rect[<span style="color: #800080;">0</span>]) * (rect[<span style="color: #800080;">3</span>] - rect[<span style="color: #800080;">1</span><span style="color: #000000;">]);
            </span><span style="color: #0000ff;">if</span> (!isValid(m, to_string(rect[<span style="color: #800080;">0</span>]) + <span style="color: #800000;">"</span><span style="color: #800000;">_</span><span style="color: #800000;">"</span> + to_string(rect[<span style="color: #800080;">1</span>]), <span style="color: #800080;">1</span>)) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span>; <span style="color: #008000;">//</span><span style="color: #008000;"> bottom-left</span>
            <span style="color: #0000ff;">if</span> (!isValid(m, to_string(rect[<span style="color: #800080;">0</span>]) + <span style="color: #800000;">"</span><span style="color: #800000;">_</span><span style="color: #800000;">"</span> + to_string(rect[<span style="color: #800080;">3</span>]), <span style="color: #800080;">2</span>)) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span>; <span style="color: #008000;">//</span><span style="color: #008000;"> top-left</span>
            <span style="color: #0000ff;">if</span> (!isValid(m, to_string(rect[<span style="color: #800080;">2</span>]) + <span style="color: #800000;">"</span><span style="color: #800000;">_</span><span style="color: #800000;">"</span> + to_string(rect[<span style="color: #800080;">3</span>]), <span style="color: #800080;">4</span>)) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span>; <span style="color: #008000;">//</span><span style="color: #008000;"> top-right</span>
            <span style="color: #0000ff;">if</span> (!isValid(m, to_string(rect[<span style="color: #800080;">2</span>]) + <span style="color: #800000;">"</span><span style="color: #800000;">_</span><span style="color: #800000;">"</span> + to_string(rect[<span style="color: #800080;">1</span>]), <span style="color: #800080;">8</span>)) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span>; <span style="color: #008000;">//</span><span style="color: #008000;"> bottom-right</span>
<span style="color: #000000;">        }
        </span><span style="color: #0000ff;">for</span> (auto it = m.begin(); it != m.end(); ++<span style="color: #000000;">it) {
            </span><span style="color: #0000ff;">int</span> t = it-&gt;<span style="color: #000000;">second;
            </span><span style="color: #0000ff;">if</span> (t != <span style="color: #800080;">15</span> &amp;&amp; t != <span style="color: #800080;">12</span> &amp;&amp; t != <span style="color: #800080;">10</span> &amp;&amp; t != <span style="color: #800080;">9</span> &amp;&amp; t != <span style="color: #800080;">6</span> &amp;&amp; t != <span style="color: #800080;">5</span> &amp;&amp; t!= <span style="color: #800080;">3</span><span style="color: #000000;">) {
                </span>++<span style="color: #000000;">cnt;
            }
        }
        </span><span style="color: #0000ff;">return</span> cnt == <span style="color: #800080;">4</span> &amp;&amp; area == (max_x - min_x) * (max_y -<span style="color: #000000;"> min_y);
    }
    </span><span style="color: #0000ff;">bool</span> isValid(unordered_map&lt;<span style="color: #0000ff;">string</span>, <span style="color: #0000ff;">int</span>&gt;&amp; m, <span style="color: #0000ff;">string</span> corner, <span style="color: #0000ff;">int</span><span style="color: #000000;"> type) {
        </span><span style="color: #0000ff;">int</span>&amp; val =<span style="color: #000000;"> m[corner];
        </span><span style="color: #0000ff;">if</span> (val &amp; type) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        val </span>|=<span style="color: #000000;"> type;
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种方法也相当的巧妙， 提出这种算法的大神细心的发现了每种点的规律，每个绿点其实都是两个顶点的重合，每个红点都是四个顶点的重合，而每个蓝点只有一个顶点，有了这条神奇的性质就不用再去判断“每个点最多只能是一个矩形的左下，左上，右上，或右下顶点”这条性质了，我们直接用一个set，对于遍历到的任意一个顶点，如果set中已经存在了，则删去这个点，如果没有就加上，这样最后会把绿点和红点都滤去，剩下的都是蓝点，我们只要看蓝点的个数是否为四个，再加上检测每个矩形面积累加和要等于最后的大矩形的面积即可，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> isRectangleCover(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> rectangles) {
        unordered_set</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> st;
        </span><span style="color: #0000ff;">int</span> min_x = INT_MAX, min_y = INT_MAX, max_x = INT_MIN, max_y = INT_MIN, area = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto rect : rectangles) {
            min_x </span>= min(min_x, rect[<span style="color: #800080;">0</span><span style="color: #000000;">]);
            min_y </span>= min(min_y, rect[<span style="color: #800080;">1</span><span style="color: #000000;">]);
            max_x </span>= max(max_x, rect[<span style="color: #800080;">2</span><span style="color: #000000;">]);
            max_y </span>= max(max_y, rect[<span style="color: #800080;">3</span><span style="color: #000000;">]);
            area </span>+= (rect[<span style="color: #800080;">2</span>] - rect[<span style="color: #800080;">0</span>]) * (rect[<span style="color: #800080;">3</span>] - rect[<span style="color: #800080;">1</span><span style="color: #000000;">]);
            </span><span style="color: #0000ff;">string</span> s1 = to_string(rect[<span style="color: #800080;">0</span>]) + <span style="color: #800000;">"</span><span style="color: #800000;">_</span><span style="color: #800000;">"</span> + to_string(rect[<span style="color: #800080;">1</span>]); <span style="color: #008000;">//</span><span style="color: #008000;"> bottom-left</span>
            <span style="color: #0000ff;">string</span> s2 = to_string(rect[<span style="color: #800080;">0</span>]) + <span style="color: #800000;">"</span><span style="color: #800000;">_</span><span style="color: #800000;">"</span> + to_string(rect[<span style="color: #800080;">3</span>]); <span style="color: #008000;">//</span><span style="color: #008000;"> top-left</span>
            <span style="color: #0000ff;">string</span> s3 = to_string(rect[<span style="color: #800080;">2</span>]) + <span style="color: #800000;">"</span><span style="color: #800000;">_</span><span style="color: #800000;">"</span> + to_string(rect[<span style="color: #800080;">3</span>]); <span style="color: #008000;">//</span><span style="color: #008000;"> top-right</span>
            <span style="color: #0000ff;">string</span> s4 = to_string(rect[<span style="color: #800080;">2</span>]) + <span style="color: #800000;">"</span><span style="color: #800000;">_</span><span style="color: #800000;">"</span> + to_string(rect[<span style="color: #800080;">1</span>]); <span style="color: #008000;">//</span><span style="color: #008000;"> bottom-right</span>
            <span style="color: #0000ff;">if</span><span style="color: #000000;"> (st.count(s1)) st.erase(s1);
            </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> st.insert(s1);
            </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (st.count(s2)) st.erase(s2);
            </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> st.insert(s2);
            </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (st.count(s3)) st.erase(s3);
            </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> st.insert(s3);
            </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (st.count(s4)) st.erase(s4);
            </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> st.insert(s4);
        }
        </span><span style="color: #0000ff;">string</span> t1 = to_string(min_x) + <span style="color: #800000;">"</span><span style="color: #800000;">_</span><span style="color: #800000;">"</span> +<span style="color: #000000;"> to_string(min_y);
        </span><span style="color: #0000ff;">string</span> t2 = to_string(min_x) + <span style="color: #800000;">"</span><span style="color: #800000;">_</span><span style="color: #800000;">"</span> +<span style="color: #000000;"> to_string(max_y);
        </span><span style="color: #0000ff;">string</span> t3 = to_string(max_x) + <span style="color: #800000;">"</span><span style="color: #800000;">_</span><span style="color: #800000;">"</span> +<span style="color: #000000;"> to_string(max_y);
        </span><span style="color: #0000ff;">string</span> t4 = to_string(max_x) + <span style="color: #800000;">"</span><span style="color: #800000;">_</span><span style="color: #800000;">"</span> +<span style="color: #000000;"> to_string(min_y);
        </span><span style="color: #0000ff;">if</span> (!st.count(t1) || !st.count(t2) || !st.count(t3) || !st.count(t4) || st.size() != <span style="color: #800080;">4</span>) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span> area == (max_x - min_x) * (max_y -<span style="color: #000000;"> min_y);
    }
};</span></pre>
</div>
<p><span style="color: #0000ff;"> </span></p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/56052/really-easy-understanding-solution-o-n-java" target="_blank">https://discuss.leetcode.com/topic/56052/really-easy-understanding-solution-o-n-java</a></p>
<p><a href="https://discuss.leetcode.com/topic/55997/short-java-solution-with-explanation-updated/2" target="_blank">https://discuss.leetcode.com/topic/55997/short-java-solution-with-explanation-updated/2</a></p>
<p><a href="https://discuss.leetcode.com/topic/55923/o-n-solution-by-counting-corners-with-detailed-explaination" target="_blank">https://discuss.leetcode.com/topic/55923/o-n-solution-by-counting-corners-with-detailed-explaination</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-08-31 13:51</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5825619" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5825619);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5860706.html" id="cb_post_title_url">[LeetCode] Elimination Game 淘汰游戏</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>There is a list of sorted integers from 1 to <em>n</em>. Starting from left to right, remove the first number and every other number afterward until you reach the end of the list.</p>
<p>Repeat the previous step again, but this time from right to left, remove the right most number and every other number from the remaining numbers.</p>
<p>We keep repeating the steps again, alternating left to right and right to left, until a single number remains.</p>
<p>Find the last number that remains starting with a list of length <em>n</em>.</p>
<p>Example:</p>
<pre>Input:
n = 9,
<span style="text-decoration: underline;">1</span> 2 <span style="text-decoration: underline;">3</span> 4 <span style="text-decoration: underline;">5</span> 6 <span style="text-decoration: underline;">7</span> 8 <span style="text-decoration: underline;">9</span>
2 <span style="text-decoration: underline;">4</span> 6 <span style="text-decoration: underline;">8</span>
<span style="text-decoration: underline;">2</span> 6
6

Output:
6</pre>
<p> </p>
<p>这道题是LeetCode第二次编程比赛的题，然而博主并没有做出来，博主用的方法是那种最笨的方法，用一个数组把n个数组都存起来，然后根据循环的奇偶来决定是从左还是从右删除，结果不幸超时TLE了。后来通过想大神请教和上网搜索，发现这道题用递归来做很简单，我们用一个bool型变量left2right，为true表示从左往右，为false表示从右往左遍历。当n为1时，不论从左往右还是从右往左都返回1。如果n大于1，且是从左往右的话，我们返回2倍的对n/2的从右往左的遍历；如果是从右往左的话，稍稍麻烦一些，我们肯定还是要对n/2调用递归函数的，但是要分奇偶情况，如果n为奇数，返回2倍的对n/2的从左往右的遍历的值；如果n为偶数，2倍的对n/2的从左往右的遍历的值，再减去1。具体这样的原因，楼主还在研究中，也不是太清楚：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> lastRemaining(<span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        </span><span style="color: #0000ff;">return</span> help(n, <span style="color: #0000ff;">true</span><span style="color: #000000;">);    
    }
    </span><span style="color: #0000ff;">int</span> help(<span style="color: #0000ff;">int</span> n, <span style="color: #0000ff;">bool</span><span style="color: #000000;"> left2right) {
        </span><span style="color: #0000ff;">if</span> (n == <span style="color: #800080;">1</span>) <span style="color: #0000ff;">return</span> <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (left2right) {
            </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">2</span> * help(n / <span style="color: #800080;">2</span>, <span style="color: #0000ff;">false</span><span style="color: #000000;">);
        } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">2</span> * help(n / <span style="color: #800080;">2</span>, <span style="color: #0000ff;">true</span>) - <span style="color: #800080;">1</span> + n % <span style="color: #800080;">2</span><span style="color: #000000;">;
        }
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种方法相当的叼，一行就搞定了简直丧心病狂啊。第一次从左往右删除的时候，奇数都被删掉了，剩下的都是偶数。如果我们对所有数都除以2，那么得到一个1到n/2的新数列。下一次我们从右往左删出，那么返回的结果应该是调用递归的结果lastRemaining(n / 2)在数组1到n/2之间的镜像。何为镜像，比如1, 2, 3, 4这个数字，2的镜像就是3, 1的镜像是4，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> lastRemaining(<span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        </span><span style="color: #0000ff;">return</span> n == <span style="color: #800080;">1</span> ? <span style="color: #800080;">1</span> : <span style="color: #800080;">2</span> * (<span style="color: #800080;">1</span> + n / <span style="color: #800080;">2</span> - lastRemaining(n / <span style="color: #800080;">2</span><span style="color: #000000;">));    
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种迭代的解法是我请教另一位大神的方法，个人感觉也非常叼，膜拜大神中。我们先来看两个简单的例子：</p>
<p>n = 8<br/>1 2 3 4 5 6 7 8<br/>   2    4    6   8<br/>   2          6<br/>               6<br/>      <br/>n = 7      <br/>1 2 3 4 5 6 7<br/>   2    4    6<br/>         4</p>
<p>如果我们仔细观察，我们可以发现从左往右删的时候，每次都是删掉第一个数字，而从右往左删的时候，则有可能删掉第一个或者第二个数字，而且每删一次，数字之间的距离会变为之前的两倍。我们要做的是每次记录当前数组的第一个数字，而且我们再通过观察可以看出，从右往左删时，如果剩下的数字个数是偶数个时，删掉的是第二个数字；如果是奇数个的时候，删掉的是第一个数字。总结出了上述规律，就可以写出代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> lastRemaining(<span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        </span><span style="color: #0000ff;">int</span> <span style="color: #0000ff;">base</span> = <span style="color: #800080;">1</span>, res = <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (<span style="color: #0000ff;">base</span> * <span style="color: #800080;">2</span> &lt;=<span style="color: #000000;"> n) {
            res </span>+= <span style="color: #0000ff;">base</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">base</span> *= <span style="color: #800080;">2</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">base</span> * <span style="color: #800080;">2</span> &gt; n) <span style="color: #0000ff;">break</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> ((n / <span style="color: #0000ff;">base</span>) % <span style="color: #800080;">2</span> == <span style="color: #800080;">1</span>) res += <span style="color: #0000ff;">base</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">base</span> *= <span style="color: #800080;">2</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="https://discuss.leetcode.com/topic/58042/c-1-line-solution-with-explanation" target="_blank">https://discuss.leetcode.com/topic/58042/c-1-line-solution-with-explanation</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-09-10 23:36</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5860706" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5860706);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5816418.html" id="cb_post_title_url">[LeetCode] Find the Difference 寻找不同</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given two strings <em>s</em> and <em>t</em> which consist of only lowercase letters.</p>
<p>String <em>t</em> is generated by random shuffling string <em>s</em> and then add one more letter at a random position.</p>
<p>Find the letter that was added in <em>t</em>.</p>
<p>Example:</p>
<pre>Input:
s = "abcd"
t = "abcde"

Output:
e

Explanation:
'e' is the letter that was added.</pre>
<p> </p>
<p>这道题给了我们两个字符串s和t，t是在s的任意一个地方加上了一个字符，让我们找出新加上的那个字符。这道题确实不是一道难题，首先第一反应的方法就是用哈希表来建立字符和个数之间的映射，如果在遍历t的时候某个映射值小于0了，那么返回该字符即可，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">char</span> findTheDifference(<span style="color: #0000ff;">string</span> s, <span style="color: #0000ff;">string</span><span style="color: #000000;"> t) {
        unordered_map</span>&lt;<span style="color: #0000ff;">char</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> m;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span> c : s) ++<span style="color: #000000;">m[c];
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span><span style="color: #000000;"> c : t) {
            </span><span style="color: #0000ff;">if</span> (--m[c] &lt; <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;"> c;
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>我们也可以使用位操作Bit Manipulation来做，利用异或的性质，相同位返回0，这样相同的字符都抵消了，剩下的就是后加的那个字符，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">char</span> findTheDifference(<span style="color: #0000ff;">string</span> s, <span style="color: #0000ff;">string</span><span style="color: #000000;"> t) {
        </span><span style="color: #0000ff;">char</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span> c : s) res ^=<span style="color: #000000;"> c;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span> c : t) res ^=<span style="color: #000000;"> c;
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>我们也可以直接用加和减，相同的字符一减一加也抵消了，剩下的就是后加的那个字符，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">char</span> findTheDifference(<span style="color: #0000ff;">string</span> s, <span style="color: #0000ff;">string</span><span style="color: #000000;"> t) {
        </span><span style="color: #0000ff;">char</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span> c : s) res -=<span style="color: #000000;"> c;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span> c : t) res +=<span style="color: #000000;"> c;
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种方法是史蒂芬大神提出来的，利用了STL的accumulate函数，实际上是上面解法二的改写，一行就写完了真是丧心病狂啊，参见代码如下：</p>
<p> </p>
<p>解法四：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">char</span> findTheDifference(<span style="color: #0000ff;">string</span> s, <span style="color: #0000ff;">string</span><span style="color: #000000;"> t) {
        </span><span style="color: #0000ff;">return</span> accumulate(begin(s), end(s += t), <span style="color: #800080;">0</span>, bit_xor&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;">());
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/55987/java-c-1-liner" target="_blank">https://discuss.leetcode.com/topic/55987/java-c-1-liner</a></p>
<p><a href="https://discuss.leetcode.com/topic/55960/two-java-solutions-using-xor-sum" target="_blank">https://discuss.leetcode.com/topic/55960/two-java-solutions-using-xor-sum</a></p>
<p><a href="https://discuss.leetcode.com/topic/55912/java-solution-using-bit-manipulation" target="_blank">https://discuss.leetcode.com/topic/55912/java-solution-using-bit-manipulation</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-08-28 23:57</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5816418" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5816418);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5806493.html" id="cb_post_title_url">[LeetCode] Longest Absolute File Path 最长的绝对文件路径</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Suppose we abstract our file system by a string in the following manner:</p>
<p>The string <code>"dir\n\tsubdir1\n\tsubdir2\n\t\tfile.ext"</code> represents:</p>
<pre>dir
    subdir1
    subdir2
        file.ext
</pre>
<p>The directory <code>dir</code> contains an empty sub-directory <code>subdir1</code> and a sub-directory <code>subdir2</code> containing a file <code>file.ext</code>.</p>
<p>The string <code>"dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext"</code> represents:</p>
<pre>dir
    subdir1
        file1.ext
        subsubdir1
    subdir2
        subsubdir2
            file2.ext
</pre>
<p>The directory <code>dir</code> contains two sub-directories <code>subdir1</code> and <code>subdir2</code>. <code>subdir1</code> contains a file <code>file1.ext</code> and an empty second-level sub-directory<code>subsubdir1</code>. <code>subdir2</code> contains a second-level sub-directory <code>subsubdir2</code> containing a file <code>file2.ext</code>.</p>
<p>We are interested in finding the longest (number of characters) absolute path to a file within our file system. For example, in the second example above, the longest absolute path is <code>"dir/subdir2/subsubdir2/file2.ext"</code>, and its length is <code>32</code> (not including the double quotes).</p>
<p>Given a string representing the file system in the above format, return the length of the longest absolute path to file in the abstracted file system. If there is no file in the system, return <code>0</code>.</p>
<p>Note:</p>
<ul>
<li>The name of a file contains at least a <code>.</code> and an extension.</li>
<li>The name of a directory or sub-directory will not contain a <code>.</code>.</li>
</ul>
<p> </p>
<p>Time complexity required: <code>O(n)</code> where <code>n</code> is the size of the input string.</p>
<p>Notice that <code>a/aa/aaa/file1.txt</code> is not the longest file path, if there is another path <code>aaaaaaaaaaaaaaaaaaaaa/sth.png</code>.</p>
<p> </p>
<p>这道题给了我们一个字符串，里面包含\n和\t这种表示回车和空格的特殊字符，让我们找到某一个最长的绝对文件路径，要注意的是，最长绝对文件路径不一定是要最深的路径，我们可以用哈希表来建立深度和当前深度的绝对路径长度之间的映射，那么当前深度下的文件的绝对路径就是文件名长度加上哈希表中当前深度对应的长度，我们的思路是遍历整个字符串，遇到\n或者\t就停下来，然后我们判断，如果遇到的是回车，我们把这段文件名提取出来，如果里面包含'.'，说明是文件，我们更新res长度，如果不包含点，说明是文件夹，我们深度level自增1，然后建立当前深度和总长度之间的映射，然后我们将深度level重置为0。之前如果遇到的是空格\t，那么我们深度加一，通过累加\t的个数，我们可以得知当前文件或文件夹的深度，然后做对应的处理，参见代码如下：</p>
<p> </p>
<p>C++ 解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> lengthLongestPath(<span style="color: #0000ff;">string</span><span style="color: #000000;"> input) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, n = input.size(), level = <span style="color: #800080;">0</span><span style="color: #000000;">;
        unordered_map</span>&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt; m {{<span style="color: #800080;">0</span>, <span style="color: #800080;">0</span><span style="color: #000000;">}};
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">int</span> start =<span style="color: #000000;"> i;
            </span><span style="color: #0000ff;">while</span> (i &lt; n &amp;&amp; input[i] != <span style="color: #800000;">'</span><span style="color: #800000;">\n</span><span style="color: #800000;">'</span> &amp;&amp; input[i] != <span style="color: #800000;">'</span><span style="color: #800000;">\t</span><span style="color: #800000;">'</span>) ++<span style="color: #000000;">i;
            </span><span style="color: #0000ff;">if</span> (i &gt;= n || input[i] == <span style="color: #800000;">'</span><span style="color: #800000;">\n</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                </span><span style="color: #0000ff;">string</span> t = input.substr(start, i -<span style="color: #000000;"> start);
                </span><span style="color: #0000ff;">if</span> (t.find(<span style="color: #800000;">'</span><span style="color: #800000;">.</span><span style="color: #800000;">'</span>) != <span style="color: #0000ff;">string</span><span style="color: #000000;">::npos) {
                    res </span>= max(res, m[level] + (<span style="color: #0000ff;">int</span><span style="color: #000000;">)t.size());
                } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    </span>++<span style="color: #000000;">level;
                    m[level] </span>= m[level - <span style="color: #800080;">1</span>] + (<span style="color: #0000ff;">int</span>)t.size() + <span style="color: #800080;">1</span><span style="color: #000000;">;
                }
                level </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                </span>++<span style="color: #000000;">level;
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种方法用到了字符串流机制，通过getline函数可以一行一行的获取数据，实际上相当于根据回车符\n把每段分割开了，然后对于每一行，我们找最后一个空格符\t的位置，然后可以得到文件或文件夹的名字，然后我们判断其是文件还是文件夹，如果是文件就更新res，如果是文件夹就更新哈希表的映射，参见代码如下：</p>
<p> </p>
<p>C++ 解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> lengthLongestPath(<span style="color: #0000ff;">string</span><span style="color: #000000;"> input) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        istringstream ss(input);
        unordered_map</span>&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt; m{{<span style="color: #800080;">0</span>, <span style="color: #800080;">0</span><span style="color: #000000;">}};
        </span><span style="color: #0000ff;">string</span> line = <span style="color: #800000;">""</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> (getline(ss, line)) {
            </span><span style="color: #0000ff;">int</span> level = line.find_last_of(<span style="color: #800000;">'</span><span style="color: #800000;">\t</span><span style="color: #800000;">'</span>) + <span style="color: #800080;">1</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">int</span> len =<span style="color: #000000;"> line.substr(level).size();
            </span><span style="color: #0000ff;">if</span> (line.find(<span style="color: #800000;">'</span><span style="color: #800000;">.</span><span style="color: #800000;">'</span>) != <span style="color: #0000ff;">string</span><span style="color: #000000;">::npos) {
                res </span>= max(res, m[level] +<span style="color: #000000;"> len);
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                m[level </span>+ <span style="color: #800080;">1</span>] = m[level] + len + <span style="color: #800080;">1</span><span style="color: #000000;">;
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>Java 解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> lengthLongestPath(String input) {
        </span><span style="color: #0000ff;">int</span> res = 0<span style="color: #000000;">;
        Map</span>&lt;Integer, Integer&gt; m = <span style="color: #0000ff;">new</span> HashMap&lt;&gt;<span style="color: #000000;">();
        m.put(</span>0, 0<span style="color: #000000;">);
        </span><span style="color: #0000ff;">for</span> (String s : input.split("\n"<span style="color: #000000;">)) {
            </span><span style="color: #0000ff;">int</span> level = s.lastIndexOf("\t") + 1<span style="color: #000000;">;
            </span><span style="color: #0000ff;">int</span> len =<span style="color: #000000;"> s.substring(level).length();
            </span><span style="color: #0000ff;">if</span> (s.contains("."<span style="color: #000000;">)) {
                res </span>= Math.max(res, m.get(level) +<span style="color: #000000;"> len);
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                m.put(level </span>+ 1, m.get(level) + len + 1<span style="color: #000000;">);
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
}</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/55108/c-o-n-solution-with-hashmap" target="_blank">https://discuss.leetcode.com/topic/55108/c-o-n-solution-with-hashmap</a></p>
<p><a href="https://discuss.leetcode.com/topic/55135/c-o-n-easy-and-straightforward-only-use-vector" target="_blank">https://discuss.leetcode.com/topic/55135/c-o-n-easy-and-straightforward-only-use-vector</a></p>
<p><a href="https://discuss.leetcode.com/topic/55561/two-different-solutions-in-java-using-stack-and-hashmap" target="_blank">https://discuss.leetcode.com/topic/55561/two-different-solutions-in-java-using-stack-and-hashmap</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-08-25 13:55</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5806493" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5806493);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5802109.html" id="cb_post_title_url">[LeetCode] First Unique Character in a String 字符串第一个不同字符</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a string, find the first non-repeating character in it and return it's index. If it doesn't exist, return -1.</p>
<p><strong>Examples:</strong></p>
<pre>s = "leetcode"
return 0.

s = "loveleetcode",
return 2.
</pre>
<p><strong>Note:</strong> You may assume the string contain only lowercase letters.</p>
<p> </p>
<p>这道题确实没有什么难度，我们只要用哈希表建立每个字符和其出现次数的映射，然后按顺序遍历字符串，找到第一个出现次数为1的字符，返回其位置即可，参见代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> firstUniqChar(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        unordered_map</span>&lt;<span style="color: #0000ff;">char</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> m;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span> c : s) ++<span style="color: #000000;">m[c];
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; s.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (m[s[i]] == <span style="color: #800080;">1</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;"> i;
        }
        </span><span style="color: #0000ff;">return</span> -<span style="color: #800080;">1</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/6231504.html">Sort Characters By Frequency</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-08-24 11:13</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5802109" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5802109);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5798275.html" id="cb_post_title_url">[LeetCode] Lexicographical Numbers 字典顺序的数字</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given an integer <em>n</em>, return 1 - <em>n</em> in lexicographical order.</p>
<p>For example, given 13, return: [1,10,11,12,13,2,3,4,5,6,7,8,9].</p>
<p>Please optimize your algorithm to use less time and space. The input size may be as large as 5,000,000.</p>
<p> </p>
<p>这道题给了我们一个整数n，让我们把区间[1,n]的所有数字按照字典顺序来排列，题目中也给了我们字典顺序的例子。那么我们需要重新排序，我最开始想到的方法是重写sort方法的comparator，思路是把所有数字都转为字符串，然后两个字符串按位相比，然后排好序后再转回数字，这种方法通过不了OJ的大集合，说明本题不是想考我们这种方法。我在论坛里看到大家普遍使用的是下面这种方法，学习了一下，感觉思路十分巧妙，估计我自己肯定想不出来。这种思路是按个位数遍历，在遍历下一个个位数之前，先遍历十位数，十位数的高位为之前的个位数，只要这个多位数并没有超过n，就可以一直往后遍历，如果超过了，我们除以10，然后再加1，如果加1后末尾形成了很多0，那么我们要用个while循环把0都去掉，然后继续运算，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; lexicalOrder(<span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> res(n);
        </span><span style="color: #0000ff;">int</span> cur = <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            res[i] </span>=<span style="color: #000000;"> cur;
            </span><span style="color: #0000ff;">if</span> (cur * <span style="color: #800080;">10</span> &lt;=<span style="color: #000000;"> n) {
                cur </span>*= <span style="color: #800080;">10</span><span style="color: #000000;">;
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                </span><span style="color: #0000ff;">if</span> (cur &gt;= n) cur /= <span style="color: #800080;">10</span><span style="color: #000000;">;
                cur </span>+= <span style="color: #800080;">1</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">while</span> (cur % <span style="color: #800080;">10</span> == <span style="color: #800080;">0</span>) cur /= <span style="color: #800080;">10</span><span style="color: #000000;">;
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种方法是上面解法的递归形式，思路并没有什么不同，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; lexicalOrder(<span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt;= <span style="color: #800080;">9</span>; ++<span style="color: #000000;">i) {
            helper(i, n, res);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">void</span> helper(<span style="color: #0000ff;">int</span> cur, <span style="color: #0000ff;">int</span> n, vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> res) {
        </span><span style="color: #0000ff;">if</span> (cur &gt; n) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
        res.push_back(cur);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt;= <span style="color: #800080;">9</span>; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (cur * <span style="color: #800080;">10</span> + i &lt;=<span style="color: #000000;"> n) {
                helper(cur </span>* <span style="color: #800080;">10</span> +<span style="color: #000000;"> i, n, res);
            } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">break</span><span style="color: #000000;">;
        }
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/55131/ac-240ms-c-solution" target="_blank">https://discuss.leetcode.com/topic/55131/ac-240ms-c-solution</a></p>
<p><a href="https://discuss.leetcode.com/topic/55091/java-recursion-backtracking-with-explanation" target="_blank">https://discuss.leetcode.com/topic/55091/java-recursion-backtracking-with-explanation</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-08-23 10:30</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5798275" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5798275);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5771434.html" id="cb_post_title_url">[LeetCode] Mini Parser 迷你解析器</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="row">
<div class="col-md-12">
<div class="row">
<div class="col-md-12">
<div class="question-content">
<p>Given a nested list of integers represented as a string, implement a parser to deserialize it.</p>
<p>Each element is either an integer, or a list -- whose elements may also be integers or other lists.</p>
<p>Note: You may assume that the string is well-formed:</p>
<ul>
<li>String is non-empty.</li>
<li>String does not contain white spaces.</li>
<li>String contains only digits <code>0-9</code>, <code>[</code>, <code>-</code> <code>,</code>, <code>]</code>.</li>
</ul>
<p> </p>
<p>Example 1:</p>
<pre>Given s = "324",

You should return a NestedInteger object which contains a single integer 324.
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Given s = "[123,[456,[789]]]",

Return a NestedInteger object containing a nested list with 2 elements:

1. An integer containing value 123.
2. A nested list containing two elements:
    i.  An integer containing value 456.
    ii. A nested list with one element:
         a. An integer containing value 789.
</pre>
<p> </p>
<p>这道题让我们实现一个迷你解析器用来把一个字符串解析成NestInteger类，关于这个嵌套链表类的题我们之前做过三道，<a href="http://www.cnblogs.com/grandyang/p/5615583.html">Nested List Weight Sum II</a>，<a href="http://www.cnblogs.com/grandyang/p/5358793.html" target="_blank">Flatten Nested List Iterator</a>，和<a href="http://www.cnblogs.com/grandyang/p/5340305.html" target="_blank">Nested List Weight Sum</a>。应该对这个类并不陌生了，我们可以先用递归来做，思路是，首先判断s是否为空，为空直接返回，不为空的话看首字符是否为'['，不是的话说明s为一个整数，我们直接返回结果。如果首字符是'['，且s长度小于等于2，说明没有内容，直接返回结果。反之如果s长度大于2，我们从i=1开始遍历，我们需要一个变量start来记录某一层的其实位置，用cnt来记录跟其实位置是否为同一深度，cnt=0表示同一深度，由于中间每段都是由逗号隔开，所以当我们判断当cnt为0，且当前字符是逗号或者已经到字符串末尾了，我们把start到当前位置之间的字符串取出来递归调用函数，把返回结果加入res中，然后start更新为i+1。如果遇到'['，计数器cnt自增1，若遇到']'，计数器cnt自减1。参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    NestedInteger deserialize(</span><span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        </span><span style="color: #0000ff;">if</span> (s.empty()) <span style="color: #0000ff;">return</span><span style="color: #000000;"> NestedInteger();
        </span><span style="color: #0000ff;">if</span> (s[<span style="color: #800080;">0</span>] != <span style="color: #800000;">'</span><span style="color: #800000;">[</span><span style="color: #800000;">'</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;"> NestedInteger(stoi(s));
        </span><span style="color: #0000ff;">if</span> (s.size() &lt;= <span style="color: #800080;">2</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;"> NestedInteger();
        NestedInteger res;
        </span><span style="color: #0000ff;">int</span> start = <span style="color: #800080;">1</span>, cnt = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt; s.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (cnt == <span style="color: #800080;">0</span> &amp;&amp; (s[i] == <span style="color: #800000;">'</span><span style="color: #800000;">,</span><span style="color: #800000;">'</span> || i == s.size() - <span style="color: #800080;">1</span><span style="color: #000000;">)) {
                res.add(deserialize(s.substr(start, i </span>-<span style="color: #000000;"> start)));
                start </span>= i + <span style="color: #800080;">1</span><span style="color: #000000;">;
            } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (s[i] == <span style="color: #800000;">'</span><span style="color: #800000;">[</span><span style="color: #800000;">'</span>) ++<span style="color: #000000;">cnt;
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (s[i] == <span style="color: #800000;">'</span><span style="color: #800000;">]</span><span style="color: #800000;">'</span>) --<span style="color: #000000;">cnt;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<div>
<div class="btn btn-xs btn-warning">我们也可以使用迭代的方法来做，这样就需要使用栈来辅助，变量start记录起始位置，我们遍历字符串，如果遇到'['，我们给栈中加上一个空的NestInteger，如果遇到的字符数逗号或者']'，如果i&gt;start，那么我们给栈顶元素调用add来新加一个NestInteger，初始化参数传入start到i之间的子字符串转为的整数，然后更新start=i+1，当遇到的']'时，如果此时栈中元素多于1个，那么我们将栈顶元素取出，加入新的栈顶元素中通过调用add函数，参见代码如下：</div>
<div class="btn btn-xs btn-warning"> </div>
<div class="btn btn-xs btn-warning" id="company_tags">解法二：</div>
<div class="btn btn-xs btn-warning">
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    NestedInteger deserialize(</span><span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        </span><span style="color: #0000ff;">if</span> (s.empty()) <span style="color: #0000ff;">return</span><span style="color: #000000;"> NestedInteger();
        </span><span style="color: #0000ff;">if</span> (s[<span style="color: #800080;">0</span>] != <span style="color: #800000;">'</span><span style="color: #800000;">[</span><span style="color: #800000;">'</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;"> NestedInteger(stoi(s));
        stack</span>&lt;NestedInteger&gt;<span style="color: #000000;"> st;
        </span><span style="color: #0000ff;">int</span> start = <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; s.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (s[i] == <span style="color: #800000;">'</span><span style="color: #800000;">[</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                st.push(NestedInteger());
                start </span>= i + <span style="color: #800080;">1</span><span style="color: #000000;">;
            } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (s[i] == <span style="color: #800000;">'</span><span style="color: #800000;">,</span><span style="color: #800000;">'</span> || s[i] == <span style="color: #800000;">'</span><span style="color: #800000;">]</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                </span><span style="color: #0000ff;">if</span> (i &gt;<span style="color: #000000;"> start) {
                    st.top().add(NestedInteger(stoi(s.substr(start, i </span>-<span style="color: #000000;"> start))));
                }
                start </span>= i + <span style="color: #800080;">1</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">if</span> (s[i] == <span style="color: #800000;">'</span><span style="color: #800000;">]</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">if</span> (st.size() &gt; <span style="color: #800080;">1</span><span style="color: #000000;">) {
                        NestedInteger t </span>=<span style="color: #000000;"> st.top(); st.pop();
                        st.top().add(t);
                    }
                }
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> st.top();
    }
};</span></pre>
</div>
<p> </p>
<p>还有一种方法是利用C++ STL中的字符串流处理类istringstream，我们需要对几个函数有些了解，比如clear()是重置字符流中的字符串，get()是获得下一个字符，peek()是返回首字符，&gt;&gt;num是读取出合法的整数，如果无法读取出整数，需要调用clear()来重置字符串，否则调用get()会出错。思路跟上面的递归解法相同，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    NestedInteger deserialize(</span><span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        istringstream </span><span style="color: #0000ff;">in</span><span style="color: #000000;">(s);
        </span><span style="color: #0000ff;">return</span> deserialize(<span style="color: #0000ff;">in</span><span style="color: #000000;">);
    }
    NestedInteger deserialize(istringstream</span>&amp; <span style="color: #0000ff;">in</span><span style="color: #000000;">) {
        </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> num;
        </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">in</span> &gt;&gt; num) <span style="color: #0000ff;">return</span><span style="color: #000000;"> NestedInteger(num);
        </span><span style="color: #0000ff;">in</span><span style="color: #000000;">.clear();
        </span><span style="color: #0000ff;">in</span>.<span style="color: #0000ff;">get</span><span style="color: #000000;">();
        NestedInteger list;
        </span><span style="color: #0000ff;">while</span> (<span style="color: #0000ff;">in</span>.peek() != <span style="color: #800000;">'</span><span style="color: #800000;">]</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
            list.add(deserialize(</span><span style="color: #0000ff;">in</span><span style="color: #000000;">));
            </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">in</span>.peek() == <span style="color: #800000;">'</span><span style="color: #800000;">,</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                </span><span style="color: #0000ff;">in</span>.<span style="color: #0000ff;">get</span><span style="color: #000000;">();
            }
        }
        </span><span style="color: #0000ff;">in</span>.<span style="color: #0000ff;">get</span><span style="color: #000000;">();
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> list;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/5615583.html">Nested List Weight Sum II</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/5358793.html" target="_blank">Flatten Nested List Iterator</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/5340305.html" target="_blank">Nested List Weight Sum</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/54258/python-c-solutions/3" target="_blank">https://discuss.leetcode.com/topic/54258/python-c-solutions/3</a></p>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<p><a href="https://discuss.leetcode.com/topic/54341/iterative-c-using-stack" target="_blank">https://discuss.leetcode.com/topic/54341/iterative-c-using-stack</a></p>
<p><a href="https://discuss.leetcode.com/topic/54277/short-java-recursive-solution" target="_blank">https://discuss.leetcode.com/topic/54277/short-java-recursive-solution</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-08-14 23:49</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5771434" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5771434);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5783392.html" id="cb_post_title_url">[LeetCode] Shuffle an Array 数组洗牌</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Shuffle a set of numbers without duplicates.</p>
<p>Example:</p>
<pre>// Init an array with set 1, 2, and 3.
int[] nums = {1,2,3};
Solution solution = new Solution(nums);

// Shuffle the array [1,2,3] and return its result. Any permutation of [1,2,3] must equally likely to be returned.
solution.shuffle();

// Resets the array back to its original configuration [1,2,3].
solution.reset();

// Returns the random shuffling of array [1,2,3].
solution.shuffle();</pre>
<p> </p>
<p>这道题让我们给数组洗牌，也就是随机打乱顺序，那么由于之前那道题<a class="entrylistItemTitle" href="http://www.cnblogs.com/grandyang/p/5759926.html" id="CategoryEntryList1_EntryStoryList_ctl00_Entries_TitleUrl_2">Linked List Random Node</a>我们接触到了<a href="https://zh.wikipedia.org/wiki/%E6%B0%B4%E5%A1%98%E6%8A%BD%E6%A8%A3" target="_blank">水塘抽样Reservoir Sampling</a>的思想，这道题实际上这道题也是用类似的思路，我们遍历数组每个位置，每次都随机生成一个坐标位置，然后交换当前遍历位置和随机生成的坐标位置的数字，这样如果数组有n个数字，那么我们也随机交换了n组位置，从而达到了洗牌的目的，这里需要注意的是i + rand() % (res.size() - i)不能写成rand() % res.size()，虽然也能通过OJ，但是根据<a href="https://yjk94.wordpress.com/2017/03/17/%E6%B4%97%E7%89%8C%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF-knuth-shuffle%E7%AE%97%E6%B3%95/" target="_blank">这个帖子</a>的最后部分的概率图表，前面那种写法不是真正的随机分布，应该使用Knuth shuffle算法，感谢热心网友们的留言，参见代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    Solution(vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> nums): v(nums) {}
    
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">* Resets the array to its original configuration and return it. </span><span style="color: #008000;">*/</span><span style="color: #000000;">
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> reset() {
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> v;
    }
    
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">* Returns a random shuffling of the array. </span><span style="color: #008000;">*/</span><span style="color: #000000;">
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> shuffle() {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; res =<span style="color: #000000;"> v;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; res.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">int</span> t = i + rand() % (res.size() -<span style="color: #000000;"> i);
            swap(res[i], res[t]);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    
</span><span style="color: #0000ff;">private</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> v;
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a class="entrylistItemTitle" href="http://www.cnblogs.com/grandyang/p/5759926.html" id="CategoryEntryList1_EntryStoryList_ctl00_Entries_TitleUrl_2">Linked List Random Node</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-08-18 11:42</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5783392" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5783392);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5764314.html" id="cb_post_title_url">[LeetCode] Ransom Note 赎金条</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p> Given  an  arbitrary  ransom  note  string  and  another  string  containing  letters from  all  the  magazines,  write  a  function  that  will  return  true  if  the  ransom   note  can  be  constructed  from  the  magazines ;  otherwise,  it  will  return  false.   </p>
<p>Each  letter  in  the  magazine  string  can  only  be  used  once  in  your  ransom  note.</p>
<p>Note:<br/>You may assume that both strings contain only lowercase letters.</p>
<pre>canConstruct("a", "b") -&gt; false
canConstruct("aa", "ab") -&gt; false
canConstruct("aa", "aab") -&gt; true</pre>
<p> </p>
<p>非常简单的一道题，就是用哈希Map统计字符的个数，参见代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> canConstruct(<span style="color: #0000ff;">string</span> ransomNote, <span style="color: #0000ff;">string</span><span style="color: #000000;"> magazine) {
        unordered_map</span>&lt;<span style="color: #0000ff;">char</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> m;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span> c : magazine) ++<span style="color: #000000;">m[c];
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span><span style="color: #000000;"> c : ransomNote) {
            </span><span style="color: #0000ff;">if</span> (--m[c] &lt; <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p>
<p> </p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-08-12 11:35</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5764314" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5764314);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5759926.html" id="cb_post_title_url">[LeetCode] Linked List Random Node 链表随机节点</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a singly linked list, return a random node's value from the linked list. Each node must have the <strong>same probability</strong> of being chosen.</p>
<p><strong>Follow up:</strong><br/>
What if the linked list is extremely large and its length is unknown to 
you? Could you solve this efficiently without using extra space?
</p>
<p><strong>Example:</strong>
</p>
<pre>// Init a singly linked list [1,2,3].
ListNode head = new ListNode(1);
head.next = new ListNode(2);
head.next.next = new ListNode(3);
Solution solution = new Solution(head);

// getRandom() should return either 1, 2, or 3 randomly. Each element should have equal probability of returning.
solution.getRandom();
</pre>
<p> </p>
<p>这道题给了我们一个链表，让我们随机返回一个节点，那么最直接的方法就是先统计出链表的长度，然后根据长度随机生成一个位置，然后从开头遍历到这个位置即可，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">* @param head The linked list's head. Note that the head is guanranteed to be not null, so it contains at least one node. </span><span style="color: #008000;">*/</span><span style="color: #000000;">
    Solution(ListNode</span>*<span style="color: #000000;"> head) {
        len </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
        ListNode </span>*cur =<span style="color: #000000;"> head;
        </span><span style="color: #0000ff;">this</span>-&gt;head =<span style="color: #000000;"> head;
        </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> (cur) {
            </span>++<span style="color: #000000;">len;
            cur </span>= cur-&gt;<span style="color: #000000;">next;
        }
    }
    
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">* Returns a random node's value. </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">int</span><span style="color: #000000;"> getRandom() {
        </span><span style="color: #0000ff;">int</span> t = rand() %<span style="color: #000000;"> len;
        ListNode </span>*cur =<span style="color: #000000;"> head;
        </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> (t) {
            </span>--<span style="color: #000000;">t;
            cur </span>= cur-&gt;<span style="color: #000000;">next;
        }
        </span><span style="color: #0000ff;">return</span> cur-&gt;<span style="color: #000000;">val;
    }
</span><span style="color: #0000ff;">private</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> len;
    ListNode </span>*<span style="color: #000000;">head;
};</span></pre>
</div>
<p> </p>
<p>Follow up中说链表可能很长，我们没法提前知道长度，这里用到了著名了<a href="https://zh.wikipedia.org/wiki/%E6%B0%B4%E5%A1%98%E6%8A%BD%E6%A8%A3" target="_blank">水塘抽样Reservoir Sampling</a>的思路，由于限定了head一定存在，所以我们先让返回值res等于head的节点值，然后让cur指向head的下一个节点，定义一个变量i，初始化为2，若cur不为空我们开始循环，我们在[0, i - 1]中取一个随机数，如果取出来0，那么我们更新res为当前的cur的节点值，然后此时i自增一，cur指向其下一个位置，这里其实相当于我们维护了一个大小为1的水塘，然后我们随机数生成为0的话，我们交换水塘中的值和当前遍历到的值，这样可以保证每个数字的概率相等，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">* @param head The linked list's head. Note that the head is guanranteed to be not null, so it contains at least one node. </span><span style="color: #008000;">*/</span><span style="color: #000000;">
    Solution(ListNode</span>*<span style="color: #000000;"> head) {
        </span><span style="color: #0000ff;">this</span>-&gt;head =<span style="color: #000000;"> head;
    }
    
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">* Returns a random node's value. </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">int</span><span style="color: #000000;"> getRandom() {
        </span><span style="color: #0000ff;">int</span> res = head-&gt;val, i = <span style="color: #800080;">2</span><span style="color: #000000;">;
        ListNode </span>*cur = head-&gt;<span style="color: #000000;">next;
        </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> (cur) {
            </span><span style="color: #0000ff;">int</span> j = rand() %<span style="color: #000000;"> i;
            </span><span style="color: #0000ff;">if</span> (j == <span style="color: #800080;">0</span>) res = cur-&gt;<span style="color: #000000;">val;
            </span>++<span style="color: #000000;">i;
            cur </span>= cur-&gt;<span style="color: #000000;">next;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
</span><span style="color: #0000ff;">private</span><span style="color: #000000;">:
    ListNode </span>*<span style="color: #000000;">head;
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/53812/using-reservoir-sampling-o-1-space-o-n-time-complexity-c" target="_blank">https://discuss.leetcode.com/topic/53812/using-reservoir-sampling-o-1-space-o-n-time-complexity-c</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-08-11 10:17</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5759926" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5759926);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5756148.html" id="cb_post_title_url">[LeetCode] Insert Delete GetRandom O(1) - Duplicates allowed 常数时间内插入删除和获得随机数 - 允许重复</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="row">
<div class="col-md-12">
<div class="row">
<div class="col-md-12">
<div class="question-content">
<p>Design a data structure that supports all following operations in <em>average</em> O(1) time.</p>
Note: Duplicate elements are allowed.
<p> </p>
<ol>
<li><code>insert(val)</code>: Inserts an item val to the collection.</li>
<li><code>remove(val)</code>: Removes an item val from the collection if present.</li>
<li><code>getRandom</code>: Returns a random element from current collection of elements. The probability of each element being returned is linearly related to the number of same value the collection contains.</li>
</ol>
<p> </p>
<p>Example:</p>
<pre>// Init an empty collection.
RandomizedCollection collection = new RandomizedCollection();

// Inserts 1 to the collection. Returns true as the collection did not contain 1.
collection.insert(1);

// Inserts another 1 to the collection. Returns false as the collection contained 1. Collection now contains [1,1].
collection.insert(1);

// Inserts 2 to the collection, returns true. Collection now contains [1,1,2].
collection.insert(2);

// getRandom should return 1 with the probability 2/3, and returns 2 with the probability 1/3.
collection.getRandom();

// Removes 1 from the collection, returns true. Collection now contains [1,2].
collection.remove(1);

// getRandom should return 1 and 2 both equally likely.
collection.getRandom();
</pre>
<p> </p>
<p>这题是之前那道<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/5740864.html" id="homepage1_HomePageDays_DaysList_ctl04_DayList_TitleUrl_0">Insert Delete GetRandom O(1)</a>的拓展，与其不同的是，之前那道题不能有重复数字，而这道题可以有，那么就不能像之前那道题那样建立每个数字和其坐标的映射了，但是我们可以建立数字和其所有出现位置的集合之间的映射，虽然写法略有不同，但是思路和之前那题完全一样，都是将数组最后一个位置的元素和要删除的元素交换位置，然后删掉最后一个位置上的元素。对于insert函数，我们将要插入的数字在nums中的位置加入m[val]数组的末尾，然后在数组nums末尾加入val，我们判断是否有重复只要看m[val]数组只有刚加的val一个值还是有多个值。remove函数是这题的难点，我们首先看哈希表中有没有val，没有的话直接返回false。然后我们取出nums的尾元素，把尾元素哈希表中的位置数组中的最后一个位置更新为m[val]的尾元素，这样我们就可以删掉m[val]的尾元素了，如果m[val]只有一个元素，那么我们把这个映射直接删除。然后我们将nums数组中的尾元素删除，并把尾元素赋给val所在的位置，注意我们在建立哈希表的映射的时候需要用堆而不是普通的vector数组，因为我们每次remove操作后都会移除nums数组的尾元素，如果我们用vector来保存数字的坐标，而且只移出末尾数字的话，有可能出现前面的坐标大小超过了此时nums的大小的情况，就会出错，所以我们用优先队列对所有的相同数字的坐标进行自动排序，每次把最大位置的坐标移出即可，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
</div>
</div>
</div>
</div>
</div>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> RandomizedCollection {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">* Initialize your data structure here. </span><span style="color: #008000;">*/</span><span style="color: #000000;">
    RandomizedCollection() {}
    
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">* Inserts a value to the collection. Returns true if the collection did not already contain the specified element. </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">bool</span> insert(<span style="color: #0000ff;">int</span><span style="color: #000000;"> val) {
        m[val].push(nums.size());
        nums.push_back(val);
        </span><span style="color: #0000ff;">return</span> m[val].size() == <span style="color: #800080;">1</span><span style="color: #000000;">;
    }
    
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">* Removes a value from the collection. Returns true if the collection contained the specified element. </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">bool</span> remove(<span style="color: #0000ff;">int</span><span style="color: #000000;"> val) {
        </span><span style="color: #0000ff;">if</span> (m[val].empty()) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> idx =<span style="color: #000000;"> m[val].top();
        m[val].pop();
        </span><span style="color: #0000ff;">if</span> (nums.size() - <span style="color: #800080;">1</span> !=<span style="color: #000000;"> idx) {
            </span><span style="color: #0000ff;">int</span> t =<span style="color: #000000;"> nums.back();
            nums[idx] </span>=<span style="color: #000000;"> t;
            m[t].pop();
            m[t].push(idx);
        }
        nums.pop_back();
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
    
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">* Get a random element from the collection. </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">int</span><span style="color: #000000;"> getRandom() {
        </span><span style="color: #0000ff;">return</span> nums[rand() %<span style="color: #000000;"> nums.size()];
    }
</span><span style="color: #0000ff;">private</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> nums;
    unordered_map</span>&lt;<span style="color: #0000ff;">int</span>, priority_queue&lt;<span style="color: #0000ff;">int</span>&gt;&gt;<span style="color: #000000;"> m;
};</span></pre>
</div>
<p> </p>
<p>有网友指出上面的方法其实不是真正的O(1)时间复杂度，因为优先队列的push不是常数级的，博主一看果然是这样的，为了严格的遵守O(1)的时间复杂度，我们将优先队列换成unordered_set，其插入删除的操作都是常数量级的，其他部分基本不用变，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> RandomizedCollection {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">* Initialize your data structure here. </span><span style="color: #008000;">*/</span><span style="color: #000000;">
    RandomizedCollection() {}
    
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">* Inserts a value to the collection. Returns true if the collection did not already contain the specified element. </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">bool</span> insert(<span style="color: #0000ff;">int</span><span style="color: #000000;"> val) {
        m[val].insert(nums.size());
        nums.push_back(val);
        </span><span style="color: #0000ff;">return</span> m[val].size() == <span style="color: #800080;">1</span><span style="color: #000000;">;
    }
    
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">* Removes a value from the collection. Returns true if the collection contained the specified element. </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">bool</span> remove(<span style="color: #0000ff;">int</span><span style="color: #000000;"> val) {
        </span><span style="color: #0000ff;">if</span> (m[val].empty()) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> idx = *<span style="color: #000000;">m[val].begin();
        m[val].erase(idx);
        </span><span style="color: #0000ff;">if</span> (nums.size() - <span style="color: #800080;">1</span> !=<span style="color: #000000;"> idx) {
            </span><span style="color: #0000ff;">int</span> t =<span style="color: #000000;"> nums.back();
            nums[idx] </span>=<span style="color: #000000;"> t;
            m[t].erase(nums.size() </span>- <span style="color: #800080;">1</span><span style="color: #000000;">);
            m[t].insert(idx);
        } 
        nums.pop_back();
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
    
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">* Get a random element from the collection. </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">int</span><span style="color: #000000;"> getRandom() {
        </span><span style="color: #0000ff;">return</span> nums[rand() %<span style="color: #000000;"> nums.size()];
    }

</span><span style="color: #0000ff;">private</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> nums;
    unordered_map</span>&lt;<span style="color: #0000ff;">int</span>, unordered_set&lt;<span style="color: #0000ff;">int</span>&gt;&gt;<span style="color: #000000;"> m;
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/5740864.html" id="homepage1_HomePageDays_DaysList_ctl04_DayList_TitleUrl_0">Insert Delete GetRandom O(1)</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/53659/c-two-solutions" target="_blank">https://discuss.leetcode.com/topic/53659/c-two-solutions</a></p>
<p><a href="https://discuss.leetcode.com/topic/54381/c-128m-solution-real-o-1-solution" target="_blank">https://discuss.leetcode.com/topic/54381/c-128m-solution-real-o-1-solution</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-08-10 11:43</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5756148" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5756148);return false;">收藏</a></div>
</div>
</html>