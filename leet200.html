<html lang="zh-cn">
<head>
<meta charset="utf-8"/>
<div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7801533.html" id="cb_post_title_url">[LeetCode] Maximum Length of Repeated Subarray 最长的重复子数组</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given two integer arrays <code>A</code> and <code>B</code>, return the maximum length of an subarray that appears in both arrays.</p>
<p><strong>Example 1:</strong><br/>
</p>
<pre><strong>Input:</strong>
A: [1,2,3,2,1]
B: [3,2,1,4,7]
<strong>Output:</strong> 3
<strong>Explanation:</strong> 
The repeated subarray with maximum length is [3, 2, 1].
</pre>
<p><strong>Note:</strong><br/>
</p>
<ol><ol>
<li>1 &lt;= len(A), len(B) &lt;= 1000</li>
<li>0 &lt;= A[i], B[i] &lt; 100</li>
</ol></ol>
<p> </p>
<p>这道题给了我们两个数组A和B，让我们返回连个数组的最长重复子数组。那么如果我们将数组换成字符串，实际这道题就是求Longest Common Substring的问题了，而貌似LeetCode上并没有这种明显的要求最长相同子串的题，注意需要跟最长子序列Longest Common Subsequence区分开，关于最长子序列会在follow up中讨论。好，先来看这道题，对于这种求极值的问题，DP是不二之选，我们使用一个二维的DP数组，其中dp[i][j]表示数组A的前i个数字和数组B的前j个数字的最长子数组的长度，如果dp[i][j]不为0，则A中第i个数组和B中第j个数字必须相等，比对于这两个数组[1,2,2]和[3,1,2]，我们的dp数组为：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #000000;"><span style="color: #0000ff;">  3 1 2</span>
<span style="color: #0000ff;">1</span> 0 <span style="color: #ff0000;">1</span> 0
<span style="color: #0000ff;">2</span> 0 0 <span style="color: #ff0000;">2</span>
<span style="color: #0000ff;">2</span> 0 0 <span style="color: #ff0000;">1</span></span></pre>
</div>
<p> </p>
<p>我们注意观察，dp值不为0的地方，都是当A[i] == B[j]的地方，而且还要加上左上方的dp值，即dp[i-1][j-1]，所以当前的dp[i][j]就等于dp[i-1][j-1] + 1，而一旦A[i] != B[j]时，直接赋值为0，不用多想，因为子数组是要连续的，一旦不匹配了，就不能再增加长度了。我们每次算出一个dp值，都要用来更新结果res，这样就能得到最长相同子数组的长度了，参见代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> findLength(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; A, vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> B) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; dp(A.size() + <span style="color: #800080;">1</span>, vector&lt;<span style="color: #0000ff;">int</span>&gt;(B.size() + <span style="color: #800080;">1</span>, <span style="color: #800080;">0</span><span style="color: #000000;">));
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt; dp.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">1</span>; j &lt; dp[i].size(); ++<span style="color: #000000;">j) {
                dp[i][j] </span>= (A[i - <span style="color: #800080;">1</span>] == B[j - <span style="color: #800080;">1</span>]) ? dp[i - <span style="color: #800080;">1</span>][j - <span style="color: #800080;">1</span>] + <span style="color: #800080;">1</span> : <span style="color: #800080;">0</span><span style="color: #000000;">;
                res </span>=<span style="color: #000000;"> max(res, dp[i][j]);
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>Follow up：在开始时，博主提到了要跟最长相同子序列Longest Common Subsequence区分开来，虽然LeetCode没有直接求最大相同子序列的题，但有几道题利用到了求该问题的思想，比如<a href="http://www.cnblogs.com/grandyang/p/7144045.html">Delete Operation for Two Strings</a>和<a href="http://www.cnblogs.com/grandyang/p/7752002.html">Minimum ASCII Delete Sum for Two Strings</a>等，详细讨论请参见评论区一楼 :)</p>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4501934.html" target="_blank">Minimum Size Subarray Sum</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-11-07 22:37</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7801533" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7801533);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7790029.html" id="cb_post_title_url">[LeetCode] 1-bit and 2-bit Characters 一位和两位字符</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>We have two special characters. The first character can be represented by one bit <code>0</code>. The second character can be represented by two bits (<code>10</code> or <code>11</code>).</p>
<p>Now given a string represented by several bits. Return whether the last character must be a one-bit character or not. The given string will always end with a zero.</p>
<p>Example 1:</p>
<pre>Input: 
bits = [1, 0, 0]
Output: True
Explanation: 
The only way to decode it is two-bit character and one-bit character. So the last character is one-bit character.
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input: 
bits = [1, 1, 1, 0]
Output: False
Explanation: 
The only way to decode it is two-bit character and two-bit character. So the last character is NOT one-bit character.
</pre>
<p> </p>
<p>Note:</p>
<ul>
<li><code>1 &lt;= len(bits) &lt;= 1000</code>.</li>
<li><code>bits[i]</code> is always <code>0</code> or <code>1</code>.</li>
</ul>
<p> </p>
<p>这道题说有两种特殊的字符，一种是两位字符，只能是二进制的11和10，另一种是单个位字符，只能是二进制的0。现在给了我们一个只包含0和1的数组，问我们能否将其正确的分割，使得最后一个字符是个单个位字符。这道题可以使用贪婪算法来做，因为两种字符互不干扰，只要我们遍历到了数字1，那么其必定是两位字符，所以后面一位也得跟着，而遍历到了数字0，那么就必定是单个位字符。所以我们可以用一个变量i来记录当前遍历到的位置，如果遇到了0，那么i自增1，如果遇到了1，那么i自增2，我们循环的条件是i &lt; n-1，即留出最后一位，所以当循环退出后，当i正好停留在n-1上，说明最后一位是单独分割开的，因为题目中限定了最后一位一定是0，所以没必要再判断了，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> isOneBitCharacter(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> bits) {
        </span><span style="color: #0000ff;">int</span> n = bits.size(), i = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (i &lt; n - <span style="color: #800080;">1</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">if</span> (bits[i] == <span style="color: #800080;">0</span>) ++<span style="color: #000000;">i;
            </span><span style="color: #0000ff;">else</span> i+= <span style="color: #800080;">2</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> i == n - <span style="color: #800080;">1</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种解法写的更加简洁了，直接用一行代替了if..else..语句，相当巧妙，当bits[i]为0时，i还是相当于自增了1，当bits[i]为1时，i相当于自增了2，最后还是在循环跳出后检测i是否为n-1，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> isOneBitCharacter(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> bits) {
        </span><span style="color: #0000ff;">int</span> n = bits.size(), i = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (i &lt; n - <span style="color: #800080;">1</span><span style="color: #000000;">) {
            i </span>+= bits[i] + <span style="color: #800080;">1</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> i == n - <span style="color: #800080;">1</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>下面我们来看递归解法，用的是回溯的思想，首先判断如果bits为空了，直接返回false，因为题目初始给的bits是非空的，在调用递归函数中为空了说明最后一位跟倒数第二位组成了个两位字符，所以不合题意返回false。再判断如果bits大小为1了，那么返回这个数字是否为0，其实直接返回true也行，因为题目中说了最后一个数字一定是0。然后我们新建一个数组t，如果bits的首元素为0，则我们的t赋值为去掉首元素的bits数组；如果bits的首元素是1，则我们的t服之为去掉前两个元素的bits数组，然后返回调用递归函数的结果即可，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> isOneBitCharacter(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> bits) {
        </span><span style="color: #0000ff;">if</span> (bits.empty()) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (bits.size() == <span style="color: #800080;">1</span>) <span style="color: #0000ff;">return</span> bits[<span style="color: #800080;">0</span>] == <span style="color: #800080;">0</span><span style="color: #000000;">;
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> t;
        </span><span style="color: #0000ff;">if</span> (bits[<span style="color: #800080;">0</span>] == <span style="color: #800080;">0</span><span style="color: #000000;">) {
            t </span>= vector&lt;<span style="color: #0000ff;">int</span>&gt;(bits.begin() + <span style="color: #800080;">1</span><span style="color: #000000;">, bits.end());
        } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (bits[<span style="color: #800080;">0</span>] == <span style="color: #800080;">1</span><span style="color: #000000;">) {
            t </span>= vector&lt;<span style="color: #0000ff;">int</span>&gt;(bits.begin() + <span style="color: #800080;">2</span><span style="color: #000000;">, bits.end());
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> isOneBitCharacter(t);
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种解法也是用的递归，递归函数用的不是原函数，这样可以只用位置变量idx来遍历，而不用新建数组t，初始时idx传入0，在递归函数中，如果idx为n了，相当于上面解法中的bits数组为空了情况，返回false；如果idx为n-1，返回true；如果bits[idx]为0，则返回调用递归函数的结果，此时idx加上1；如果bits[idx]为1，则返回调用递归函数的结果，此时idx加上2，参见代码如下：</p>
<p> </p>
<p>解法四：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> isOneBitCharacter(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> bits) {
        </span><span style="color: #0000ff;">return</span> helper(bits, <span style="color: #800080;">0</span><span style="color: #000000;">);
    }
    </span><span style="color: #0000ff;">bool</span> helper(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; bits, <span style="color: #0000ff;">int</span><span style="color: #000000;"> idx) {
        </span><span style="color: #0000ff;">int</span> n =<span style="color: #000000;"> bits.size();
        </span><span style="color: #0000ff;">if</span> (idx == n) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (idx == n - <span style="color: #800080;">1</span>) <span style="color: #0000ff;">return</span> bits[idx] == <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (bits[idx] == <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span> helper(bits, idx + <span style="color: #800080;">1</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">return</span> helper(bits, idx + <span style="color: #800080;">2</span><span style="color: #000000;">);
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4315649.html" target="_blank">Gray Code</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/108743/java-solution-1-or-2">https://discuss.leetcode.com/topic/108743/java-solution-1-or-2</a></p>
<p><a href="https://discuss.leetcode.com/topic/108766/c-both-iterative-and-recursive-solutions">https://discuss.leetcode.com/topic/108766/c-both-iterative-and-recursive-solutions</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-11-05 23:57</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7790029" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7790029);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7823424.html" id="cb_post_title_url">[LeetCode] Max Stack 最大栈</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="question-description">
<p>Design a max stack that supports push, pop, top, peekMax and popMax.</p>
<p> </p>
<ol>
<li>push(x) -- Push element x onto stack.</li>
<li>pop() -- Remove the element on top of the stack and return it.</li>
<li>top() -- Get the element on the top.</li>
<li>peekMax() -- Retrieve the maximum element in the stack.</li>
<li>popMax() -- Retrieve the maximum element in the stack, and remove it. If you find more than one maximum elements, only remove the top-most one.</li>
</ol>
<p> </p>
<p>Example 1:</p>
<pre>MaxStack stack = new MaxStack();
stack.push(5); 
stack.push(1);
stack.push(5);
stack.top(); -&gt; 5
stack.popMax(); -&gt; 5
stack.top(); -&gt; 1
stack.peekMax(); -&gt; 5
stack.pop(); -&gt; 1
stack.top(); -&gt; 5
</pre>
<p> </p>
<p>Note:</p>
<ol>
<li>-1e7 &lt;= x &lt;= 1e7</li>
<li>Number of operations won't exceed 10000.</li>
<li>The last four operations won't be called when stack is empty.</li>
</ol>
<p> </p>
<p>这道题让我们实现一个最大栈，包含一般栈的功能，但是还新加了两个功能peekMax()和popMax()，随时随地可以查看和返回最大值。之前有一道很类似的题<a href="http://www.cnblogs.com/grandyang/p/4091064.html" target="_blank">Min Stack</a>，所以我们可以借鉴那道题的解法，使用两个栈来模拟，s1为普通的栈，用来保存所有的数字，而s2为最大栈，用来保存出现的最大的数字。</p>
<p>在push()函数中，我们先来看s2，如果s2为空，或者s2的栈顶元素小于等于x，将x压入s2中。因为s2保存的是目前为止最大的数字，所以一旦新数字大于等于栈顶元素，说明遇到更大的数字了，压入栈。然后将数组压入s1，s1保存所有的数字，所以都得压入栈。</p>
<p>在pop()函数中，当s2的栈顶元素和s1的栈顶元素相同时，我们要移除s2的栈顶元素，因为一个数字不在s1中了，就不能在s2中。然后取出s1的栈顶元素，并移除s1，返回即可。</p>
<p>在top()函数中，直接返回s1的top()函数即可。</p>
<p>在peekMax()函数中，直接返回s2的top()函数即可。</p>
<p>在popMax()函数中，先将s2的栈顶元素保存到一个变量mx中，然后我们要在s1中删除这个元素，由于栈无法直接定位元素，所以我们用一个临时栈t，将s1的出栈元素保存到临时栈t中，当s1的栈顶元素和s2的栈顶元素相同时退出while循环，此时我们在s1中找到了s2的栈顶元素，分别将s1和s2的栈顶元素移除，然后要做的是将临时栈t中的元素加回s1中，注意此时容易犯的一个错误是，没有同时更新s2，所以我们直接调用push()函数即可，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> MaxStack {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">* initialize your data structure here. </span><span style="color: #008000;">*/</span><span style="color: #000000;">
    MaxStack() {}
    
    </span><span style="color: #0000ff;">void</span> push(<span style="color: #0000ff;">int</span><span style="color: #000000;"> x) {
        </span><span style="color: #0000ff;">if</span> (s2.empty() || s2.top() &lt;=<span style="color: #000000;"> x) s2.push(x);
        s1.push(x);
    }
    
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> pop() {
        </span><span style="color: #0000ff;">if</span> (!s2.empty() &amp;&amp; s2.top() ==<span style="color: #000000;"> s1.top()) s2.pop();
        </span><span style="color: #0000ff;">int</span> t =<span style="color: #000000;"> s1.top(); s1.pop();
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> t;
    }
    
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> top() {
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> s1.top();
    }
    
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> peekMax() {
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> s2.top();
    }
    
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> popMax() {
        </span><span style="color: #0000ff;">int</span> mx =<span style="color: #000000;"> s2.top();
        stack</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> t;
        </span><span style="color: #0000ff;">while</span> (s1.top() !=<span style="color: #000000;"> s2.top()) {
            t.push(s1.top()); s1.pop();
        }
        s1.pop(); s2.pop();
        </span><span style="color: #0000ff;">while</span> (!<span style="color: #000000;">t.empty()) {
            push(t.top()); t.pop();
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> mx;
    }

</span><span style="color: #0000ff;">private</span><span style="color: #000000;">:
    stack</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> s1, s2;
};</span></pre>
</div>
<p> </p>
<p>下面这种解法没有利用一般的stack，而是建立一种较为复杂的数据结构，首先用一个list链表来保存所有的数字，然后建立一个数字和包含所有相同的数字的位置iterator的向量容器的映射map。</p>
<p>在push()函数中，把新数字加到list表头，然后把数字x的位置iterator加到数字映射的向量容器的末尾。</p>
<p>在pop()函数中，先得到表头数字，然后把该数字对应的iterator向量容器的末尾元素删掉，如果此时向量容器为空了，将这个映射直接删除，移除表头数字，返回该数字即可。</p>
<p>在top()函数中，直接返回表头数字即可。</p>
<p>在peekMax()函数中，因为map是按key值自动排序的，直接尾映射的key值即可。</p>
<p>在popMax()函数中，首先保存尾映射的key值，也就是最大值到变量x中，然后在其对应的向量容器的末尾取出其在list中的iterator。然后删除该向量容器的尾元素，如果此时向量容器为空了，将这个映射直接删除。根据之前取出的iterator，在list中删除对应的数字，返回x即可，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> MaxStack {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">* initialize your data structure here. </span><span style="color: #008000;">*/</span><span style="color: #000000;">
    MaxStack() {}
    
    </span><span style="color: #0000ff;">void</span> push(<span style="color: #0000ff;">int</span><span style="color: #000000;"> x) {
        v.insert(v.begin(), x);
        m[x].push_back(v.begin());
    }
    
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> pop() {
        </span><span style="color: #0000ff;">int</span> x = *<span style="color: #000000;">v.begin();
        m[x].pop_back();
        </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (m[x].empty()) m.erase(x);
        v.erase(v.begin());
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> x;
    }
    
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> top() {
        </span><span style="color: #0000ff;">return</span> *<span style="color: #000000;">v.begin();
    }
    
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> peekMax() {
        </span><span style="color: #0000ff;">return</span> m.rbegin()-&gt;<span style="color: #000000;">first;
    }
    
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> popMax() {
        </span><span style="color: #0000ff;">int</span> x = m.rbegin()-&gt;<span style="color: #000000;">first;
        auto it </span>=<span style="color: #000000;"> m[x].back();
        m[x].pop_back();
        </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (m[x].empty()) m.erase(x);
        v.erase(it);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> x;
    }

</span><span style="color: #0000ff;">private</span><span style="color: #000000;">:
    list</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> v;
    map</span>&lt;<span style="color: #0000ff;">int</span>, vector&lt;list&lt;<span style="color: #0000ff;">int</span>&gt;::iterator&gt;&gt;<span style="color: #000000;"> m;
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4091064.html" target="_blank">Min Stack</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/110014/c-using-two-stack">https://discuss.leetcode.com/topic/110014/c-using-two-stack</a></p>
<p><a href="https://discuss.leetcode.com/topic/110066/c-o-logn-for-write-ops-o-1-for-reads">https://discuss.leetcode.com/topic/110066/c-o-logn-for-write-ops-o-1-for-reads</a> </p>
</div>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-11-12 22:56</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7823424" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7823424);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/8586531.html" id="cb_post_title_url">[LeetCode] Range Module 范围模块</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>A Range Module is a module that tracks ranges of numbers. Your task is to design and implement the following interfaces in an efficient manner.</p>
<p> </p>
<ul>
<li><code>addRange(int left, int right)</code> Adds the half-open interval <code>[left, right)</code>, tracking every real number in that interval. Adding an interval that partially overlaps with currently tracked numbers should add any numbers in the interval <code>[left, right)</code> that are not already tracked.</li>
</ul>
<p> </p>
<p> </p>
<ul>
<li><code>queryRange(int left, int right)</code> Returns true if and only if every real number in the interval <code>[left, right)</code> is currently being tracked.</li>
</ul>
<p> </p>
<p> </p>
<ul>
<li><code>removeRange(int left, int right)</code> Stops tracking every real number currently being tracked in the interval <code>[left, right)</code>.</li>
</ul>
<p> </p>
<p>Example 1:</p>
<pre>addRange(10, 20): null
removeRange(14, 16): null
queryRange(10, 14): true (Every number in [10, 14) is being tracked)
queryRange(13, 15): false (Numbers like 14, 14.03, 14.17 in [13, 15) are not being tracked)
queryRange(16, 17): true (The number 16 in [16, 17) is still being tracked, despite the remove operation)
</pre>
<p> </p>
<p>Note:</p>
<ul>
<li>A half open interval <code>[left, right)</code> denotes all real numbers <code>left &lt;= x &lt; right</code>.</li>
<li><code>0 &lt; left &lt; right &lt; 10^9</code> in all calls to <code>addRange, queryRange, removeRange</code>.</li>
<li>The total number of calls to <code>addRange</code> in a single test case is at most <code>1000</code>.</li>
<li>The total number of calls to <code>queryRange</code> in a single test case is at most <code>5000</code>.</li>
<li>The total number of calls to <code>removeRange</code> in a single test case is at most <code>1000</code>.</li>
</ul>
<p> </p>
<p>这道题让我们实现一个RangeModule的类，里面有三个功能函数，分别好似插入范围，查找范围，删除范围，题目中的例子给的也很明确，基本不会引起什么歧义。其实不管范围也好，区间也好，都是一回事，跟之前的区间的题目<a href="http://www.cnblogs.com/grandyang/p/4367569.html" target="_blank">Insert Interval</a>和<a href="http://www.cnblogs.com/grandyang/p/4370601.html" target="_blank">Merge Intervals</a>没有什么不同。这里的插入范围函数的实现方法跟之前那道<a href="http://www.cnblogs.com/grandyang/p/4367569.html" target="_blank">Insert Interval</a>的解法一样，直接抄过来就好。然后对于查找范围函数，由于题目中说只要有数字未被包括，就返回false。那么我们反过来想，只有当某个范围完全覆盖了这个要查找的范围才会返回true，所以我们可以遍历所有的范围，然后看是否有一个范围完全覆盖了要查找的范围，有的话返回true，循环结束后返回false。最后来看删除范围函数，其实现方法跟插入范围函数很类似，但又有少许不同。首先我们还是新建一个数组res存结果，然后遍历已有的范围，如果当前范围的结束位置小于等于要删除的范围的起始位置，由于题目中的范围定义是左开右闭，那么说明没有重叠，加入结果res，并且用变量cur自增1来记录当前位置。如果当前范围的起始位置大于等于要删除的范围的结束位置，说明咩有重叠，加入结果res。否则就是有重叠的情况，这里跟插入范围有所不同的是，插入范围只需要加入一个范围，而删除范围操作有可能将原来的大范围break成为两个小的范围，所以我们用一个临时数组t来存break掉后的小范围。如果当前范围的起始位置小于要删除的范围的起始位置left，说明此时一定有一段范围留下来了，即从当前范围的起始位置到要删除的范围的起始位置left，将这段范围加入临时数组t，同理，如果当前范围的结束位置大于要删除的范围的结束位置right，将这段范围加入临时数组t。最后将数组t加入结果res中的cur位置即可，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> RangeModule {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    RangeModule() {}
    
    </span><span style="color: #0000ff;">void</span> addRange(<span style="color: #0000ff;">int</span> left, <span style="color: #0000ff;">int</span><span style="color: #000000;"> right) {
        vector</span>&lt;pair&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;&gt;<span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">int</span> n = v.size(), cur = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (v[i].second &lt;<span style="color: #000000;"> left) {
                res.push_back(v[i]);
                </span>++<span style="color: #000000;">cur;
            } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (v[i].first &gt;<span style="color: #000000;"> right) {
                res.push_back(v[i]);
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                left </span>=<span style="color: #000000;"> min(left, v[i].first);
                right </span>=<span style="color: #000000;"> max(right, v[i].second);
            }
        }
        res.insert(res.begin() </span>+<span style="color: #000000;"> cur, {left, right});
        v </span>=<span style="color: #000000;"> res;
    }
    
    </span><span style="color: #0000ff;">bool</span> queryRange(<span style="color: #0000ff;">int</span> left, <span style="color: #0000ff;">int</span><span style="color: #000000;"> right) {
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto a : v) {
            </span><span style="color: #0000ff;">if</span> (a.first &lt;= left &amp;&amp; a.second &gt;= right) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
    }
    
    </span><span style="color: #0000ff;">void</span> removeRange(<span style="color: #0000ff;">int</span> left, <span style="color: #0000ff;">int</span><span style="color: #000000;"> right) {
        vector</span>&lt;pair&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;&gt;<span style="color: #000000;"> res, t;
        </span><span style="color: #0000ff;">int</span> n = v.size(), cur = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (v[i].second &lt;=<span style="color: #000000;"> left) {
                res.push_back(v[i]);
                </span>++<span style="color: #000000;">cur;
            } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (v[i].first &gt;=<span style="color: #000000;"> right) {
                res.push_back(v[i]);
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                </span><span style="color: #0000ff;">if</span> (v[i].first &lt;<span style="color: #000000;"> left) {
                    t.push_back({v[i].first, left});
                }
                </span><span style="color: #0000ff;">if</span> (v[i].second &gt;<span style="color: #000000;"> right) {
                    t.push_back({right, v[i].second});
                }
            }
        }
        res.insert(res.begin() </span>+<span style="color: #000000;"> cur, t.begin(), t.end());
        v </span>=<span style="color: #000000;"> res;
    }

</span><span style="color: #0000ff;">private</span><span style="color: #000000;">:
    vector</span>&lt;pair&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;&gt;<span style="color: #000000;"> v;
};</span></pre>
</div>
<p> </p>
<p>下面来看一种优化了时间复杂度的解法，我们使用TreeMap来建立范围的起始位置和结束位置之间的映射，利用了TreeMap的自动排序功能，其会根据起始位置从小到大进行排序。既然是有序的，我们就可以利用二分法来快速进行查找了。</p>
<p>在加入范围函数中，我们首先用upper_bound函数来查找第一个大于left的位置，标记为l，再用upper_bound函数来查找第一个大于right的位置，标记为r。我们其实是想找第一个不大于left和right的位置的，由于C++没有floorKey这个函数，所以我们只能用upper_bound找大于left和right的位置，然后再往前移一个。如果l不是TreeMap中的第一个位置，且前面一个范围的结束位置小于left，说明和前一个范围没有交集，那么还是回到当前这个范围吧。如果此时l和r指向同一个位置，说明当前要加入的范围没有跟其他任何一个范围有交集，所以我们直接返回即可，不需要其他任何操作。否则的话我们将left和l指向范围的起始位置中的较小值赋给i，将right和r指向的前一个位置的结束位置的较大值赋给j，然后将l和r之间的范围都删除掉（注意这里r自增了1，是因为之前先自减了1），然后将i和j返回即可。返回后我们建立起这个映射即可。</p>
<p>在查找范围函数中，我们先用upper_bound找出第一个大于left位置的范围it，然后看如果it不是第一个范围，并且如果其前面的一个范围的结束位置大于等于right，说明已经完全包括这个要查找的范围，因为前一个范围的起始位置小于left，且结束位置大于等于right，直接返回true。</p>
<p>在删除范围函数中，查找重叠范围的方法跟加入范围函数中的操作一样，所以抽出来放到了find函数中，由于删除的范围有可能完全覆盖了原有范围，也有可能只是部分覆盖，将一个大的范围拆成了一个或者两个范围。所以我们判断，如果left大于覆盖范围的起始位置，那么将这段建立映射，同理，如果覆盖范围的结束位置大于right，同样建立这段的映射，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> RangeModule {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    RangeModule() {}
    
    </span><span style="color: #0000ff;">void</span> addRange(<span style="color: #0000ff;">int</span> left, <span style="color: #0000ff;">int</span><span style="color: #000000;"> right) {
        auto x </span>=<span style="color: #000000;"> find(left, right);
        m[x.first] </span>=<span style="color: #000000;"> x.second;
    }
    
    </span><span style="color: #0000ff;">bool</span> queryRange(<span style="color: #0000ff;">int</span> left, <span style="color: #0000ff;">int</span><span style="color: #000000;"> right) {
        auto it </span>=<span style="color: #000000;"> m.upper_bound(left);
        </span><span style="color: #0000ff;">return</span> it != m.begin() &amp;&amp; (--it)-&gt;second &gt;=<span style="color: #000000;"> right;
    }
    
    </span><span style="color: #0000ff;">void</span> removeRange(<span style="color: #0000ff;">int</span> left, <span style="color: #0000ff;">int</span><span style="color: #000000;"> right) {
        auto x </span>=<span style="color: #000000;"> find(left, right);
        </span><span style="color: #0000ff;">if</span> (left &gt; x.first) m[x.first] =<span style="color: #000000;"> left;
        </span><span style="color: #0000ff;">if</span> (x.second &gt; right) m[right] =<span style="color: #000000;"> x.second;
    }

</span><span style="color: #0000ff;">private</span><span style="color: #000000;">:
    map</span>&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> m;
    
    pair</span>&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt; find(<span style="color: #0000ff;">int</span> left, <span style="color: #0000ff;">int</span><span style="color: #000000;"> right) {
        auto l </span>= m.upper_bound(left), r =<span style="color: #000000;"> m.upper_bound(right);
        </span><span style="color: #0000ff;">if</span> (l != m.begin() &amp;&amp; (--l)-&gt;second &lt; left) ++<span style="color: #000000;">l;
        </span><span style="color: #0000ff;">if</span> (l == r) <span style="color: #0000ff;">return</span><span style="color: #000000;"> {left, right};
        </span><span style="color: #0000ff;">int</span> i = min(left, l-&gt;first), j = max(right, (--r)-&gt;<span style="color: #000000;">second);
        m.erase(l, </span>++<span style="color: #000000;">r);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> {i, j};
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/5548284.html">Data Stream as Disjoint Intervals</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4367569.html" target="_blank">Insert Interval</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4370601.html" target="_blank">Merge Intervals</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-03-16 23:53</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=8586531" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(8586531);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7776979.html" id="cb_post_title_url">[LeetCode] Best Time to Buy and Sell Stock with Transaction Fee 买股票的最佳时间含交易费</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Your are given an array of integers <code>prices</code>, for which the <code>i</code>-th element is the price of a given stock on day <code>i</code>; and a non-negative integer <code>fee</code> representing a transaction fee.</p>
<p>You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction. You may not buy more than 1 share of a stock at a time (ie. you must sell the stock share before you buy again.)</p>
<p>Return the maximum profit you can make.</p>
<p>Example 1:</p>
<pre>Input: prices = [1, 3, 2, 8, 4, 9], fee = 2
Output: 8
Explanation: The maximum profit can be achieved by:</pre>
<ul>
<li>Buying at prices[0] = 1</li>
<li>Selling at prices[3] = 8</li>
<li>Buying at prices[4] = 4</li>
<li>Selling at prices[5] = 9</li>
</ul>
<pre>The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.
</pre>
<p> </p>
<p>Note:</p>
<ul>
<li><code>0 &lt; prices.length &lt;= 50000</code>.</li>
<li><code>0 &lt; prices[i] &lt; 50000</code>.</li>
<li><code>0 &lt;= fee &lt; 50000</code>.</li>
</ul>
<p> </p>
<p>又是一道股票交易的题，之前已经有过类似的五道题了，<a href="https://discuss.leetcode.com/topic/107998/most-consistent-ways-of-dealing-with-the-series-of-stock-problems" target="_blank">fun4LeetCode大神的帖子</a>做了amazing的归纳总结，有时间的话博主也写个总结。这道题跟<a href="http://www.cnblogs.com/grandyang/p/4280803.html" target="_blank">Best Time to Buy and Sell Stock II</a>其实最像，但是由于那道题没有交易费的限制，所以我们就无脑贪婪就可以了，见到利润就往上加。但是这道题有了交易费，所以当卖出的利润小于交易费的时候，我们就不应该卖了，不然亏了。所以这道题还是还是得用动态规划来做，按照fun4LeetCode大神的理论，本质其实是个三维dp数组，由于第三维只有两种情况，卖出和保留，而且第二维交易的次数在这道题中没有限制，所以我们用两个一维数组就可以了，sold[i]表示第i天卖掉股票此时的最大利润，hold[i]表示第i天保留手里的股票此时的最大利润。那么我们来分析递推公式，在第i天，如果我们要卖掉手中的股票，那么此时我们的总利润应该是前一天手里有股票的利润(不然没股票卖毛啊)，加上此时的卖出价格，减去交易费得到的利润总值，跟前一天卖出的利润相比，取其中较大值，如果前一天卖出的利润较大，那么我们就前一天卖了，不留到今天了。然后来看如果第i天不卖的利润，就是昨天股票卖了的利润然后今天再买入股票，得减去今天的价格，得到的值和昨天股票保留时的利润相比，取其中的较大值，如果昨天保留股票的利润大，那么我们就继续保留到今天，所以递推时可以得到：</p>
<p>sold[i] = max(sold[i - 1], hold[i - 1] + prices[i] - fee);</p>
<p>hold[i] = max(hold[i - 1], sold[i - 1] - prices[i]);</p>
<p>参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> maxProfit(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; prices, <span style="color: #0000ff;">int</span><span style="color: #000000;"> fee) {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; sold(prices.size(), <span style="color: #800080;">0</span>), hold =<span style="color: #000000;"> sold;
        hold[</span><span style="color: #800080;">0</span>] = -prices[<span style="color: #800080;">0</span><span style="color: #000000;">];
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt; prices.size(); ++<span style="color: #000000;">i) {
            sold[i] </span>= max(sold[i - <span style="color: #800080;">1</span>], hold[i - <span style="color: #800080;">1</span>] + prices[i] -<span style="color: #000000;"> fee);
            hold[i] </span>= max(hold[i - <span style="color: #800080;">1</span>], sold[i - <span style="color: #800080;">1</span>] -<span style="color: #000000;"> prices[i]);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> sold.back();
    }
};</span></pre>
</div>
<p> </p>
<p>我们发现不管是卖出还是保留，第i天到利润只跟第i-1天有关系，所以我们可以优化空间，用两个变量来表示当前的卖出和保留的利润，更新方法和上面的基本相同，就是开始要保存sold的值，不然sold先更新后，再更新hold时就没能使用更新前的值了，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> maxProfit(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; prices, <span style="color: #0000ff;">int</span><span style="color: #000000;"> fee) {
        </span><span style="color: #0000ff;">int</span> sold = <span style="color: #800080;">0</span>, hold = -prices[<span style="color: #800080;">0</span><span style="color: #000000;">];
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span><span style="color: #000000;"> price : prices) {
            </span><span style="color: #0000ff;">int</span> t =<span style="color: #000000;"> sold;
            sold </span>= max(sold, hold + price -<span style="color: #000000;"> fee);
            hold </span>= max(hold, t -<span style="color: #000000;"> price);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> sold;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4997417.html">Best Time to Buy and Sell Stock with Cooldown</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4295761.html" target="_blank">Best Time to Buy and Sell Stock IV</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4281975.html" target="_blank">Best Time to Buy and Sell Stock III</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4280803.html" target="_blank">Best Time to Buy and Sell Stock II</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4280131.html" target="_blank">Best Time to Buy and Sell Stock</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/107992/java-dp-solution-easy-understand">https://discuss.leetcode.com/topic/107992/java-dp-solution-easy-understand</a></p>
<p><a href="https://discuss.leetcode.com/topic/107977/c-concise-solution-o-n-time-o-1-space">https://discuss.leetcode.com/topic/107977/c-concise-solution-o-n-time-o-1-space</a></p>
<p><a href="https://discuss.leetcode.com/topic/107998/most-consistent-ways-of-dealing-with-the-series-of-stock-problems">https://discuss.leetcode.com/topic/107998/most-consistent-ways-of-dealing-with-the-series-of-stock-problems</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-11-03 10:29</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7776979" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7776979);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7753959.html" id="cb_post_title_url">[LeetCode] Subarray Product Less Than K 子数组乘积小于K</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Your are given an array of positive integers <code>nums</code>.</p>
<p>Count and print the number of (contiguous) subarrays where the product of all the elements in the subarray is less than <code>k</code>.</p>
<p><strong>Example 1:</strong><br/>
</p>
<pre><strong>Input:</strong> nums = [10, 5, 2, 6], k = 100
<strong>Output:</strong> 8
<strong>Explanation:</strong> The 8 subarrays that have product less than 100 are: [10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6].
Note that [10, 5, 2] is not included as the product of 100 is not strictly less than k.
</pre>
<p><strong>Note:</strong></p>
<div class="question-description">
<ul>
<li><code>0 &lt; nums.length &lt;= 50000</code>.</li>
<li><code>0 &lt; nums[i] &lt; 1000</code>.</li>
<li><code>0 &lt;= k &lt; 10^6</code>.</li>
</ul>
</div>
<p> </p>
<p>这道题给了我们一个数组和一个数字K，让我们求子数组且满足乘积小于K的个数。既然是子数组，那么必须是连续的，所以肯定不能给数组排序了，这道题好在限定了输入数字都是正数，能稍稍好做一点。博主刚开始用的是暴力搜索的方法来做的，就是遍历所有的子数组算乘积和K比较，两个for循环就行了，但是OJ不答应。于是上网搜大神们的解法，思路很赞。相当于是一种滑动窗口的解法，维护一个数字乘积刚好小于k的滑动窗口，用变量left来记录其左边界的位置，右边界i就是当前遍历到的位置。遍历原数组，用prod乘上当前遍历到的数字，然后进行while循环，如果prod大于等于k，则滑动窗口的左边界需要向右移动一位，删除最左边的数字，那么少了一个数字，乘积就会改变，所以用prod除以最左边的数字，然后左边右移一位，即left自增1。当我们确定了窗口的大小后，就可以统计子数组的个数了，就是窗口的大小。为啥呢，比如[5 2 6]这个窗口，k还是100，右边界刚滑到6这个位置，这个窗口的大小就是包含6的子数组乘积小于k的个数，即[6], [2 6], [5 2 6]，正好是3个。所以窗口每次向右增加一个数字，然后左边去掉需要去掉的数字后，窗口的大小就是新的子数组的个数，每次加到结果res中即可，参见代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> numSubarrayProductLessThanK(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; nums, <span style="color: #0000ff;">int</span><span style="color: #000000;"> k) {
        </span><span style="color: #0000ff;">if</span> (k &lt;= <span style="color: #800080;">1</span>) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, prod = <span style="color: #800080;">1</span>, left = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; nums.size(); ++<span style="color: #000000;">i) {
            prod </span>*=<span style="color: #000000;"> nums[i];
            </span><span style="color: #0000ff;">while</span> (prod &gt;= k) prod /= nums[left++<span style="color: #000000;">];
            res </span>+= i - left + <span style="color: #800080;">1</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>讨论：这道题其实可有很多种变形，比如当数组的数字有负数和0该怎么做？或者求的不是子数组，而是子序列该怎么做，子序列的话就可以排序啦，当然还是需要都是正数，才有排序的意义，博主觉得如果有负数和0，是不是只能暴力破解了，或者使用<a href="http://www.cnblogs.com/grandyang/p/4028713.html" target="_blank">Maximum Product Subarray</a>中的方法？再有一种的变形就是求子数组或子序列乘积刚好等于k，这就跟<a href="http://www.cnblogs.com/grandyang/p/6810361.html">Subarray Sum Equals K</a>和<a href="http://www.cnblogs.com/grandyang/p/5336668.html" target="_blank">Maximum Size Subarray Sum Equals k</a>这两题中使用的方法类似吧，建立子数组和其乘积之间的映射来快速找到。</p>
<p>欢迎大家在评论区留言讨论！</p>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4028713.html" target="_blank">Maximum Product Subarray</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/6810361.html">Subarray Sum Equals K</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/5336668.html" target="_blank">Maximum Size Subarray Sum Equals k</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-10-30 12:32</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7753959" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7753959);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7752002.html" id="cb_post_title_url">[LeetCode] Minimum ASCII Delete Sum for Two Strings 两个字符串的最小ASCII删除和</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="question-description">
<p>Given two strings <code>s1, s2</code>, find the lowest ASCII sum of deleted characters to make two strings equal.</p>
<p>Example 1:</p>
<pre>Input: s1 = "sea", s2 = "eat"
Output: 231
Explanation: Deleting "s" from "sea" adds the ASCII value of "s" (115) to the sum.
Deleting "t" from "eat" adds 116 to the sum.
At the end, both strings are equal, and 115 + 116 = 231 is the minimum sum possible to achieve this.
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input: s1 = "delete", s2 = "leet"
Output: 403
Explanation: Deleting "dee" from "delete" to turn the string into "let",
adds 100[d]+101[e]+101[e] to the sum.  Deleting "e" from "leet" adds 101[e] to the sum.
At the end, both strings are equal to "let", and the answer is 100+101+101+101 = 403.
If instead we turned both strings into "lee" or "eet", we would get answers of 433 or 417, which are higher.
</pre>
<p> </p>
<p>Note:</p>
<ul>
<li><code>0 &lt; s1.length, s2.length &lt;= 1000</code>.</li>
<li>All elements of each string will have an ASCII value in <code>[97, 122]</code>.</li>
</ul>
<p> </p>
<p>这道题给了我们两个字符串，让我们删除一些字符使得两个字符串相等，我们希望删除的字符的ASCII码最小。这道题跟之前那道<a href="http://www.cnblogs.com/grandyang/p/7144045.html">Delete Operation for Two Strings</a>极其类似，那道题让求删除的最少的字符数，这道题换成了ASCII码值。其实很多大厂的面试就是这种改动，虽然很少出原题，但是这种小范围的改动却是很经常的，所以当背题侠是没有用的，必须要完全掌握了解题思想，并能举一反三才是最重要的。看到这种玩字符串又是求极值的题，想都不要想直接上DP，我们建立一个二维数组dp，其中dp[i][j]表示字符串s1的前i个字符和字符串s2的前j个字符变相等所要删除的字符的最小ASCII码累加值。那么我们可以先初始化边缘，即有一个字符串为空的话，那么另一个字符串有多少字符就要删多少字符，才能变空字符串。所以我们初始化dp[0][j]和dp[i][0]，计算方法就是上一个dp值加上对应位置的字符，有点像计算累加数组的方法，由于字符就是用ASCII表示的，所以我们不用转int，直接累加就可以。这里我们把dp[i][0]的计算放入大的循环中计算，是为了少写一个for循环。好，现在我们来看递推公式，需要遍历这个二维数组的每一个位置即dp[i][j]，当对应位置的字符相等时，s1[i-1] == s2[j-1]，(注意由于dp数组的i和j是从1开始的，所以字符串中要减1)，那么我们直接赋值为上一个状态的dp值，即dp[i-1][j-1]，因为已经匹配上了，不用删除字符。如果s1[i-1] != s2[j-1]，那么就有两种情况，我们可以删除s[i-1]的字符，且加上被删除的字符的ASCII码到上一个状态的dp值中，即dp[i-1][j] + s1[i-1]，或者删除s[j-1]的字符，且加上被删除的字符的ASCII码到上一个状态的dp值中，即dp[i][j-1] + s2[j-1]。这不难理解吧，比如sea和eat，当首字符s和e失配了，那么有两种情况，要么删掉s，用ea和eat继续匹配，或者删掉e，用sea和at继续匹配，记住删掉的字符一定要累加到dp值中才行，参见代码如下：</p>
<p> </p>
<p>解法一： </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> minimumDeleteSum(<span style="color: #0000ff;">string</span> s1, <span style="color: #0000ff;">string</span><span style="color: #000000;"> s2) {
        </span><span style="color: #0000ff;">int</span> m = s1.size(), n =<span style="color: #000000;"> s2.size();
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; dp(m + <span style="color: #800080;">1</span>, vector&lt;<span style="color: #0000ff;">int</span>&gt;(n + <span style="color: #800080;">1</span>, <span style="color: #800080;">0</span><span style="color: #000000;">));
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">1</span>; j &lt;= n; ++j) dp[<span style="color: #800080;">0</span>][j] = dp[<span style="color: #800080;">0</span>][j - <span style="color: #800080;">1</span>] + s2[j - <span style="color: #800080;">1</span><span style="color: #000000;">];
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt;= m; ++<span style="color: #000000;">i) {
            dp[i][</span><span style="color: #800080;">0</span>] = dp[i - <span style="color: #800080;">1</span>][<span style="color: #800080;">0</span>] + s1[i - <span style="color: #800080;">1</span><span style="color: #000000;">];
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">1</span>; j &lt;= n; ++<span style="color: #000000;">j) {
                dp[i][j] </span>= (s1[i - <span style="color: #800080;">1</span>] == s2[j - <span style="color: #800080;">1</span>]) ? dp[i - <span style="color: #800080;">1</span>][j - <span style="color: #800080;">1</span>] : min(dp[i - <span style="color: #800080;">1</span>][j] + s1[i - <span style="color: #800080;">1</span>], dp[i][j - <span style="color: #800080;">1</span>] + s2[j - <span style="color: #800080;">1</span><span style="color: #000000;">]);
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> dp[m][n];
    }
};</span></pre>
</div>
<p> </p>
<p>我们也可以优化空间复杂度，使用一个一维数组dp，其中dp[i]表示字符串s1和字符串s2的前i个字符变相等所要删除的字符的最小ASCII码累加值。刚开始还是要初始化dp[j]，这里用变量t1和t2保存上一个状态的值，并不断更新。如果面试官没有特别的要求，还是用二维dp数组吧，毕竟逻辑更清晰一些，一维的容易写错～</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> minimumDeleteSum(<span style="color: #0000ff;">string</span> s1, <span style="color: #0000ff;">string</span><span style="color: #000000;"> s2) {
        </span><span style="color: #0000ff;">int</span> m = s1.size(), n =<span style="color: #000000;"> s2.size();
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; dp(n + <span style="color: #800080;">1</span>, <span style="color: #800080;">0</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">1</span>; j &lt;= n; ++j) dp[j] = dp[j - <span style="color: #800080;">1</span>] + s2[j - <span style="color: #800080;">1</span><span style="color: #000000;">];
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt;= m; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">int</span> t1 = dp[<span style="color: #800080;">0</span><span style="color: #000000;">];
            dp[</span><span style="color: #800080;">0</span>] += s1[i - <span style="color: #800080;">1</span><span style="color: #000000;">];
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">1</span>; j &lt;= n; ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">int</span> t2 =<span style="color: #000000;"> dp[j];
                dp[j] </span>= (s1[i - <span style="color: #800080;">1</span>] == s2[j - <span style="color: #800080;">1</span>]) ? t1 : min(dp[j] + s1[i - <span style="color: #800080;">1</span>], dp[j - <span style="color: #800080;">1</span>] + s2[j - <span style="color: #800080;">1</span><span style="color: #000000;">]);
                t1 </span>=<span style="color: #000000;"> t2;
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> dp[n];
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种方法思路也很巧妙，反其道而行之，相当于先计算了字符串s1和s2的最大相同子序列，在这道题中就是最大相同子序列的ASCII码值，然后用s1和s2的所有字符之和减去这个最大ASCII码值的两倍，就是要删除的字符的最小ASCII码值了。那么还是建立二维数组dp，其中dp[i][j]表示字符串s1的前i个字符和字符串s2点前j个字符中的最大相同子序列的ASCII值。然后我们遍历所有的位置，当对应位置的字符相等时，s1[i-1] == s2[j-1]，那么我们直接赋值为上一个状态的dp值加上这个相同的字符，即dp[i-1][j-1] + s1[i-1]，注意这里跟解法一不同之处，因为dp的定义不同，所以写法不同。如果s1[i-1] != s2[j-1]，那么就有两种情况，我们可以删除s[i-1]的字符，即dp[i-1][j]，或者删除s[j-1]的字符，即dp[i][j-1]，取二者中最大值赋给dp[i][j]。最后分别算出s1和s2的累加值，减去两倍的dp最大值即可，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> minimumDeleteSum(<span style="color: #0000ff;">string</span> s1, <span style="color: #0000ff;">string</span><span style="color: #000000;"> s2) {
        </span><span style="color: #0000ff;">int</span> m = s1.size(), n =<span style="color: #000000;"> s2.size();
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; dp(m + <span style="color: #800080;">1</span>, vector&lt;<span style="color: #0000ff;">int</span>&gt;(n + <span style="color: #800080;">1</span>, <span style="color: #800080;">0</span><span style="color: #000000;">));
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt;= m; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">1</span>; j &lt;= n; ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> (s1[i - <span style="color: #800080;">1</span>] == s2[j - <span style="color: #800080;">1</span>]) dp[i][j] = dp[i - <span style="color: #800080;">1</span>][j - <span style="color: #800080;">1</span>] + s1[i - <span style="color: #800080;">1</span><span style="color: #000000;">];
                </span><span style="color: #0000ff;">else</span> dp[i][j] = max(dp[i - <span style="color: #800080;">1</span>][j], dp[i][j - <span style="color: #800080;">1</span><span style="color: #000000;">]);
            }
        }
        </span><span style="color: #0000ff;">int</span> sum1 = accumulate(s1.begin(), s1.end(), <span style="color: #800080;">0</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">int</span> sum2 = accumulate(s2.begin(), s2.end(), <span style="color: #800080;">0</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">return</span> sum1 + sum2 - <span style="color: #800080;">2</span> *<span style="color: #000000;"> dp[m][n];
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4344107.html" target="_blank">Edit Distance</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4938187.html">Longest Increasing Subsequence</a></p>
</div>
<div id="interviewed-div"><a href="http://www.cnblogs.com/grandyang/p/7144045.html">Delete Operation for Two Strings</a></div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/107995/concise-dp-solution">https://discuss.leetcode.com/topic/107995/concise-dp-solution</a></p>
<p><a href="https://discuss.leetcode.com/topic/107980/c-dp-with-explanation/2">https://discuss.leetcode.com/topic/107980/c-dp-with-explanation</a></p>
<p><a href="https://discuss.leetcode.com/topic/108029/lcs-variation-solution-python-c/2">https://discuss.leetcode.com/topic/108029/lcs-variation-solution-python-c</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-10-29 23:50</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7752002" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7752002);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/8542820.html" id="cb_post_title_url">[LeetCode] Number of Distinct Islands II 不同岛屿的个数之二</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a non-empty 2D array <code>grid</code> of 0's and 1's, an island is a group of <code>1</code>'s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.</p>
<p>Count the number of distinct islands. An island is considered to be the same as another if they have the same shape, or have the same shape after rotation (90, 180, or 270 degrees only) or reflection (left/right direction or up/down direction).</p>
<p>Example 1:</p>
<pre>11000
10000
00001
00011
</pre>
<p>Given the above grid map, return <code>1</code>. <br/><br/>Notice that:</p>
<pre>11
1
</pre>
<p>and</p>
<pre> 1
11
</pre>
<p>are considered same island shapes. Because if we make a 180 degrees clockwise rotation on the first island, then two islands will have the same shapes.</p>
<p> </p>
<p>Example 2:</p>
<pre>11100
10001
01001
01110</pre>
<p>Given the above grid map, return <code>2</code>.<br/><br/>Here are the two distinct islands:</p>
<pre>111
1
</pre>
<p>and</p>
<pre>1
1
</pre>
<p><br/>Notice that:</p>
<pre>111
1
</pre>
<p>and</p>
<pre>1
111
</pre>
<p>are considered same island shapes. Because if we flip the first array in the up/down direction, then they have the same shapes.</p>
<p> </p>
<p>Note: The length of each dimension in the given <code>grid</code> does not exceed 50.</p>
<p> </p>
<p>s</p>
<p> </p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-03-10 23:55</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=8542820" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(8542820);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/9937844.html" id="cb_post_title_url">[LeetCode] Binary Search 二分搜索法</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a sorted (in ascending order) integer array <code>nums</code> of <code>n</code> elements and a <code>target</code> value, write a function to search <code>target</code> in <code>nums</code>. If <code>target</code> exists, then return its index, otherwise return <code>-1</code>.</p>
<p><br/>Example 1:</p>
<pre>Input: <code>nums</code> = [-1,0,3,5,9,12], <code>target</code> = 9
Output: 4
Explanation: 9 exists in <code>nums</code> and its index is 4

</pre>
<p>Example 2:</p>
<pre>Input: <code>nums</code> = [-1,0,3,5,9,12], <code>target</code> = 2
Output: -1
Explanation: 2 does not exist in <code>nums</code> so return -1
</pre>
<p> </p>
<p>Note:</p>
<ol>
<li>You may assume that all elements in <code>nums</code> are unique.</li>
<li><code>n</code> will be in the range <code>[1, 10000]</code>.</li>
<li>The value of each element in <code>nums</code> will be in the range <code>[-9999, 9999]</code>.</li>
</ol>
<p> </p>
<p>这道题就是最基本的二分搜索法了，这是博主之前总结的<a class="entrylistItemTitle" href="http://www.cnblogs.com/grandyang/p/6854825.html" id="CategoryEntryList1_EntryStoryList_ctl00_Entries_TitleUrl_1">LeetCode Binary Search Summary 二分搜索法小结</a>的四种之中的第一类，也是最简单的一类，写法什么很模版啊，注意right的初始化值，还有while的循环条件，以及right的更新值，这三点不同的人可能会有不同的写法，选一种自己最习惯的就好啦，参见代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> search(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; nums, <span style="color: #0000ff;">int</span><span style="color: #000000;"> target) {
        </span><span style="color: #0000ff;">int</span> left = <span style="color: #800080;">0</span>, right =<span style="color: #000000;"> nums.size();
        </span><span style="color: #0000ff;">while</span> (left &lt;<span style="color: #000000;"> right) {
            </span><span style="color: #0000ff;">int</span> mid = left + (right - left) / <span style="color: #800080;">2</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> (nums[mid] == target) <span style="color: #0000ff;">return</span><span style="color: #000000;"> mid;
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (nums[mid] &lt; target) left = mid + <span style="color: #800080;">1</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">else</span> right =<span style="color: #000000;"> mid;
        }
        </span><span style="color: #0000ff;">return</span> -<span style="color: #800080;">1</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="https://www.cnblogs.com/grandyang/p/9937770.html">Search in a Sorted Array of Unknown Size</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a href="http://www.cnblogs.com/grandyang/p/4606334.html" target="_blank">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-11-10 00:50</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=9937844" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(9937844);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/9937770.html" id="cb_post_title_url">[LeetCode] Search in a Sorted Array of Unknown Size 在未知大小的有序数组中搜索</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given an integer array sorted in ascending order, write a function to search <code>target</code> in <code>nums</code>.  If <code>target</code> exists, then return its index, otherwise return <code>-1</code>. However, the array size is unknown to you. You may only access the array using an <code>ArrayReader</code> interface, where <code>ArrayReader.get(k)</code> returns the element of the array at index <code>k</code> (0-indexed).</p>
<p>You may assume all integers in the array are less than <code>10000</code>, and if you access the array out of bounds, <code>ArrayReader.get</code> will return <code>2147483647</code>.</p>
<p> </p>
<p>Example 1:</p>
<pre>Input: <code>array</code> = [-1,0,3,5,9,12], <code>target</code> = 9
Output: 4
Explanation: 9 exists in <code>nums</code> and its index is 4
</pre>
<p>Example 2:</p>
<pre>Input: <code>array</code> = [-1,0,3,5,9,12], <code>target</code> = 2
Output: -1
Explanation: 2 does not exist in <code>nums</code> so return -1</pre>
<p> </p>
<p>Note:</p>
<ol>
<li>You may assume that all elements in the array are unique.</li>
<li>The value of each element in the array will be in the range <code>[-9999, 9999]</code>.</li>
</ol>
<p> </p>
<p>这道题给了我们一个未知大小的数组，让我们在其中搜索数字。给了我们一个ArrayReader的类，我们可以通过get函数来获得数组中的数字，如果越界了的话，会返回整型数最大值。既然是有序数组，又要搜索，那么二分搜索法肯定是不二之选，问题是需要知道数组的首尾两端的位置，才能进行二分搜索，而这道题刚好就是大小未知的数组。所以博主的第一个想法就是先用二分搜索法来求出数组的大小，然后再用一个二分搜索来查找数字，这种方法是可以通过OJ的。但其实我们是不用先来确定数组的大小的，而是可以直接进行搜索数字，我们实际上是假设数组就有整型最大值个数字，在多余的位置上相当于都填上了整型最大值，那么这也是一个有序的数组，我们可以直接用一个二分搜索法进行查找即可，参见代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> Forward declaration of ArrayReader class.</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> ArrayReader;

</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> search(<span style="color: #0000ff;">const</span> ArrayReader&amp; reader, <span style="color: #0000ff;">int</span><span style="color: #000000;"> target) {
        </span><span style="color: #0000ff;">int</span> left = <span style="color: #800080;">0</span>, right =<span style="color: #000000;"> INT_MAX;
        </span><span style="color: #0000ff;">while</span> (left &lt;<span style="color: #000000;"> right) {
            </span><span style="color: #0000ff;">int</span> mid = left + (right - left) / <span style="color: #800080;">2</span>, x = reader.<span style="color: #0000ff;">get</span><span style="color: #000000;">(mid);
            </span><span style="color: #0000ff;">if</span> (x == target) <span style="color: #0000ff;">return</span><span style="color: #000000;"> mid;
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (x &lt; target) left = mid + <span style="color: #800080;">1</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">else</span> right =<span style="color: #000000;"> mid;
        }
        </span><span style="color: #0000ff;">return</span> -<span style="color: #800080;">1</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/9937844.html" id="homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0">Binary Search</a></p>
<p> </p>
<p>类似题目：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-11-09 23:58</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=9937770" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(9937770);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/9914546.html" id="cb_post_title_url">[LeetCode] Insert into a Binary Search Tree 二叉搜索树中插入结点</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given the root node of a binary search tree (BST) and a value to be inserted into the tree, insert the value into the BST. Return the root node of the BST after the insertion. It is guaranteed that the new value does not exist in the original BST.</p>
<p>Note that there may exist multiple valid ways for the insertion, as long as the tree remains a BST after insertion. You can return any of them.</p>
<p>For example, </p>
<pre>Given the tree:
        4
       / \
      2   7
     / \
    1   3
And the value to insert: 5
</pre>
<p>You can return this binary search tree:</p>
<pre>         4
       /   \
      2     7
     / \   /
    1   3 5
</pre>
<p>This tree is also valid:</p>
<pre>         5
       /   \
      2     7
     / \   
    1   3
         \
          4</pre>
<p> </p>
<p>这道题让我们在二叉搜索树中插入结点，当前还需要保持二叉搜索树的性质，那么插入结点的方式就有多种，就像题目中给的那个例子。结点5可以有不同的方法，但是很显然，放在结点7的左子结点比代替结点4成为根结点要来的简单许多。怎么简单我们就怎么来，所以还是按照简单的来吧。由于二叉搜索树自带二分的性质，那么首先根结点比较，如果大于根结点值的话，说明肯定要插入到右子树中。所以接下来跟7比较，对于递归函数来说，结点7也可以当作是一个新的根结点，那么由于结点7的值大于目标值5，所以要去其左子树，我们发现其左子结点为空，那么我们就可以根据目标值来生成一个新的结点，然后连到结点7的左子树上即可。那么在递归函数中，首先判断当前结点是否为空，为空的话就新建一个结点返回。否则就判断当前结点值是否大于目标值，是的话就对左子结点调用递归函数，并将返回值赋给当前结点的左子结点，否则就对右子结点调用递归函数，并将返回值赋给当前结点的右子结点，最后返回当前结点即可，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    TreeNode</span>* insertIntoBST(TreeNode* root, <span style="color: #0000ff;">int</span><span style="color: #000000;"> val) {
        </span><span style="color: #0000ff;">if</span> (!root) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> TreeNode(val);
        </span><span style="color: #0000ff;">if</span> (root-&gt;val &gt; val) root-&gt;left = insertIntoBST(root-&gt;<span style="color: #000000;">left, val);
        </span><span style="color: #0000ff;">else</span> root-&gt;right = insertIntoBST(root-&gt;<span style="color: #000000;">right, val);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> root;
    }
};</span></pre>
</div>
<p> </p>
<p>我们也可以不使用递归来做，而是用迭代。整体思路跟递归并没有太大的区别，但没有递归写法简洁。首先还是判空，若为空，就新建结点返回。然后用一个变量cur来遍历，在while循环中，如果当前值大于目标值，如果其左子结点不存在，那么我们新建结点，并连上其左子结点，并跳出循环；若左子结点存在，则cur指向其左子结点。否则，当前值小于目标值，若其右子结点不存在，新建结点并连上其右子结点，并跳出循环；若右子结点存在，则cur指向其右子结点。最后返回root即可，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    TreeNode</span>* insertIntoBST(TreeNode* root, <span style="color: #0000ff;">int</span><span style="color: #000000;"> val) {
        </span><span style="color: #0000ff;">if</span> (!root) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> TreeNode(val);
        TreeNode </span>*cur =<span style="color: #000000;"> root;
        </span><span style="color: #0000ff;">while</span> (<span style="color: #0000ff;">true</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">if</span> (cur-&gt;val &gt;<span style="color: #000000;"> val) {
                </span><span style="color: #0000ff;">if</span> (!cur-&gt;left) {cur-&gt;left = <span style="color: #0000ff;">new</span> TreeNode(val); <span style="color: #0000ff;">break</span><span style="color: #000000;">;}
                cur </span>= cur-&gt;<span style="color: #000000;">left;
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                </span><span style="color: #0000ff;">if</span> (!cur-&gt;right) {cur-&gt;right = <span style="color: #0000ff;">new</span> TreeNode(val); <span style="color: #0000ff;">break</span><span style="color: #000000;">;}
                cur </span>= cur-&gt;<span style="color: #000000;">right;
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> root;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/9912434.html" id="homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_1">Search in a Binary Search Tree</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-11-06 12:09</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=9914546" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(9914546);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/9912434.html" id="cb_post_title_url">[LeetCode] Search in a Binary Search Tree 二叉搜索树中搜索</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given the root node of a binary search tree (BST) and a value. You need to find the node in the BST that the node's value equals the given value. Return the subtree rooted with that node. If such node doesn't exist, you should return NULL.</p>
<p>For example, </p>
<pre>Given the tree:
        4
       / \
      2   7
     / \
    1   3

And the value to search: 2
</pre>
<p>You should return this subtree:</p>
<pre>      2     
     / \   
    1   3
</pre>
<p>In the example above, if we want to search the value <code>5</code>, since there is no node with value <code>5</code>, we should return <code>NULL</code>.</p>
<p>Note that an empty tree is represented by <code>NULL</code>, therefore you would see the expected output (serialized tree format) as <code>[]</code>, not <code>null</code>.</p>
<p> </p>
<p>这道题让我们搜索一个二叉搜索树，既然是二叉搜索树，而不是普通的二叉树，那么我们肯定要利用二叉搜索树特定的性质来解题，即左&lt;根&lt;右。那么就是说任意一个结点的左子树中的所有结点均小于当前结点，其右子树中的所有结点均大于当前结点。那么这不就是一个天然的二分么，当仁不让的二分搜索法呼之欲出啊。首先判空，如果当前结点不存在，直接返回空。如果当前结点值等于目标值，返回当前结点。接下来就看如果当前结点值大于目标值，则对左子结点调用递归函数，否则就对右子结点调用递归函数，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    TreeNode</span>* searchBST(TreeNode* root, <span style="color: #0000ff;">int</span><span style="color: #000000;"> val) {
        </span><span style="color: #0000ff;">if</span> (!root) <span style="color: #0000ff;">return</span><span style="color: #000000;"> NULL;
        </span><span style="color: #0000ff;">if</span> (root-&gt;val == val) <span style="color: #0000ff;">return</span><span style="color: #000000;"> root;
        </span><span style="color: #0000ff;">return</span> (root-&gt;val &gt; val) ? searchBST(root-&gt;left, val) : searchBST(root-&gt;<span style="color: #000000;">right, val);
    }
};</span></pre>
</div>
<p> </p>
<p>我们也可以使用迭代形式来解，使用一个while循环，思路都是一样的，如果当前结点存在，且结点值不等于目标值，那么若结点值大于目标值，则当前结点指向其左子结点，否则指向其右子结点，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    TreeNode</span>* searchBST(TreeNode* root, <span style="color: #0000ff;">int</span><span style="color: #000000;"> val) {
        </span><span style="color: #0000ff;">while</span> (root &amp;&amp; root-&gt;val !=<span style="color: #000000;"> val) {
            root </span>= (root-&gt;val &gt; val) ? root-&gt;left : root-&gt;<span style="color: #000000;">right;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> root;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/5237170.html" target="_blank">Closest Binary Search Tree Value</a></p>
<p><a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/9914546.html" id="homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0">Insert into a Binary Search Tree</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-11-06 00:00</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=9912434" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(9912434);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/8486414.html" id="cb_post_title_url">[LeetCode] Falling Squares 下落的方块</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>On an infinite number line (x-axis), we drop given squares in the order they are given.</p>
<p>The <code>i</code>-th square dropped (<code>positions[i] = (left, side_length)</code>) is a square with the left-most point being <code>positions[i][0]</code> and sidelength <code>positions[i][1]</code>.</p>
<p>The square is dropped with the bottom edge parallel to the number line, and from a higher height than all currently landed squares. We wait for each square to stick before dropping the next.</p>
<p>The squares are infinitely sticky on their bottom edge, and will remain fixed to any positive length surface they touch (either the number line or another square). Squares dropped adjacent to each other will not stick together prematurely.</p>
<p> </p>
<p>Return a list <code>ans</code> of heights. Each height <code>ans[i]</code> represents the current highest height of any square we have dropped, after dropping squares represented by <code>positions[0], positions[1], ..., positions[i]</code>.</p>
<p>Example 1:</p>
<pre>Input: [[1, 2], [2, 3], [6, 1]]
Output: [2, 5, 5]
Explanation:</pre>
<p>After the first drop of <code>positions[0] = [1, 2]: _aa _aa ------- </code>The maximum height of any square is 2.</p>
<p>After the second drop of <code>positions[1] = [2, 3]: __aaa __aaa __aaa _aa__ _aa__ -------------- </code>The maximum height of any square is 5. The larger square stays on top of the smaller square despite where its center of gravity is, because squares are infinitely sticky on their bottom edge.</p>
<p>After the third drop of <code>positions[1] = [6, 1]: __aaa __aaa __aaa _aa _aa___a -------------- </code>The maximum height of any square is still 5. Thus, we return an answer of <code>[2, 5, 5]</code>.</p>
<p> </p>
<p> </p>
<p>Example 2:</p>
<pre>Input: [[100, 100], [200, 100]]
Output: [100, 100]
Explanation: Adjacent squares don't get stuck prematurely - only their bottom edge can stick to surfaces.
</pre>
<p> </p>
<p>Note:</p>
<ul>
<li><code>1 &lt;= positions.length &lt;= 1000</code>.</li>
<li><code>1 &lt;= positions[i][0] &lt;= 10^8</code>.</li>
<li><code>1 &lt;= positions[i][1] &lt;= 10^6</code>.</li>
</ul>
<p> </p>
<p>这道题不就是经典的俄罗斯方块么？！只不过是简化版的，我们只有方块下落，没有其他那些奇形怪状的东西，这样简化了难度，不过方块的大小不是固定的，有可能很大，但是不管方块再大，只要有一点点部分搭在其他方块上面，整个方块都会在上面，并不会掉下来，让我们求每落下一个方块后的最大高度。我们知道返回的是每落下一个方块后当前场景中的最大高度，那么返回的数组的长度就应该和落下方块的个数相同。所以我们可以建立一个heights数组，其中heights[i]表示第i块方块落下后所在的高度，那么第i块方块落下后场景的最大高度就是[0, i]区间内的最大值。那么我们在求出heights数组后，只要不停返回[0, i]区间内的最大值即可。继续来看，这道题的难点就是方块重叠的情况，我们先来想，如果各个方块不重叠，那么heights[i]的高度就是每个方块自身的高度。一旦重叠了，就得在已有的基础上再加上自身的高度。那么我们可以采用brute force的思想，对于每个一个下落的方块，我们都去看和后面将要落下的方块有没有重叠，有的话，和后面将要落下的方块的位置相比较，取二者中较大值为后面要落下的方块位置高度heights[j]。判读两个方块是否重叠的方法是如果方块2的左边界小于方块1的右边界，并且方块2点右边界大于方块1点左边界。就拿题目中的例子1来举例吧，第一个下落的方块的范围是[1, 3]，长度为2，则heights[0]=2，然后我们看其和第二个方块[2, 5]是否重叠，发现是重叠的，则heights[1]更新为2，再看第三个方块[6, 7]，不重叠，不更新。然后第二个方块落下，此时累加高度，则heights[1]=5，再看第三个方块，不重叠，不更新。然后第三个方块落下, heights[2]=1。此时我们heights数组更新好了，然后我们开始从头遍历，维护一个当前最大值curMax，每次将[0, i]中最大值加入结果res即可，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; fallingSquares(vector&lt;pair&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> positions) {
        </span><span style="color: #0000ff;">int</span> n = positions.size(), cur = <span style="color: #800080;">0</span><span style="color: #000000;">;
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> heights(n), res;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">int</span> len = positions[i].second, left = positions[i].first, right = left +<span style="color: #000000;"> len;
            heights[i] </span>+=<span style="color: #000000;"> len;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = i + <span style="color: #800080;">1</span>; j &lt; n; ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">int</span> l = positions[j].first, r = l +<span style="color: #000000;"> positions[j].second;
                </span><span style="color: #0000ff;">if</span> (l &lt; right &amp;&amp; r &gt;<span style="color: #000000;"> left) {
                    heights[j] </span>=<span style="color: #000000;"> max(heights[j], heights[i]);
                }
            }
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span><span style="color: #000000;"> h : heights) {
            cur </span>=<span style="color: #000000;"> max(cur, h);
            res.push_back(cur);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>我们来看一种时间复杂度为O(nlogn)的解法，这种解法将每一个不同高度的区间都存到了一个HashMap中，然后每当有新的方块落下的时候，可以使用二分法来快速定位到可能发生重叠的区间的位置，如果有重叠的话，将原区间再根据高度拆成多个小区间，并且一直维护一个当前出现过的最高值，并加入结果res中。我们的HashMap的映射是建立pair和int之间的映射，由于HashMap是有自动排序的功能，默认的是使用pair中第一个元素，正好就是每个方块的起始位置。然后我们遍历每个下落的方块，建立一个临时的二维数组t，用来保存拆分后的小区间。然后我们取出当前方块的起始终止位置start和end，然后我们希望在HashMap中找第一个不大于当前方块起始位置的区间，在Java中我们可以使用floorKey()函数，但是在C++中，我们只有lower_bound()和upper_bound()可以用，分别表示找第一个不大于目标值，和第一个大于目标值的区间，那么我们为了找到第一个不大于当前起始位置的区间，可以先用upper_bound()来找到第一个大于起始位置的区间，然后向前移动一个，就是第一个不大于的了。注意向前移动操作有前提条件，就是upper_bound()返回的位置不能是首位置，否则无法前移，还有就是如果前一个区间的结束为止小于等于当前区间的起始位置，说明两个区间没有重叠，我们再移回来。</p>
<p>下面就要进行拆分区间的核心操作了，我们用一个while循环，循环条件是it存在，并且it指向区间的起始位置小于当前区间的结束位置。由于之前的操作确定了这两个区间一定会有重叠，那么重叠的方式就有一下四种（上方为当前区间，下方为it区间）：</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">      ———
      </span>| |<span style="color: #000000;">
      ———
<span style="color: #ff0000;">——————</span>——
</span><span style="color: #ff0000;">|</span>      |<span style="color: #000000;"><span style="color: #ff0000;">
——————</span>——</span></pre>
</div>
<p>如上图所示，如果当前区间（上方）的起始位置大于it指向区间（下方）的起始位置，说明红色那段区间需要被拆分出来，我们将其拆分出来并存入数组t中。</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">  ———
  </span>| |<span style="color: #000000;">
  ———
    —<span style="color: #ff00ff;">———————
    </span></span>|      <span style="color: #ff00ff;">|</span><span style="color: #000000;">
    —<span style="color: #ff00ff;">———————</span></span></pre>
</div>
<p>如上图所示，如果当前区间（上方）的结束位置小于it指向区间（下方）的结束位置，说明洋红色那段区间需要被拆分出来，我们将其拆分出来并存入数组t中。</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">  ———
  </span>| |<span style="color: #000000;">
  ———
<span style="color: #ff0000;">——</span>———<span style="color: #ff00ff;">———
</span></span><span style="color: #ff0000;">|</span>      <span style="color: #ff00ff;">|</span><span style="color: #000000;"><span style="color: #ff0000;">
——</span>———<span style="color: #ff00ff;">———</span></span></pre>
</div>
<p>如上图所示，红色区间和洋红色区间都需要拆分出来，我们将其拆分出来并存入数组t中。</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">————————
</span>|      |<span style="color: #000000;">
————————
  ———
  </span>| |<span style="color: #000000;">
  ———</span></pre>
</div>
<p>如上图所示，底层方块被完全覆盖了，没有区间需要被拆分出来。</p>
<p>我们用底层it指向的区间的高度来更新h，这里的h表示当前方块下落后的基础高度，然后我们将底层it指向的区间删除，因为我们已经将没有被覆盖的区间拆分出来并存入数组t中了。注意erase()函数返回的是被删除区间的下一个位置，这样使得我们的while函数能继续判断，直到it区间和当前区间不再重叠位置。退出while循环后，我们需要将当前下落方块的区间加入HashMap中，高度为基础高度h加上自身高度len。接下来就把数组t中拆分出来的小区间都加入到HashMap中，然后用当前用h+len来更新curMax，表示当前场景最大高度，加入结果res中，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; fallingSquares(vector&lt;pair&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> positions) {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> res;
        map</span>&lt;pair&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> m;
        </span><span style="color: #0000ff;">int</span> curMax = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (auto &amp;<span style="color: #000000;">pos : positions) {
            vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;<span style="color: #000000;"> t;
            </span><span style="color: #0000ff;">int</span> len = pos.second, start = pos.first, end = start + len, h = <span style="color: #800080;">0</span><span style="color: #000000;">;
            auto it </span>=<span style="color: #000000;"> m.upper_bound({start, start});
            </span><span style="color: #0000ff;">if</span> (it != m.begin() &amp;&amp; (--it)-&gt;first.second &lt;= start) ++<span style="color: #000000;">it;
            </span><span style="color: #0000ff;">while</span> (it != m.end() &amp;&amp; it-&gt;first.first &lt;<span style="color: #000000;"> end) {
                </span><span style="color: #0000ff;">if</span> (start &gt; it-&gt;first.first) t.push_back({it-&gt;first.first, start, it-&gt;<span style="color: #000000;">second});
                </span><span style="color: #0000ff;">if</span> (end &lt; it-&gt;first.second) t.push_back({end, it-&gt;first.second, it-&gt;<span style="color: #000000;">second});
                h </span>= max(h, it-&gt;<span style="color: #000000;">second);
                it </span>=<span style="color: #000000;"> m.erase(it);
            }
            m[{start, end}] </span>= h +<span style="color: #000000;"> len;
            </span><span style="color: #0000ff;">for</span> (auto &amp;a : t) m[{a[<span style="color: #800080;">0</span>], a[<span style="color: #800080;">1</span>]}] = a[<span style="color: #800080;">2</span><span style="color: #000000;">];
            curMax </span>= max(curMax, h +<span style="color: #000000;"> len);
            res.push_back(curMax);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4534586.html" target="_blank">The Skyline Problem</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-02-28 23:50</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=8486414" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(8486414);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7733098.html" id="cb_post_title_url">[LeetCode] Partition to K Equal Sum Subsets 分割K个等和的子集</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given an array of integers <code>nums</code> and a positive integer <code>k</code>, find whether it's possible to divide this array into <code>k</code>non-empty subsets whose sums are all equal.</p>
<p>Example 1:</p>
<pre>Input: nums = [4, 3, 2, 3, 5, 2, 1], k = 4
Output: True
Explanation: It's possible to divide it into 4 subsets (5), (1, 4), (2,3), (2,3) with equal sums.
</pre>
<p> </p>
<p>Note:</p>
<ul>
<li><code>1 &lt;= k &lt;= len(nums) &lt;= 16</code>.</li>
<li><code>0 &lt; nums[i] &lt; 10000</code>.</li>
</ul>
<p> </p>
<p>这道题给了我们一个数组nums和一个数字k，问我们该数字能不能分成k个非空子集合，使得每个子集合的和相同。给了k的范围是[1,16]，而且数组中的数字都是正数。这跟之前那道<a href="http://www.cnblogs.com/grandyang/p/5951422.html">Partition Equal Subset Sum</a>很类似，但是那道题只让分成两个子集合，所以问题可以转换为是否存在和为整个数组和的一半的子集合，可以用dp来做。但是这道题让求k个和相同的，感觉无法用dp来做，因为就算找出了一个，其余的也需要验证。这道题我们可以用递归来做，首先我们还是求出数组的所有数字之和sum，首先判断sum是否能整除k，不能整除的话直接返回false。然后需要一个visited数组来记录哪些数组已经被选中了，然后调用递归函数，我们的目标是组k个子集合，是的每个子集合之和为target = sum/k。我们还需要变量start，表示从数组的某个位置开始查找，curSum为当前子集合之和，在递归函数中，如果k=1，说明此时只需要组一个子集合，那么当前的就是了，直接返回true。如果curSum等于target了，那么我们再次调用递归，此时传入k-1，start和curSum都重置为0，因为我们当前又找到了一个和为target的子集合，要开始继续找下一个。否则的话就从start开始遍历数组，如果当前数字已经访问过了则直接跳过，否则标记为已访问。然后调用递归函数，k保持不变，因为还在累加当前的子集合，start传入i+1，curSum传入curSum+nums[i]，因为要累加当前的数字，如果递归函数返回true了，则直接返回true。否则就将当前数字重置为未访问的状态继续遍历，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> canPartitionKSubsets(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; nums, <span style="color: #0000ff;">int</span><span style="color: #000000;"> k) {
        </span><span style="color: #0000ff;">int</span> sum = accumulate(nums.begin(), nums.end(), <span style="color: #800080;">0</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">if</span> (sum % k != <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        vector</span>&lt;<span style="color: #0000ff;">bool</span>&gt; visited(nums.size(), <span style="color: #0000ff;">false</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">return</span> helper(nums, k, sum / k, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span><span style="color: #000000;">, visited);
    }
    </span><span style="color: #0000ff;">bool</span> helper(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; nums, <span style="color: #0000ff;">int</span> k, <span style="color: #0000ff;">int</span> target, <span style="color: #0000ff;">int</span> start, <span style="color: #0000ff;">int</span> curSum, vector&lt;<span style="color: #0000ff;">bool</span>&gt;&amp;<span style="color: #000000;"> visited) {
        </span><span style="color: #0000ff;">if</span> (k == <span style="color: #800080;">1</span>) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (curSum == target) <span style="color: #0000ff;">return</span> helper(nums, k - <span style="color: #800080;">1</span>, target, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span><span style="color: #000000;">, visited);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = start; i &lt; nums.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (visited[i]) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
            visited[i] </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> (helper(nums, k, target, i + <span style="color: #800080;">1</span>, curSum + nums[i], visited)) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
            visited[i] </span>= <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种方法也挺巧妙的，思路是建立长度为k的数组v，只有当v里面所有的数字都是target的时候，才能返回true。我们还需要给数组排个序，由于题目中限制了全是正数，所以数字累加只会增大不会减小，一旦累加超过了target，这个子集合是无法再变小的，所以就不能加入这个数。实际上相当于贪婪算法，由于题目中数组数字为正的限制，有解的话就可以用贪婪算法得到。我们用一个变量idx表示当前遍历的数字，排序后，我们从末尾大的数字开始累加，我们遍历数组v，当前位置加上nums[idx]，如果超过了target，我们掉过继续到下一个位置，否则就调用递归，此时的idx为idx-1，表示之前那个数字已经成功加入数组v了，我们尝试着加下一个数字。如果递归返回false了，我们就将nums[idx]从数组v中对应的位置减去，还原状态，然后继续下一个位置。如果某个递归中idx等于-1了，表明所有的数字已经遍历完了，此时我们检查数组v中k个数字是否都为target，是的话返回true，否则返回false，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> canPartitionKSubsets(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; nums, <span style="color: #0000ff;">int</span><span style="color: #000000;"> k) {
        </span><span style="color: #0000ff;">int</span> sum = accumulate(nums.begin(), nums.end(), <span style="color: #800080;">0</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">if</span> (sum % k != <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; v(k, <span style="color: #800080;">0</span><span style="color: #000000;">);
        sort(nums.begin(), nums.end());
        </span><span style="color: #0000ff;">return</span> helper(nums, sum / k, v, (<span style="color: #0000ff;">int</span>)nums.size() - <span style="color: #800080;">1</span><span style="color: #000000;">);
    }
    </span><span style="color: #0000ff;">bool</span> helper(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; nums, <span style="color: #0000ff;">int</span> target, vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; v, <span style="color: #0000ff;">int</span><span style="color: #000000;"> idx) {
        </span><span style="color: #0000ff;">if</span> (idx == -<span style="color: #800080;">1</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span><span style="color: #000000;"> t : v) {
                </span><span style="color: #0000ff;">if</span> (t != target) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            }
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">int</span> num =<span style="color: #000000;"> nums[idx];
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; v.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (v[i] + num &gt; target) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
            v[i] </span>+=<span style="color: #000000;"> num;
            </span><span style="color: #0000ff;">if</span> (helper(nums, target, v, idx - <span style="color: #800080;">1</span>)) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
            v[i] </span>-=<span style="color: #000000;"> num;
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/5951422.html">Partition Equal Subset Sum</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/107178/easy-to-understand-java-solution">https://discuss.leetcode.com/topic/107178/easy-to-understand-java-solution</a></p>
<div><a href="https://discuss.leetcode.com/topic/107185/java-c-straightforward-dfs-solution" target="_blank">https://discuss.leetcode.com/topic/107185/java-c-straightforward-dfs-solution</a></div>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-10-25 23:38</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7733098" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7733098);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7722949.html" id="cb_post_title_url">[LeetCode] Degree of an Array 数组的度</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a non-empty array of non-negative integers <code>nums</code>, the degree of this array is defined as the maximum frequency of any one of its elements.</p>
<p>Your task is to find the smallest possible length of a (contiguous) subarray of <code>nums</code>, that has the same degree as <code>nums</code>.</p>
<p>Example 1:</p>
<pre>Input: [1, 2, 2, 3, 1]
Output: 2
Explanation: 
The input array has a degree of 2 because both elements 1 and 2 appear twice.
Of the subarrays that have the same degree:
[1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]
The shortest length is 2. So return 2.
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input: [1,2,2,3,1,4,2]
Output: 6
</pre>
<p> </p>
<p>Note:</p>
<ul>
<li><code>nums.length</code> will be between 1 and 50,000.</li>
<li><code>nums[i]</code> will be an integer between 0 and 49,999.</li>
</ul>
<p> </p>
<p>这道题给了我们一个数组，定义数组的度为某个或某些数字出现最多的次数，要我们找最短的子数组使其和原数组拥有相同的度。那么我们肯定需要统计每个数字出现的次数，就要用哈希表来建立每个数字和其出现次数之间的映射。由于我们要求包含原度的最小长度的子数组，那么最好的情况就是子数组的首位数字都是统计度的数字，即出现最多的数字。那么我们肯定要知道该数字的第一次出现的位置和最后一次出现的位置，由于我们开始不知道哪些数字会出现最多次，所以我们统计所有数字的首尾出现位置，那么我们再用一个哈希表，建立每个数字和其首尾出现的位置。我们用变量degree来表示数组的度。好，现在我们遍历原数组，累加当前数字出现的次数，当某个数字是第一次出现，那么我们用当前位置的来更新该数字出现的首尾位置，否则只更新尾位置。每遍历一个数，我们都更新一下degree。当遍历完成后，我们已经有了数组的度，还有每个数字首尾出现的位置，下面就来找出现次数为degree的数组，然后计算其首尾位置差加1就是candidate数组的长度，由于出现次数为degree的数字不一定只有一个，我们遍历所有的，找出其中最小的即可，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> findShortestSubArray(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        </span><span style="color: #0000ff;">int</span> n = nums.size(), res = INT_MAX, degree = <span style="color: #800080;">0</span><span style="color: #000000;">;
        unordered_map</span>&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> m;
        unordered_map</span>&lt;<span style="color: #0000ff;">int</span>, pair&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;&gt;<span style="color: #000000;"> pos;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; nums.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (++m[nums[i]] == <span style="color: #800080;">1</span><span style="color: #000000;">) {
                pos[nums[i]] </span>=<span style="color: #000000;"> {i, i};
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                pos[nums[i]].second </span>=<span style="color: #000000;"> i;
            }
            degree </span>=<span style="color: #000000;"> max(degree, m[nums[i]]);
        }
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto a : m) {
            </span><span style="color: #0000ff;">if</span> (degree ==<span style="color: #000000;"> a.second) {
                res </span>= min(res, pos[a.first].second - pos[a.first].first + <span style="color: #800080;">1</span><span style="color: #000000;">);
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种方法只用了一次遍历，思路跟上面的解法很相似，还是要建立数字出现次数的哈希表，还有就是建立每个数字和其第一次出现位置之间的映射，那么我们当前遍历的位置其实可以看作是尾位置，还是可以计算子数组的长度的。我们遍历数组，累加当前数字出现的次数，如果某个数字是第一次出现，建立该数字和当前位置的映射，如果当前数字的出现次数等于degree时，当前位置为尾位置，首位置在startIdx中取的，二者做差加1来更新结果res；如果当前数字的出现次数大于degree，说明之前的结果代表的数字不是出现最多的，直接将结果res更新为当前数字的首尾差加1的长度，然后degree也更新为当前数字出现的次数。参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> findShortestSubArray(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        </span><span style="color: #0000ff;">int</span> n = nums.size(), res = INT_MAX, degree = <span style="color: #800080;">0</span><span style="color: #000000;">;
        unordered_map</span>&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> m, startIdx;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span>++<span style="color: #000000;">m[nums[i]];
            </span><span style="color: #0000ff;">if</span> (!startIdx.count(nums[i])) startIdx[nums[i]] =<span style="color: #000000;"> i;
            </span><span style="color: #0000ff;">if</span> (m[nums[i]] ==<span style="color: #000000;"> degree) {
                res </span>= min(res, i - startIdx[nums[i]] + <span style="color: #800080;">1</span><span style="color: #000000;">);
            } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (m[nums[i]] &gt;<span style="color: #000000;"> degree) {
                res </span>= i - startIdx[nums[i]] + <span style="color: #800080;">1</span><span style="color: #000000;">;
                degree </span>=<span style="color: #000000;"> m[nums[i]];
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4377150.html" target="_blank">Maximum Subarray</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/107097/java-o-n-time-o-n-space">https://discuss.leetcode.com/topic/107097/java-o-n-time-o-n-space</a></p>
<p><a href="https://discuss.leetcode.com/topic/107216/concise-c-solution-using-hash-map-o-n-time">https://discuss.leetcode.com/topic/107216/concise-c-solution-using-hash-map-o-n-time</a></p>
<p> </p>
<p><a href="http://www.cnblogs.com/grandyang/p/5265628.html">http://www.cnblogs.com/grandyang/p/5265628.html</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-10-24 12:39</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7722949" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7722949);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7716150.html" id="cb_post_title_url">[LeetCode] Count Binary Substrings 统计二进制子字符串</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="question-description">
<p>Give a string <code>s</code>, count the number of non-empty (contiguous) substrings that have the same number of 0's and 1's, and all the 0's and all the 1's in these substrings are grouped consecutively.</p>
<p>Substrings that occur multiple times are counted the number of times they occur.</p>
<p>Example 1:</p>
<pre>Input: "00110011"
Output: 6
Explanation: There are 6 substrings that have equal number of consecutive 1's and 0's: "0011", "01", "1100", "10", "0011", and "01".
<br/>Notice that some of these substrings repeat and are counted the number of times they occur.
<br/>Also, "00110011" is not a valid substring because all the 0's (and 1's) are not grouped together.
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input: "10101"
Output: 4
Explanation: There are 4 substrings: "10", "01", "10", "01" that have equal number of consecutive 1's and 0's.
</pre>
<p> </p>
<p>Note:</p>
<ul>
<li><code>s.length</code> will be between 1 and 50,000.</li>
<li><code>s</code> will only consist of "0" or "1" characters.</li>
</ul>
<p> </p>
<p>这道题给了我们一个二进制字符串，然后我们统计具有相同0和1的个数，且0和1各自都群组在一起(即0和1不能交替出现)的子字符串的个数，题目中的两个例子也很能说明问题。那么我们来分析题目中的第一个例子00110011，符合要求的子字符串要求0和1同时出现，那么当第一个1出现的时候，前面由于前面有两个0，所以肯定能组成01，再遇到下一个1时，此时1有2个，0有2个，能组成0011，下一个遇到0时，此时0的个数重置为1，而1的个数有两个，所以一定有10，同理，下一个还为0，就会有1100存在，之后的也是这样分析。那么我们可以发现我们只要分别统计0和1的个数，而且如果当前遇到的是1，那么只要之前统计的0的个数大于当前1的个数，就一定有一个对应的子字符串，而一旦前一个数字和当前的数字不一样的时候，那么当前数字的计数要重置为1。所以我们遍历元数组，如果是第一个数字，那么对应的ones或zeros自增1。然后进行分情况讨论，如果当前数字是1，然后判断如果前面的数字也是1，则ones自增1，否则ones重置为1。如果此时zeros大于ones，res自增1。反之同理，如果当前数字是0，然后判断如果前面的数字也是0，则zeros自增1，否则zeros重置为1。如果此时ones大于zeros，res自增1。参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> countBinarySubstrings(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        </span><span style="color: #0000ff;">int</span> zeros = <span style="color: #800080;">0</span>, ones = <span style="color: #800080;">0</span>, res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; s.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (i == <span style="color: #800080;">0</span><span style="color: #000000;">) {
                (s[i] </span>== <span style="color: #800000;">'</span><span style="color: #800000;">1</span><span style="color: #800000;">'</span>) ? ++ones : ++<span style="color: #000000;">zeros;
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                </span><span style="color: #0000ff;">if</span> (s[i] == <span style="color: #800000;">'</span><span style="color: #800000;">1</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                    ones </span>= (s[i - <span style="color: #800080;">1</span>] == <span style="color: #800000;">'</span><span style="color: #800000;">1</span><span style="color: #800000;">'</span>) ? ones + <span style="color: #800080;">1</span> : <span style="color: #800080;">1</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">if</span> (zeros &gt;= ones) ++<span style="color: #000000;">res;
                } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (s[i] == <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                    zeros </span>= (s[i - <span style="color: #800080;">1</span>] == <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span>) ? zeros + <span style="color: #800080;">1</span> : <span style="color: #800080;">1</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">if</span> (ones &gt;= zeros) ++<span style="color: #000000;">res;
                }
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种方法更加简洁了，不用具体的分0和1的情况来讨论了，而是直接用了pre和cur两个变量，其中pre初始化为0，cur初始化为1，然后从第二个数字开始遍历，如果当前数字和前面的数字相同，则cur自增1，否则pre赋值为cur，cur重置1。然后判断如果pre大于等于cur，res自增1。其实核心思想跟上面的方法一样，只不过pre和cur可以在0和1之间切换，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> countBinarySubstrings(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, pre = <span style="color: #800080;">0</span>, cur = <span style="color: #800080;">1</span>, n =<span style="color: #000000;"> s.size();
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (s[i] == s[i - <span style="color: #800080;">1</span>]) ++<span style="color: #000000;">cur;
            </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                pre </span>=<span style="color: #000000;"> cur;
                cur </span>= <span style="color: #800080;">1</span><span style="color: #000000;">;
            }
            </span><span style="color: #0000ff;">if</span> (pre &gt;= cur) ++<span style="color: #000000;">res;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/5265628.html" target="_blank">Encode and Decode Strings</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/107096/java-o-n-time-o-1-space">https://discuss.leetcode.com/topic/107096/java-o-n-time-o-1-space</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p>
</div></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-10-23 12:25</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7716150" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7716150);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7712724.html" id="cb_post_title_url">[LeetCode] Max Area of Island 岛的最大面积</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="question-description">
<p>Given a non-empty 2D array <code>grid</code> of 0's and 1's, an island is a group of <code>1</code>'s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.</p>
<p>Find the maximum area of an island in the given 2D array. (If there is no island, the maximum area is 0.)</p>
<p>Example 1:</p>
<pre>[[0,0,1,0,0,0,0,1,0,0,0,0,0],
 [0,0,0,0,0,0,0,1,1,1,0,0,0],
 [0,1,1,0,1,0,0,0,0,0,0,0,0],
 [0,1,0,0,1,1,0,0,1,0,1,0,0],
 [0,1,0,0,1,1,0,0,1,1,1,0,0],
 [0,0,0,0,0,0,0,0,0,0,1,0,0],
 [0,0,0,0,0,0,0,1,1,1,0,0,0],
 [0,0,0,0,0,0,0,1,1,0,0,0,0]]
</pre>
Given the above grid, return <code>6</code>. Note the answer is not 11, because the island must be connected 4-directionally.
<p> </p>
<p>Example 2:</p>
<pre>[[0,0,0,0,0,0,0,0]]</pre>
Given the above grid, return <code>0</code>.
<p> </p>
<p>Note: The length of each dimension in the given <code>grid</code> does not exceed 50.</p>
<p> </p>
<p>这道题跟之前的那两道<a href="http://www.cnblogs.com/grandyang/p/4402656.html" target="_blank">Number of Islands</a>和<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/7698778.html" id="homepage1_HomePageDays_DaysList_ctl01_DayList_TitleUrl_0">Number of Distinct Islands</a>是同一个类型的，只不过这次需要统计出每个岛的大小，再来更新结果res。先用递归来做，遍历grid，当遇到为1的点，我们调用递归函数，在递归函数中，我们首先判断i和j是否越界，还有grid[i][j]是否为1，我们没有用visited数组，而是直接修改了grid数组，遍历过的标记为-1。如果合法，那么cnt自增1，并且更新结果res，然后对其周围四个相邻位置分别调用递归函数即可，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; dirs{{<span style="color: #800080;">0</span>,-<span style="color: #800080;">1</span>},{-<span style="color: #800080;">1</span>,<span style="color: #800080;">0</span>},{<span style="color: #800080;">0</span>,<span style="color: #800080;">1</span>},{<span style="color: #800080;">1</span>,<span style="color: #800080;">0</span><span style="color: #000000;">}};
    </span><span style="color: #0000ff;">int</span> maxAreaOfIsland(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> grid) {
        </span><span style="color: #0000ff;">int</span> m = grid.size(), n = grid[<span style="color: #800080;">0</span>].size(), res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; m; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; n; ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> (grid[i][j] != <span style="color: #800080;">1</span>) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">int</span> cnt = <span style="color: #800080;">0</span><span style="color: #000000;">;
                helper(grid, i, j, cnt, res);
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">void</span> helper(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp; grid, <span style="color: #0000ff;">int</span> i, <span style="color: #0000ff;">int</span> j, <span style="color: #0000ff;">int</span>&amp; cnt, <span style="color: #0000ff;">int</span>&amp;<span style="color: #000000;"> res) {
        </span><span style="color: #0000ff;">int</span> m = grid.size(), n = grid[<span style="color: #800080;">0</span><span style="color: #000000;">].size();
        </span><span style="color: #0000ff;">if</span> (i &lt; <span style="color: #800080;">0</span> || i &gt;= m || j &lt; <span style="color: #800080;">0</span> || j &gt;= n || grid[i][j] &lt;= <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
        res </span>= max(res, ++<span style="color: #000000;">cnt);
        grid[i][j] </span>*= -<span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto dir : dirs) {
            helper(grid, i </span>+ dir[<span style="color: #800080;">0</span>], j + dir[<span style="color: #800080;">1</span><span style="color: #000000;">], cnt, res);
        }
    }
};</span></pre>
</div>
<p> </p>
<p>下面是迭代的写法，BFS遍历，使用queue来辅助运算，思路没啥太大区别，都是套路，都是模版，往里套就行了，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; dirs{{<span style="color: #800080;">0</span>,-<span style="color: #800080;">1</span>},{-<span style="color: #800080;">1</span>,<span style="color: #800080;">0</span>},{<span style="color: #800080;">0</span>,<span style="color: #800080;">1</span>},{<span style="color: #800080;">1</span>,<span style="color: #800080;">0</span><span style="color: #000000;">}};
    </span><span style="color: #0000ff;">int</span> maxAreaOfIsland(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> grid) {
        </span><span style="color: #0000ff;">int</span> m = grid.size(), n = grid[<span style="color: #800080;">0</span>].size(), res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; m; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; n; ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> (grid[i][j] != <span style="color: #800080;">1</span>) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">int</span> cnt = <span style="color: #800080;">0</span><span style="color: #000000;">;
                queue</span>&lt;pair&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;&gt;<span style="color: #000000;"> q{{{i, j}}};
                grid[i][j] </span>*= -<span style="color: #800080;">1</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">while</span> (!<span style="color: #000000;">q.empty()) {
                    auto t </span>=<span style="color: #000000;"> q.front(); q.pop();
                    res </span>= max(res, ++<span style="color: #000000;">cnt);
                    </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto dir : dirs) {
                        </span><span style="color: #0000ff;">int</span> x = t.first + dir[<span style="color: #800080;">0</span>], y = t.second + dir[<span style="color: #800080;">1</span><span style="color: #000000;">];
                        </span><span style="color: #0000ff;">if</span> (x &lt; <span style="color: #800080;">0</span> || x &gt;= m || y &lt; <span style="color: #800080;">0</span> || y &gt;= n || grid[x][y] &lt;= <span style="color: #800080;">0</span>) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                        grid[x][y] </span>*= -<span style="color: #800080;">1</span><span style="color: #000000;">;
                        q.push({x, y});
                    }
                }
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/7698778.html" id="homepage1_HomePageDays_DaysList_ctl01_DayList_TitleUrl_0">Number of Distinct Islands</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/6096138.html">Island Perimeter</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4402656.html" target="_blank">Number of Islands</a></p>
<p> </p>
</div>
<div id="interviewed-div"><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></div></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-10-22 23:51</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7712724" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7712724);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7698778.html" id="cb_post_title_url">[LeetCode] Number of Distinct Islands 不同岛屿的个数</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a non-empty 2D array <code>grid</code> of 0's and 1's, an island is a group of <code>1</code>'s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.</p>
<p>Count the number of distinct islands. An island is considered to be the same as another if and only if one island can be translated (and not rotated or reflected) to equal the other.</p>
<p>Example 1:</p>
<pre>11000
11000
00011
00011
</pre>
<p>Given the above grid map, return <code>1</code>.</p>
<p> </p>
<p>Example 2:</p>
<pre>11011
10000
00001
11011</pre>
<p>Given the above grid map, return <code>3</code>.<br/><br/>Notice that:</p>
<pre>11
1
</pre>
<p>and</p>
<pre> 1
11
</pre>
<p>are considered different island shapes, because we do not consider reflection / rotation.</p>
<p> </p>
<p>Note: The length of each dimension in the given <code>grid</code> does not exceed 50.</p>
<p> </p>
<p>这道题让我们求不同岛屿的个数，是之前那道<a href="http://www.cnblogs.com/grandyang/p/4402656.html" target="_blank">Number of Islands</a>的拓展，这道题的难点是如何去判断两个岛屿是否是不同的岛屿，首先1的个数肯定是要相同，但是1的个数相同不能保证一定是相同的岛屿，比如例子2中的那两个岛屿的就不相同，就是说两个相同的岛屿通过平移可以完全重合，但是不能旋转。那么我们如何来判断呢，我们发现可以通过相对位置坐标来判断，比如我们使用岛屿的最左上角的1当作基点，那么基点左边的点就是(0,-1)，右边的点就是(0,1), 上边的点就是(-1,0)，下面的点就是(1,0)。那么例子1中的两个岛屿都可以表示为[(0,0), (0,1), (1,0), (1,1)]，点的顺序是基点-右边点-下边点-右下点。通过这样就可以判断两个岛屿是否相同了，下面这种解法我们没有用数组来存，而是encode成了字符串，比如这四个点的数组就存为"0_0_0_1_1_0_1_1_"，然后把字符串存入集合unordered_set中，利用其自动去重复的特性，就可以得到不同的岛屿的数量啦，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; dirs{{<span style="color: #800080;">0</span>,-<span style="color: #800080;">1</span>},{-<span style="color: #800080;">1</span>,<span style="color: #800080;">0</span>},{<span style="color: #800080;">0</span>,<span style="color: #800080;">1</span>},{<span style="color: #800080;">1</span>,<span style="color: #800080;">0</span><span style="color: #000000;">}};
    </span><span style="color: #0000ff;">int</span> numDistinctIslands(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> grid) {
        </span><span style="color: #0000ff;">int</span> m = grid.size(), n = grid[<span style="color: #800080;">0</span><span style="color: #000000;">].size();
        unordered_set</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> res;
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">bool</span>&gt;&gt; visited(m, vector&lt;<span style="color: #0000ff;">bool</span>&gt;(n, <span style="color: #0000ff;">false</span><span style="color: #000000;">));
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; m; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; n; ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> (grid[i][j] == <span style="color: #800080;">1</span> &amp;&amp; !<span style="color: #000000;">visited[i][j]) {
                    </span><span style="color: #0000ff;">set</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> s;
                    helper(grid, i, j, i, j, visited, s);
                    </span><span style="color: #0000ff;">string</span> t = <span style="color: #800000;">""</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">for</span> (auto str : s) t += str + <span style="color: #800000;">"</span><span style="color: #800000;">_</span><span style="color: #800000;">"</span><span style="color: #000000;">;
                    res.insert(t);
                }
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res.size();
    }
    </span><span style="color: #0000ff;">void</span> helper(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp; grid, <span style="color: #0000ff;">int</span> x0, <span style="color: #0000ff;">int</span> y0, <span style="color: #0000ff;">int</span> i, <span style="color: #0000ff;">int</span> j, vector&lt;vector&lt;<span style="color: #0000ff;">bool</span>&gt;&gt;&amp; visited, <span style="color: #0000ff;">set</span>&lt;<span style="color: #0000ff;">string</span>&gt;&amp;<span style="color: #000000;"> s) {
        </span><span style="color: #0000ff;">int</span> m = grid.size(), n = grid[<span style="color: #800080;">0</span><span style="color: #000000;">].size();
        visited[i][j] </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto dir : dirs) {
            </span><span style="color: #0000ff;">int</span> x = i + dir[<span style="color: #800080;">0</span>], y = j + dir[<span style="color: #800080;">1</span><span style="color: #000000;">];
            </span><span style="color: #0000ff;">if</span> (x &lt; <span style="color: #800080;">0</span> || x &gt;= m || y &lt; <span style="color: #800080;">0</span> || y &gt;= n || grid[x][y] == <span style="color: #800080;">0</span> || visited[x][y]) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">string</span> str = to_string(x - x0) + <span style="color: #800000;">"</span><span style="color: #800000;">_</span><span style="color: #800000;">"</span> + to_string(y -<span style="color: #000000;"> y0);
            s.insert(str);
            helper(grid, x0, y0, x, y, visited, s);
        }
    }
};</span></pre>
</div>
<p> </p>
<p>当然我们也可以不encode字符串，直接将相对坐标存入数组中，然后把整个数组放到集合set中，还是会去掉相同的数组，而且这种解法直接在grid数组上标记访问过的位置，写起来更加简洁了，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; dirs{{<span style="color: #800080;">0</span>,-<span style="color: #800080;">1</span>},{-<span style="color: #800080;">1</span>,<span style="color: #800080;">0</span>},{<span style="color: #800080;">0</span>,<span style="color: #800080;">1</span>},{<span style="color: #800080;">1</span>,<span style="color: #800080;">0</span><span style="color: #000000;">}};
    </span><span style="color: #0000ff;">int</span> numDistinctIslands(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> grid) {
        </span><span style="color: #0000ff;">int</span> m = grid.size(), n = grid[<span style="color: #800080;">0</span><span style="color: #000000;">].size();
        </span><span style="color: #0000ff;">set</span>&lt;vector&lt;pair&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;&gt;&gt;<span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; m; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; n; ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> (grid[i][j] != <span style="color: #800080;">1</span>) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                vector</span>&lt;pair&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;&gt;<span style="color: #000000;"> v;
                helper(grid, i, j, i, j, v);
                res.insert(v);
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res.size();
    }
    </span><span style="color: #0000ff;">void</span> helper(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp; grid, <span style="color: #0000ff;">int</span> x0, <span style="color: #0000ff;">int</span> y0, <span style="color: #0000ff;">int</span> i, <span style="color: #0000ff;">int</span> j, vector&lt;pair&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> v) {
        </span><span style="color: #0000ff;">int</span> m = grid.size(), n = grid[<span style="color: #800080;">0</span><span style="color: #000000;">].size();
        </span><span style="color: #0000ff;">if</span> (i &lt; <span style="color: #800080;">0</span> || i &gt;= m || j &lt; <span style="color: #800080;">0</span> || j &gt;= n || grid[i][j] &lt;= <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
        grid[i][j] </span>*= -<span style="color: #800080;">1</span><span style="color: #000000;">;
        v.push_back({i </span>- x0, j -<span style="color: #000000;"> y0});
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto dir : dirs) {
            helper(grid, x0, y0, i </span>+ dir[<span style="color: #800080;">0</span>], j + dir[<span style="color: #800080;">1</span><span style="color: #000000;">], v);
        }
    }
};</span></pre>
</div>
<p> </p>
<p>既然递归DFS可以，那么迭代的BFS就坐不住了，其实思路没什么区别，这种类似迷宫遍历的题都是一个套路，整体框架都很像，细枝末节需要改改就行了，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; dirs{{<span style="color: #800080;">0</span>,-<span style="color: #800080;">1</span>},{-<span style="color: #800080;">1</span>,<span style="color: #800080;">0</span>},{<span style="color: #800080;">0</span>,<span style="color: #800080;">1</span>},{<span style="color: #800080;">1</span>,<span style="color: #800080;">0</span><span style="color: #000000;">}};
    </span><span style="color: #0000ff;">int</span> numDistinctIslands(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> grid) {
        </span><span style="color: #0000ff;">int</span> m = grid.size(), n = grid[<span style="color: #800080;">0</span><span style="color: #000000;">].size();
        </span><span style="color: #0000ff;">set</span>&lt;vector&lt;pair&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;&gt;&gt;<span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; m; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; n; ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> (grid[i][j] != <span style="color: #800080;">1</span>) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                vector</span>&lt;pair&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;&gt;<span style="color: #000000;"> v;
                queue</span>&lt;pair&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;&gt;<span style="color: #000000;"> q{{{i, j}}};
                grid[i][j] </span>*= -<span style="color: #800080;">1</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">while</span> (!<span style="color: #000000;">q.empty()) {
                    auto t </span>=<span style="color: #000000;"> q.front(); q.pop();
                    </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto dir : dirs) {
                        </span><span style="color: #0000ff;">int</span> x = t.first + dir[<span style="color: #800080;">0</span>], y = t.second + dir[<span style="color: #800080;">1</span><span style="color: #000000;">];
                        </span><span style="color: #0000ff;">if</span> (x &lt; <span style="color: #800080;">0</span> || x &gt;= m || y &lt; <span style="color: #800080;">0</span> || y &gt;= n || grid[x][y] &lt;= <span style="color: #800080;">0</span>) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                        q.push({x, y});
                        grid[x][y] </span>*= -<span style="color: #800080;">1</span><span style="color: #000000;">;
                        v.push_back({x </span>- i, y -<span style="color: #000000;"> j});
                    }
                }
                res.insert(v);
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res.size();
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4402656.html" target="_blank">Number of Islands</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/106264/java-c-clean-code">https://discuss.leetcode.com/topic/106264/java-c-clean-code</a></p>
<p><a href="https://discuss.leetcode.com/topic/106276/c-bfs-set-with-explanation">https://discuss.leetcode.com/topic/106276/c-bfs-set-with-explanation</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-10-20 11:53</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7698778" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7698778);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7696387.html" id="cb_post_title_url">[LeetCode] Binary Number with Alternating Bits 有交替位的二进制数</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="question-description">
<p>Given a positive integer, check whether it has alternating bits: namely, if two adjacent bits will always have different values.</p>
<p>Example 1:</p>
<pre>Input: 5
Output: True
Explanation:
The binary representation of 5 is: 101
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input: 7
Output: False
Explanation:
The binary representation of 7 is: 111.
</pre>
<p> </p>
<p>Example 3:</p>
<pre>Input: 11
Output: False
Explanation:
The binary representation of 11 is: 1011.
</pre>
<p> </p>
<p>Example 4:</p>
<pre>Input: 10
Output: True
Explanation:
The binary representation of 10 is: 1010.
</pre>
<p> </p>
<p>这道题让我们判断一个二进制数的1和0是否是交替出现的，博主开始也美想到啥简便方法，就一位一位来检测呗，用个变量bit来记录上一个位置的值，初始化为-1，然后我们用‘与’1的方法来获取最低位的值，如果是1，那么当此时bit已经是1的话，说明两个1相邻了，返回false，否则bit赋值为1。同理，如果是0，那么当此时bit已经是0的话，说明两个0相邻了，返回false，否则bit赋值为0。判断完别忘了将n向右移动一位。如果while循环退出了，返回true，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> hasAlternatingBits(<span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        </span><span style="color: #0000ff;">int</span> bit = -<span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (n &gt; <span style="color: #800080;">0</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">if</span> (n &amp; <span style="color: #800080;">1</span> == <span style="color: #800080;">1</span><span style="color: #000000;">) {
                </span><span style="color: #0000ff;">if</span> (bit == <span style="color: #800080;">1</span>) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                bit </span>= <span style="color: #800080;">1</span><span style="color: #000000;">;
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                </span><span style="color: #0000ff;">if</span> (bit == <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                bit </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
            }
            n </span>&gt;&gt;= <span style="color: #800080;">1</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种解法写的更加简洁了，我们不需要用if条件来判断，而是可以通过‘亦或’1的方式来将0和1互换，当然我们也可以通过d = 1 - d 来达到同样的效果，但还是写成‘亦或’1比较叼，while循环的条件是最低位等于d，而d不停的在0和1之间切换，n每次也向右平移一位，这样能交替检测0和1，循环退出后，如果n为0，则返回true，反之则返回false，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> hasAlternatingBits(<span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        </span><span style="color: #0000ff;">int</span> d = n &amp; <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> ((n &amp; <span style="color: #800080;">1</span>) ==<span style="color: #000000;"> d) {
            d </span>^= <span style="color: #800080;">1</span><span style="color: #000000;">;
            n </span>&gt;&gt;= <span style="color: #800080;">1</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> n == <span style="color: #800080;">0</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种解法就十分的巧妙了，利用了0和1的交替的特性，进行错位相加，从而组成全1的二进制数，然后再用一个检测全1的二进制数的trick，就是‘与’上加1后的数，因为全1的二进制数加1，就会进一位，并且除了最高位，其余位都是0，跟原数相‘与’就会得0，所以我们可以这样判断。比如n是10101，那么n&gt;&gt;1就是1010，二者相加就是11111，再加1就是100000，二者相‘与’就是0，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> hasAlternatingBits(<span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        </span><span style="color: #0000ff;">return</span> ((n + (n &gt;&gt; <span style="color: #800080;">1</span>) + <span style="color: #800080;">1</span>) &amp; (n + (n &gt;&gt; <span style="color: #800080;">1</span>))) == <span style="color: #800080;">0</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种解法也很巧妙，先将n右移两位，再和原来的n亦或，得到的新n其实就是除了最高位，其余都是0的数，然后再和自身减1的数相‘与’，如果是0就返回true，反之false。比如n是10101，那么n/4是101，二者相‘亦或’，得到10000，此时再减1，为1111，二者相‘与’得0，参见代码如下：</p>
<p> </p>
<p>解法四：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> hasAlternatingBits(<span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        </span><span style="color: #0000ff;">return</span> ((n ^= n / <span style="color: #800080;">4</span>) &amp; (n - <span style="color: #800080;">1</span>)) == <span style="color: #800080;">0</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4325432.html" target="_blank">Number of 1 Bits</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/106280/c-concise-code">https://discuss.leetcode.com/topic/106280/c-concise-code</a></p>
<p><a href="https://discuss.leetcode.com/topic/106356/oneliners-c-java-ruby-python">https://discuss.leetcode.com/topic/106356/oneliners-c-java-ruby-python</a> </p>
</div>
<div id="interviewed-div"><a href="https://discuss.leetcode.com/topic/106295/java-c-very-simple-solution-1-line">https://discuss.leetcode.com/topic/106295/java-c-very-simple-solution-1-line</a></div>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a> </p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-10-19 23:51</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7696387" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7696387);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7689927.html" id="cb_post_title_url">[LeetCode] Top K Frequent Words 前K个高频词</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="question-description">
<p>Given a non-empty list of words, return the <em>k</em> most frequent elements.</p>
<p>Your answer should be sorted by frequency from highest to lowest. If two words have the same frequency, then the word with the lower alphabetical order comes first.</p>
<p>Example 1:</p>
<pre>Input: ["i", "love", "leetcode", "i", "love", "coding"], k = 2
Output: ["i", "love"]
Explanation: "i" and "love" are the two most frequent words.
    Note that "i" comes before "love" due to a lower alphabetical order.
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input: ["the", "day", "is", "sunny", "the", "the", "the", "sunny", "is", "is"], k = 4
Output: ["the", "is", "sunny", "day"]
Explanation: "the", "is", "sunny" and "day" are the four most frequent words,
    with the number of occurrence being 4, 3, 2 and 1 respectively.
</pre>
<p> </p>
<p>Note:</p>
<ol>
<li>You may assume <em>k</em> is always valid, 1 ≤ <em>k</em> ≤ number of unique elements.</li>
<li>Input words contain only lowercase letters.</li>
</ol>
<p> </p>
<p>Follow up:</p>
<ol>
<li>Try to solve it in <em>O</em>(<em>n</em> log <em>k</em>) time and <em>O</em>(<em>n</em>) extra space.</li>
<li>Can you solve it in <em>O</em>(<em>n</em>) time with only <em>O</em>(<em>k</em>) extra space?</li>
</ol>
<p> </p>
<p>这道题让我们求前K个高频词，跟之前那道题<a href="http://www.cnblogs.com/grandyang/p/5454125.html">Top K Frequent Elements</a>极其类似，换了个数据类型就又是一道新题。唯一的不同就是之前那道题对于出现频率相同的数字，没有顺序要求。而这道题对于出现频率相同的单词，需要按照字母顺序来排。但是解法都一样，还是用最大堆和桶排序的方法。首先来看最大堆的方法，思路是先建立每个单词和其出现次数之间的映射，然后把单词和频率的pair放进最大堆，如果没有相同频率的单词排序要求，我们完全可以让频率当作pair的第一项，这样priority_queue默认是以pair的第一项为key进行从大到小的排序，而当第一项相等时，又会以第二项由大到小进行排序，这样就与题目要求的相同频率的单词要按字母顺序排列不相符，当然我们可以在存入结果res时对相同频率的词进行重新排序处理，也可以对priority_queue的排序机制进行自定义，这里我们采用第二种方法，我们自定义排序机制，我们让a.second &gt; b.second，让小频率的词在第一位，然后当a.second == b.second时，我们让a.first &lt; b.first，这是让字母顺序大的排在前面（这里博主需要强调一点的是，priority_queue的排序机制的写法和vector的sort的排序机制的写法正好顺序相反，同样的写法，用在sort里面就是频率小的在前面，不信的话可以自己试一下）。定义好最小堆后，我们首先统计单词的出现频率，然后组成pair排序最小堆之中，我们只保存k个pair，超过了就把队首的pair移除队列，最后我们把单词放入结果res中即可，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; topKFrequent(vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp; words, <span style="color: #0000ff;">int</span><span style="color: #000000;"> k) {
        vector</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> res(k);
        unordered_map</span>&lt;<span style="color: #0000ff;">string</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> freq;
        auto cmp </span>= [](pair&lt;<span style="color: #0000ff;">string</span>, <span style="color: #0000ff;">int</span>&gt;&amp; a, pair&lt;<span style="color: #0000ff;">string</span>, <span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> b) {
            </span><span style="color: #0000ff;">return</span> a.second &gt; b.second || (a.second == b.second &amp;&amp; a.first &lt;<span style="color: #000000;"> b.first);
        };
        priority_queue</span>&lt;pair&lt;<span style="color: #0000ff;">string</span>, <span style="color: #0000ff;">int</span>&gt;, vector&lt;pair&lt;<span style="color: #0000ff;">string</span>, <span style="color: #0000ff;">int</span>&gt;&gt;, decltype(cmp) &gt;<span style="color: #000000;"> q(cmp);
        </span><span style="color: #0000ff;">for</span> (auto word : words) ++<span style="color: #000000;">freq[word];
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto f : freq) {
            q.push(f);
            </span><span style="color: #0000ff;">if</span> (q.size() &gt;<span style="color: #000000;"> k) q.pop();
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = res.size() - <span style="color: #800080;">1</span>; i &gt;= <span style="color: #800080;">0</span>; --<span style="color: #000000;">i) {
            res[i] </span>=<span style="color: #000000;"> q.top().first; q.pop();
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种解法还是一种堆排序的思路，这里我们用map，来建立次数和出现该次数所有单词的集合set之间的映射，这里也利用了set能自动排序的特性，当然我们还是需要首先建立每个单词和其出现次数的映射，然后将其组成pair放入map种，map是从小到大排序的，这样我们从最后面取pair，就是次数最大的，每次取出一层中所有的单词，如果此时的k大于该层的单词个数，就将整层的单词加入结果res中，否则就取前K个就行了，取完要更更新K值，如果K小于等于0了，就break掉，返回结果res即可，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; topKFrequent(vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp; words, <span style="color: #0000ff;">int</span><span style="color: #000000;"> k) {
        vector</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> res;
        unordered_map</span>&lt;<span style="color: #0000ff;">string</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> freq;
        map</span>&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">set</span>&lt;<span style="color: #0000ff;">string</span>&gt;&gt;<span style="color: #000000;"> m;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">string</span> word : words) ++<span style="color: #000000;">freq[word];
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto a : freq) {
            m[a.second].insert(a.first);
        }
        </span><span style="color: #0000ff;">for</span> (auto it = m.rbegin(); it != m.rend(); ++<span style="color: #000000;">it) {
            </span><span style="color: #0000ff;">if</span> (k &lt;= <span style="color: #800080;">0</span>) <span style="color: #0000ff;">break</span><span style="color: #000000;">;
            auto t </span>= it-&gt;<span style="color: #000000;">second;
            vector</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> v(t.begin(), t.end());
            </span><span style="color: #0000ff;">if</span> (k &gt;=<span style="color: #000000;"> t.size()) {
                res.insert(res.end(), v.begin(), v.end());
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                res.insert(res.end(), v.begin(), v.begin() </span>+<span style="color: #000000;"> k);
            }
            k </span>-=<span style="color: #000000;"> t.size();
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种解法是一种桶排序的思路，我们根据出现次数建立多个bucket，桶的个数不会超过单词的个数，在每个桶中，我们对单词按字符顺序进行排序。我们可以用个数组来表示桶，每一层中放一个集合，利用set的自动排序的功能，使其能按字母顺序排列。我们还是需要首先建立每个单词和其出现次数的映射，然后将其组成pair放入map种，map是从小到大排序的，这样我们倒序遍历所有的桶，这样取pair，就是次数最大的，每次取出一层中所有的单词，如果此时的k大于该层的单词个数，就将整层的单词加入结果res中，否则就取前K个就行了，取完要更更新K值，如果K小于等于0了，就break掉，返回结果res即可，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; topKFrequent(vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp; words, <span style="color: #0000ff;">int</span><span style="color: #000000;"> k) {
        vector</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> res;
        unordered_map</span>&lt;<span style="color: #0000ff;">string</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> freq;
        vector</span>&lt;<span style="color: #0000ff;">set</span>&lt;<span style="color: #0000ff;">string</span>&gt;&gt; v(words.size() + <span style="color: #800080;">1</span>, <span style="color: #0000ff;">set</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;">());
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">string</span> word : words) ++<span style="color: #000000;">freq[word];
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto a : freq) {
            v[a.second].insert(a.first);
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = v.size() - <span style="color: #800080;">1</span>; i &gt;= <span style="color: #800080;">0</span>; --<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (k &lt;= <span style="color: #800080;">0</span>) <span style="color: #0000ff;">break</span><span style="color: #000000;">;
            vector</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> t(v[i].begin(), v[i].end());
            </span><span style="color: #0000ff;">if</span> (k &gt;=<span style="color: #000000;"> t.size()) {
                res.insert(res.end(), t.begin(), t.end());
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                res.insert(res.end(), t.begin(), t.begin() </span>+<span style="color: #000000;"> k);
            }
            k </span>-=<span style="color: #000000;"> t.size();
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/5454125.html">Top K Frequent Elements</a></p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/7897166.html" id="homepage1_HomePageDays_DaysList_ctl02_DayList_TitleUrl_0">Design Search Autocomplete System</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/106861/o-nlog-k-priority-queue-c-code">https://discuss.leetcode.com/topic/106861/o-nlog-k-priority-queue-c-code</a> </p>
<p><a href="https://discuss.leetcode.com/topic/106868/clean-heap-based-solution-o-nlogk-time-and-o-n-space-16ms">https://discuss.leetcode.com/topic/106868/clean-heap-based-solution-o-nlogk-time-and-o-n-space-16ms</a></p>
<p> </p>
</div>
<div id="interviewed-div"><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></div></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-10-18 23:52</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7689927" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7689927);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/8468045.html" id="cb_post_title_url">[LeetCode] Stickers to Spell Word 贴片拼单词</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>We are given N different types of stickers. Each sticker has a lowercase English word on it.</p>
<p>You would like to spell out the given <code>target</code> string by cutting individual letters from your collection of stickers and rearranging them.</p>
<p>You can use each sticker more than once if you want, and you have infinite quantities of each sticker.</p>
<p>What is the minimum number of stickers that you need to spell out the <code>target</code>? If the task is impossible, return -1.</p>
<p>Example 1:</p>
<p>Input:</p>
<pre>["with", "example", "science"], "thehat"
</pre>
<p> </p>
<p>Output:</p>
<pre>3
</pre>
<p> </p>
<p>Explanation:</p>
<pre>We can use 2 "with" stickers, and 1 "example" sticker.
After cutting and rearrange the letters of those stickers, we can form the target "thehat".
Also, this is the minimum number of stickers necessary to form the target string.
</pre>
<p> </p>
<p>Example 2:</p>
<p>Input:</p>
<pre>["notice", "possible"], "basicbasic"
</pre>
<p> </p>
<p>Output:</p>
<pre>-1
</pre>
<p> </p>
<p>Explanation:</p>
<pre>We can't form the target "basicbasic" from cutting letters from the given stickers.
</pre>
<p> </p>
<p>Note:</p>
<ul>
<li><code>stickers</code> has length in the range <code>[1, 50]</code>.</li>
<li><code>stickers</code> consists of lowercase English words (without apostrophes).</li>
<li><code>target</code> has length in the range <code>[1, 15]</code>, and consists of lowercase English letters.</li>
<li>In all test cases, all words were chosen <span style="text-decoration: underline;">randomly</span> from the 1000 most common US English words, and the target was chosen as a concatenation of two random words.</li>
<li>The time limit may be more challenging than usual. It is expected that a 50 sticker test case can be solved within 35ms on average.</li>
</ul>
<p> </p>
<p>这道题给了我们N个贴片，每个贴片上有一个小写字母的单词，给了我们一个目标单词target，让我们通过剪下贴片单词上的字母来拼出目标值，每个贴片都有无数个，问我们最少用几个贴片能拼出目标值target，如果不能拼出来的话，就返回-1。这道题博主最开始尝试用贪婪算法，结果发现不行，有网友留言提示说是多重背包问题，然后去论坛上看大神们的解法，果然都是用DP做的，之前曾有网友推荐过一个“背包九讲”的帖子，大概扫过几眼，真是叼到飞起啊，博主希望有时间也能总结一下。先来看这道题吧，既然是用DP来做，那么就需要用dp数组了，我们使用一个一维的dp数组，其中dp[i]表示组成第i个子集合所需要的最少的sticker的个数，注意这里是子集合，而不是子串。长度为n的字符串共有2的n次方个子集合，比如字符串"ab"，就有4个子集合，分别是 "", "a", "b", "ab"。字符串"abc"就有8个子集合，如果我们用0到7来分别对应其子集合，就有：</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">     abc   subset 
</span><span style="color: #800080;">0</span>    <span style="color: #800080;">000</span>     <span style="color: #800000;">""</span>
<span style="color: #800080;">1</span>    0<span style="color: #800080;">01</span><span style="color: #000000;">     c
</span><span style="color: #800080;">2</span>    <span style="color: #800080;">010</span><span style="color: #000000;">     b
</span><span style="color: #800080;">3</span>    0<span style="color: #800080;">11</span><span style="color: #000000;">     bc
</span><span style="color: #800080;">4</span>    1<span style="color: #800080;">00</span><span style="color: #000000;">     a
</span><span style="color: #800080;">5</span>    <span style="color: #800080;">101</span><span style="color: #000000;">     ac
</span><span style="color: #800080;">6</span>    1<span style="color: #800080;">10</span><span style="color: #000000;">     bb
</span><span style="color: #800080;">7</span>    <span style="color: #800080;">111</span>     abc</pre>
</div>
<p>我们可以看到0到7的二进制数的每一位上的0和1就相当于mask，是1的话就选上该位对应的字母，000就表示都不选，就是空集，111就表示都选，就是abc，那么只要我们将所有子集合的dp值都算出来，最后返回dp数组的最后一个位置上的数字，就是和目标子串相等的子集合啦。我们以下面这个简单的例子来讲解：</p>
<p>stickers = ["ab", "bc", "ac"], target = "abc"</p>
<p>之前说了abc的共有8个子集合，所以dp数组的长度为8，除了dp[0]初始化为0之外，其余的都初始化为INT_MAX，然后我们开始逐个更新dp数组的值，我们的目标是从sticker中取出字符，来拼出子集合，所以如果当前遍历到的dp值仍为INT_MAX的话，说明该子集合无法被拼出来，自然我们也无法再其基础上去拼别打子集合了，直接跳过。否则我们就来遍历所有的sticker，让变量cur等于i，说明此时是在第i个子集合的基础上去reach其他的子集合，我们遍历当前sticker的每一个字母，对于sticker的每个字母，我们都扫描一遍target的所有字符，如果target里有这个字符，且该字符未出现在当前cur位置的子集合中，则将该字符加入子集合中。什么意思呢，比如当前我们的cur是3，二进制为011，对应的子集合是"bc"，此时如果我们遍历到的sticker是"ab"，那么遇到"a"时，我们知道target中是有"a"的，然后我们看"bc"中包不包括"a"，判断方法是看 (cur &gt;&gt; k) &amp; 1 是否为0，这可以乍看上去不太好理解，其实不难想，因为我们的子集合是跟二进制对应的，"bc"就对应着011，第一个0就表示"a"缺失，所以我们想看哪个字符，就提取出该字符对应的二进制位，提取方法就是 cur &gt;&gt; k，表示cur向右移动k位，懂位操作Bit Manipulation的童鞋应该不难理解，提出出来的值与上1就知道该位是0还是1了，如果是0，表示缺失，那么把该位变为1，通过 cur |= 1 &lt;&lt; k来实现，那么此时我们的cur就变位7，二进制为111，对应的子集合是"abc"，更新此时的dp[cur]为 dp[cur] 和 dp[i] + 1 中的较大值即可，最后循环结束后，如果"abc"对应的dp值还是INT_MAX，就返回-1，否则返回其dp值，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> minStickers(vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp; stickers, <span style="color: #0000ff;">string</span><span style="color: #000000;"> target) {
        </span><span style="color: #0000ff;">int</span> n = target.size(), m = <span style="color: #800080;">1</span> &lt;&lt;<span style="color: #000000;"> n;
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> dp(m, INT_MAX);
        dp[</span><span style="color: #800080;">0</span>] = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; m; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (dp[i] == INT_MAX) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">string</span> &amp;<span style="color: #000000;">sticker : stickers) {
                </span><span style="color: #0000ff;">int</span> cur =<span style="color: #000000;"> i;
                </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span><span style="color: #000000;"> c : sticker) {
                    </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> k = <span style="color: #800080;">0</span>; k &lt; n; ++<span style="color: #000000;">k) {
                        </span><span style="color: #0000ff;">if</span> (target[k] == c &amp;&amp; !((cur &gt;&gt; k) &amp; <span style="color: #800080;">1</span><span style="color: #000000;">)) {
                            cur </span>|= <span style="color: #800080;">1</span> &lt;&lt;<span style="color: #000000;"> k;
                            </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                        }
                    }
                }
                dp[cur] </span>= min(dp[cur], dp[i] + <span style="color: #800080;">1</span><span style="color: #000000;">);
            }
        }
        </span><span style="color: #0000ff;">return</span> dp[m - <span style="color: #800080;">1</span>] == INT_MAX ? -<span style="color: #800080;">1</span> : dp[m - <span style="color: #800080;">1</span><span style="color: #000000;">];
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种解法是带记忆数组memo的递归解法，可以看作是DP解法的递归形式，核心思想都一样。只不过dp数组换成了哈希Map，建立子集合跟最小使用的sticker的个数之间的映射，初始化空集为0，我们首先统计每个sticker的各个字母出现的频率，放到对应的二维数组freq中，然后就是调用递归函数。在递归函数中，首先判断，如果target已经在memo中，直接返回其值。否则我们开始计算，首先统计出此时的target字符串的各个字母出现次数，然后我们遍历统计所有sticker中各个字母出现次数的数组freq，如果target字符串的第一个字母不在当前sticker中，我们直接跳过，注意递归函数中的target字符串不是原始的字符串，我们心间一个临时字符串t，然后我们遍历target字符串中存在的字符，如果target中的某字符存在的个数多于sticker中对应的字符，那么将多余的部分存在字符串t中，表示当前sticker无法拼出的字符，交给下一个递归函数来处理，我们看再次调用递归函数的结果ans，如果不为-1，说明可以拼出剩余的那些字符，那么此时我们的res更新为ans+1，循环退出后，此时我们的res就应该是组成当前递归函数中的target串的最少贴片数，更新dp[target]值，如果res是INT_MAX，说明无法拼出，更新为-1，否则更新为res，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> minStickers(vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp; stickers, <span style="color: #0000ff;">string</span><span style="color: #000000;"> target) {
        </span><span style="color: #0000ff;">int</span> N =<span style="color: #000000;"> stickers.size();
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; freq(N, vector&lt;<span style="color: #0000ff;">int</span>&gt;(<span style="color: #800080;">26</span>, <span style="color: #800080;">0</span><span style="color: #000000;">));
        unordered_map</span>&lt;<span style="color: #0000ff;">string</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> memo;
        memo[</span><span style="color: #800000;">""</span>] = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; N; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span> c : stickers[i]) ++freq[i][c - <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span><span style="color: #000000;">];
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> helper(freq, target, memo);
    }
    </span><span style="color: #0000ff;">int</span> helper(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp; freq, <span style="color: #0000ff;">string</span> target, unordered_map&lt;<span style="color: #0000ff;">string</span>, <span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> memo) {
        </span><span style="color: #0000ff;">if</span> (memo.count(target)) <span style="color: #0000ff;">return</span><span style="color: #000000;"> memo[target];
        </span><span style="color: #0000ff;">int</span> res = INT_MAX, N =<span style="color: #000000;"> freq.size();
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; cnt(<span style="color: #800080;">26</span>, <span style="color: #800080;">0</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span> c : target) ++cnt[c - <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span><span style="color: #000000;">];
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; N; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (freq[i][target[<span style="color: #800080;">0</span>] - <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span>] == <span style="color: #800080;">0</span>) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">string</span> t = <span style="color: #800000;">""</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; <span style="color: #800080;">26</span>; ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> (cnt[j] - freq[i][j] &gt; <span style="color: #800080;">0</span>) t += <span style="color: #0000ff;">string</span>(cnt[j] - freq[i][j], <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span> +<span style="color: #000000;"> j);
            }
            </span><span style="color: #0000ff;">int</span> ans =<span style="color: #000000;"> helper(freq, t, memo);
            </span><span style="color: #0000ff;">if</span> (ans != -<span style="color: #800080;">1</span>) res = min(res, ans + <span style="color: #800080;">1</span><span style="color: #000000;">);
        }
        memo[target] </span>= (res == INT_MAX) ? -<span style="color: #800080;">1</span><span style="color: #000000;"> : res;
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> memo[target];
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/5764314.html">Ransom Note</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-02-24 23:58</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=8468045" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(8468045);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7639798.html" id="cb_post_title_url">[LeetCode] Employee Importance 员工重要度</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>You are given a data structure of employee information, which includes the employee's <strong>unique id</strong>, his <strong>importance value</strong> and his <strong>direct</strong> subordinates' id.</p>
<p>For example, employee 1 is the leader of employee 2, and employee 2 is the leader of employee 3. They have importance value 15, 10 and 5, respectively. Then employee 1 has a data structure like [1, 15, [2]], and employee 2 has [2, 10, [3]], and employee 3 has [3, 5, []]. Note that although employee 3 is also a subordinate of employee 1, the relationship is <strong>not direct</strong>.</p>
<p>Now given the employee information of a company, and an employee id, you need to return the total importance value of this employee and all his subordinates.</p>
<p><strong>Example 1:</strong><br/>
</p>
<pre><strong>Input:</strong> [[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1
<strong>Output:</strong> 11
<strong>Explanation:</strong>
Employee 1 has importance value 5, and he has two direct subordinates: employee 2 and employee 3. They both have importance value 3. So the total importance value of employee 1 is 5 + 3 + 3 = 11.
</pre>
<p><strong>Note:</strong><br/>
</p>
<ol><ol>
<li>One employee has at most one <strong>direct</strong> leader and may have several subordinates.</li>
<li>The maximum number of employees won't exceed 2000.</li>
</ol></ol>
<p> </p>
<p>这道题定义了一种员工类，有id，重要度，和direct report的员工，让我们求某个员工的总重要度。我们要明白的是就算某个员工不直接向你汇报工作，而是向你手下人汇报，这个人的重要度也会算进你的重要度中。这其实就是之前那道<a href="http://www.cnblogs.com/grandyang/p/5340305.html" target="_blank">Nested List Weight Sum</a>的变化形式，我们可以用DFS来做。首先我们想，为了快速的通过id来定位到员工类，需要建立一个id和员工类的映射，然后我们根据给定的员工id来算其重要度。计算方法当然是其本身的重要度加上其所有手下人的重要度，对于手下人，还要累加其手下人的重要度，为了不重复计算某个员工的重要度，我们建立一个集合，将遍历过的员工id放到集合中，这样一旦我们遍历到集合中有的员工，直接返回0即可；否则就将该员工id加入集合中，然后建立一个结果res变量，加上当前员工的重要度，然后遍历其所有手下，对其每个手下人调用递归函数加到res上，最后返回res即可，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> getImportance(vector&lt;Employee*&gt; employees, <span style="color: #0000ff;">int</span><span style="color: #000000;"> id) {
        unordered_set</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> s;
        unordered_map</span>&lt;<span style="color: #0000ff;">int</span>, Employee*&gt;<span style="color: #000000;"> m;
        </span><span style="color: #0000ff;">for</span> (auto e : employees) m[e-&gt;id] =<span style="color: #000000;"> e;
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> helper(id, m, s);
    }
    </span><span style="color: #0000ff;">int</span> helper(<span style="color: #0000ff;">int</span> id, unordered_map&lt;<span style="color: #0000ff;">int</span>, Employee*&gt;&amp; m, unordered_set&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> s) {
        </span><span style="color: #0000ff;">if</span> (s.count(id)) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        s.insert(id);
        </span><span style="color: #0000ff;">int</span> res = m[id]-&gt;<span style="color: #000000;">importance;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> num : m[id]-&gt;<span style="color: #000000;">subordinates) {
            res </span>+=<span style="color: #000000;"> helper(num, m, s);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>我们也可以用BFS来做，使用一个queue来辅助运算，开始将给定员工id放入，然后当queue不为空进行循环，每次取出队首员工，如果已经访问过了，直接跳过，否则加入集合中，然后累加上当前员工的复杂度到结果res，然后将其所有手下人加入队列等待遍历，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> getImportance(vector&lt;Employee*&gt; employees, <span style="color: #0000ff;">int</span><span style="color: #000000;"> id) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        queue</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> q{{id}};
        unordered_set</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> s;
        unordered_map</span>&lt;<span style="color: #0000ff;">int</span>, Employee*&gt;<span style="color: #000000;"> m;
        </span><span style="color: #0000ff;">for</span> (auto e : employees) m[e-&gt;id] =<span style="color: #000000;"> e;
        </span><span style="color: #0000ff;">while</span> (!<span style="color: #000000;">q.empty()) {
            auto t </span>=<span style="color: #000000;"> q.front(); q.pop();
            </span><span style="color: #0000ff;">if</span> (s.count(t)) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
            s.insert(t);
            res </span>+= m[t]-&gt;<span style="color: #000000;">importance;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> num : m[t]-&gt;<span style="color: #000000;">subordinates) {
                q.push(num);
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/5340305.html" target="_blank">Nested List Weight Sum</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-10-09 10:06</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7639798" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7639798);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/8453386.html" id="cb_post_title_url">[LeetCode] Maximum Sum of 3 Non-Overlapping Subarrays 三个非重叠子数组的最大和</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>In a given array <code>nums</code> of positive integers, find three non-overlapping subarrays with maximum sum.</p>
<p>Each subarray will be of size <code>k</code>, and we want to maximize the sum of all <code>3*k</code> entries.</p>
<p>Return the result as a list of indices representing the starting position of each interval (0-indexed). If there are multiple answers, return the lexicographically smallest one.</p>
<p>Example:</p>
<pre>Input: [1,2,1,2,6,7,5,1], 2
Output: [0, 3, 5]
Explanation: Subarrays [1, 2], [2, 6], [7, 5] correspond to the starting indices [0, 3, 5].
We could have also taken [2, 1], but an answer of [1, 3, 5] would be lexicographically larger.
</pre>
<p> </p>
<p>Note:</p>
<ul>
<li><code>nums.length</code> will be between 1 and 20000.</li>
<li><code>nums[i]</code> will be between 1 and 65535.</li>
<li><code>k</code> will be between 1 and floor(nums.length / 3).</li>
</ul>
<p> </p>
<p>这道题给了我们一个只包含正数的数组，让我们找三个长度为k的不重叠的子数组，使得所有子数组的数字之和最大。首先我们应该明确的是，暴力搜索在这道题上基本不太可能，因为遍历一个子数组的复杂度是平方级，遍历三个还不得六次方啊，看OJ不削你～那么我们只能另辟蹊径，对于这种求子数组和有关的题目时，一般都需要建立累加和数组，为啥呢，因为累加和数组可以快速的求出任意长度的子数组之和，当然也能快速的求出长度为k的子数组之和。因为这道题只让我们找出三个子数组，那么我们可以先确定中间那个子数组的位置，这样左右两边的子数组的位置范围就缩小了，中间子数组的起点不能是从开头到结尾整个区间，必须要在首尾各留出k个位置给其他两个数组。一旦中间子数组的起始位置确定了，那么其和就能通过累加和数组快速确定。那么现在就要在左右两边的区间内分别找出和最大的子数组，遍历所有的子数组显然不是很高效，如何快速求出呢，这里我们需要使用动态规划Dynamic Programming的思想来维护两个DP数组left和right，其中:</p>
<p>left[i]表示在区间[0, i]范围内长度为k且和最大的子数组的起始位置</p>
<p>right[i]表示在区间[i, n - 1]范围内长度为k且和最大的子数组的起始位置</p>
<p>这两个dp数组各需要一个for循环来更新，left数组都初始化为0，前k个数字没办法，肯定起点都是0，变量total初始化为前k个数字之和，然后从第k+1个数字开始，每次向前取k个，利用累加和数组sums快速算出数字之和，跟total比较，如果大于total的话，那么更新total和left数组当前位置值，否则的话left数组的当前值就赋值为前一位的值。同理对right数组的更新也类似，total初始化为最后k个数字之和，然后从前一个数字向前遍历，如果大于total，更新total和right数组的当前位置，否则right数组的当前值就赋值为后一位的值。一旦left数组和right数组都更新好了，那么就可以遍历中间子数组的起始位置了，然后我们可以通过left和right数组快速定位出左边和右边的最大子数组的起始位置，并快速计算出这三个子数组的所有数字之和，用来更新全局最大值mx，如果mx被更新了的话，记录此时的三个子数组的起始位置到结果res中，参见代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; maxSumOfThreeSubarrays(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; nums, <span style="color: #0000ff;">int</span><span style="color: #000000;"> k) {
        </span><span style="color: #0000ff;">int</span> n = nums.size(), mx =<span style="color: #000000;"> INT_MIN;
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; sums{<span style="color: #800080;">0</span>}, res, left(n, <span style="color: #800080;">0</span>), right(n, n -<span style="color: #000000;"> k);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> num : nums) sums.push_back(sums.back() +<span style="color: #000000;"> num);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = k, total = sums[k] - sums[<span style="color: #800080;">0</span>]; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (sums[i + <span style="color: #800080;">1</span>] - sums[i + <span style="color: #800080;">1</span> - k] &gt;<span style="color: #000000;"> total) {
                left[i] </span>= i + <span style="color: #800080;">1</span> -<span style="color: #000000;"> k;
                total </span>= sums[i + <span style="color: #800080;">1</span>] - sums[i + <span style="color: #800080;">1</span> -<span style="color: #000000;"> k];
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                left[i] </span>= left[i - <span style="color: #800080;">1</span><span style="color: #000000;">];
            }
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = n - <span style="color: #800080;">1</span> - k, total = sums[n] - sums[n - k]; i &gt;= <span style="color: #800080;">0</span>; --<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (sums[i + k] - sums[i] &gt;=<span style="color: #000000;"> total) {
                right[i] </span>=<span style="color: #000000;"> i;
                total </span>= sums[i + k] -<span style="color: #000000;"> sums[i];
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                right[i] </span>= right[i + <span style="color: #800080;">1</span><span style="color: #000000;">];
            }
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = k; i &lt;= n - <span style="color: #800080;">2</span> * k; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">int</span> l = left[i - <span style="color: #800080;">1</span>], r = right[i +<span style="color: #000000;"> k];
            </span><span style="color: #0000ff;">int</span> total = (sums[i + k] - sums[i]) + (sums[l + k] - sums[l]) + (sums[r + k] -<span style="color: #000000;"> sums[r]);
            </span><span style="color: #0000ff;">if</span> (mx &lt;<span style="color: #000000;"> total) {
                mx </span>=<span style="color: #000000;"> total;
                res </span>=<span style="color: #000000;"> {l, i, r};
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4281975.html" target="_blank">Best Time to Buy and Sell Stock III</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-02-18 23:50</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=8453386" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(8453386);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7639153.html" id="cb_post_title_url">[LeetCode] Knight Probability in Chessboard 棋盘上骑士的可能性</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="question-description">
<p>On an <code>N</code>x<code>N</code> chessboard, a knight starts at the <code>r</code>-th row and <code>c</code>-th column and attempts to make exactly <code>K</code> moves. The rows and columns are 0 indexed, so the top-left square is <code>(0, 0)</code>, and the bottom-right square is <code>(N-1, N-1)</code>.</p>
<p>A chess knight has 8 possible moves it can make, as illustrated below. Each move is two squares in a cardinal direction, then one square in an orthogonal direction.</p>
<img alt="" src="https://leetcode.com/static/images/problemset/knight.png"/>
<p>Each time the knight is to move, it chooses one of eight possible moves uniformly at random (even if the piece would go off the chessboard) and moves there.</p>
<p>The knight continues moving until it has made exactly <code>K</code> moves or has moved off the chessboard. Return the probability that the knight remains on the board after it has stopped moving.</p>
<p>Example:</p>
<pre>Input: 3, 2, 0, 0
Output: 0.0625
Explanation: There are two moves (to (1,2), (2,1)) that will keep the knight on the board.
From each of those positions, there are also two moves that will keep the knight on the board.
The total probability the knight stays on the board is 0.0625.
</pre>
<p> </p>
<p>Note:</p>
<ul>
<li><code>N</code> will be between 1 and 25.</li>
<li><code>K</code> will be between 0 and 100.</li>
<li>The knight always initially starts on the board.</li>
</ul>
<p> </p>
<p>这道题给了我们一个大小为NxN国际象棋棋盘，上面有个骑士，相当于我们中国象棋中的马，能走‘日’字，给了我们一个起始位置，然后说允许我们走K步，问走完K步之后还能留在棋盘上的概率是多少。那么要求概率，我们必须要先分别求出分子和分母，其中分子是走完K步还在棋盘上的走法，分母是没有限制条件的总共的走法。那么分母最好算，每步走有8种跳法，那么K步就是8的K次方种了。关键是要求出分子，博主开始向的方法是以给定位置为起始点，然后进行BFS，每步遍历8种情况，遇到在棋盘上的就计数器加1，结果TLE了。上论坛看大家的解法，结果发现都是换了一个角度来解决问题的，并不很关心骑士的起始位置，而是把棋盘上所有位置上经过K步还留在棋盘上的走法总和都算出来，那么最后直接返回需要的值即可。跟之前那道<a href="http://www.cnblogs.com/grandyang/p/6927921.html">Out of Boundary Paths</a>没啥本质上的区别，又是换了一个马甲就不会了系列。还是要用DP来做，我们可以用三维DP数组，也可以用二维DP数组来做，这里为了省空间，我们就用二维DP数组来做，其中dp[i][j]表示在棋盘(i, j)位置上走完当前步骤还留在棋盘上的走法总和，初始化为1，我们其实将步骤这个维度当成了时间维度在不停更新。好，下面我们先写出8种‘日’字走法的位置的坐标，就像之前遍历迷宫上下左右四个方向坐标一样，这不过这次位置变了而已。然后我们一步一步来遍历，每一步都需要完整遍历一遍棋盘的每个位置，新建一个临时数组t，大小和dp数组相同，但是初始化为0，然后对于遍历到的棋盘上的每一个格子，我们都遍历8中解法，如果新的位置不在棋盘上了，直接跳过，否则就加上上一步中的dp数组中对应的值，遍历完棋盘后，将dp数组更新为这个临时数组t，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">double</span> knightProbability(<span style="color: #0000ff;">int</span> N, <span style="color: #0000ff;">int</span> K, <span style="color: #0000ff;">int</span> r, <span style="color: #0000ff;">int</span><span style="color: #000000;"> c) {
        </span><span style="color: #0000ff;">if</span> (K == <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span> <span style="color: #800080;">1</span><span style="color: #000000;">;
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">double</span>&gt;&gt; dp(N, vector&lt;<span style="color: #0000ff;">double</span>&gt;(N, <span style="color: #800080;">1</span><span style="color: #000000;">));
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; dirs{{-<span style="color: #800080;">1</span>,-<span style="color: #800080;">2</span>},{-<span style="color: #800080;">2</span>,-<span style="color: #800080;">1</span>},{-<span style="color: #800080;">2</span>,<span style="color: #800080;">1</span>},{-<span style="color: #800080;">1</span>,<span style="color: #800080;">2</span>},{<span style="color: #800080;">1</span>,<span style="color: #800080;">2</span>},{<span style="color: #800080;">2</span>,<span style="color: #800080;">1</span>},{<span style="color: #800080;">2</span>,-<span style="color: #800080;">1</span>},{<span style="color: #800080;">1</span>,-<span style="color: #800080;">2</span><span style="color: #000000;">}};
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> m = <span style="color: #800080;">0</span>; m &lt; K; ++<span style="color: #000000;">m) {
            vector</span>&lt;vector&lt;<span style="color: #0000ff;">double</span>&gt;&gt; t(N, vector&lt;<span style="color: #0000ff;">double</span>&gt;(N, <span style="color: #800080;">0</span><span style="color: #000000;">));
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; N; ++<span style="color: #000000;">i) {
                </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; N; ++<span style="color: #000000;">j) {
                    </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto dir : dirs) {
                        </span><span style="color: #0000ff;">int</span> x = i + dir[<span style="color: #800080;">0</span>], y = j + dir[<span style="color: #800080;">1</span><span style="color: #000000;">];
                        </span><span style="color: #0000ff;">if</span> (x &lt; <span style="color: #800080;">0</span> || x &gt;= N || y &lt; <span style="color: #800080;">0</span> || y &gt;= N) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                        t[i][j] </span>+=<span style="color: #000000;"> dp[x][y];
                    }
                }
            }
            dp </span>=<span style="color: #000000;"> t;
        }
        </span><span style="color: #0000ff;">return</span> dp[r][c] / pow(<span style="color: #800080;">8</span><span style="color: #000000;">, K);
    }
};</span></pre>
</div>
<p> </p>
<p>我们也可以使用有memo数组优化的递归来做，避免重复运算，从而能通过OJ。递归下的memo数组其实就是迭代下的dp数组，这里我们用三维的数组，初始化为0。在递归函数中，如果k为0了，说明已经走了k步，返回 1。如果memo[k][r][c]不为0，说明这种情况之前已经计算过，直接返回。然后遍历8种走法，计算新的位置，如果不在棋盘上就跳过；然后更新memo[k][r][c]，使其加上对新位置调用递归的返回值，注意此时带入k-1和新的位置，退出循环后返回memo[k][r][c]即可，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; dirs{{-<span style="color: #800080;">1</span>,-<span style="color: #800080;">2</span>},{-<span style="color: #800080;">2</span>,-<span style="color: #800080;">1</span>},{-<span style="color: #800080;">2</span>,<span style="color: #800080;">1</span>},{-<span style="color: #800080;">1</span>,<span style="color: #800080;">2</span>},{<span style="color: #800080;">1</span>,<span style="color: #800080;">2</span>},{<span style="color: #800080;">2</span>,<span style="color: #800080;">1</span>},{<span style="color: #800080;">2</span>,-<span style="color: #800080;">1</span>},{<span style="color: #800080;">1</span>,-<span style="color: #800080;">2</span><span style="color: #000000;">}};
    </span><span style="color: #0000ff;">double</span> knightProbability(<span style="color: #0000ff;">int</span> N, <span style="color: #0000ff;">int</span> K, <span style="color: #0000ff;">int</span> r, <span style="color: #0000ff;">int</span><span style="color: #000000;"> c) {
        vector</span>&lt;vector&lt;vector&lt;<span style="color: #0000ff;">double</span>&gt;&gt;&gt; memo(K + <span style="color: #800080;">1</span>, vector&lt;vector&lt;<span style="color: #0000ff;">double</span>&gt;&gt;(N, vector&lt;<span style="color: #0000ff;">double</span>&gt;(N, <span style="color: #800080;">0.0</span><span style="color: #000000;">)));
        </span><span style="color: #0000ff;">return</span> helper(memo, N, K, r, c) / pow(<span style="color: #800080;">8</span><span style="color: #000000;">, K);
    }
    </span><span style="color: #0000ff;">double</span> helper(vector&lt;vector&lt;vector&lt;<span style="color: #0000ff;">double</span>&gt;&gt;&gt;&amp; memo, <span style="color: #0000ff;">int</span> N, <span style="color: #0000ff;">int</span> k, <span style="color: #0000ff;">int</span> r, <span style="color: #0000ff;">int</span><span style="color: #000000;"> c) {
        </span><span style="color: #0000ff;">if</span> (k == <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span> <span style="color: #800080;">1.0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (memo[k][r][c] != <span style="color: #800080;">0.0</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;"> memo[k][r][c];
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto dir : dirs) {
            </span><span style="color: #0000ff;">int</span> x = r + dir[<span style="color: #800080;">0</span>], y = c + dir[<span style="color: #800080;">1</span><span style="color: #000000;">];
            </span><span style="color: #0000ff;">if</span> (x &lt; <span style="color: #800080;">0</span> || x &gt;= N || y &lt; <span style="color: #800080;">0</span> || y &gt;= N) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
            memo[k][r][c] </span>+= helper(memo, N, k - <span style="color: #800080;">1</span><span style="color: #000000;">, x, y);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> memo[k][r][c];
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/6927921.html">Out of Boundary Paths</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/105571/my-accepted-dp-solution" target="_blank">https://discuss.leetcode.com/topic/105571/my-accepted-dp-solution</a></p>
<p><a href="https://discuss.leetcode.com/topic/105597/c-java-dp-concise-solution" target="_blank">https://discuss.leetcode.com/topic/105597/c-java-dp-concise-solution</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p>
</div></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-10-08 23:29</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7639153" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7639153);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7636259.html" id="cb_post_title_url">[LeetCode] Longest Univalue Path 最长相同值路径</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a binary tree, find the length of the longest path where each node in the path has the same value. This path may or may not pass through the root.</p>
<p>Note: The length of path between two nodes is represented by the number of edges between them.</p>
<p>Example 1:</p>
<p>Input:</p>
<pre>              5
             / \
            4   5
           / \   \
          1   1   5
</pre>
<p> </p>
<p>Output:</p>
<pre>2
</pre>
<p> </p>
<p>Example 2:</p>
<p>Input:</p>
<pre>              1
             / \
            4   5
           / \   \
          4   4   5
</pre>
<p> </p>
<p>Output:</p>
<pre>2
</pre>
<p> </p>
<p>Note: The given binary tree has not more than 10000 nodes. The height of the tree is not more than 1000.</p>
<p> </p>
<p>这道题让我们求最长的相同值路径，跟之前那道<a href="http://www.cnblogs.com/grandyang/p/5206862.html" target="_blank">Count Univalue Subtrees</a>十分的类似，解法也很类似。对于这种树的路径问题，递归是不二之选。在递归函数中，我们首先对其左右子结点调用递归函数，得到其左右子树的最大相同值路径，下面就要来看当前结点和其左右子结点之间的关系了，如果其左子结点存在且和当前节点值相同，则left自增1，否则left重置0；同理，如果其右子结点存在且和当前节点值相同，则right自增1，否则right重置0。然后用left+right来更新结果res。而调用当前节点值的函数只能返回left和right中的较大值，因为如果还要跟父节点组path，就只能在左右子节点中选一条path，当然选值大的那个了，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> longestUnivaluePath(TreeNode*<span style="color: #000000;"> root) {
        </span><span style="color: #0000ff;">if</span> (!root) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        helper(root, root, res);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">int</span> helper(TreeNode* node, TreeNode* parent, <span style="color: #0000ff;">int</span>&amp;<span style="color: #000000;"> res) {
        </span><span style="color: #0000ff;">if</span> (!node) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> left = helper(node-&gt;<span style="color: #000000;">left, node, res);
        </span><span style="color: #0000ff;">int</span> right = helper(node-&gt;<span style="color: #000000;">right, node, res);
        left </span>= (node-&gt;left &amp;&amp; node-&gt;val == node-&gt;left-&gt;val) ? left + <span style="color: #800080;">1</span> : <span style="color: #800080;">0</span><span style="color: #000000;">;
        right </span>= (node-&gt;right &amp;&amp; node-&gt;val == node-&gt;right-&gt;val) ? right + <span style="color: #800080;">1</span> : <span style="color: #800080;">0</span><span style="color: #000000;">;
        res </span>= max(res, left +<span style="color: #000000;"> right);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> max(left, right);
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种解法使用了两个递归函数，使得写法更加简洁了，首先还是先判断root是否为空，是的话返回0。然后对左右子节点分别调用当前函数，取其中较大值保存到变量sub中，表示左右子树中最长的相同值路径，然后就是要跟当前树的最长相同值路径比较，计算方法是对左右子结点调用一个helper函数，并把当前结点值传进去，把返回值加起来和sub比较，去较大值返回。在helper函数里，当当前结点为空，或者当前节点值不等于父结点值的话，返回0。否则结返回对左右子结点分别调用helper递归函数中的较大值加1，我们发现这种写法跟求树的最大深度很像，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> longestUnivaluePath(TreeNode*<span style="color: #000000;"> root) {
        </span><span style="color: #0000ff;">if</span> (!root) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> sub = max(longestUnivaluePath(root-&gt;left), longestUnivaluePath(root-&gt;<span style="color: #000000;">right));
        </span><span style="color: #0000ff;">return</span> max(sub, helper(root-&gt;left, root-&gt;val) + helper(root-&gt;right, root-&gt;<span style="color: #000000;">val));
    }
    </span><span style="color: #0000ff;">int</span> helper(TreeNode* node, <span style="color: #0000ff;">int</span><span style="color: #000000;"> parent) {
        </span><span style="color: #0000ff;">if</span> (!node || node-&gt;val != parent) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">1</span> + max(helper(node-&gt;left, node-&gt;val), helper(node-&gt;right, node-&gt;<span style="color: #000000;">val));
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4280120.html" target="_blank">Binary Tree Maximum Path Sum</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/5206862.html" target="_blank">Count Univalue Subtrees</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/6007336.html">Path Sum III</a>  </p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-10-07 23:51</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7636259" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7636259);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7631434.html" id="cb_post_title_url">[LeetCode] Repeated String Match 重复字符串匹配</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given two strings A and B, find the minimum number of times A has to be repeated such that B is a substring of it. If no such solution, return -1.</p>
<p>For example, with A = "abcd" and B = "cdabcdab".</p>
<p>Return 3, because by repeating A three times (“abcdabcdabcd”), B is a substring of it; and B is not a substring of A repeated two times ("abcdabcd").</p>
<p>Note:<br/>The length of <code>A</code> and <code>B</code> will be between 1 and 10000.</p>
<p> </p>
<p>这道题让我们用字符串B来匹配字符串A，问字符串A需要重复几次，如果无法匹配，则返回-1。那么B要能成为A的字符串，那么A的长度肯定要大于等于B，所以当A的长度小于B的时候，我们可以先进行重复A，直到A的长度大于等于B，并且累计次数cnt。那么此时我们用find来找，看B是否存在A中，如果存在直接返回cnt。如果不存在，我们再加上一个A，再来找，这样可以处理这种情况A="abc", B="cab"，如果此时还找不到，说明无法匹配，返回-1，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> repeatedStringMatch(<span style="color: #0000ff;">string</span> A, <span style="color: #0000ff;">string</span><span style="color: #000000;"> B) {
        </span><span style="color: #0000ff;">int</span> n1 = A.size(), n2 = B.size(), cnt = <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">string</span> t =<span style="color: #000000;"> A;
        </span><span style="color: #0000ff;">while</span> (t.size() &lt;<span style="color: #000000;"> n2) {
            t </span>+=<span style="color: #000000;"> A;
            </span>++<span style="color: #000000;">cnt;
        }
        </span><span style="color: #0000ff;">if</span> (t.find(B) != <span style="color: #0000ff;">string</span>::npos) <span style="color: #0000ff;">return</span><span style="color: #000000;"> cnt;
        t </span>+=<span style="color: #000000;"> A;
        </span><span style="color: #0000ff;">return</span> (t.find(B) != <span style="color: #0000ff;">string</span>::npos) ? cnt + <span style="color: #800080;">1</span> : -<span style="color: #800080;">1</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种解法就更简洁了，思路和上面的一样，都是每次给t增加一个字符串A，我们其实可以直接算出最多需要增加的个数，即B的长度除以A的长度再加上2，当B小于A的时候，那么可能需要两个A，所以i就是小于等于2，这样我们每次在t中找B，如果找到了，就返回i，没找到，就增加一个A，循环推出后返回-1即可，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> repeatedStringMatch(<span style="color: #0000ff;">string</span> A, <span style="color: #0000ff;">string</span><span style="color: #000000;"> B) {
        </span><span style="color: #0000ff;">string</span> t =<span style="color: #000000;"> A;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt;= B.size() / A.size() + <span style="color: #800080;">2</span>; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (t.find(B) != <span style="color: #0000ff;">string</span>::npos) <span style="color: #0000ff;">return</span><span style="color: #000000;"> i;
            t </span>+=<span style="color: #000000;"> A;
        }
        </span><span style="color: #0000ff;">return</span> -<span style="color: #800080;">1</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种解法还是由热心网友<a href="http://home.cnblogs.com/u/1090659/" id="a_comment_author_3832129" target="_blank">edyyy</a>提供，没有用到字符串自带的find函数，而是逐个字符进行比较，循环字符串A中的所有字符，然后用个变量j，初始化为0，用来循环字符串B中的字符，每个字符和A中对应的字符进行比较，此时从A中取字符就要把A当作一个循环数组来处理，用(i+j)%m来取字符，还要确保j小于n，避免越界，如果字符匹配的话，j自增1。while 循环结束后，如果j等于n了，说明B中所有的字符都成功匹配了，那么我们来计算A的重复次数，通过(i+j-1)/m + 1来得到，注意i+j要减1再除以m，之后再加上一次。因为当i+j正好等于m时，说明此时不用重复A，那么(i+j-1)/m + 1还是等于1，当i+j&gt;m的时候，需要重复A了，(i+j-1)/m + 1也可以得到正确的结构，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> repeatedStringMatch(<span style="color: #0000ff;">string</span> A, <span style="color: #0000ff;">string</span><span style="color: #000000;"> B) {
        </span><span style="color: #0000ff;">int</span> m = A.size(), n =<span style="color: #000000;"> B.size();
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; m; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">while</span> (j &lt; n &amp;&amp; A[(i + j) % m] == B[j]) ++<span style="color: #000000;">j;
            </span><span style="color: #0000ff;">if</span> (j == n) <span style="color: #0000ff;">return</span> (i + j - <span style="color: #800080;">1</span>) / m + <span style="color: #800080;">1</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> -<span style="color: #800080;">1</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/6087347.html">Repeated Substring Pattern</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/105579/c-4-lines-o-m-n-o-1-and-8-lines-kmp-o-m-n-o-n">https://discuss.leetcode.com/topic/105579/c-4-lines-o-m-n-o-1-and-8-lines-kmp-o-m-n-o-n</a></p>
<p><a href="https://discuss.leetcode.com/topic/105566/java-solution-just-keep-building-oj-missing-test-cases">https://discuss.leetcode.com/topic/105566/java-solution-just-keep-building-oj-missing-test-cases</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-10-06 13:21</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7631434" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7631434);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/8445733.html" id="cb_post_title_url">[LeetCode] Redundant Connection II 冗余的连接之二</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="question-description">
<p>In this problem, a rooted tree is a directed graph such that, there is exactly one node (the root) for which all other nodes are descendants of this node, plus every node has exactly one parent, except for the root node which has no parents.</p>
<p>The given input is a directed graph that started as a rooted tree with N nodes (with distinct values 1, 2, ..., N), with one additional directed edge added. The added edge has two different vertices chosen from 1 to N, and was not an edge that already existed.</p>
<p>The resulting graph is given as a 2D-array of <code>edges</code>. Each element of <code>edges</code> is a pair <code>[u, v]</code> that represents a directed edge connecting nodes <code>u</code> and <code>v</code>, where <code>u</code> is a parent of child <code>v</code>.</p>
<p>Return an edge that can be removed so that the resulting graph is a rooted tree of N nodes. If there are multiple answers, return the answer that occurs last in the given 2D-array.</p>
<p>Example 1:</p>
<pre>Input: [[1,2], [1,3], [2,3]]
Output: [2,3]
Explanation: The given directed graph will be like this:
  1
 / \
v   v
2--&gt;3
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input: [[1,2], [2,3], [3,4], [4,1], [1,5]]
Output: [4,1]
Explanation: The given directed graph will be like this:
5 &lt;- 1 -&gt; 2
     ^    |
     |    v
     4 &lt;- 3
</pre>
<p> </p>
<p>Note:</p>
<ul>
<li>The size of the input 2D-array will be between 3 and 1000.</li>
<li>Every integer represented in the 2D-array will be between 1 and N, where N is the size of the input array.</li>
</ul>
<p> </p>
</div>
<p>这道题是之前那道<a href="http://www.cnblogs.com/grandyang/p/7628977.html">Redundant Connection</a>的拓展，那道题给的是无向图，只需要删掉组成环的最后一条边即可，归根到底就是检测环就行了。而这道题给我们的是有向图，那么整个就复杂多了，因为有多种情况存在，比如给的例子1就是无环，但是有入度为2的结点3。再比如例子2就是有环，但是没有入度为2的结点。其实还有一种情况例子没有给出，就是既有环，又有入度为2的结点。好，我们现在就来总结一下这三种情况：</p>
<p>第一种：无环，但是有结点入度为2的结点（结点3）</p>
<p>[[1,2], [1,3], [2,3]]</p>
<div class="cnblogs_code">
<pre>  <span style="color: #800080;">1</span>
 /<span style="color: #000000;"> \
v   v
</span><span style="color: #800080;">2</span>--&gt;<span style="color: #800080;">3</span></pre>
</div>
<p> </p>
<p>第二种：有环，没有入度为2的结点</p>
<p>[[1,2], [2,3], [3,4], [4,1], [1,5]]</p>
<div class="cnblogs_code">
<pre><span style="color: #800080;">5</span> &lt;- <span style="color: #800080;">1</span> -&gt; <span style="color: #800080;">2</span>
     ^    |
     |<span style="color: #000000;">    v
     </span><span style="color: #800080;">4</span> &lt;- <span style="color: #800080;">3</span></pre>
</div>
<p> </p>
<p>第三种：有环，且有入度为2的结点（结点1）</p>
<p>[[1,2],[2,3],[3,1],[1,4]]</p>
<div class="cnblogs_code">
<pre>     <span style="color: #800080;">4</span>
    /<span style="color: #000000;">
   v
   </span><span style="color: #800080;">1</span>
 /  ^<span style="color: #000000;">
v    \
</span><span style="color: #800080;">2</span> --&gt;<span style="color: #800080;">3</span></pre>
</div>
<p> </p>
<p>对于这三种情况的处理方法各不相同，首先对于第一种情况，我们返回的产生入度为2的后加入的那条边[2, 3]，而对于第二种情况，我们返回的是刚好组成环的最后加入的那条边[4, 1]，最后对于第三种情况我们返回的是组成环，且组成入度为2的那条边[3, 1]。</p>
<p>明白了这些，我们先来找入度为2的点，如果有的话，那么我们将当前产生入度为2的后加入的那条边标记为second，前一条边标记为first。然后我们来找环，为了方便起见，找环使用联合查找Union Find的方法，可参见<a href="http://www.cnblogs.com/grandyang/p/7628977.html">Redundant Connection</a>中的解法三。当我们找到了环之后，如果first不存在，说明是第二种情况，我们返回刚好组成环的最后加入的那条边。如果first存在，说明是第三种情况，我们返回first。如果没有环存在，说明是第一种情况，我们返回second，参见代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; findRedundantDirectedConnection(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> edges) {
        </span><span style="color: #0000ff;">int</span> n =<span style="color: #000000;"> edges.size();
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; root(n + <span style="color: #800080;">1</span>, <span style="color: #800080;">0</span><span style="color: #000000;">), first, second;
        </span><span style="color: #0000ff;">for</span> (auto&amp;<span style="color: #000000;"> edge : edges) {
            </span><span style="color: #0000ff;">if</span> (root[edge[<span style="color: #800080;">1</span>]] == <span style="color: #800080;">0</span><span style="color: #000000;">) {
                root[edge[</span><span style="color: #800080;">1</span>]] = edge[<span style="color: #800080;">0</span><span style="color: #000000;">];
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                first </span>= {root[edge[<span style="color: #800080;">1</span>]], edge[<span style="color: #800080;">1</span><span style="color: #000000;">]};
                second </span>=<span style="color: #000000;"> edge;
                edge[</span><span style="color: #800080;">1</span>] = <span style="color: #800080;">0</span><span style="color: #000000;">;
            }
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt;= n; ++i) root[i] =<span style="color: #000000;"> i;
        </span><span style="color: #0000ff;">for</span> (auto&amp;<span style="color: #000000;"> edge : edges) {
            </span><span style="color: #0000ff;">if</span> (edge[<span style="color: #800080;">1</span>] == <span style="color: #800080;">0</span>) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">int</span> x = getRoot(root, edge[<span style="color: #800080;">0</span>]), y = getRoot(root, edge[<span style="color: #800080;">1</span><span style="color: #000000;">]);
            </span><span style="color: #0000ff;">if</span> (x == y) <span style="color: #0000ff;">return</span> first.empty() ?<span style="color: #000000;"> edge : first;
            root[x] </span>=<span style="color: #000000;"> y;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> second;
    }
    </span><span style="color: #0000ff;">int</span> getRoot(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; root, <span style="color: #0000ff;">int</span><span style="color: #000000;"> i) {
        </span><span style="color: #0000ff;">return</span> i == root[i] ?<span style="color: #000000;"> i : getRoot(root, root[i]);
    }
};</span></pre>
</div>
<p> </p>
<p>讨论：使用联合查找Union Find的方法一般都需要写个子函数，来查找祖宗结点，上面的解法getRoot()函数就是这个子函数，我们使用递归的形式来写的，其实还可以用迭代的方式来写，下面这两种写法都可以：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">int</span> getRoot(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; root, <span style="color: #0000ff;">int</span><span style="color: #000000;"> i) {
    </span><span style="color: #0000ff;">while</span> (i !=<span style="color: #000000;"> root[i]) {
        root[i] </span>=<span style="color: #000000;"> root[root[i]];
        i </span>=<span style="color: #000000;"> root[i];
    }
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> i;
}</span></pre>
</div>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">int</span> getRoot(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; root, <span style="color: #0000ff;">int</span><span style="color: #000000;"> i) {
    </span><span style="color: #0000ff;">while</span> (i != root[i]) i =<span style="color: #000000;"> root[i];
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> i;
}</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/7628977.html">Redundant Connection</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-02-12 22:29</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=8445733" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(8445733);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7628977.html" id="cb_post_title_url">[LeetCode] Redundant Connection 冗余的连接</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>In this problem, a tree is an undirected graph that is connected and has no cycles.</p>
<p>The given input is a graph that started as a tree with N nodes (with distinct values 1, 2, ..., N), with one additional edge added. The added edge has two different vertices chosen from 1 to N, and was not an edge that already existed.</p>
<p>The resulting graph is given as a 2D-array of <code>edges</code>. Each element of <code>edges</code> is a pair <code>[u, v]</code> with <code>u &lt; v</code>, that represents an undirected edge connecting nodes <code>u</code> and <code>v</code>.</p>
<p>Return an edge that can be removed so that the resulting graph is a tree of N nodes. If there are multiple answers, return the answer that occurs last in the given 2D-array. The answer edge <code>[u, v]</code> should be in the same format, with <code>u &lt; v</code>.</p>
<p>Example 1:</p>
<pre>Input: [[1,2], [1,3], [2,3]]
Output: [2,3]
Explanation: The given undirected graph will be like this:
  1
 / \
2 - 3
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input: [[1,2], [2,3], [3,4], [1,4], [1,5]]
Output: [1,4]
Explanation: The given undirected graph will be like this:
5 - 1 - 2
    |   |
    4 - 3
</pre>
<p> </p>
<p>Note:</p>
<ul>
<li>The size of the input 2D-array will be between 3 and 1000.</li>
<li>Every integer represented in the 2D-array will be between 1 and N, where N is the size of the input array.</li>
</ul>
<p> </p>
<p> </p>
<p>这道题给我们了一个无向图，让我们删掉组成环的最后一条边，其实这道题跟之前那道<a href="http://www.cnblogs.com/grandyang/p/5257919.html" target="_blank">Graph Valid Tree</a>基本没什么区别，三种解法都基本相同。博主觉得老题稍微变一下就是一道新题，而onsite遇到原题的概率很小，大多情况下都会稍稍变一下，所以举一反三的能力真的很重要，要完全吃透一道题也不太容易，需要多下功夫。我们首先来看递归的解法，这种解法的思路是，每加入一条边，就进行环检测，一旦发现了环，就返回当前边。对于无向图，我们还是用邻接表来保存，建立每个结点和其所有邻接点的映射，由于两个结点之间不算有环，所以我们要避免这种情况 1-&gt;{2}, 2-&gt;{1}的死循环，所以我们用一个变量pre记录上一次递归的结点，比如上一次遍历的是结点1，那么在遍历结点2的邻接表时，就不会再次进入结点1了，这样有效的避免了死循环，使其能返回正确的结果，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; findRedundantConnection(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> edges) {
        unordered_map</span>&lt;<span style="color: #0000ff;">int</span>, unordered_set&lt;<span style="color: #0000ff;">int</span>&gt;&gt;<span style="color: #000000;"> m;
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto edge : edges) {
            </span><span style="color: #0000ff;">if</span> (hasCycle(edge[<span style="color: #800080;">0</span>], edge[<span style="color: #800080;">1</span>], m, -<span style="color: #800080;">1</span>)) <span style="color: #0000ff;">return</span><span style="color: #000000;"> edge;
            m[edge[</span><span style="color: #800080;">0</span>]].insert(edge[<span style="color: #800080;">1</span><span style="color: #000000;">]);
            m[edge[</span><span style="color: #800080;">1</span>]].insert(edge[<span style="color: #800080;">0</span><span style="color: #000000;">]);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> {};
    }
    </span><span style="color: #0000ff;">bool</span> hasCycle(<span style="color: #0000ff;">int</span> cur, <span style="color: #0000ff;">int</span> target, unordered_map&lt;<span style="color: #0000ff;">int</span>, unordered_set&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp; m, <span style="color: #0000ff;">int</span><span style="color: #000000;"> pre) {
        </span><span style="color: #0000ff;">if</span> (m[cur].count(target)) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span><span style="color: #000000;"> num : m[cur]) {
            </span><span style="color: #0000ff;">if</span> (num == pre) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> (hasCycle(num, target, m, cur)) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>既然递归能做，一般来说迭代也木有问题。但是由于BFS的遍历机制和DFS不同，所以没法采用利用变量pre来避免上面所说的死循环(不是很确定，可能是博主没想出来，有做出来的请在评论区贴上代码)，所以我们采用一个集合来记录遍历过的结点，如果该结点已经遍历过了，那么直接跳过即可，否则我们就把该结点加入queue和集合，继续循环，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; findRedundantConnection(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> edges) {
        unordered_map</span>&lt;<span style="color: #0000ff;">int</span>, unordered_set&lt;<span style="color: #0000ff;">int</span>&gt;&gt;<span style="color: #000000;"> m;
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto edge : edges) {
            queue</span>&lt;<span style="color: #0000ff;">int</span>&gt; q{{edge[<span style="color: #800080;">0</span><span style="color: #000000;">]}};
            unordered_set</span>&lt;<span style="color: #0000ff;">int</span>&gt; s{{edge[<span style="color: #800080;">0</span><span style="color: #000000;">]}};
            </span><span style="color: #0000ff;">while</span> (!<span style="color: #000000;">q.empty()) {
                auto t </span>=<span style="color: #000000;"> q.front(); q.pop();
                </span><span style="color: #0000ff;">if</span> (m[t].count(edge[<span style="color: #800080;">1</span>])) <span style="color: #0000ff;">return</span><span style="color: #000000;"> edge;
                </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span><span style="color: #000000;"> num : m[t]) {
                    </span><span style="color: #0000ff;">if</span> (s.count(num)) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                    q.push(num);
                    s.insert(num);
                }
            }
            m[edge[</span><span style="color: #800080;">0</span>]].insert(edge[<span style="color: #800080;">1</span><span style="color: #000000;">]);
            m[edge[</span><span style="color: #800080;">1</span>]].insert(edge[<span style="color: #800080;">0</span><span style="color: #000000;">]);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> {};
    }
};</span></pre>
</div>
<p> </p>
<p>其实这道题最好的解法使用Union Find来做，论坛上清一色的都是用这种解法来做的，像博主用DFS和BFS这么清新脱俗的方法还真不多:) 其实Union Find的核心思想并不是很难理解，首先我们建立一个长度为(n+1)的数组root，由于这道题并没有明确的说明n是多少，只是说了输入的二位数组的长度不超过1000，那么n绝对不会超过2000，我们加1的原因是由于结点值是从1开始的，而数组是从0开始的，我们懒得转换了，就多加一位得了。我们将这个数组都初始化为-1，有些人喜欢初始化为i，都可以。开始表示每个结点都是一个单独的组，所谓的Union Find就是要让结点之间建立关联，比如若root[1] = 2，就表示结点1和结点2是相连的，root[2] = 3表示结点2和结点3是相连的，如果我们此时新加一条边[1, 3]的话，我们通过root[1]得到2，再通过root[2]得到3，说明结点1有另一条路径能到结点3，这样就说明环是存在的；如果没有这条路径，那么我们要将结点1和结点3关联起来，让root[1] = 3即可，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; findRedundantConnection(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> edges) {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; root(<span style="color: #800080;">2001</span>, -<span style="color: #800080;">1</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto edge : edges) {
            </span><span style="color: #0000ff;">int</span> x = find(root, edge[<span style="color: #800080;">0</span>]), y = find(root, edge[<span style="color: #800080;">1</span><span style="color: #000000;">]);
            </span><span style="color: #0000ff;">if</span> (x == y) <span style="color: #0000ff;">return</span><span style="color: #000000;"> edge;
            root[x] </span>=<span style="color: #000000;"> y;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> {};
    }
    </span><span style="color: #0000ff;">int</span> find(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; root, <span style="color: #0000ff;">int</span><span style="color: #000000;"> i) {
        </span><span style="color: #0000ff;">while</span> (root[i] != -<span style="color: #800080;">1</span><span style="color: #000000;">) {
            i </span>=<span style="color: #000000;"> root[i];
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> i;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/5257919.html" target="_blank">Graph Valid Tree</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/104729/10-line-java-solution-union-find">https://discuss.leetcode.com/topic/104729/10-line-java-solution-union-find</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-10-05 11:43</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7628977" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7628977);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/8415880.html" id="cb_post_title_url">[LeetCode] K Empty Slots K个空槽</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>There is a garden with <code>N</code> slots. In each slot, there is a flower. The <code>N</code> flowers will bloom one by one in <code>N</code> days. In each day, there will be <code>exactly</code> one flower blooming and it will be in the status of blooming since then.</p>
<p>Given an array <code>flowers</code> consists of number from <code>1</code> to <code>N</code>. Each number in the array represents the place where the flower will open in that day.</p>
<p>For example, <code>flowers[i] = x</code> means that the unique flower that blooms at day <code>i</code> will be at position <code>x</code>, where <code>i</code> and <code>x</code> will be in the range from <code>1</code> to <code>N</code>.</p>
<p>Also given an integer <code>k</code>, you need to output in which day there exists two flowers in the status of blooming, and also the number of flowers between them is <code>k</code> and these flowers are not blooming.</p>
<p>If there isn't such day, output -1.</p>
<p>Example 1:</p>
<pre>Input: 
flowers: [1,3,2]
k: 1
Output: 2
Explanation: In the second day, the first and the third flower have become blooming.
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input: 
flowers: [1,2,3]
k: 1
Output: -1
</pre>
<p> </p>
<p>Note:</p>
<ol>
<li>The given array will be in the range [1, 20000].</li>
</ol>
<p> </p>
<p>这道题给了我们这样一个场景，说是花园里有N个空槽，可以放花，每天放一朵开着的花，而且一旦放了就会一直开下去。不是按顺序放花，而是给了我们一个数组flowers，其中flowers[i] = x表示第i天放的花会在位置x。其实题目这里有误，数组是从0开始的，而天数和位置都是从1开始的，所以正确的应该是第i+1天放的花会在位置x。然后给了我们一个整数k，让我们判断是否正好有两朵盛开的花中间有k个空槽，如果有，返回当前天数，否则返回-1。博主刚开始想的是先用暴力破解来做，用一个状态数组，如果该位置有花为1，无花为0，然后每增加一朵花，就遍历一下状态数组，找有没有连续k个0，结果TLE了。这说明，应该等所有花都放好了，再来找才行，但是这样仅用0和1的状态数组是不行的，我们得换个形式。</p>
<p>我们用一个days数组，其中days[i] = t表示在i+1位置上会在第t天放上花，那么如果days数组为[1 3 2]，就表示第一个位置会在第一天放上花，第二个位置在第三天放上花，第三个位置在第二天放上花。我们想，在之前的状态数组中，0表示没放花，1表示放了花，而days数组中的数字表示放花的天数，那么就是说数字大的就是花放的时间晚，那么在当前时间i，所有大于i的是不是也就是可以看作是没放花呢，这样问题就迎刃而解了，我们来找一个k+2大小的子数组，除了首尾两个数字，中间的k个数字都要大于首尾两个数字即可，那么首尾两个数字中较大的数就是当前的天数。left和right是这个大小为k+2的窗口，初始化时left为0，right为k+1，然后i从0开始遍历，这里循环的条件时right小于n，当窗口的右边界越界后，循环自然需要停止。如果当days[i]小于days[left]，或者days[i]小于等于days[right]的时候，有两种情况，一种是i在[left, right]范围内，说明窗口中有数字小于边界数字，这不满足我们之前限定的条件，至于days[i]为何可以等于days[right]，是因为当i遍历到right到位置时，说明中间的数字都是大于左右边界数的，此时我们要用左右边界中较大的那个数字更新结果res。不管i是否等于right，只要进了这个if条件，说明当前窗口要么是不合题意，要么是遍历完了，我们此时要重新给left和right赋值，其中left赋值为i，right赋值为k+1+i，还是大小为k+2的窗口，继续检测。最后我们看结果res，如果还是INT_MAX，说明无法找到，返回-1即可，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> kEmptySlots(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; flowers, <span style="color: #0000ff;">int</span><span style="color: #000000;"> k) {
        </span><span style="color: #0000ff;">int</span> res = INT_MAX, left = <span style="color: #800080;">0</span>, right = k + <span style="color: #800080;">1</span>, n =<span style="color: #000000;"> flowers.size();
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; days(n, <span style="color: #800080;">0</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++i) days[flowers[i] - <span style="color: #800080;">1</span>] = i + <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; right &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (days[i] &lt; days[left] || days[i] &lt;=<span style="color: #000000;"> days[right]) {
                </span><span style="color: #0000ff;">if</span> (i == right) res =<span style="color: #000000;"> min(res, max(days[left], days[right]));
                left </span>=<span style="color: #000000;"> i; 
                right </span>= k + <span style="color: #800080;">1</span> +<span style="color: #000000;"> i;
            }
        }
        </span><span style="color: #0000ff;">return</span> (res == INT_MAX) ? -<span style="color: #800080;">1</span><span style="color: #000000;"> : res;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种方法用到了TreeSet来做，利用其自动排序的特点，然后用lower_bound和upper_bound进行快速的二分查找。 题目中的flowers[i] = x表示第i+1天放的花会在位置x。所以我们遍历flowers数组，其实就是按照时间顺序进行的，我们取出当前需要放置的位置cur，然后在集合set中查找第一个大于cur的数字，如果存在的话，说明两者中间点位置都没有放花，而如果中间正好有k个空位的话，那么当前天数就即为所求。这是当cur为左边界的情况，同样，我们可以把cur当右边界来检测，在集合set中查找第一个小于cur的数字，如果二者中间有k个空位，也返回当前天数。需要注意的是，C++和Java中的upper_bound和higher是相同作用的，但是lower_bound和lower却不太一样。C++中的lower_bound找的是第一个不小于目标值的数字，所以可能会返回和目标值相同或者大于目标值的数字。只要这个数字不是第一个数字，然后我们往前退一位，就是要求的第一个小于目标值的数字，这相当于Java中的lower函数，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> kEmptySlots(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; flowers, <span style="color: #0000ff;">int</span><span style="color: #000000;"> k) {
        </span><span style="color: #0000ff;">set</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> s;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; flowers.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">int</span> cur =<span style="color: #000000;"> flowers[i];
            auto it </span>=<span style="color: #000000;"> s.upper_bound(cur);
            </span><span style="color: #0000ff;">if</span> (it != s.end() &amp;&amp; *it - cur == k + <span style="color: #800080;">1</span><span style="color: #000000;">) {
                </span><span style="color: #0000ff;">return</span> i + <span style="color: #800080;">1</span><span style="color: #000000;">;
            }
            it </span>=<span style="color: #000000;"> s.lower_bound(cur);
            </span><span style="color: #0000ff;">if</span> (it != s.begin() &amp;&amp; cur - *(--it) == k + <span style="color: #800080;">1</span><span style="color: #000000;">) {
                </span><span style="color: #0000ff;">return</span> i + <span style="color: #800080;">1</span><span style="color: #000000;">;
            }
            s.insert(cur);
        }
        </span><span style="color: #0000ff;">return</span> -<span style="color: #800080;">1</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>讨论：这道题有一个很好的follow up，就是改为最后的有k盆连续开花的是哪一天，就是k个连续不空的槽，博主没有想出特别好的解法，只能采用暴力搜索的解法。比如就像解法一，求出了days数组后。我们可以遍历每个长度为k的子数组，然后找出该子数组中最大的数字，然后找出所有的这些最大数字中的最小的一个，就是所求。或者，我们可以使用类似于合并区间的思想，遍历flowers数组，每遍历一个数字，如果跟现有的区间连续，就加入当前区间，直到出现某个区间的长度大于等于k了，则当前天数即为所求。如果各位看官大神们有更好的解法，一定要留言告知博主哈～</p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/104738/java-accepted-solution" target="_blank">https://discuss.leetcode.com/topic/104738/java-accepted-solution</a></p>
<p><a href="https://discuss.leetcode.com/topic/104771/java-c-simple-o-n-solution" target="_blank">https://discuss.leetcode.com/topic/104771/java-c-simple-o-n-solution</a></p>
<p><a href="https://discuss.leetcode.com/topic/106088/iterate-over-time-vs-iterate-over-position" target="_blank">https://discuss.leetcode.com/topic/106088/iterate-over-time-vs-iterate-over-position</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-02-05 02:47</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=8415880" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(8415880);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7627331.html" id="cb_post_title_url">[LeetCode] Baseball Game 棒球游戏</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>You're now a baseball game point recorder.</p>
<p>Given a list of strings, each string can be one of the 4 following types:</p>
<ol>
<li><code>Integer</code> (one round's score): Directly represents the number of points you get in this round.</li>
<li><code>"+"</code> (one round's score): Represents that the points you get in this round are the sum of the last two <code>valid</code>round's points.</li>
<li><code>"D"</code> (one round's score): Represents that the points you get in this round are the doubled data of the last <code>valid</code> round's points.</li>
<li><code>"C"</code> (an operation, which isn't a round's score): Represents the last <code>valid</code> round's points you get were invalid and should be removed.</li>
</ol>
<p> </p>
<p>Each round's operation is permanent and could have an impact on the round before and the round after.</p>
<p>You need to return the sum of the points you could get in all the rounds.</p>
<p>Example 1:</p>
<pre>Input: ["5","2","C","D","+"]
Output: 30
Explanation: 
Round 1: You could get 5 points. The sum is: 5.
Round 2: You could get 2 points. The sum is: 7.
Operation 1: The round 2's data was invalid. The sum is: 5.  
Round 3: You could get 10 points (the round 2's data has been removed). The sum is: 15.
Round 4: You could get 5 + 10 = 15 points. The sum is: 30.
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input: ["5","-2","4","C","D","9","+","+"]
Output: 27
Explanation: 
Round 1: You could get 5 points. The sum is: 5.
Round 2: You could get -2 points. The sum is: 3.
Round 3: You could get 4 points. The sum is: 7.
Operation 1: The round 3's data is invalid. The sum is: 3.  
Round 4: You could get -4 points (the round 3's data has been removed). The sum is: -1.
Round 5: You could get 9 points. The sum is: 8.
Round 6: You could get -4 + 9 = 5 points. The sum is 13.
Round 7: You could get 9 + 5 = 14 points. The sum is 27.
</pre>
<p> </p>
<p>Note:</p>
<ul>
<li>The size of the input list will be between 1 and 1000.</li>
<li>Every integer represented in the list will be between -30000 and 30000.</li>
</ul>
<p> </p>
<p>这道题不是一道难题，直接按照题目的描述来分情况处理即可，博主开始在取数组的最后一个数和倒数第二个数的时候还做了数组为空检测，但是的貌似这道题默认输入都是合法的，不会存在上一轮不存在还要取值的情况，那就不用检测啦，代码就更加的简洁啦：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> calPoints(vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp;<span style="color: #000000;"> ops) {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> v;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">string</span><span style="color: #000000;"> op : ops) {
            </span><span style="color: #0000ff;">if</span> (op == <span style="color: #800000;">"</span><span style="color: #800000;">+</span><span style="color: #800000;">"</span><span style="color: #000000;">) {
                v.push_back(v.back() </span>+ v[v.size() - <span style="color: #800080;">2</span><span style="color: #000000;">]);
            } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (op == <span style="color: #800000;">"</span><span style="color: #800000;">D</span><span style="color: #800000;">"</span><span style="color: #000000;">) {
                v.push_back(</span><span style="color: #800080;">2</span> *<span style="color: #000000;"> v.back());
            } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (op == <span style="color: #800000;">"</span><span style="color: #800000;">C</span><span style="color: #800000;">"</span><span style="color: #000000;">) {
                v.pop_back();
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                v.push_back(stoi(op));
            }
        }
        </span><span style="color: #0000ff;">return</span> accumulate(v.begin(), v.end(), <span style="color: #800080;">0</span><span style="color: #000000;">);
    }
};</span></pre>
</div>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-10-04 22:17</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7627331" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7627331);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7623614.html" id="cb_post_title_url">[LeetCode] Next Closest Time 下一个最近时间点</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="question-description">
<p>Given a time represented in the format "HH:MM", form the next closest time by reusing the current digits. There is no limit on how many times a digit can be reused.</p>
<p>You may assume the given input string is always valid. For example, "01:34", "12:09" are all valid. "1:34", "12:9" are all invalid.</p>
<p>Example 1:</p>
<pre>Input: "19:34"
Output: "19:39"
Explanation: The next closest time choosing from digits 1, 9, 3, 4, is 19:39, which occurs 5 minutes later.  It is not 19:33, because this occurs 23 hours and 59 minutes later.
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input: "23:59"
Output: "22:22"
Explanation: The next closest time choosing from digits 2, 3, 5, 9, is 22:22. It may be assumed that the returned time is next day's time since it is smaller than the input time numerically.
</pre>
<p> </p>
<p>这道题给了我们一个时间点，让我们求最近的下一个时间点，规定了不能产生新的数字，当下个时间点超过零点时，就当第二天的时间。为了找到下一个时间点，我们肯定是从分钟开始换数字，而且换的数字要是存在的数字，那么我们最先要做的就是统计当前时间点中的数字，由于可能有重复数字的存在，我们把数字都存入集合set中，这样可以去除重复数字，并且可以排序，然后再转为vector。下面就从低位分钟开始换数字了，如果低位分钟上的数字已经是最大的数字了，那么说明要转过一轮了，就要把低位分钟上的数字换成最小的那个数字；否则就将低位分钟上的数字换成下一个数字。然后再看高位分钟上的数字，同理，如果高位分钟上的数字已经是最大的数字，或则下一个数字大于5，那么直接换成最小值；否则就将高位分钟上的数字换成下一个数字。对于小时位上的数字也是同理，对于小时低位上的数字情况比较复杂，当小时高位不为2的时候，低位可以是任意数字，而当高位为2时，低位需要小于等于3。对于小时高位，其必须要小于等于2，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> nextClosestTime(<span style="color: #0000ff;">string</span><span style="color: #000000;"> time) {
        </span><span style="color: #0000ff;">string</span> res =<span style="color: #000000;"> time;
        </span><span style="color: #0000ff;">set</span>&lt;<span style="color: #0000ff;">int</span>&gt; s{time[<span style="color: #800080;">0</span>], time[<span style="color: #800080;">1</span>], time[<span style="color: #800080;">3</span>], time[<span style="color: #800080;">4</span><span style="color: #000000;">]};
        </span><span style="color: #0000ff;">string</span><span style="color: #000000;"> str(s.begin(), s.end());
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = res.size() - <span style="color: #800080;">1</span>; i &gt;= <span style="color: #800080;">0</span>; --<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (res[i] == <span style="color: #800000;">'</span><span style="color: #800000;">:</span><span style="color: #800000;">'</span>) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">int</span> pos =<span style="color: #000000;"> str.find(res[i]);
            </span><span style="color: #0000ff;">if</span> (pos == str.size() - <span style="color: #800080;">1</span><span style="color: #000000;">) {
                res[i] </span>= str[<span style="color: #800080;">0</span><span style="color: #000000;">];
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                </span><span style="color: #0000ff;">char</span> next = str[pos + <span style="color: #800080;">1</span><span style="color: #000000;">];
                </span><span style="color: #0000ff;">if</span> (i == <span style="color: #800080;">4</span><span style="color: #000000;">) {
                    res[i] </span>=<span style="color: #000000;"> next;
                    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
                } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (i == <span style="color: #800080;">3</span> &amp;&amp; next &lt;= <span style="color: #800000;">'</span><span style="color: #800000;">5</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                    res[i] </span>=<span style="color: #000000;"> next;
                    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res; 
                } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (i == <span style="color: #800080;">1</span> &amp;&amp; (res[<span style="color: #800080;">0</span>] != <span style="color: #800000;">'</span><span style="color: #800000;">2</span><span style="color: #800000;">'</span> || (res[<span style="color: #800080;">0</span>] == <span style="color: #800000;">'</span><span style="color: #800000;">2</span><span style="color: #800000;">'</span> &amp;&amp; next &lt;= <span style="color: #800000;">'</span><span style="color: #800000;">3</span><span style="color: #800000;">'</span><span style="color: #000000;">))) {
                    res[i] </span>=<span style="color: #000000;"> next;
                    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
                } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (i == <span style="color: #800080;">0</span> &amp;&amp; next &lt;= <span style="color: #800000;">'</span><span style="color: #800000;">2</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                    res[i] </span>=<span style="color: #000000;"> next;
                    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
                }
                res[i] </span>= str[<span style="color: #800080;">0</span><span style="color: #000000;">];
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种方法的写法比较简洁，实际上用了暴力搜索，由于按分钟算的话，一天只有1440分钟，也就是1440个时间点，我们可以从当前时间点开始，遍历一天的时间，也就是接下来的1440个时间点，得到一个新的整型时间点后，我们按位来更新结果res，对于每个更新的数字字符，看其是否在原时间点字符中存在，如果不存在，直接break，然后开始遍历下一个时间点，如果四个数字都成功存在了，那么将当前时间点中间夹上冒号返回即可，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> nextClosestTime(<span style="color: #0000ff;">string</span><span style="color: #000000;"> time) {
        </span><span style="color: #0000ff;">string</span> res = <span style="color: #800000;">"</span><span style="color: #800000;">0000</span><span style="color: #800000;">"</span><span style="color: #000000;">;
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; v{<span style="color: #800080;">600</span>, <span style="color: #800080;">60</span>, <span style="color: #800080;">10</span>, <span style="color: #800080;">1</span><span style="color: #000000;">};
        </span><span style="color: #0000ff;">int</span> found = time.find(<span style="color: #800000;">"</span><span style="color: #800000;">:</span><span style="color: #800000;">"</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">int</span> cur = stoi(time.substr(<span style="color: #800080;">0</span>, found)) * <span style="color: #800080;">60</span> + stoi(time.substr(found + <span style="color: #800080;">1</span><span style="color: #000000;">));
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>, d = <span style="color: #800080;">0</span>; i &lt;= <span style="color: #800080;">1440</span>; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">int</span> next = (cur + i) % <span style="color: #800080;">1440</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">for</span> (d = <span style="color: #800080;">0</span>; d &lt; <span style="color: #800080;">4</span>; ++<span style="color: #000000;">d) {
                res[d] </span>= <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span> + next /<span style="color: #000000;"> v[d]; 
                next </span>%=<span style="color: #000000;"> v[d];
                </span><span style="color: #0000ff;">if</span> (time.find(res[d]) == <span style="color: #0000ff;">string</span>::npos) <span style="color: #0000ff;">break</span><span style="color: #000000;">;
            }
            </span><span style="color: #0000ff;">if</span> (d &gt;= <span style="color: #800080;">4</span>) <span style="color: #0000ff;">break</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> res.substr(<span style="color: #800080;">0</span>, <span style="color: #800080;">2</span>) + <span style="color: #800000;">"</span><span style="color: #800000;">:</span><span style="color: #800000;">"</span> + res.substr(<span style="color: #800080;">2</span><span style="color: #000000;">);
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/104692/c-java-clean-code">https://discuss.leetcode.com/topic/104692/c-java-clean-code</a></p>
<p><a href="https://discuss.leetcode.com/topic/104736/concise-java-solution">https://discuss.leetcode.com/topic/104736/concise-java-solution</a></p>
<p><a href="https://discuss.leetcode.com/topic/105411/short-simple-java-using-regular-expression">https://discuss.leetcode.com/topic/105411/short-simple-java-using-regular-expression</a></p>
</div>
<div id="interviewed-div"> </div>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a> </p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-10-03 13:03</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7623614" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7623614);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7618468.html" id="cb_post_title_url">[LeetCode] Valid Palindrome II 验证回文字符串之二</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a non-empty string <code>s</code>, you may delete <strong>at most</strong> one character. Judge whether you can make it a palindrome.</p>
<p><strong>Example 1:</strong><br/>
</p>
<pre><strong>Input:</strong> "aba"
<strong>Output:</strong> True
</pre>
<p><strong>Example 2:</strong><br/>
</p>
<pre><strong>Input:</strong> "abca"
<strong>Output:</strong> True
<strong>Explanation:</strong> You could delete the character 'c'.
</pre>
<p><strong>Note:</strong><br/>
</p>
<ol><ol>
<li>The string will only contain lowercase characters a-z.
The maximum length of the string is 50000.</li>
</ol></ol>
<p> </p>
<p>这道题是之前那道<a href="http://www.cnblogs.com/grandyang/p/4030114.html" target="_blank">Valid Palindrome</a>的拓展，还是让我们验证回复字符串，但是区别是这道题的字符串中只含有小写字母，而且这道题允许删除一个字符，那么当遇到不匹配的时候，我们到底是删除左边的字符，还是右边的字符呢，我们的做法是两种情况都要算一遍，只要有一种能返回true，那么结果就返回true。我们可以写一个子函数来判断字符串中的某一个范围内的子字符串是否为回文串，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> validPalindrome(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        </span><span style="color: #0000ff;">int</span> left = <span style="color: #800080;">0</span>, right = s.size() - <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (left &lt;<span style="color: #000000;"> right) {
            </span><span style="color: #0000ff;">if</span> (s[left] != s[right]) <span style="color: #0000ff;">return</span> isValid(s, left, right - <span style="color: #800080;">1</span>) || isValid(s, left + <span style="color: #800080;">1</span><span style="color: #000000;">, right);
            </span>++left; --<span style="color: #000000;">right;
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
    </span><span style="color: #0000ff;">bool</span> isValid(<span style="color: #0000ff;">string</span> s, <span style="color: #0000ff;">int</span> left, <span style="color: #0000ff;">int</span><span style="color: #000000;"> right) {
        </span><span style="color: #0000ff;">while</span> (left &lt;<span style="color: #000000;"> right) {
            </span><span style="color: #0000ff;">if</span> (s[left] != s[right]) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            </span>++left; --<span style="color: #000000;">right;
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种写法跟上面的解法思路一样，只不过没有写额外的函数，还是要遍历两种情况，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> validPalindrome(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        </span><span style="color: #0000ff;">int</span> left = <span style="color: #800080;">0</span>, right = s.size() - <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (left &lt;<span style="color: #000000;"> right) {
            </span><span style="color: #0000ff;">if</span> (s[left] ==<span style="color: #000000;"> s[right]) {
                </span>++left; --<span style="color: #000000;">right;
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                </span><span style="color: #0000ff;">int</span> l = left, r = right - <span style="color: #800080;">1</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">while</span> (l &lt;<span style="color: #000000;"> r) {
                    </span><span style="color: #0000ff;">if</span> (s[l] != s[r]) <span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span>++l; --<span style="color: #000000;">r;
                    </span><span style="color: #0000ff;">if</span> (l &gt;= r) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                }
                </span>++<span style="color: #000000;">left;
                </span><span style="color: #0000ff;">while</span> (left &lt;<span style="color: #000000;"> right) {
                    </span><span style="color: #0000ff;">if</span> (s[left] != s[right]) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                    </span>++left; --<span style="color: #000000;">right;
                }
            }
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4030114.html" target="_blank">Valid Palindrome</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/103939/java-o-n-time-o-1-space">https://discuss.leetcode.com/topic/103939/java-o-n-time-o-1-space</a></p>
<p><a href="https://discuss.leetcode.com/topic/103911/two-solutions-optimized-and-recursive-java-and-c">https://discuss.leetcode.com/topic/103911/two-solutions-optimized-and-recursive-java-and-c</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-10-02 08:17</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7618468" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7618468);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/8395062.html" id="cb_post_title_url">[LeetCode] 24 Game 二十四点游戏</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="question-description">
<p>You have 4 cards each containing a number from 1 to 9. You need to judge whether they could operated through <code>*</code>, <code>/</code>, <code>+</code>, <code>-</code>, <code>(</code>, <code>)</code>to get the value of 24.</p>
<p>Example 1:</p>
<pre>Input: [4, 1, 8, 7]
Output: True
Explanation: (8-4) * (7-1) = 24
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input: [1, 2, 1, 2]
Output: False
</pre>
<p> </p>
<p>Note:</p>
<ol>
<li>The division operator <code>/</code> represents real division, not integer division. For example, 4 / (1 - 2/3) = 12.</li>
<li>Every operation done is between two numbers. In particular, we cannot use <code>-</code> as a unary operator. For example, with <code>[1, 1, 1, 1]</code> as input, the expression <code>-1 - 1 - 1 - 1</code> is not allowed.</li>
<li>You cannot concatenate numbers together. For example, if the input is <code>[1, 2, 1, 2]</code>, we cannot write this as 12 + 12.</li>
</ol>
<p> </p>
<p>这道题就是经典的24点游戏了，记得小时候经常玩这个游戏，就是每个人发四张牌，看谁最快能算出24，这完全是脑力大比拼啊，不是拼的牌技。玩的多了，就会摸出一些套路来，比如尽量去凑2和12，3和8，4和6等等，但是对于一些特殊的case，比如 [1, 5, 5, 5] 这种，正确的解法是 5 * (5 - 1 / 5)，一般人都会去试加减乘，和能整除的除法，而像这种带小数的确实很难想到，但是程序计算就没问题，可以遍历所有的情况，这也是这道题的实际意义所在吧。那么既然是要遍历所有的情况，我们应该隐约感觉到应该是要使用递归来做的。我们想，任意的两个数字之间都可能进行加减乘除，其中加法和乘法对于两个数字的前后顺序没有影响，但是减法和除法是有影响的，而且做除法的时候还要另外保证除数不能为零。我们要遍历任意两个数字，然后对于这两个数字，尝试各种加减乘除后得到一个新数字，将这个新数字加到原数组中，记得原来的两个数要移除掉，然后调用递归函数进行计算，我们可以发现每次调用递归函数后，数组都减少一个数字，那么当减少到只剩一个数字了，就是最后的计算结果，所以我们在递归函数开始时判断，如果数组只有一个数字，且为24，说明可以算出24，结果res赋值为true返回。这里我们的结果res是一个全局的变量，如果已经为true了，就没必要再进行运算了，所以第一行应该是判断结果res，为true就直接返回了。我们遍历任意两个数字，分别用p和q来取出，然后进行两者的各种加减乘除的运算，将结果保存进数组临时数组t，记得要判断除数不为零。然后将原数组nums中的p和q移除，遍历临时数组t中的数字，将其加入数组nums，然后调用递归函数，记得完成后要移除数字，恢复状态，这是递归解法很重要的一点。最后还要把p和q再加回原数组nums，这也是还原状态，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> judgePoint24(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        </span><span style="color: #0000ff;">bool</span> res = <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">double</span> eps = <span style="color: #800080;">0.001</span><span style="color: #000000;">;
        vector</span>&lt;<span style="color: #0000ff;">double</span>&gt;<span style="color: #000000;"> arr(nums.begin(), nums.end());
        helper(arr, eps, res);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">void</span> helper(vector&lt;<span style="color: #0000ff;">double</span>&gt;&amp; nums, <span style="color: #0000ff;">double</span> eps, <span style="color: #0000ff;">bool</span>&amp;<span style="color: #000000;"> res) {
        </span><span style="color: #0000ff;">if</span> (res) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (nums.size() == <span style="color: #800080;">1</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">if</span> (abs(nums[<span style="color: #800080;">0</span>] - <span style="color: #800080;">24</span>) &lt; eps) res = <span style="color: #0000ff;">true</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; nums.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; i; ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">double</span> p = nums[i], q =<span style="color: #000000;"> nums[j];
                vector</span>&lt;<span style="color: #0000ff;">double</span>&gt; t{p + q, p - q, q - p, p *<span style="color: #000000;"> q};
                </span><span style="color: #0000ff;">if</span> (p &gt; eps) t.push_back(q /<span style="color: #000000;"> p);
                </span><span style="color: #0000ff;">if</span> (q &gt; eps) t.push_back(p /<span style="color: #000000;"> q);
                nums.erase(nums.begin() </span>+<span style="color: #000000;"> i);
                nums.erase(nums.begin() </span>+<span style="color: #000000;"> j);
                </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">double</span><span style="color: #000000;"> d : t) {
                    nums.push_back(d);
                    helper(nums, eps, res);
                    nums.pop_back();
                }
                nums.insert(nums.begin() </span>+<span style="color: #000000;"> j, q);
                nums.insert(nums.begin() </span>+<span style="color: #000000;"> i, p);
            }
        }
    }
};</span></pre>
</div>
<p> </p>
<p>来看一种很不同的递归写法，这里将加减乘除操作符放到了一个数组ops中。并且没有用全局变量res，而是让递归函数带有bool型返回值。在递归函数中，还是要先看nums数组的长度，如果为1了，说明已经计算完成，直接看结果是否为0就行了。然后遍历任意两个数字，注意这里的i和j都分别从0到了数组长度，而上面解法的j是从0到i，这是因为上面解法将p - q, q - p, q / q, q / p都分别列出来了，而这里仅仅是nums[i] - nums[j], nums[i] / nums[j]，所以i和j要交换位置，但是为了避免加法和乘法的重复计算，我们可以做个判断，还有别忘记了除数不为零的判断，i和j不能相同的判断。我们建立一个临时数组t，将非i和j位置的数字都加入t，然后遍历操作符数组ops，每次取出一个操作符，然后将nums[i]和nums[j]的计算结果加入t，调用递归函数，如果递归函数返回true了，那么就直接返回true。否则移除刚加入的结果，还原t的状态，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> judgePoint24(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        </span><span style="color: #0000ff;">double</span> eps = <span style="color: #800080;">0.001</span><span style="color: #000000;">;
        vector</span>&lt;<span style="color: #0000ff;">char</span>&gt; ops{<span style="color: #800000;">'</span><span style="color: #800000;">+</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">-</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">*</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">/</span><span style="color: #800000;">'</span><span style="color: #000000;">};
        vector</span>&lt;<span style="color: #0000ff;">double</span>&gt;<span style="color: #000000;"> arr(nums.begin(), nums.end());
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> helper(arr, ops, eps);
    }
    </span><span style="color: #0000ff;">bool</span> helper(vector&lt;<span style="color: #0000ff;">double</span>&gt;&amp; nums, vector&lt;<span style="color: #0000ff;">char</span>&gt;&amp; ops, <span style="color: #0000ff;">double</span><span style="color: #000000;"> eps) {
        </span><span style="color: #0000ff;">if</span> (nums.size() == <span style="color: #800080;">1</span>) <span style="color: #0000ff;">return</span> abs(nums[<span style="color: #800080;">0</span>] - <span style="color: #800080;">24</span>) &lt;<span style="color: #000000;"> eps;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; nums.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; nums.size(); ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> (i == j) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                vector</span>&lt;<span style="color: #0000ff;">double</span>&gt;<span style="color: #000000;"> t;
                </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> k = <span style="color: #800080;">0</span>; k &lt; nums.size(); ++<span style="color: #000000;">k) {
                    </span><span style="color: #0000ff;">if</span> (k != i &amp;&amp; k !=<span style="color: #000000;"> j) t.push_back(nums[k]);
                }
                </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span><span style="color: #000000;"> op : ops) {
                    </span><span style="color: #0000ff;">if</span> ((op == <span style="color: #800000;">'</span><span style="color: #800000;">+</span><span style="color: #800000;">'</span> || op == <span style="color: #800000;">'</span><span style="color: #800000;">*</span><span style="color: #800000;">'</span>) &amp;&amp; i &gt; j) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">if</span> (op == <span style="color: #800000;">'</span><span style="color: #800000;">/</span><span style="color: #800000;">'</span> &amp;&amp; nums[j] &lt; eps) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">switch</span><span style="color: #000000;">(op) {
                        </span><span style="color: #0000ff;">case</span> <span style="color: #800000;">'</span><span style="color: #800000;">+</span><span style="color: #800000;">'</span>: t.push_back(nums[i] + nums[j]); <span style="color: #0000ff;">break</span><span style="color: #000000;">;
                        </span><span style="color: #0000ff;">case</span> <span style="color: #800000;">'</span><span style="color: #800000;">-</span><span style="color: #800000;">'</span>: t.push_back(nums[i] - nums[j]); <span style="color: #0000ff;">break</span><span style="color: #000000;">;
                        </span><span style="color: #0000ff;">case</span> <span style="color: #800000;">'</span><span style="color: #800000;">*</span><span style="color: #800000;">'</span>: t.push_back(nums[i] * nums[j]); <span style="color: #0000ff;">break</span><span style="color: #000000;">;
                        </span><span style="color: #0000ff;">case</span> <span style="color: #800000;">'</span><span style="color: #800000;">/</span><span style="color: #800000;">'</span>: t.push_back(nums[i] / nums[j]); <span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    }
                    </span><span style="color: #0000ff;">if</span> (helper(t, ops, eps)) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                    t.pop_back();
                }
            }
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>讨论：博主在调试的时候，遇到了这个test case: [1, 3, 4, 6]，返回的是true，但是博主心算了一会，并没有想出其是如何算出24的。所以博主在想，能不能修改下代码，使得其能将运算的过程返回出来。其实并不难改，基于解法二来改一下，我们发现，计算后的结果被存入了临时数组t，进行下一次递归，我们需要将这个过程保存下来，用一个字符串数组，比如"1+3"，或者"1-3"等等，这个数组跟数组t大小相同，操作基本相同，同时需要被传入到下一次递归函数中，而在下一次递归函数中，数组t中取出的就是4和-2，但是字符串数组就可以取出"1+3"和"1-3"，我们就可以继续和别的数进行计算了，比如要乘以4，我们需要给取出的字符串加上括号，就变成了(1+3)*4了，就通过这种方法就可以将过程返回了，运行test case: [1, 3, 4, 6]，返回得到：</p>
<p>(6/(1-(3/4)))</p>
<p>没有问题，还有就是，由于组成24的方法可能不止1种，我们可以将所有情况都返回，那么我们的递归函数就不要有返回值，这样可以遍历完所有的情况，对于test case: [1, 2, 3, 8]，返回如下：</p>
<p>((8-2)*(1+3))<br/>(8/(1-(2/3)))<br/>(3/((2-1)/8))<br/>(3*(8/(2-1)))<br/>(8*(3*(2-1)))<br/>(2*(1+(3+8)))<br/>(8/((2-1)/3))<br/>(3*(8*(2-1)))<br/>((1+3)*(8-2))<br/>((3*8)/(2-1))<br/>(8*(3/(2-1)))<br/>((3*8)*(2-1))<br/>(2*(8+(1+3)))<br/>((2-1)*(3*8))<br/>(2*(3+(1+8)))</p>
<p>被惊到了有木有！居然有这么多种计算方法可以得到24～</p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/104042/679-24-game-c-recursive">https://discuss.leetcode.com/topic/104042/679-24-game-c-recursive</a></p>
<p><a href="https://discuss.leetcode.com/topic/103962/java-easy-to-understand-backtracking">https://discuss.leetcode.com/topic/103962/java-easy-to-understand-backtracking</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p>
</div></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-01-31 21:59</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=8395062" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(8395062);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7617017.html" id="cb_post_title_url">[LeetCode] Valid Parenthesis String 验证括号字符串</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a string containing only three types of characters: '(', ')' and '*', write a function to check whether this string is valid. We define the validity of a string by these rules:</p>
<ol>
<li>Any left parenthesis <code>'('</code> must have a corresponding right parenthesis <code>')'</code>.</li>
<li>Any right parenthesis <code>')'</code> must have a corresponding left parenthesis <code>'('</code>.</li>
<li>Left parenthesis <code>'('</code> must go before the corresponding right parenthesis <code>')'</code>.</li>
<li><code>'*'</code> could be treated as a single right parenthesis <code>')'</code> or a single left parenthesis <code>'('</code> or an empty string.</li>
<li>An empty string is also valid.</li>
</ol>
<p> </p>
<p>Example 1:</p>
<pre>Input: "()"
Output: True
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input: "(*)"
Output: True
</pre>
<p> </p>
<p>Example 3:</p>
<pre>Input: "(*))"
Output: True
</pre>
<p> </p>
<p>Note:</p>
<ol>
<li>The string size will be in the range [1, 100].</li>
</ol>
<p> </p>
<p>这道题让我们验证括号字符串，跟之前那道<a href="http://www.cnblogs.com/grandyang/p/4424587.html" target="_blank">Valid Parentheses</a>有些类似。不同之处在于这道题不只有小括号，还存在星号，星号可以当左括号，右括号，或空来使用，问我们能不能得到一个合法的括号字符串。那么我们想，如果不存在星号，那么这题是不是异常的简单，我们甚至连stack都可以不用，直接用一个变量，遇到左括号，自增1，遇到右括号，如果此时计数器已经为0了，直接返回false，否则自减1，一旦计数器出现了负数，立即返回false，最后还要看变量是否为0即可。但是由于星号的存在，这道题就变的复杂了，由于星号可以当括号用，所以当遇到右括号时，就算此时变量为0，也可以用星号来当左括号使用。那么星号什么时候都能当括号来用吗，我们来看两个例子 *) 和 *( ，在第一种情况下，星号可以当左括号来用，而在第二种情况下，无论星号当左括号，右括号，还是空，*( 都是不对的。当然这种情况只限于星号和左括号之间的位置关系，而只要星号在右括号前面，就一定可以消掉右括号。那么我们使用两个stack，分别存放左括号和星号的位置，遍历字符串，当遇到星号时，压入星号栈star，当遇到左括号时，压入左括号栈left，当遇到右括号时，此时如果left和star均为空时，直接返回false；如果left不为空，则pop一个左括号来抵消当前的右括号；否则从star中取出一个星号当作左括号来抵消右括号。当循环结束后，我们希望left中没有多余的左括号，就算有，我们可以尝试着用星号来抵消，当star和left均不为空时，进行循环，如果left的栈顶左括号的位置在star的栈顶星号的右边，那么就组成了 *( 模式，直接返回false；否则就说明星号可以抵消左括号，各自pop一个元素。最终退出循环后我们看left中是否还有多余的左括号，没有就返回true，否则false，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> checkValidString(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        stack</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> left, star;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; s.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (s[i] == <span style="color: #800000;">'</span><span style="color: #800000;">*</span><span style="color: #800000;">'</span><span style="color: #000000;">) star.push(i);
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (s[i] == <span style="color: #800000;">'</span><span style="color: #800000;">(</span><span style="color: #800000;">'</span><span style="color: #000000;">) left.push(i);
            </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                </span><span style="color: #0000ff;">if</span> (left.empty() &amp;&amp; star.empty()) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">if</span> (!<span style="color: #000000;">left.empty()) left.pop();
                </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> star.pop();
            }
        }
        </span><span style="color: #0000ff;">while</span> (!left.empty() &amp;&amp; !<span style="color: #000000;">star.empty()) {
            </span><span style="color: #0000ff;">if</span> (left.top() &gt; star.top()) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            left.pop(); star.pop();
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> left.empty();
    }
};</span></pre>
</div>
<p> </p>
<p>如果你觉得上面的解法逻辑稍稍复杂了一些，我们来看一种逻辑无比简单的解法。既然星号可以当左括号和右括号，那么我们就正反各遍历一次，正向遍历的时候，我们把星号都当成左括号，此时用经典的验证括号的方法，即遇左括号计数器加1，遇右括号则自减1，如果中间某个时刻计数器小于0了，直接返回false。如果最终计数器等于0了，我们直接返回true，因为此时我们把星号都当作了左括号，可以跟所有的右括号抵消。而此时就算计数器大于0了，我们暂时不能返回false，因为有可能多余的左括号是星号变的，星号也可以表示空，所以有可能不多，我们还需要反向q一下，哦不，是反向遍历一下，这是我们将所有的星号当作右括号，遇右括号计数器加1，遇左括号则自减1，如果中间某个时刻计数器小于0了，直接返回false。遍历结束后直接返回true，这是为啥呢？此时计数器有两种情况，要么为0，要么大于0。为0不用说，肯定是true，为啥大于0也是true呢？因为之前正向遍历的时候，我们的左括号多了，我们之前说过了，多余的左括号可能是星号变的，也可能是本身就多的左括号。本身就多的左括号这种情况会在反向遍历时被检测出来，如果没有检测出来，说明多余的左括号一定是星号变的。而这些星号在反向遍历时又变做了右括号，最终导致了右括号有剩余，所以当这些星号都当作空的时候，左右括号都是对应的，即是合法的。你可能会有疑问，右括号本身不会多么，其实不会的，如果多的话，会在正向遍历中被检测出来，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> checkValidString(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        </span><span style="color: #0000ff;">int</span> left = <span style="color: #800080;">0</span>, right = <span style="color: #800080;">0</span>, n =<span style="color: #000000;"> s.size();
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (s[i] == <span style="color: #800000;">'</span><span style="color: #800000;">(</span><span style="color: #800000;">'</span> || s[i] == <span style="color: #800000;">'</span><span style="color: #800000;">*</span><span style="color: #800000;">'</span>) ++<span style="color: #000000;">left;
            </span><span style="color: #0000ff;">else</span> --<span style="color: #000000;">left;
            </span><span style="color: #0000ff;">if</span> (left &lt; <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">if</span> (left == <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = n - <span style="color: #800080;">1</span>; i &gt;= <span style="color: #800080;">0</span>; --<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (s[i] == <span style="color: #800000;">'</span><span style="color: #800000;">)</span><span style="color: #800000;">'</span> || s[i] == <span style="color: #800000;">'</span><span style="color: #800000;">*</span><span style="color: #800000;">'</span>) ++<span style="color: #000000;">right;
            </span><span style="color: #0000ff;">else</span> --<span style="color: #000000;">right;
            </span><span style="color: #0000ff;">if</span> (right &lt; <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种方法是用递归来写的，思路特别的简单直接，感觉应该属于暴力破解法。使用了变量cnt来记录左括号的个数，变量start表示当前开始遍历的位置，那么在递归函数中，首先判断如果cnt小于0，直接返回false。否则进行从start开始的遍历，如果当前字符为左括号，cnt自增1；如果为右括号，若cnt此时小于等于0，返回false，否则cnt自减1；如果为星号，我们同时递归三种情况，分别是当星号为空，左括号，或右括号，只要有一种情况返回true，那么就是true了。如果循环退出后，若cnt为0，返回true，否则false，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> checkValidString(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        </span><span style="color: #0000ff;">return</span> helper(s, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span><span style="color: #000000;">);
    }
    </span><span style="color: #0000ff;">bool</span> helper(<span style="color: #0000ff;">string</span> s, <span style="color: #0000ff;">int</span> start, <span style="color: #0000ff;">int</span><span style="color: #000000;"> cnt) {
        </span><span style="color: #0000ff;">if</span> (cnt &lt; <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = start; i &lt; s.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (s[i] == <span style="color: #800000;">'</span><span style="color: #800000;">(</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                </span>++<span style="color: #000000;">cnt;
            } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (s[i] == <span style="color: #800000;">'</span><span style="color: #800000;">)</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                </span><span style="color: #0000ff;">if</span> (cnt &lt;= <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                </span>--<span style="color: #000000;">cnt;
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                </span><span style="color: #0000ff;">return</span> helper(s, i + <span style="color: #800080;">1</span>, cnt) || helper(s, i + <span style="color: #800080;">1</span>, cnt + <span style="color: #800080;">1</span>) || helper(s, i + <span style="color: #800080;">1</span>, cnt - <span style="color: #800080;">1</span><span style="color: #000000;">);
            }
        }
        </span><span style="color: #0000ff;">return</span> cnt == <span style="color: #800080;">0</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种解法是论坛上排第一的解法，感觉思路清新脱俗，博主研究了好久，参考了网友的留言才稍稍弄懂了一些，这里维护了两个变量low和high，其中low表示在有左括号的情况下，将星号当作右括号时左括号的个数(这样做的原因是尽量不多增加右括号的个数)，而high表示将星号当作左括号时左括号的个数。是不是很绕，没办法。那么当high小于0时，说明就算把星号都当作左括号了，还是不够抵消右括号，返回false。而当low大于0时，说明左括号的个数太多了，没有足够多的右括号来抵消，返回false。那么开始遍历字符串，当遇到左括号时，low和high都自增1；当遇到右括号时，只有当low大于0时，low才自减1，保证了low不会小于0，而high直接自减1；当遇到星号时，只有当low大于0时，low才自减1，保证了low不会小于0，而high直接自增1，因为high把星号当作左括号。当此时high小于0，说明右括号太多，返回false。当循环退出后，我们看low是否为0，参见代码如下：</p>
<p> </p>
<p>解法四：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> checkValidString(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        </span><span style="color: #0000ff;">int</span> low = <span style="color: #800080;">0</span>, high = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span><span style="color: #000000;"> c : s) {
            </span><span style="color: #0000ff;">if</span> (c == <span style="color: #800000;">'</span><span style="color: #800000;">(</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                </span>++low; ++<span style="color: #000000;">high;
            } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (c == <span style="color: #800000;">'</span><span style="color: #800000;">)</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                </span><span style="color: #0000ff;">if</span> (low &gt; <span style="color: #800080;">0</span>) --<span style="color: #000000;">low;
                </span>--<span style="color: #000000;">high;
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                </span><span style="color: #0000ff;">if</span> (low &gt; <span style="color: #800080;">0</span>) --<span style="color: #000000;">low;
                </span>++<span style="color: #000000;">high;
            }
            </span><span style="color: #0000ff;">if</span> (high &lt; <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> low == <span style="color: #800080;">0</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4424587.html" target="_blank">Valid Parentheses</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/8606024.html">Special Binary String</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a href="http://www.cnblogs.com/grandyang/p/4606334.html" target="_blank">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-10-01 12:40</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7617017" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7617017);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7616525.html" id="cb_post_title_url">[LeetCode] Map Sum Pairs 映射配对之和</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="question-description">
<p>Implement a MapSum class with <code>insert</code>, and <code>sum</code> methods.</p>
<p>For the method <code>insert</code>, you'll be given a pair of (string, integer). The string represents the key and the integer represents the value. If the key already existed, then the original key-value pair will be overridden to the new one.</p>
<p>For the method <code>sum</code>, you'll be given a string representing the prefix, and you need to return the sum of all the pairs' value whose key starts with the prefix.</p>
<p>Example 1:</p>
<pre>Input: insert("apple", 3), Output: Null
Input: sum("ap"), Output: 3
Input: insert("app", 2), Output: Null
Input: sum("ap"), Output: 5
</pre>
<p> </p>
<p>这道题让我们实现一个MapSum类，里面有两个方法，insert和sum，其中inser就是插入一个键值对，而sum方法比较特别，是在找一个前缀，需要将所有有此前缀的单词的值累加起来返回。看到这种玩前缀的题，照理来说是要用前缀树来做的。但是博主一般想偷懒，不想新写一个结构或类，于是就使用map来代替前缀树啦。博主开始想到的方法是建立前缀和一个pair之间的映射，这里的pair的第一个值表示该词的值，第二个值表示将该词作为前缀的所有词的累加值，那么我们的sum函数就异常的简单了，直接将pair中的两个值相加即可。关键就是要在insert中把数据结构建好，构建的方法也不难，首先我们suppose原本这个key是有值的，我们更新的时候只需要加上它的差值即可，就算key不存在默认就是0，算差值也没问题。然后我们将first值更新为val，然后就是遍历其所有的前缀了，给每个前缀的second都加上diff即可，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> MapSum {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">* Initialize your data structure here. </span><span style="color: #008000;">*/</span><span style="color: #000000;">
    MapSum() {}
    
    </span><span style="color: #0000ff;">void</span> insert(<span style="color: #0000ff;">string</span> key, <span style="color: #0000ff;">int</span><span style="color: #000000;"> val) {
        </span><span style="color: #0000ff;">int</span> diff = val - m[key].first, n =<span style="color: #000000;"> key.size();
        m[key].first </span>=<span style="color: #000000;"> val;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = n - <span style="color: #800080;">1</span>; i &gt; <span style="color: #800080;">0</span>; --<span style="color: #000000;">i) {
            m[key.substr(</span><span style="color: #800080;">0</span>, i)].second +=<span style="color: #000000;"> diff;
        }
    }
    
    </span><span style="color: #0000ff;">int</span> sum(<span style="color: #0000ff;">string</span><span style="color: #000000;"> prefix) {
        </span><span style="color: #0000ff;">return</span> m[prefix].first +<span style="color: #000000;"> m[prefix].second;
    }

</span><span style="color: #0000ff;">private</span><span style="color: #000000;">:
    unordered_map</span>&lt;<span style="color: #0000ff;">string</span>, pair&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;&gt;<span style="color: #000000;"> m;
};</span></pre>
</div>
<p> </p>
<p>下面这种方法是论坛上投票最高的方法，感觉很叼，用的是带排序的map，insert就是把单词加入map。在map里会按照字母顺序自动排序，然后在sum函数里，我们根据prefix来用二分查找快速定位到第一个不小于prefix的位置，然后向后遍历，向后遍历的都是以prefix为前缀的单词，如果我们发现某个单词不是以prefix为前缀了，直接break；否则就累加其val值，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> MapSum {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">* Initialize your data structure here. </span><span style="color: #008000;">*/</span><span style="color: #000000;">
    MapSum() {}
    
    </span><span style="color: #0000ff;">void</span> insert(<span style="color: #0000ff;">string</span> key, <span style="color: #0000ff;">int</span><span style="color: #000000;"> val) {
        m[key] </span>=<span style="color: #000000;"> val;
    }
    
    </span><span style="color: #0000ff;">int</span> sum(<span style="color: #0000ff;">string</span><span style="color: #000000;"> prefix) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, n =<span style="color: #000000;"> prefix.size();
        </span><span style="color: #0000ff;">for</span> (auto it = m.lower_bound(prefix); it != m.end(); ++<span style="color: #000000;">it) {
            </span><span style="color: #0000ff;">if</span> (it-&gt;first.substr(<span style="color: #800080;">0</span>, n) != prefix) <span style="color: #0000ff;">break</span><span style="color: #000000;">;
            res </span>+= it-&gt;<span style="color: #000000;">second;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    
</span><span style="color: #0000ff;">private</span><span style="color: #000000;">:
    map</span>&lt;<span style="color: #0000ff;">string</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> m;
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/103924/java-map-solution">https://discuss.leetcode.com/topic/103924/java-map-solution</a></p>
<p><a href="https://discuss.leetcode.com/topic/104006/c-easy-solution-ordered-map">https://discuss.leetcode.com/topic/104006/c-easy-solution-ordered-map</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p>
</div></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-09-30 23:54</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7616525" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7616525);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7612918.html" id="cb_post_title_url">[LeetCode] Implement Magic Dictionary 实现神奇字典</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Implement a magic directory with <code>buildDict</code>, and <code>search</code> methods.</p>
<p>For the method <code>buildDict</code>, you'll be given a list of non-repetitive words to build a dictionary.</p>
<p>For the method <code>search</code>, you'll be given a word, and judge whether if you modify exactly one character into another character in this word, the modified word is in the dictionary you just built.</p>
<p>Example 1:</p>
<pre>Input: buildDict(["hello", "leetcode"]), Output: Null
Input: search("hello"), Output: False
Input: search("hhllo"), Output: True
Input: search("hell"), Output: False
Input: search("leetcoded"), Output: False
</pre>
<p> </p>
<p>Note:</p>
<ol>
<li>You may assume that all the inputs are consist of lowercase letters <code>a-z</code>.</li>
<li>For contest purpose, the test data is rather small by now. You could think about highly efficient algorithm after the contest.</li>
<li>Please remember to RESET your class variables declared in class MagicDictionary, as static/class variables are persisted across multiple test cases. Please see <a href="https://leetcode.com/faq/#different-output">here</a> for more details.</li>
</ol>
<p> </p>
<p>这道题让我们设计一种神奇字典的数据结构，里面有一些单词，实现的功能是当我们搜索一个单词，只有存在和这个单词只有一个位置上的字符不相同的才能返回true，否则就返回false，注意完全相同也是返回false，必须要有一个字符不同。博主首先想到了<a href="http://www.cnblogs.com/grandyang/p/5184698.html" target="_blank">One Edit Distance</a>那道题，只不过这道题的两个单词之间长度必须相等。所以只需检测和要搜索单词长度一样的单词即可，所以我们用的数据结构就是根据单词的长度来分，把长度相同相同的单词放到一起，这样就可以减少搜索量。那么对于和要搜索单词进行比较的单词，由于已经保证了长度相等，我们直接进行逐个字符比较即可，用cnt表示不同字符的个数，初始化为0。如果当前遍历到的字符相等，则continue；如果当前遍历到的字符不相同，并且此时cnt已经为1了，则break，否则cnt就自增1。退出循环后，我们检测是否所有字符都比较完了且cnt为1，是的话则返回true，否则就是跟下一个词比较。如果所有词都比较完了，则返回false，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> MagicDictionary {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">* Initialize your data structure here. </span><span style="color: #008000;">*/</span><span style="color: #000000;">
    MagicDictionary() {}
    
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">* Build a dictionary through a list of words </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">void</span> buildDict(vector&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> dict) {
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">string</span><span style="color: #000000;"> word : dict) {
            m[word.size()].push_back(word);
        }
    }
    
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">* Returns if there is any word in the trie that equals to the given word after modifying exactly one character </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">bool</span> search(<span style="color: #0000ff;">string</span><span style="color: #000000;"> word) {
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">string</span><span style="color: #000000;"> str : m[word.size()]) {
            </span><span style="color: #0000ff;">int</span> cnt = <span style="color: #800080;">0</span>, i = <span style="color: #800080;">0</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">for</span> (; i &lt; word.size(); ++<span style="color: #000000;">i) {
                </span><span style="color: #0000ff;">if</span> (word[i] == str[i]) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">if</span> (word[i] != str[i] &amp;&amp; cnt == <span style="color: #800080;">1</span>) <span style="color: #0000ff;">break</span><span style="color: #000000;">; 
                </span>++<span style="color: #000000;">cnt;
            }
            </span><span style="color: #0000ff;">if</span> (i == word.size() &amp;&amp; cnt == <span style="color: #800080;">1</span>) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
    }

</span><span style="color: #0000ff;">private</span><span style="color: #000000;">:
    unordered_map</span>&lt;<span style="color: #0000ff;">int</span>, vector&lt;<span style="color: #0000ff;">string</span>&gt;&gt;<span style="color: #000000;"> m;
};</span></pre>
</div>
<p> </p>
<p>下面这种解法实际上是用到了前缀树中的search的思路，但是我们又没有整个用到prefix tree，博主感觉那样写法略复杂，其实我们只需要借鉴一下search方法就行了。我们首先将所有的单词都放到一个集合中，然后在search函数中，我们遍历要搜索的单词的每个字符，然后把每个字符都用a-z中的字符替换一下，形成一个新词，当然遇到本身要跳过。然后在集合中看是否存在，存在的话就返回true。记得换完一圈字符后要换回去，不然就不满足只改变一个字符的条件了，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> MagicDictionary {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">* Initialize your data structure here. </span><span style="color: #008000;">*/</span><span style="color: #000000;">
    MagicDictionary() {}
    
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">* Build a dictionary through a list of words </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">void</span> buildDict(vector&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> dict) {
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">string</span><span style="color: #000000;"> word : dict) s.insert(word);
    }
    
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">* Returns if there is any word in the trie that equals to the given word after modifying exactly one character </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">bool</span> search(<span style="color: #0000ff;">string</span><span style="color: #000000;"> word) {
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; word.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">char</span> t =<span style="color: #000000;"> word[i];
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span> c = <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span>; c &lt;= <span style="color: #800000;">'</span><span style="color: #800000;">z</span><span style="color: #800000;">'</span>; ++<span style="color: #000000;">c) {
                </span><span style="color: #0000ff;">if</span> (c == t) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                word[i] </span>=<span style="color: #000000;"> c;
                </span><span style="color: #0000ff;">if</span> (s.count(word)) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
            }
            word[i] </span>=<span style="color: #000000;"> t;
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
    }
    
</span><span style="color: #0000ff;">private</span><span style="color: #000000;">:
    unordered_set</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> s;
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4491665.html" target="_blank">Implement Trie (Prefix Tree)</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/103004/c-clean-code">https://discuss.leetcode.com/topic/103004/c-clean-code</a></p>
<p><a href="https://discuss.leetcode.com/topic/102992/easy-14-lines-java-solution-hashmap">https://discuss.leetcode.com/topic/102992/easy-14-lines-java-solution-hashmap</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-09-29 21:52</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7612918" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7612918);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/8379506.html" id="cb_post_title_url">[LeetCode] Cut Off Trees for Golf Event 为高尔夫赛事砍树</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="question-description">
<div>
<p>You are asked to cut off trees in a forest for a golf event. The forest is represented as a non-negative 2D map, in this map:</p>
<ol>
<li><code>0</code> represents the <code>obstacle</code> can't be reached.</li>
<li><code>1</code> represents the <code>ground</code> can be walked through.</li>
<li><code>The place with number bigger than 1</code> represents a <code>tree</code> can be walked through, and this positive number represents the tree's height.</li>
</ol>
<p> </p>
<p>You are asked to cut off all the trees in this forest in the order of tree's height - always cut off the tree with lowest height first. And after cutting, the original place has the tree will become a grass (value 1).</p>
<p>You will start from the point (0, 0) and you should output the minimum steps you need to walk to cut off all the trees. If you can't cut off all the trees, output -1 in that situation.</p>
<p>You are guaranteed that no two <code>trees</code> have the same height and there is at least one tree needs to be cut off.</p>
<p>Example 1:</p>
<pre>Input: 
[
 [1,2,3],
 [0,0,4],
 [7,6,5]
]
Output: 6
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input: 
[
 [1,2,3],
 [0,0,0],
 [7,6,5]
]
Output: -1
</pre>
<p> </p>
<p>Example 3:</p>
<pre>Input: 
[
 [2,3,4],
 [0,0,5],
 [8,7,6]
]
Output: 6
Explanation: You started from the point (0,0) and you can cut off the tree in (0,0) directly without walking.
</pre>
<p> </p>
<p>Hint: size of the given matrix will not exceed 50x50.</p>
<p> </p>
</div>
</div>
<p>这道题让我们砍掉所有高度大于1的树，而且要求是按顺序从低到高来砍，那么本质实际上还是要求任意两点之间的最短距离啊。对于这种类似迷宫遍历求最短路径的题，BFS是不二之选啊。那么这道题就对高度相邻的两棵树之间调用一个BFS，所以我们可以把BFS的内容放倒子函数helper中来使用。那么我们首先就要将所有的树从低到高进行排序，我们遍历原二位矩阵，将每棵树的高度及其横纵坐标取出来，组成一个三元组，然后放到vector中，之后用sort对数组进行排序，因为sort默认是以第一个数字排序，这也是为啥我们要把高度放在第一个位置。然后我们就遍历我们的trees数组，我们的起始位置是（0，0），终点位置是从trees数组中取出的树的位置，然后调用BFS的helper函数，这个BFS的子函数就是很基本的写法，没啥过多需要讲解的地方，会返回最短路径的值，如果无法到达目标点，就返回-1。所以我们先检查，如果helper函数返回-1了，那么我们就直接返回-1，否则就将cnt加到结果res中。然后更新我们的起始点为当前树的位置，然后循环取下一棵树即可，参见代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> cutOffTree(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> forest) {
        </span><span style="color: #0000ff;">int</span> m = forest.size(), n = forest[<span style="color: #800080;">0</span>].size(), res = <span style="color: #800080;">0</span>, row = <span style="color: #800080;">0</span>, col = <span style="color: #800080;">0</span><span style="color: #000000;">;
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;<span style="color: #000000;"> trees;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; m; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; n; ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> (forest[i][j] &gt; <span style="color: #800080;">1</span><span style="color: #000000;">) trees.push_back({forest[i][j], i, j});
            }
        }
        sort(trees.begin(), trees.end());
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; trees.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">int</span> cnt = helper(forest, row, col, trees[i][<span style="color: #800080;">1</span>], trees[i][<span style="color: #800080;">2</span><span style="color: #000000;">]);
            </span><span style="color: #0000ff;">if</span> (cnt == -<span style="color: #800080;">1</span>) <span style="color: #0000ff;">return</span> -<span style="color: #800080;">1</span><span style="color: #000000;">;
            res </span>+=<span style="color: #000000;"> cnt;
            row </span>= trees[i][<span style="color: #800080;">1</span><span style="color: #000000;">];
            col </span>= trees[i][<span style="color: #800080;">2</span><span style="color: #000000;">];
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">int</span> helper(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp; forest, <span style="color: #0000ff;">int</span> row, <span style="color: #0000ff;">int</span> col, <span style="color: #0000ff;">int</span> treeRow, <span style="color: #0000ff;">int</span><span style="color: #000000;"> treeCol) {
        </span><span style="color: #0000ff;">if</span> (row == treeRow &amp;&amp; col == treeCol) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> m = forest.size(), n = forest[<span style="color: #800080;">0</span>].size(), cnt = <span style="color: #800080;">0</span><span style="color: #000000;">;
        queue</span>&lt;pair&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;&gt;<span style="color: #000000;"> q{{{row, col}}};
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">bool</span>&gt;&gt; visited(m, vector&lt;<span style="color: #0000ff;">bool</span>&gt;(n, <span style="color: #0000ff;">false</span><span style="color: #000000;">));
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; dirs{{-<span style="color: #800080;">1</span>,<span style="color: #800080;">0</span>},{<span style="color: #800080;">0</span>,<span style="color: #800080;">1</span>},{<span style="color: #800080;">1</span>,<span style="color: #800080;">0</span>},{<span style="color: #800080;">0</span>,-<span style="color: #800080;">1</span><span style="color: #000000;">}};
        </span><span style="color: #0000ff;">while</span> (!<span style="color: #000000;">q.empty()) {
            </span>++<span style="color: #000000;">cnt;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = q.size() - <span style="color: #800080;">1</span>; i &gt;= <span style="color: #800080;">0</span>; --<span style="color: #000000;">i) {
                auto t </span>=<span style="color: #000000;"> q.front(); q.pop();
                </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto dir : dirs) {
                    </span><span style="color: #0000ff;">int</span> x = t.first + dir[<span style="color: #800080;">0</span>], y = t.second + dir[<span style="color: #800080;">1</span><span style="color: #000000;">];
                    </span><span style="color: #0000ff;">if</span> (x &lt; <span style="color: #800080;">0</span> || x &gt;= m || y &lt; <span style="color: #800080;">0</span> || y &gt;= n || visited[x][y] || forest[x][y] == <span style="color: #800080;">0</span>) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">if</span> (x == treeRow &amp;&amp; y == treeCol) <span style="color: #0000ff;">return</span><span style="color: #000000;"> cnt;
                    visited[x][y] </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                    q.push({x, y});
                }
            }
        }
        </span><span style="color: #0000ff;">return</span> -<span style="color: #800080;">1</span><span style="color: #000000;">;
    }
}; </span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/102973/c-sort-bfs-with-explanation">https://discuss.leetcode.com/topic/102973/c-sort-bfs-with-explanation</a></p>
<p><a href="https://discuss.leetcode.com/topic/103052/java-solution-priorityqueue-bfs">https://discuss.leetcode.com/topic/103052/java-solution-priorityqueue-bfs</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-01-29 21:13</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=8379506" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(8379506);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7608976.html" id="cb_post_title_url">[LeetCode] Longest Continuous Increasing Subsequence 最长连续递增序列</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given an unsorted array of integers, find the length of longest <code>continuous</code> increasing subsequence.</p>
<p>Example 1:</p>
<pre>Input: [1,3,5,4,7]
Output: 3
Explanation: The longest continuous increasing subsequence is [1,3,5], its length is 3. 
Even though [1,3,5,7] is also an increasing subsequence, it's not a continuous one where 5 and 7 are separated by 4. 
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input: [2,2,2,2,2]
Output: 1
Explanation: The longest continuous increasing subsequence is [2], its length is 1. 
</pre>
<p> </p>
<p>Note: Length of the array will not exceed 10,000.</p>
<p> </p>
<p>这道题让我们求一个数组的最长连续递增序列，由于有了连续这个条件，跟之前那道<a href="http://www.cnblogs.com/grandyang/p/7603903.html">Number of Longest Increasing Subsequence</a>比起来，其实难度就降低了很多。我们可以使用一个计数器，如果遇到大的数字，计数器自增1；如果是一个小的数字，则计数器重置为1。我们用一个变量cur来表示前一个数字，初始化为整型最大值，当前遍历到的数字num就和cur比较就行了，每次用cnt来更新结果res，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> findLengthOfLCIS(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, cnt = <span style="color: #800080;">0</span>, cur =<span style="color: #000000;"> INT_MAX;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span><span style="color: #000000;"> num : nums) {
            </span><span style="color: #0000ff;">if</span> (num &gt; cur) ++<span style="color: #000000;">cnt;
            </span><span style="color: #0000ff;">else</span> cnt = <span style="color: #800080;">1</span><span style="color: #000000;">;
            res </span>=<span style="color: #000000;"> max(res, cnt);
            cur </span>=<span style="color: #000000;"> num;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种方法的思路和上面的解法一样，每次都和前面一个数字来比较，注意处理无法取到钱一个数字的情况，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> findLengthOfLCIS(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, cnt = <span style="color: #800080;">0</span>, n =<span style="color: #000000;"> nums.size();
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (i == <span style="color: #800080;">0</span> || nums[i - <span style="color: #800080;">1</span>] &lt; nums[i]) res = max(res, ++<span style="color: #000000;">cnt);
            </span><span style="color: #0000ff;">else</span> cnt = <span style="color: #800080;">1</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/7603903.html">Number of Longest Increasing Subsequence</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/102999/java-c-clean-solution">https://discuss.leetcode.com/topic/102999/java-c-clean-solution</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-09-28 22:30</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7608976" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7608976);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7603903.html" id="cb_post_title_url">[LeetCode] Number of Longest Increasing Subsequence 最长递增序列的个数</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="question-description">
<p>Given an unsorted array of integers, find the number of longest increasing subsequence.</p>
<p>Example 1:</p>
<pre>Input: [1,3,5,4,7]
Output: 2
Explanation: The two longest increasing subsequence are [1, 3, 4, 7] and [1, 3, 5, 7].
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input: [2,2,2,2,2]
Output: 5
Explanation: The length of longest continuous increasing subsequence is 1, and there are 5 subsequences' length is 1, so output 5.
</pre>
<p> </p>
<p>Note: Length of the given array will be not exceed 2000 and the answer is guaranteed to be fit in 32-bit signed int.</p>
<p> </p>
<p>这道题给了我们一个数组，让我们求最长递增序列的个数，题目中的两个例子也很好的说明了问题。那么对于这种求个数的问题，直觉告诉我们应该要使用DP来做。其实这道题在设计DP数组的时候有个坑，如果我们将dp[i]定义为到i位置的最长子序列的个数的话，那么递推公式不好找。但是如果我们将dp[i]定义为以nums[i]为结尾的递推序列的个数的话，再配上这些递推序列的长度，将会比较容易的发现递推关系。这里我们用len[i]表示以nums[i]为结尾的递推序列的长度，用cnt[i]表示以nums[i]为结尾的递推序列的个数，初始化都赋值为1，只要有数字，那么至少都是1。然后我们遍历数组，对于每个遍历到的数字nums[i]，我们再遍历其之前的所有数字nums[j]，当nums[i]小于等于nums[j]时，不做任何处理，因为不是递增序列。反之，则判断len[i]和len[j]的关系，如果len[i]等于len[j] + 1，说明nums[i]这个数字可以加在以nums[j]结尾的递增序列后面，并且以nums[j]结尾的递增序列个数可以直接加到以nums[i]结尾的递增序列个数上。如果len[i]小于len[j] + 1，说明我们找到了一条长度更长的递增序列，那么我们此时奖len[i]更新为len[j]+1，并且原本的递增序列都不能用了，直接用cnt[j]来代替。我们在更新完len[i]和cnt[i]之后，要更新mx和res，如果mx等于len[i]，则把cnt[i]加到res之上；如果mx小于len[i]，则更新mx为len[i]，更新结果res为cnt[i]，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> findNumberOfLIS(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, mx = <span style="color: #800080;">0</span>, n =<span style="color: #000000;"> nums.size();
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; len(n, <span style="color: #800080;">1</span>), cnt(n, <span style="color: #800080;">1</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; i; ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> (nums[i] &lt;= nums[j]) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">if</span> (len[i] == len[j] + <span style="color: #800080;">1</span>) cnt[i] +=<span style="color: #000000;"> cnt[j];
                </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (len[i] &lt; len[j] + <span style="color: #800080;">1</span><span style="color: #000000;">) {
                    len[i] </span>= len[j] + <span style="color: #800080;">1</span><span style="color: #000000;">;
                    cnt[i] </span>=<span style="color: #000000;"> cnt[j];
                }
            }
            </span><span style="color: #0000ff;">if</span> (mx == len[i]) res +=<span style="color: #000000;"> cnt[i];
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (mx &lt;<span style="color: #000000;"> len[i]) {
                mx </span>=<span style="color: #000000;"> len[i];
                res </span>=<span style="color: #000000;"> cnt[i];
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种方法跟上面的解法基本一样，就是把更新结果res放在了遍历完数组之后，我们利用mx来找到所有的cnt[i]，累加到结果res上，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> findNumberOfLIS(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, mx = <span style="color: #800080;">0</span>, n =<span style="color: #000000;"> nums.size();
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; len(n, <span style="color: #800080;">1</span>), cnt(n, <span style="color: #800080;">1</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; i; ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> (nums[i] &lt;= nums[j]) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">if</span> (len[i] == len[j] + <span style="color: #800080;">1</span>) cnt[i] +=<span style="color: #000000;"> cnt[j];
                </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (len[i] &lt; len[j] + <span style="color: #800080;">1</span><span style="color: #000000;">) {
                    len[i] </span>= len[j] + <span style="color: #800080;">1</span><span style="color: #000000;">;
                    cnt[i] </span>=<span style="color: #000000;"> cnt[j];
                }
            }
            mx </span>=<span style="color: #000000;"> max(mx, len[i]);
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (mx == len[i]) res +=<span style="color: #000000;"> cnt[i];
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4938187.html">Longest Increasing Subsequence</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/7608976.html">Longest Continuous Increasing Subsequence</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/102974/c-dp-with-explanation-o-n-2">https://discuss.leetcode.com/topic/102974/c-dp-with-explanation-o-n-2</a></p>
<p><a href="https://discuss.leetcode.com/topic/103020/java-c-simple-dp-solution-with-explanation">https://discuss.leetcode.com/topic/103020/java-c-simple-dp-solution-with-explanation</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p>
</div></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-09-27 21:06</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7603903" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7603903);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7595595.html" id="cb_post_title_url">[LeetCode] Bulb Switcher II 灯泡开关之二</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>There is a room with <code>n</code> lights which are turned on initially and 4 buttons on the wall. After performing exactly <code>m</code> unknown operations towards buttons, you need to return how many different kinds of status of the <code>n</code> lights could be.</p>
<p>Suppose <code>n</code> lights are labeled as number [1, 2, 3 ..., n], function of these 4 buttons are given below:</p>
<ol>
<li>Flip all the lights.</li>
<li>Flip lights with even numbers.</li>
<li>Flip lights with odd numbers.</li>
<li>Flip lights with (3k + 1) numbers, k = 0, 1, 2, ...</li>
</ol>
<p> </p>
<p>Example 1:</p>
<pre>Input: n = 1, m = 1.
Output: 2
Explanation: Status can be: [on], [off]
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input: n = 2, m = 1.
Output: 3
Explanation: Status can be: [on, off], [off, on], [off, off]
</pre>
<p> </p>
<p>Example 3:</p>
<pre>Input: n = 3, m = 1.
Output: 4
Explanation: Status can be: [off, on, off], [on, off, on], [off, off, off], [off, on, on].
</pre>
<p> </p>
<p>Note: <code>n</code> and <code>m</code> both fit in range [0, 1000].</p>
<p> </p>
<p>这道题是之前那道<a href="http://www.cnblogs.com/grandyang/p/5100098.html">Bulb Switcher</a>的拓展，但是关灯的方式改变了。现在有四种关灯方法，全关，关偶数灯，关奇数灯，关3k+1的灯。现在给我们n盏灯，允许m步操作，问我们总共能组成多少种不同的状态。博主开始想，题目没有让列出所有的情况，而只是让返回总个数。那么博主觉得应该不能用递归的暴力破解来做，一般都是用DP来做啊。可是想了半天也没想出递推公式，只得作罢。只好去参考大神们的做法，发现这道题的结果并不会是一个超大数，最多情况只有8种。转念一想，也是，如果结果是一个超大数，一般都会对一个超大数10e7来取余，而这道题并没有，所以是一个很大的hint，只不过博主没有get到。博主应该多列几种情况的，说不定就能找出规律。下面先来看一种暴力解法，首先我们先做一个小小的优化，我们来分析四种情况：</p>
<p>第一种情况：<strong><span style="color: #ff0000;">1</span></strong>，<strong><span style="color: #ff0000;">2</span></strong>，<strong><span style="color: #ff0000;">3</span></strong>，<strong><span style="color: #ff0000;">4</span></strong>，<strong><span style="color: #ff0000;">5</span></strong>，<strong><span style="color: #ff0000;">6</span></strong>，<span style="color: #ff0000;"><span style="color: #0000ff;"><strong>7</strong></span><span style="color: #000000;">，<span style="color: #0000ff;"><strong>8</strong></span>，<span style="color: #0000ff;"><strong>9</strong></span>，<span style="color: #0000ff;"><strong>10</strong></span>，<span style="color: #0000ff;"><strong>11</strong></span>，<span style="color: #0000ff;"><strong>12</strong></span>，<span style="color: #ff0000;"><strong>13</strong></span>，<span style="color: #ff0000;"><strong>14</strong></span>，<span style="color: #ff0000;"><strong>15</strong><span style="color: #000000;">，...</span></span></span></span></p>
<p>第二种情况：1，<span style="color: #ff0000;"><strong>2</strong></span>，3，<span style="color: #ff0000;"><strong>4</strong></span>，5，<span style="color: #ff0000;"><strong>6</strong></span>，7，<span style="color: #0000ff;"><strong>8</strong></span>，9，<span style="color: #0000ff;"><strong>10</strong></span>，11，<span style="color: #0000ff;"><strong>12</strong></span>，13，<span style="color: #ff0000;"><strong>14</strong></span>，15，...</p>
<p>第三种情况：<strong><span style="color: #ff0000;">1</span></strong>，2，<strong><span style="color: #ff0000;">3</span></strong>，4，<strong><span style="color: #ff0000;">5</span></strong>，6，<span style="color: #ff0000;"><span style="color: #0000ff;"><strong>7</strong></span><span style="color: #000000;">，8，<span style="color: #0000ff;"><strong>9</strong></span>，10，<span style="color: #0000ff;"><strong>11</strong></span>，12，<strong><span style="color: #ff0000;">13</span></strong>，14，<span style="color: #ff0000;"><strong>15</strong><span style="color: #000000;">，...</span></span></span></span></p>
<p>第四种情况：<span style="color: #ff0000;"><strong>1</strong></span>，2，3，<span style="color: #ff0000;"><strong>4</strong></span>，5，6，<span style="color: #ff0000;"><span style="color: #0000ff;"><strong>7</strong></span><span style="color: #000000;">，8，9，<span style="color: #0000ff;"><strong>10</strong></span>，11，12，<strong><span style="color: #ff0000;">13</span></strong>，14，15，...</span></span></p>
<p>通过观察上面的数组，我们可以发现以6个为1组，都是重复的pattern，那么实际上我们可以把重复的pattern去掉而且并不会影响结果。如果n大于6，我们则对其取余再加上6，新的n跟使用原来的n会得到同样的结果，但这样降低了我们的计算量。</p>
<p>下面我们先来生成n个1，这里1表示灯亮，0表示灯灭，然后我们需要一个set来记录已经存在的状态，用一个queue来辅助我们的BFS运算。我们需要循环m次，因为要操作m次，每次开始循环之前，先统计出此时queue中数字的个数len，然后进行len次循环，这就像二叉树中的层序遍历，必须上一层的结点全部遍历完了才能进入下一层，当然，在每一层开始前，我们都需要情况集合s，这样每个操作之间才不会互相干扰。然后在每层的数字循环中，我们取出队首状态，然后分别调用四种方法，突然感觉，这很像迷宫遍历问题，上下左右四个方向，周围四个状态算出来，我们将不再集合set中的状态加入queue和集合set。当m次操作遍历完成后，队列queue中状态的个数即为所求，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> flipLights(<span style="color: #0000ff;">int</span> n, <span style="color: #0000ff;">int</span><span style="color: #000000;"> m) {
        n </span>== (n &lt;= <span style="color: #800080;">6</span>) ? n : (n % <span style="color: #800080;">6</span> + <span style="color: #800080;">6</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">int</span> start = (<span style="color: #800080;">1</span> &lt;&lt; n) - <span style="color: #800080;">1</span><span style="color: #000000;">;
        unordered_set</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> s;
        queue</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> q{{start}};
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; m; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">int</span> len =<span style="color: #000000;"> q.size();
            s.clear();
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> k = <span style="color: #800080;">0</span>; k &lt; len; ++<span style="color: #000000;">k) {
                </span><span style="color: #0000ff;">int</span> t =<span style="color: #000000;"> q.front(); q.pop();
                vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> next{flipAll(t, n), flipEven(t, n), flipOdd(t, n), flip3k1(t, n)};
                </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span><span style="color: #000000;"> num : next) {
                    </span><span style="color: #0000ff;">if</span> (s.count(num)) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                    q.push(num);
                    s.insert(num);
                }
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> q.size();
    }
    
    </span><span style="color: #0000ff;">int</span> flipAll(<span style="color: #0000ff;">int</span> t, <span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        </span><span style="color: #0000ff;">int</span> x = (<span style="color: #800080;">1</span> &lt;&lt; n) - <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span> t ^<span style="color: #000000;"> x;
    }
    
    </span><span style="color: #0000ff;">int</span> flipEven(<span style="color: #0000ff;">int</span> t, <span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; i += <span style="color: #800080;">2</span><span style="color: #000000;">) {
            t </span>^= (<span style="color: #800080;">1</span> &lt;&lt;<span style="color: #000000;"> i);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> t;
    }
    
    </span><span style="color: #0000ff;">int</span> flipOdd(<span style="color: #0000ff;">int</span> t, <span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt; n; i += <span style="color: #800080;">2</span><span style="color: #000000;">) {
            t </span>^= (<span style="color: #800080;">1</span> &lt;&lt;<span style="color: #000000;"> i);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> t;
    }
    
    </span><span style="color: #0000ff;">int</span> flip3k1(<span style="color: #0000ff;">int</span> t, <span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; i += <span style="color: #800080;">3</span><span style="color: #000000;">) {
            t </span>^= (<span style="color: #800080;">1</span> &lt;&lt;<span style="color: #000000;"> i);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> t;
    }
};</span></pre>
</div>
<p> </p>
<p>上面那个方法虽然正确，但是有些复杂了，由于这道题最多只有8中情况，所以很适合分情况来讨论：</p>
<p>- 当m和n其中有任意一个数是0时，返回1</p>
<p>- 当n = 1时</p>
<p>只有两种情况，0和1</p>
<p>- 当n = 2时，</p>
<p>这时候要看m的次数，如果m = 1，那么有三种状态 00，01，10</p>
<p>当m &gt; 1时，那么有四种状态，00，01，10，11</p>
<p>- 当m = 1时，</p>
<p>此时n至少为3，那么我们有四种状态，000，010，101，011</p>
<p>- 当m = 2时，</p>
<p>此时n至少为3，我们有七种状态：111，101，010，100，000，001，110</p>
<p>- 当m &gt; 2时，</p>
<p>此时n至少为3，我们有八种状态：111，101，010，100，000，001，110，011</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> flipLights(<span style="color: #0000ff;">int</span> n, <span style="color: #0000ff;">int</span><span style="color: #000000;"> m) {
        </span><span style="color: #0000ff;">if</span> (n == <span style="color: #800080;">0</span> || m == <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span> <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (n == <span style="color: #800080;">1</span>) <span style="color: #0000ff;">return</span> <span style="color: #800080;">2</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (n == <span style="color: #800080;">2</span>) <span style="color: #0000ff;">return</span> m == <span style="color: #800080;">1</span> ? <span style="color: #800080;">3</span> : <span style="color: #800080;">4</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (m == <span style="color: #800080;">1</span>) <span style="color: #0000ff;">return</span> <span style="color: #800080;">4</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span> m == <span style="color: #800080;">2</span> ? <span style="color: #800080;">7</span> : <span style="color: #800080;">8</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种简洁到变态的方法是史蒂芬大神观察规律得到的，他自己也在<a href="https://discuss.leetcode.com/topic/102395/2-short-lines-simple-formula" target="_blank">帖子中</a>说不清为啥这样可以，但是就是叼，贴上来纯属娱乐吧～</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> flipLights(<span style="color: #0000ff;">int</span> n, <span style="color: #0000ff;">int</span><span style="color: #000000;"> m) {
        n </span>= min(n, <span style="color: #800080;">3</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">return</span> min(<span style="color: #800080;">1</span> &lt;&lt; n, <span style="color: #800080;">1</span> + m *<span style="color: #000000;"> n);
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/5100098.html">Bulb Switcher</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/102022/c-concise-code-o-1" target="_blank">https://discuss.leetcode.com/topic/102022/c-concise-code-o-1</a></p>
<p><a href="https://discuss.leetcode.com/topic/102395/2-short-lines-simple-formula" target="_blank">https://discuss.leetcode.com/topic/102395/2-short-lines-simple-formula</a></p>
<p><a href="https://discuss.leetcode.com/topic/102227/short-and-clean-java-o-1-solution" target="_blank">https://discuss.leetcode.com/topic/102227/short-and-clean-java-o-1-solution</a></p>
<p><a href="https://discuss.leetcode.com/topic/102107/easy-to-understand-java-bfs-solution-o-m" target="_blank">https://discuss.leetcode.com/topic/102107/easy-to-understand-java-bfs-solution-o-m</a></p>
<p> </p>
<p><a href="http://www.cnblogs.com/grandyang/p/4606334.html" target="_blank">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-09-26 10:53</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7595595" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7595595);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7590156.html" id="cb_post_title_url">[LeetCode] Second Minimum Node In a Binary Tree 二叉树中第二小的结点</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a non-empty special binary tree consisting of nodes with the non-negative value, where each node in this tree has exactly <code>two</code> or <code>zero</code> sub-node. If the node has two sub-nodes, then this node's value is the smaller value among its two sub-nodes.</p>
<p>Given such a binary tree, you need to output the second minimum value in the set made of all the nodes' value in the whole tree.</p>
<p>If no such second minimum value exists, output -1 instead.</p>
<p>Example 1:</p>
<pre>Input: 
    2
   / \
  2   5
     / \
    5   7

Output: 5
Explanation: The smallest value is 2, the second smallest value is 5.
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input: 
    2
   / \
  2   2

Output: -1
Explanation: The smallest value is 2, but there isn't any second smallest value.</pre>
<p> </p>
<p>这道题让我们找二叉树中的第二小的结点值，并且给该二叉树做了一些限制，比如对于任意一个结点，要么其没有子结点，要么就同时有两个子结点，而且父结点值是子结点值中较小的那个，当然两个子结点值可以相等。那么直接上暴力搜索呗，根据该树的附加条件可知，根结点一定是最小的结点值first，那么我们只要找出第二小的值second即可，初始化为整型的最大值。然后对根结点调用递归函数，将first和second当作参数传进去即可。在递归函数中，如果当前结点为空，直接返回，若当前结点孩值不等于first，说明其肯定比first要大，然后我们看其是否比second小，小的话就更新second，然后对当前结点的左右子结点分别调用递归函数即可，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> findSecondMinimumValue(TreeNode*<span style="color: #000000;"> root) {
        </span><span style="color: #0000ff;">int</span> first = root-&gt;val, second =<span style="color: #000000;"> INT_MAX;
        helper(root, first, second);
        </span><span style="color: #0000ff;">return</span> (second == first || second == INT_MAX) ? -<span style="color: #800080;">1</span><span style="color: #000000;"> : second;
    }
    </span><span style="color: #0000ff;">void</span> helper(TreeNode* node, <span style="color: #0000ff;">int</span>&amp; first, <span style="color: #0000ff;">int</span>&amp;<span style="color: #000000;"> second) {
        </span><span style="color: #0000ff;">if</span> (!node) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (node-&gt;val != first &amp;&amp; node-&gt;val &lt;<span style="color: #000000;"> second) {
            second </span>= node-&gt;<span style="color: #000000;">val;
        }
        helper(node</span>-&gt;<span style="color: #000000;">left, first, second);
        helper(node</span>-&gt;<span style="color: #000000;">right, first, second);
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种方法也是用递归来做的，不过现在递归函数有了返回值，在递归函数中，还是先判断当前结点是否为空，为空直接返回-1。然后就是看当前结点是否等于first，不等于直接返回当前结点值。如果等于，我们对其左右子结点分别调用递归函数，分别得到left和right。如果left和right其中有一个为-1了，我们取其中的较大值；如果left和right都不为-1，我们取其中的较小值返回即可，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> findSecondMinimumValue(TreeNode*<span style="color: #000000;"> root) {
        </span><span style="color: #0000ff;">return</span> helper(root, root-&gt;<span style="color: #000000;">val);
    }
    </span><span style="color: #0000ff;">int</span> helper(TreeNode* node, <span style="color: #0000ff;">int</span><span style="color: #000000;"> first) {
        </span><span style="color: #0000ff;">if</span> (!node) <span style="color: #0000ff;">return</span> -<span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (node-&gt;val != first) <span style="color: #0000ff;">return</span> node-&gt;<span style="color: #000000;">val;
        </span><span style="color: #0000ff;">int</span> left = helper(node-&gt;left, first), right = helper(node-&gt;<span style="color: #000000;">right, first);
        </span><span style="color: #0000ff;">return</span> (left == -<span style="color: #800080;">1</span> || right == -<span style="color: #800080;">1</span>) ?<span style="color: #000000;"> max(left, right) : min(left, right);
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种递归方法更加简洁了，没有再使用专门的递归函数helper，而是对当前根结点判断其左子树是否存在，不存在就返回-1。题目中说了是非空树，所以根结点一定存在。然后我们比较如果左子结点值等于根结点值，我们则对其左子结点调用递归函数；否则left就等于其左子结点值。再比较如果右子结点值等于根结点值，则对其右子结点调用递归函数；否则right就等于其右子结点值。最后我们还是看如果left和right其中有一个为-1了，我们取其中的较大值；如果left和right都不为-1，我们取其中的较小值返回即可，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> findSecondMinimumValue(TreeNode*<span style="color: #000000;"> root) {
        </span><span style="color: #0000ff;">if</span> (!root-&gt;left) <span style="color: #0000ff;">return</span> -<span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> left = (root-&gt;left-&gt;val == root-&gt;val) ? findSecondMinimumValue(root-&gt;left) : root-&gt;left-&gt;<span style="color: #000000;">val;
        </span><span style="color: #0000ff;">int</span> right = (root-&gt;right-&gt;val == root-&gt;val) ? findSecondMinimumValue(root-&gt;right) : root-&gt;right-&gt;<span style="color: #000000;">val;
        </span><span style="color: #0000ff;">return</span> (left == -<span style="color: #800080;">1</span> || right == -<span style="color: #800080;">1</span>) ?<span style="color: #000000;"> max(left, right) : min(left, right);
    }
};</span></pre>
</div>
<p> </p>
<p>整了三种递归的解法，来看一种迭代的解法吧，用的是层序遍历，但还是用的解法一种的不停更新second的方法，参见代码如下：</p>
<p> </p>
<p>解法四：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> findSecondMinimumValue(TreeNode*<span style="color: #000000;"> root) {
        </span><span style="color: #0000ff;">int</span> first = root-&gt;val, second =<span style="color: #000000;"> INT_MAX;
        queue</span>&lt;TreeNode*&gt;<span style="color: #000000;"> q{{root}};
        </span><span style="color: #0000ff;">while</span> (!<span style="color: #000000;">q.empty()) {
            auto t </span>=<span style="color: #000000;"> q.front(); q.pop();
            </span><span style="color: #0000ff;">if</span> (t-&gt;val != first &amp;&amp; t-&gt;val &lt;<span style="color: #000000;"> second) {
                second </span>= t-&gt;<span style="color: #000000;">val;
            }
            </span><span style="color: #0000ff;">if</span> (t-&gt;left) q.push(t-&gt;<span style="color: #000000;">left);
            </span><span style="color: #0000ff;">if</span> (t-&gt;right) q.push(t-&gt;<span style="color: #000000;">right);
        }
        </span><span style="color: #0000ff;">return</span> (second == first || second == INT_MAX) ? -<span style="color: #800080;">1</span><span style="color: #000000;"> : second;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4620012.html">Kth Smallest Element in a BST</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/102277/java-4-lines">https://discuss.leetcode.com/topic/102277/java-4-lines</a></p>
<p><a href="https://discuss.leetcode.com/topic/102027/c-dfs-recursion">https://discuss.leetcode.com/topic/102027/c-dfs-recursion</a></p>
<p><a href="https://discuss.leetcode.com/topic/102035/bfs-acc-solution-java-and-c-code">https://discuss.leetcode.com/topic/102035/bfs-acc-solution-java-and-c-code</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-09-25 05:04</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7590156" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7590156);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7583875.html" id="cb_post_title_url">[LeetCode] Maximum Swap 最大置换</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a non-negative integer, you could swap two digits at most once to get the maximum valued number. Return the maximum valued number you could get.</p>
<p>Example 1:</p>
<pre>Input: 2736
Output: 7236
Explanation: Swap the number 2 and the number 7.
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input: 9973
Output: 9973
Explanation: No swap.
</pre>
<p> </p>
<p>Note:</p>
<ol>
<li>The given number is in the range [0, 108]</li>
</ol>
<p> </p>
<p>这道题给了我们一个数字，我们有一次机会可以置换该数字中的任意两位，让我们返回置换后的最大值，当然如果当前数字就是最大值，我们也可以选择不置换，直接返回原数。那么最简单粗暴的方法当然就是将所有可能的置换都进行一遍，然后更新结果res，取其中较大的数字，这样一定会得到置换后的最大数字，这里使用了整型数和字符串之间的相互转换，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> maximumSwap(<span style="color: #0000ff;">int</span><span style="color: #000000;"> num) {
        </span><span style="color: #0000ff;">string</span> str =<span style="color: #000000;"> to_string(num);
        </span><span style="color: #0000ff;">int</span> res = num, n =<span style="color: #000000;"> str.size();
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = i + <span style="color: #800080;">1</span>; j &lt; n; ++<span style="color: #000000;">j) {
                swap(str[i], str[j]);
                res </span>=<span style="color: #000000;"> max(res, stoi(str));
                swap(str[i], str[j]);
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种解法是一种更优解，思路是这样的，由于我们希望置换后的数字最大，那么肯定最好的高位上的小数字和低位上的大数字进行置换，比如题目汇总的例子1。而如果高位上的都是大数字，像例子2那样，很有可能就不需要置换。所以我们需要找到每个数字右边的最大数字(包括其自身)，这样我们再从高位像低位遍历，如果某一位上的数字小于其右边的最大数字，说明需要调换，由于最大数字可能不止出现一次，我们希望能跟较低位的数字置换，这样置换后的数字最大，所以我们就从低位向高位遍历来找那个最大的数字，找到后进行调换即可。比如对于1993这个数：</p>
<p>1 9 9 3</p>
<p>9 9 9 3  (back数组)</p>
<p><span style="color: #ff0000;"><strong>9</strong></span> 9 <span style="color: #ff0000;"><strong>1</strong></span> 3</p>
<p>我们建立好back数组后，从头遍历原数字，发现1比9小，于是从末尾往前找9，找到后一置换，就得到了9913。</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> maximumSwap(<span style="color: #0000ff;">int</span><span style="color: #000000;"> num) {
        </span><span style="color: #0000ff;">string</span> res = to_string(num), back =<span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = back.size() - <span style="color: #800080;">2</span>; i &gt;= <span style="color: #800080;">0</span>; --<span style="color: #000000;">i) {
            back[i] </span>= max(back[i], back[i + <span style="color: #800080;">1</span><span style="color: #000000;">]);
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; res.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (res[i] == back[i]) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = res.size() - <span style="color: #800080;">1</span>; j &gt; i; --<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> (res[j] ==<span style="color: #000000;"> back[i]) {
                    swap(res[i], res[j]);
                    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> stoi(res);
                }
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> stoi(res);
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种解法建了十个桶，分别代表数字0到9，每个桶存该数字出现的最后一个位置，也就是低位。这样我们从开头开始遍历数字上的每位上的数字，然后从大桶开始遍历，如果该大桶的数字对应的位置大于当前数字的位置，说明低位的数字要大于当前高位上的数字，那么直接交换这两个数字返回即可，其实核心思路跟上面的解法蛮像的，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> maximumSwap(<span style="color: #0000ff;">int</span><span style="color: #000000;"> num) {
        </span><span style="color: #0000ff;">string</span> str =<span style="color: #000000;"> to_string(num);
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; buckets(<span style="color: #800080;">10</span>, <span style="color: #800080;">0</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; str.size(); ++<span style="color: #000000;">i) {
            buckets[str[i] </span>- <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span>] =<span style="color: #000000;"> i;
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; str.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> k = <span style="color: #800080;">9</span>; k &gt; str[i] - <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span>; --<span style="color: #000000;">k) {
                </span><span style="color: #0000ff;">if</span> (buckets[k] &lt;= i) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                swap(str[i], str[buckets[k]]);
                </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> stoi(str);
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> num;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/5136749.html">Create Maximum Number</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/102052/simple-c-using-std-string-and-std-stoi">https://discuss.leetcode.com/topic/102052/simple-c-using-std-string-and-std-stoi</a></p>
<p><a href="https://discuss.leetcode.com/topic/102350/c-3ms-o-n-time-o-n-space-dp-solution">https://discuss.leetcode.com/topic/102350/c-3ms-o-n-time-o-n-space-dp-solution</a></p>
<p> </p>
<p><a href="http://www.cnblogs.com/grandyang/p/4606334.html" target="_blank">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-09-24 01:29</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7583875" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7583875);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7583185.html" id="cb_post_title_url">[LeetCode] Trim a Binary Search Tree 修剪一棵二叉搜索树</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a binary search tree and the lowest and highest boundaries as <code>L</code> and <code>R</code>, trim the tree so that all its elements lies in <code>[L, R]</code> (R &gt;= L). You might need to change the root of the tree, so the result should return the new root of the trimmed binary search tree.</p>
<p>Example 1:</p>
<pre>Input: 
    1
   / \
  0   2

  L = 1
  R = 2

Output: 
    1
      \
       2
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input: 
    3
   / \
  0   4
   \
    2
   /
  1

  L = 1
  R = 3

Output: 
      3
     / 
   2   
  /
 1</pre>
<p> </p>
<p>这道题让我们修剪一棵二叉搜索树，给了个边界范围[L, R], 所有不在这个范围内的结点应该被移除掉，但是仍需要保留二叉搜索树的性质，即左&lt;根&lt;右，有时候是小于等于。博主最开始的想法是先遍历一遍二叉树，将在返回内的结点值都放到一个数组后，遍历结束后再根据数组重建一棵二叉搜索树。这种方法会在某些test case上fail掉，可能会改变原来的二叉搜索树的结构，所以我们只能换一种思路。正确方法其实应该是在遍历的过程中就修改二叉树，移除不合题意的结点。当然对于二叉树的题，十有八九都是要用递归来解的。首先判断如果root为空，那么直接返回空即可。然后就是要看根结点是否在范围内，如果根结点值小于L，那么返回对其右子结点调用递归函数的值；如果根结点大于R，那么返回对其左子结点调用递归函数的值。如果根结点在范围内，将其左子结点更新为对其左子结点调用递归函数的返回值，同样，将其右子结点更新为对其右子结点调用递归函数的返回值。最后返回root即可，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    TreeNode</span>* trimBST(TreeNode* root, <span style="color: #0000ff;">int</span> L, <span style="color: #0000ff;">int</span><span style="color: #000000;"> R) {
        </span><span style="color: #0000ff;">if</span> (!root) <span style="color: #0000ff;">return</span><span style="color: #000000;"> NULL;
        </span><span style="color: #0000ff;">if</span> (root-&gt;val &lt; L) <span style="color: #0000ff;">return</span> trimBST(root-&gt;<span style="color: #000000;">right, L, R);
        </span><span style="color: #0000ff;">if</span> (root-&gt;val &gt; R) <span style="color: #0000ff;">return</span> trimBST(root-&gt;<span style="color: #000000;">left, L, R);
        root</span>-&gt;left = trimBST(root-&gt;<span style="color: #000000;">left, L, R);
        root</span>-&gt;right = trimBST(root-&gt;<span style="color: #000000;">right, L, R);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> root;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种方法是迭代的写法，虽然树的题一般都是用递归来写，简洁又美观。但是我们也可以强行用while来代替递归，比如下面这种写法：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    TreeNode</span>* trimBST(TreeNode* root, <span style="color: #0000ff;">int</span> L, <span style="color: #0000ff;">int</span><span style="color: #000000;"> R) {
        </span><span style="color: #0000ff;">if</span> (!root) <span style="color: #0000ff;">return</span><span style="color: #000000;"> NULL;
        </span><span style="color: #0000ff;">while</span> (root-&gt;val &lt; L || root-&gt;val &gt;<span style="color: #000000;"> R) {
            root </span>= (root-&gt;val &lt; L) ? root-&gt;right : root-&gt;<span style="color: #000000;">left;
        }
        TreeNode </span>*cur =<span style="color: #000000;"> root;
        </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> (cur) {
            </span><span style="color: #0000ff;">while</span> (cur-&gt;left &amp;&amp; cur-&gt;left-&gt;val &lt;<span style="color: #000000;"> L) {
                cur</span>-&gt;left = cur-&gt;left-&gt;<span style="color: #000000;">right;
            }
            cur </span>= cur-&gt;<span style="color: #000000;">left;
        }
        cur </span>=<span style="color: #000000;"> root;
        </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> (cur) {
            </span><span style="color: #0000ff;">while</span> (cur-&gt;right &amp;&amp; cur-&gt;right-&gt;val &gt;<span style="color: #000000;"> R) {
                cur</span>-&gt;right = cur-&gt;right-&gt;<span style="color: #000000;">left;
            }
            cur </span>= cur-&gt;<span style="color: #000000;">right;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> root;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/102034/java-solution-6-liner">https://discuss.leetcode.com/topic/102034/java-solution-6-liner</a></p>
<p><a href="https://discuss.leetcode.com/topic/104140/java-solution-iteration-version">https://discuss.leetcode.com/topic/104140/java-solution-iteration-version</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-09-23 22:18</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7583185" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7583185);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/8367505.html" id="cb_post_title_url">[LeetCode] Kth Smallest Number in Multiplication Table 乘法表中的第K小的数字</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="question-description">
<p>Nearly every one have used the <a href="https://en.wikipedia.org/wiki/Multiplication_table">Multiplication Table</a>. But could you find out the <code>k-th</code> smallest number quickly from the multiplication table?</p>
<p>Given the height <code>m</code> and the length <code>n</code> of a <code>m * n</code> Multiplication Table, and a positive integer <code>k</code>, you need to return the <code>k-th</code> smallest number in this table.</p>
<p>Example 1:</p>
<pre>Input: m = 3, n = 3, k = 5
Output: 
Explanation: 
The Multiplication Table:
1	2	3
2	4	6
3	6	9

The 5-th smallest number is 3 (1, 2, 2, 3, 3).
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input: m = 2, n = 3, k = 6
Output: 
Explanation: 
The Multiplication Table:
1	2	3
2	4	6

The 6-th smallest number is 6 (1, 2, 2, 3, 4, 6).
</pre>
<p> </p>
<p>Note:</p>
<ol>
<li>The <code>m</code> and <code>n</code> will be in the range [1, 30000].</li>
<li>The <code>k</code> will be in the range [1, m * n]</li>
</ol>
<p> </p>
</div>
<p>这道题跟之前那道<a href="http://www.cnblogs.com/grandyang/p/5727892.html">Kth Smallest Element in a Sorted Matrix</a>没有什么太大的区别，这里的乘法表也是各行各列分别有序的。那么之前帖子里的方法都可以拿来参考。之前帖子中的解法一在这道题中无法通过OJ，维护一个大小为k的优先队列实在是没有利用到这道题乘法表的特点，但是后两种解法都是可以的。为了快速定位出第K小的数字，我们采用二分搜索法，由于是有序矩阵，那么左上角的数字一定是最小的，而右下角的数字一定是最大的，所以这个是我们搜索的范围，然后我们算出中间数字mid，由于矩阵中不同行之间的元素并不是严格有序的，所以我们要在每一行都查找一下mid，由于乘法表每行都是连续数字1，2，3...乘以当前行号（从1开始计数），所以我们甚至不需要在每行中使用二分查找，而是直接定位出位置。具体做法是，先比较mid和该行最后一个数字的大小，最后一数字是n * i，i是行数，n是该行数字的个数，如果mid大的话，直接将该行所有数字的个数加入cnt，否则的话加上mid / i，比如当前行是2, 4, 6, 8, 10，如果我们要查找小于7的个数，那么就是7除以2，得3，就是有三个数小于7，直接加入cnt即可。这样我们就可以快速算出矩阵中所有小于mid的个数，根据cnt和k的大小关系，来更新我们的范围，循环推出后，left就是第K小的数字，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
 </span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
     </span><span style="color: #0000ff;">int</span> findKthNumber(<span style="color: #0000ff;">int</span> m, <span style="color: #0000ff;">int</span> n, <span style="color: #0000ff;">int</span><span style="color: #000000;"> k) {
         </span><span style="color: #0000ff;">int</span> left = <span style="color: #800080;">1</span>, right = m *<span style="color: #000000;"> n;
         </span><span style="color: #0000ff;">while</span> (left &lt;<span style="color: #000000;"> right) {
             </span><span style="color: #0000ff;">int</span> mid = left + (right - left) / <span style="color: #800080;">2</span>, cnt = <span style="color: #800080;">0</span><span style="color: #000000;">;
             </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt;= m; ++<span style="color: #000000;">i) {
                 cnt </span>+= (mid &gt; n * i) ? n : (mid /<span style="color: #000000;"> i);
             }
             </span><span style="color: #0000ff;">if</span> (cnt &lt; k) left = mid + <span style="color: #800080;">1</span><span style="color: #000000;">;
             </span><span style="color: #0000ff;">else</span> right =<span style="color: #000000;"> mid;
         }
         </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> right;
     }
 };</span></pre>
</div>
<p> </p>
<p>下面这种解法在统计小于mid的数字个数的方法上有些不同，并不是逐行来统计，而是从左下角的数字开始统计，如果该数字小于mid，说明该数字及上方所有数字都小于mid，cnt加上i个，然后向右移动一位继续比较。如果当前数字小于mid了，那么向上移动一位，直到横纵方向有一个越界停止，其他部分都和上面的解法相同，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
 </span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
     </span><span style="color: #0000ff;">int</span> findKthNumber(<span style="color: #0000ff;">int</span> m, <span style="color: #0000ff;">int</span> n, <span style="color: #0000ff;">int</span><span style="color: #000000;"> k) {
         </span><span style="color: #0000ff;">int</span> left = <span style="color: #800080;">1</span>, right = m *<span style="color: #000000;"> n;
         </span><span style="color: #0000ff;">while</span> (left &lt;<span style="color: #000000;"> right) {
             </span><span style="color: #0000ff;">int</span> mid = left + (right - left) / <span style="color: #800080;">2</span>, cnt = <span style="color: #800080;">0</span>, i = m, j = <span style="color: #800080;">1</span><span style="color: #000000;">;
             </span><span style="color: #0000ff;">while</span> (i &gt;= <span style="color: #800080;">1</span> &amp;&amp; j &lt;=<span style="color: #000000;"> n) {
                 </span><span style="color: #0000ff;">if</span> (i * j &lt;=<span style="color: #000000;"> mid) {
                     cnt </span>+=<span style="color: #000000;"> i;
                     </span>++<span style="color: #000000;">j;
                 } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                     </span>--<span style="color: #000000;">i;
                 }
             }
             </span><span style="color: #0000ff;">if</span> (cnt &lt; k) left = mid + <span style="color: #800080;">1</span><span style="color: #000000;">;
             </span><span style="color: #0000ff;">else</span> right =<span style="color: #000000;"> mid;
         }
         </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> right;
     }
 };</span></pre>
</div>
<p> </p>
<p>下面这种解法由网友bambu提供，是对解法二的优化，再快一点，使用除法来快速定位新的j值，然后迅速算出当前行的小于mid的数的个数，然后快速更新i的值，这比之前那种一次只加1或减1的方法要高效许多，感觉像是解法一和解法二的混合体，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
 </span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
     </span><span style="color: #0000ff;">int</span> findKthNumber(<span style="color: #0000ff;">int</span> m, <span style="color: #0000ff;">int</span> n, <span style="color: #0000ff;">int</span><span style="color: #000000;"> k) {
        </span><span style="color: #0000ff;">int</span> left = <span style="color: #800080;">1</span>, right = m *<span style="color: #000000;"> n;
        </span><span style="color: #0000ff;">while</span> (left &lt;<span style="color: #000000;"> right) {
            </span><span style="color: #0000ff;">int</span> mid = left + (right - left) / <span style="color: #800080;">2</span>, cnt = <span style="color: #800080;">0</span>, i = m, j = <span style="color: #800080;">1</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">while</span> (i &gt;= <span style="color: #800080;">1</span> &amp;&amp; j &lt;=<span style="color: #000000;"> n) {
                 </span><span style="color: #0000ff;">int</span> t =<span style="color: #000000;"> j;
                 j </span>= (mid &gt; n * i) ? n + <span style="color: #800080;">1</span> : (mid / i + <span style="color: #800080;">1</span><span style="color: #000000;">);
                 cnt </span>+= (j - t) *<span style="color: #000000;"> i;
                 i </span>= mid /<span style="color: #000000;"> j;
             }
            </span><span style="color: #0000ff;">if</span> (cnt &lt; k) left = mid + <span style="color: #800080;">1</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">else</span> right =<span style="color: #000000;"> mid;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> right;
     }
 };</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/5727892.html">Kth Smallest Element in a Sorted Matrix</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/8627783.html" target="_blank">Find K-th Smallest Pair Distance</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/101194/my-8-lines-c-solution">https://discuss.leetcode.com/topic/101194/my-8-lines-c-solution</a></p>
<p><a href="https://discuss.leetcode.com/topic/101132/java-solution-binary-search">https://discuss.leetcode.com/topic/101132/java-solution-binary-search</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-01-27 22:38</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=8367505" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(8367505);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7577878.html" id="cb_post_title_url">[LeetCode] Beautiful Arrangement II 优美排列之二</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="question-description">
<p>Given two integers <code>n</code> and <code>k</code>, you need to construct a list which contains <code>n</code> different positive integers ranging from <code>1</code> to <code>n</code> and obeys the following requirement: <br/>Suppose this list is [a1, a2, a3, ... , an], then the list [|a1 - a2|, |a2 - a3|, |a3 - a4|, ... , |an-1 - an|] has exactly <code>k</code> distinct integers.</p>
<p>If there are multiple answers, print any of them.</p>
<p>Example 1:</p>
<pre>Input: n = 3, k = 1
Output: [1, 2, 3]
Explanation: The [1, 2, 3] has three different positive integers ranging from 1 to 3, and the [1, 1] has exactly 1 distinct integer: 1.
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input: n = 3, k = 2
Output: [1, 3, 2]
Explanation: The [1, 3, 2] has three different positive integers ranging from 1 to 3, and the [2, 1] has exactly 2 distinct integers: 1 and 2.
</pre>
<p> </p>
<p>Note:</p>
<ol>
<li>The <code>n</code> and <code>k</code> are in the range 1 &lt;= k &lt; n &lt;= 104.</li>
</ol>
<p> </p>
<p>这道题虽然也叫优美排列，但是貌似跟之前那道<a href="http://www.cnblogs.com/grandyang/p/6533276.html">Beautiful Arrangement</a>的关系不太大。这道题给我们了一个数字n和一个数字k，让找出一种排列方式，使得1到n组成的数组中相邻两个数的差的绝对值正好有k种。给了k和n的关系为k&lt;n。那么我们首先来考虑，是否这种条件关系下，是否已定存在这种优美排列呢，我们用一个例子来分析，比如说当n=8，我们有数组：</p>
<p>1, 2, 3, 4, 5, 6, 7, 8</p>
<p>当我们这样有序排列的话，相邻两数的差的绝对值为1。我们想差的绝对值最大能为多少，应该是把1和8放到一起，为7。那么为了尽可能的产生不同的差的绝对值，我们在8后面需要放一个小数字，比如2，这样会产生差的绝对值6，同理，后面再跟一个大数，比如7，产生差的绝对值5，以此类推，我们得到下列数组：</p>
<p>1, 8, 2, 7, 3, 6, 4, 5</p>
<p>其差的绝对值为：7，6，5，4，3，2，1</p>
<p>共有7种，所以我们知道k最大为n-1，所以这样的排列一定会存在。我们的策略是，先按照这种最小最大数相邻的方法排列，没排一个，k自减1，当k减到1的时候，后面的排列方法只要按照生序的方法排列，就不会产生不同的差的绝对值，这种算法的时间复杂度是O(n)，属于比较高效的那种。我们使用两个指针，初始时分别指向1和n，然后分别从i和j取数加入结果res，每取一个数字k自减1，直到k减到1的时候，开始按升序取后面的数字，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; constructArray(<span style="color: #0000ff;">int</span> n, <span style="color: #0000ff;">int</span><span style="color: #000000;"> k) {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>, j =<span style="color: #000000;"> n;
        </span><span style="color: #0000ff;">while</span> (i &lt;=<span style="color: #000000;"> j) {
            </span><span style="color: #0000ff;">if</span> (k &gt; <span style="color: #800080;">1</span>) res.push_back(k-- % <span style="color: #800080;">2</span> ? i++ : j--<span style="color: #000000;">);
            </span><span style="color: #0000ff;">else</span> res.push_back(i++<span style="color: #000000;">);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种方法是把上面的if...else的语句用三元操作符合并成了一句，看起来更加简洁了一些。 </p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; constructArray(<span style="color: #0000ff;">int</span> n, <span style="color: #0000ff;">int</span><span style="color: #000000;"> k) {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>, j =<span style="color: #000000;"> n;
        </span><span style="color: #0000ff;">while</span> (i &lt;=<span style="color: #000000;"> j) {
            res.push_back(k </span>&gt; <span style="color: #800080;">1</span> ? (k-- % <span style="color: #800080;">2</span> ? i++ : j--) : i++<span style="color: #000000;">);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/6533276.html">Beautiful Arrangement</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/101113/c-java-clean-code-4-liner/2">https://discuss.leetcode.com/topic/101113/c-java-clean-code-4-liner</a></p>
</div>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-09-22 23:50</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7577878" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7577878);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7570954.html" id="cb_post_title_url">[LeetCode] Path Sum IV 二叉树的路径和之四</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>If the depth of a tree is smaller than <code>5</code>, then this tree can be represented by a list of three-digits integers.</p>
<p>For each integer in this list:</p>
<ol>
<li>The hundreds digit represents the depth <code>D</code> of this node, <code>1 &lt;= D &lt;= 4.</code></li>
<li>The tens digit represents the position <code>P</code> of this node in the level it belongs to, <code>1 &lt;= P &lt;= 8</code>. The position is the same as that in a full binary tree.</li>
<li>The units digit represents the value <code>V</code> of this node, <code>0 &lt;= V &lt;= 9.</code></li>
</ol>
<p> </p>
<p>Given a list of <code>ascending</code> three-digits integers representing a binary with the depth smaller than 5. You need to return the sum of all paths from the root towards the leaves.</p>
<p>Example 1:</p>
<pre>Input: [113, 215, 221]
Output: 12
Explanation: 
The tree that the list represents is:
    3
   / \
  5   1

The path sum is (3 + 5) + (3 + 1) = 12.
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input: [113, 221]
Output: 4
Explanation: 
The tree that the list represents is: 
    3
     \
      1

The path sum is (3 + 1) = 4.</pre>
<p> </p>
<p>这道题还是让我们求二叉树的路径之和，但是跟之前不同的是，树的存储方式比较特别，并没有专门的数结点，而是使用一个三位数字来存的，百位数是该结点的深度，十位上是该结点在某一层中的位置，个位数是该结点的结点值。为了求路径之和，我们肯定还是需要遍历树，但是由于没有树结点，所以我们可以用其他的数据结构代替。比如我们可以将每个结点的位置信息和结点值分离开，然后建立两者之间的映射。比如我们可以将百位数和十位数当作key，将个位数当作value，建立映射。由于题目中说了数组是有序的，所以首元素就是根结点，然后我们进行先序遍历即可。在递归函数中，我们先将深度和位置拆分出来，然后算出左右子结点的深度和位置的两位数，我们还要维护一个变量cur，用来保存当前路径之和。如果当前结点的左右子结点不存在，说明此时cur已经是一条完整的路径之和了，加到结果res中，直接返回。否则就是对存在的左右子结点调用递归函数即可，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> pathSum(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        </span><span style="color: #0000ff;">if</span> (nums.empty()) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        unordered_map</span>&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> m;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span><span style="color: #000000;"> num : nums) {
            m[num </span>/ <span style="color: #800080;">10</span>] = num % <span style="color: #800080;">10</span><span style="color: #000000;">;
        }
        helper(nums[</span><span style="color: #800080;">0</span>] / <span style="color: #800080;">10</span>, m, <span style="color: #800080;">0</span><span style="color: #000000;">, res);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">void</span> helper(<span style="color: #0000ff;">int</span> num, unordered_map&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;&amp; m, <span style="color: #0000ff;">int</span> cur, <span style="color: #0000ff;">int</span>&amp;<span style="color: #000000;"> res) {
        </span><span style="color: #0000ff;">int</span> level = num / <span style="color: #800080;">10</span>, pos = num % <span style="color: #800080;">10</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> left = (level + <span style="color: #800080;">1</span>) * <span style="color: #800080;">10</span> + <span style="color: #800080;">2</span> * pos - <span style="color: #800080;">1</span>, right = left + <span style="color: #800080;">1</span><span style="color: #000000;">;
        cur </span>+=<span style="color: #000000;"> m[num];
        </span><span style="color: #0000ff;">if</span> (!m.count(left) &amp;&amp; !<span style="color: #000000;">m.count(right)) {
            res </span>+=<span style="color: #000000;"> cur;
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (m.count(left)) helper(left, m, cur, res);
        </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (m.count(right)) helper(right, m, cur, res);
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种方法是迭代的形式，我们使用的层序遍历，与先序遍历不同的是，我们不能维护一个当前路径之和的变量，这样会重复计算结点值，而是在遍历每一层的结点时，加上其父结点的值，如果某一个结点没有子结点了，才将累加起来的结点值加到结果res中，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> pathSum(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        </span><span style="color: #0000ff;">if</span> (nums.empty()) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, cur = <span style="color: #800080;">0</span><span style="color: #000000;">;
        unordered_map</span>&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> m;
        queue</span>&lt;<span style="color: #0000ff;">int</span>&gt; q{{nums[<span style="color: #800080;">0</span>] / <span style="color: #800080;">10</span><span style="color: #000000;">}};
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span><span style="color: #000000;"> num : nums) {
            m[num </span>/ <span style="color: #800080;">10</span>] = num % <span style="color: #800080;">10</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">while</span> (!<span style="color: #000000;">q.empty()) {
            </span><span style="color: #0000ff;">int</span> t =<span style="color: #000000;"> q.front(); q.pop();
            </span><span style="color: #0000ff;">int</span> level = t / <span style="color: #800080;">10</span>, pos = t % <span style="color: #800080;">10</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">int</span> left = (level + <span style="color: #800080;">1</span>) * <span style="color: #800080;">10</span> + <span style="color: #800080;">2</span> * pos - <span style="color: #800080;">1</span>, right = left + <span style="color: #800080;">1</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> (!m.count(left) &amp;&amp; !<span style="color: #000000;">m.count(right)) {
                res </span>+=<span style="color: #000000;"> m[t];
            }
            </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (m.count(left)) {
                m[left] </span>+=<span style="color: #000000;"> m[t];
                q.push(left);
            }
            </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (m.count(right)) {
                m[right] </span>+=<span style="color: #000000;"> m[t];
                q.push(right);
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/6007336.html">Path Sum III</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4280120.html" target="_blank">Binary Tree Maximum Path Sum</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4042156.html" target="_blank">Path Sum II</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4036961.html" target="_blank">Path Sum</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/101111/java-solution-represent-tree-using-hashmap/2">https://discuss.leetcode.com/topic/101111/java-solution-represent-tree-using-hashmap</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-09-21 20:40</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7570954" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7570954);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7565424.html" id="cb_post_title_url">[LeetCode] Non-decreasing Array 非递减数列</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given an array with <code>n</code> integers, your task is to check if it could become non-decreasing by modifying at most <code>1</code>element.</p>
<p>We define an array is non-decreasing if <code>array[i] &lt;= array[i + 1]</code> holds for every <code>i</code> (1 &lt;= i &lt; n).</p>
<p>Example 1:</p>
<pre>Input: [4,2,3]
Output: True
Explanation: You could modify the first <code class="hljs lsl"><span class="hljs-number">4</span></code> to <code class="hljs lsl"><span class="hljs-number">1</span></code> to get a non-decreasing array.
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input: [4,2,1]
Output: False
Explanation: You can't get a non-decreasing array by modify at most one element.
</pre>
<p> </p>
<p>Note: The <code>n</code> belongs to [1, 10,000].</p>
<p> </p>
<p>这道题给了我们一个数组，说我们最多有1次修改某个数字的机会，问能不能将数组变为非递减数组。题目中给的例子太少，不能覆盖所有情况，我们再来看下面三个例子：</p>
<p><span style="color: #ff0000;"><strong>4</strong></span>，2，3</p>
<p>-1，<strong><span style="color: #ff0000;">4</span></strong>，2，3</p>
<p>2，3，3，<span style="color: #ff0000;"><strong>2</strong></span>，4</p>
<p>我们通过分析上面三个例子可以发现，当我们发现后面的数字小于前面的数字产生冲突后，有时候需要修改前面较大的数字(比如前两个例子需要修改4)，有时候却要修改后面较小的那个数字(比如前第三个例子需要修改2)，那么有什么内在规律吗？是有的，判断修改那个数字其实跟再前面一个数的大小有关系，首先如果再前面的数不存在，比如例子1，4前面没有数字了，我们直接修改前面的数字为当前的数字2即可。而当再前面的数字存在，并且小于当前数时，比如例子2，-1小于2，我们还是需要修改前面的数字4为当前数字2；如果再前面的数大于当前数，比如例子3，3大于2，我们需要修改当前数2为前面的数3。这是修改的情况，由于我们只有一次修改的机会，所以用一个变量cnt，初始化为1，修改数字后cnt自减1，当下次再需要修改时，如果cnt已经为0了，直接返回false。遍历结束后返回true，参见代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> checkPossibility(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        </span><span style="color: #0000ff;">int</span> cnt = <span style="color: #800080;">1</span>, n =<span style="color: #000000;"> nums.size();
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (nums[i] &lt; nums[i - <span style="color: #800080;">1</span><span style="color: #000000;">]) {
                </span><span style="color: #0000ff;">if</span> (cnt == <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">if</span> (i == <span style="color: #800080;">1</span> || nums[i] &gt;= nums[i - <span style="color: #800080;">2</span>]) nums[i - <span style="color: #800080;">1</span>] =<span style="color: #000000;"> nums[i];
                </span><span style="color: #0000ff;">else</span> nums[i] = nums[i - <span style="color: #800080;">1</span><span style="color: #000000;">];
                </span>--<span style="color: #000000;">cnt;
            } 
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/101144/java-c-simple-greedy-like-solution-with-explanation">https://discuss.leetcode.com/topic/101144/java-c-simple-greedy-like-solution-with-explanation</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-09-20 22:26</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7565424" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7565424);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/8319913.html" id="cb_post_title_url">[LeetCode] Strange Printer 奇怪的打印机</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="question-description">
<p>There is a strange printer with the following two special requirements:</p>
<ol>
<li>The printer can only print a sequence of the same character each time.</li>
<li>At each turn, the printer can print new characters starting from and ending at any places, and will cover the original existing characters.</li>
</ol>
<p> </p>
<p>Given a string consists of lower English letters only, your job is to count the minimum number of turns the printer needed in order to print it.</p>
<p>Example 1:</p>
<pre>Input: "aaabbb"
Output: 2
Explanation: Print "aaa" first and then print "bbb".
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input: "aba"
Output: 2
Explanation: Print "aaa" first and then print "b" from the second place of the string, which will cover the existing character 'a'.
</pre>
<p> </p>
<p>Hint: Length of the given string will not exceed 100.</p>
<p> </p>
<p>这道题说有一种奇怪的打印机每次只能打印一排相同的字符，然后可以在任意起点和终点位置之间打印新的字符，用来覆盖原有的字符。现在给了我们一个新的字符串，问我们需要几次可以正确的打印出来。题目中给了两个非常简单的例子，主要是帮助我们理解的。博主最开始想的方法是一种类似贪婪算法，先是找出出现次数最多的字符，然后算需要多少次变换能将所有其他字符都变成那个出现最多次的字符，结果fail了。然后又试了一种类似剥洋葱的方法，从首尾都分别找连续相同的字符，如果首尾字符相同，则两部分一起移去，否则就移去连续相同个数多的子序列，这种基于贪婪算法的解法还是fail了，所以这道题是典型的只能动态规划Dynamic Programming，而不能用贪婪算法Greedy Algorithm的题。这道题的解题思路跟之前那道<a href="http://www.cnblogs.com/grandyang/p/6850657.html">Remove Boxes</a>很相似，博主在那个帖子中做了详细的讲解，是根据fun4leetcode大神的帖子写的，大神的思路对解这道题也相当有帮助。其实这道题并没有之前那道<a href="http://www.cnblogs.com/grandyang/p/6850657.html">Remove Boxes</a>难，移除盒子的题有隐含的条件需要加到重现关系中，大大地增加了题目的难度，非常地难想出来，这道题没有隐含条件都是个Hard题，那道题妥妥应该是Super Hard。</p>
<p>好，话不多说，来分析这道题吧。思考的线索和思路很重要，不理解核心精髓，当背题侠是没用的，稍微变个形式又不会了，博主就经常是这样的-.-!!!。既然说了要用DP来做，先整个二维dp数组呗，其中dp[i][j]表示打印出字符串[i, j]范围内字符的最小步数，难点就是找递推公式啦。遇到乍看去没啥思路的题，博主一般会先从简单的例子开始，看能不能分析出规律，从而找到解题的线索。首先如果只有一个字符，比如字符串是"a"的话，那么直接一次打印出来就行了。如果字符串是"ab"的话，那么我们要么先打印出"aa"，再改成"ab"，或者先打印出"bb"，再改成"ab"。同理，如果字符串是"abc"的话，就需要三次打印。那么一个很明显的特征是，如果没有重复的字符，打印的次数就是字符的个数。燃鹅这题的难点就是要处理有相同字符的情况，比如字符串是"aba"的时候，我们先打"aaa"的话，两步就搞定了，如果先打"bbb"的话，就需要三步。我们再来看一个字符串"abcb"，我们知道需要需要三步，我们看如果把这个字符串分成两个部分"a"和"bcb"，它们分别的步数是1和2，加起来的3是整个的步数。而对于字符串"abba"，如果分成"a"和"bba"，它们分别的步数也是1和2，但是总步数却是2。这是因为分出的"a"和"bba"中的最后一个字符相同。对于字符串"abbac"，因为位置0上的a和位置3上的a相同，那么整个字符串的步数相当于"bb"和"ac"的步数之和，为3。那么分析到这，是不是有点眉目了？我们关心的是字符相等的地方，对于[i, j]范围的字符，我们从i+1位置上的字符开始遍历到j，如果和i位置上的字符相等，我们就以此位置为界，将[i+1, j]范围内的字符拆为两个部分，将二者的dp值加起来，和原dp值相比，取较小的那个。所以我们的递推式如下:</p>
<div class="cnblogs_code">
<pre>dp[i][j] = min(dp[i][j], dp[i + <span style="color: #800080;">1</span>][k - <span style="color: #800080;">1</span>] + dp[k][j]       (s[k] == s[i] and i + <span style="color: #800080;">1</span> &lt;= k &lt;= j)</pre>
</div>
<p>要注意一些初始化的值，dp[i][i]是1，因为一个字符嘛，打印1次，还是就是在遍历k之前，dp[i][j]初始化为 1 + dp[i + 1][j]，为啥呢，可以看成在[i + 1, j]的范围上多加了一个s[i]字符，最坏的情况就是加上的是一个不曾出现过的字符，步数顶多加1步，注意我们的i是从后往前遍历的，当然你可以从前往后遍历，参数对应好就行了，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> strangePrinter(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        </span><span style="color: #0000ff;">int</span> n =<span style="color: #000000;"> s.size();
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; dp(n, vector&lt;<span style="color: #0000ff;">int</span>&gt;(n, <span style="color: #800080;">0</span><span style="color: #000000;">));
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = n - <span style="color: #800080;">1</span>; i &gt;= <span style="color: #800080;">0</span>; --<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = i; j &lt; n; ++<span style="color: #000000;">j) {
                dp[i][j] </span>= (i == j) ? <span style="color: #800080;">1</span> : (<span style="color: #800080;">1</span> + dp[i + <span style="color: #800080;">1</span><span style="color: #000000;">][j]);
                </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> k = i + <span style="color: #800080;">1</span>; k &lt;= j; ++<span style="color: #000000;">k) {
                    </span><span style="color: #0000ff;">if</span> (s[k] == s[i]) dp[i][j] = min(dp[i][j], dp[i + <span style="color: #800080;">1</span>][k - <span style="color: #800080;">1</span>] +<span style="color: #000000;"> dp[k][j]);
                }
            }
        }
        </span><span style="color: #0000ff;">return</span> (n == <span style="color: #800080;">0</span>) ? <span style="color: #800080;">0</span> : dp[<span style="color: #800080;">0</span>][n - <span style="color: #800080;">1</span><span style="color: #000000;">];
    }
};</span></pre>
</div>
<p> </p>
<p>理解了上面的DP的方法，那么也可以用递归的形式来写，记忆数组memo就相当于dp数组，整个思路完全一样，参见代码如下： </p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> strangePrinter(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        </span><span style="color: #0000ff;">int</span> n =<span style="color: #000000;"> s.size();
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; memo(n, vector&lt;<span style="color: #0000ff;">int</span>&gt;(n, <span style="color: #800080;">0</span><span style="color: #000000;">));
        </span><span style="color: #0000ff;">return</span> helper(s, <span style="color: #800080;">0</span>, n - <span style="color: #800080;">1</span><span style="color: #000000;">, memo);
    }
    </span><span style="color: #0000ff;">int</span> helper(<span style="color: #0000ff;">string</span> s, <span style="color: #0000ff;">int</span> i, <span style="color: #0000ff;">int</span> j, vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> memo) {
        </span><span style="color: #0000ff;">if</span> (i &gt; j) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (memo[i][j]) <span style="color: #0000ff;">return</span><span style="color: #000000;"> memo[i][j];
        memo[i][j] </span>= helper(s, i + <span style="color: #800080;">1</span>, j, memo) + <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> k = i + <span style="color: #800080;">1</span>; k &lt;= j; ++<span style="color: #000000;">k) {
            </span><span style="color: #0000ff;">if</span> (s[k] ==<span style="color: #000000;"> s[i]) {
                memo[i][j] </span>= min(memo[i][j], helper(s, i + <span style="color: #800080;">1</span>, k - <span style="color: #800080;">1</span>, memo) +<span style="color: #000000;"> helper(s, k, j, memo));
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> memo[i][j];
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/6850657.html">Remove Boxes</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/5006441.html">Burst Balloons</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/6759881.html" target="_blank">Zuma Game</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/100137/java-solution-dp">https://discuss.leetcode.com/topic/100137/java-solution-dp</a></p>
<p><a href="https://discuss.leetcode.com/topic/100212/c-29ms-dp-solution">https://discuss.leetcode.com/topic/100212/c-29ms-dp-solution</a></p>
<p><a href="https://discuss.leetcode.com/topic/100135/java-o-n-3-short-dp-solution">https://discuss.leetcode.com/topic/100135/java-o-n-3-short-dp-solution</a></p>
<p> </p>
</div>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-01-20 09:44</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=8319913" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(8319913);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7550360.html" id="cb_post_title_url">[LeetCode] Equal Tree Partition 划分等价树</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a binary tree with <code>n</code> nodes, your task is to check if it's possible to partition the tree to two trees which have the equal sum of values after removing exactly one edge on the original tree.</p>
<p>Example 1:</p>
<pre>Input:     
    5
   / \
  10 10
    /  \
   2   3

Output: True
Explanation: 
    5
   / 
  10
      
Sum: 15

   10
  /  \
 2    3

Sum: 15
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input:     
    1
   / \
  2  10
    /  \
   2   20

Output: False
Explanation: You can't split the tree into two trees with equal sum after removing exactly one edge on the tree.</pre>
<p> </p>
<p>这道题让我们划分等价树，就是说当移除一条边后，被分成的两棵树的结点之和需要相等。那么通过观察题目中的例子我们可以发现，如果我们将每个结点的结点值变成其所有子结点的结点值之和再加上当前的结点值，那么对于例子1来说，根结点的结点值就变成了30，断开位置的结点就变成了15，那么我们就可以发现其实只要断开位置的结点值是根结点值的一半，就存在等价划分。所以这道题的难点就是更新每个结点的结点值，我们可以使用递归来做。博主最开始使用的是unordered_set，把更新后的每个结点值都存入集合中，但是对于test case: [0, 1, -1] 会fail, 仔细分析下这个case，发现更新后的根结点值还是0，而且0已经被存入集合了，而0除以2还是0，在集合中存在，会返回true，但其实这棵树是不能等价划分的。0的情况确实比较特殊，所以我们使用unordered_map，建立更新后的结点值和其出现次数之间的映射，这样只有map中0的个数大于1的时候，才返回true。这样完美的避开了根结点为0的陷阱，Perfect！参见代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> checkEqualTree(TreeNode*<span style="color: #000000;"> root) {
        unordered_map</span>&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> m;
        </span><span style="color: #0000ff;">int</span> sum =<span style="color: #000000;"> helper(root, m);
        </span><span style="color: #0000ff;">if</span> (sum == <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span> m[<span style="color: #800080;">0</span>] &gt; <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span> sum % <span style="color: #800080;">2</span> == <span style="color: #800080;">0</span> &amp;&amp; m.count(sum / <span style="color: #800080;">2</span><span style="color: #000000;">);
    }
    </span><span style="color: #0000ff;">int</span> helper(TreeNode* node, unordered_map&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> m) {
        </span><span style="color: #0000ff;">if</span> (!node) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> cur = node-&gt;val + helper(node-&gt;left, m) + helper(node-&gt;<span style="color: #000000;">right, m);
        </span>++<span style="color: #000000;">m[cur];
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> cur;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/100179/java-c-simple-solution-with-only-one-hashmap">https://discuss.leetcode.com/topic/100179/java-c-simple-solution-with-only-one-hashmap</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-09-19 10:14</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7550360" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7550360);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7538821.html" id="cb_post_title_url">[LeetCode] Maximum Width of Binary Tree 二叉树的最大宽度</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a binary tree, write a function to get the maximum width of the given tree. The width of a tree is the maximum width among all levels. The binary tree has the same structure as a full binary tree, but some nodes are null.</p>
<p>The width of one level is defined as the length between the end-nodes (the leftmost and right most non-null nodes in the level, where the <code>null</code> nodes between the end-nodes are also counted into the length calculation.</p>
<p>Example 1:</p>
<pre>Input: 

           1
         /   \
        3     2
       / \     \  
      5   3     9 

Output: 4
Explanation: The maximum width existing in the third level with the length 4 (5,3,null,9).
</pre>
<p>Example 2:</p>
<pre>Input: 

          1
         /  
        3    
       / \       
      5   3     

Output: 2
Explanation: The maximum width existing in the third level with the length 2 (5,3).
</pre>
<p>Example 3:</p>
<pre>Input: 

          1
         / \
        3   2 
       /        
      5      

Output: 2
Explanation: The maximum width existing in the second level with the length 2 (3,2).
</pre>
<p>Example 4:</p>
<pre>Input: 

          1
         / \
        3   2
       /     \  
      5       9 
     /         \
    6           7
Output: 8
Explanation:The maximum width existing in the fourth level with the length 8 (6,null,null,null,null,null,null,7).


</pre>
<p>Note: Answer will in the range of 32-bit signed integer.</p>
<p> </p>
<p>这道题让我们求二叉树的最大宽度，根据题目中的描述可知，这里的最大宽度不是满树的时候的最大宽度，如果是那样的话，肯定是最后一层的结点数最多。这里的最大宽度应该是两个存在的结点中间可容纳的总的结点个数，中间的结点可以为空。那么其实只要我们知道了每一层中最左边和最右边的结点的位置，我们就可以算出这一层的宽度了。所以这道题的关键就是要记录每一层中最左边结点的位置，我们知道对于一棵完美二叉树，如果根结点是深度1，那么每一层的结点数就是2*n-1，那么每个结点的位置就是[1, 2*n-1]中的一个，假设某个结点的位置是i，那么其左右子结点的位置可以直接算出来，为2*i和2*i+1，可以自行带例子检验。由于之前说过，我们需要保存每一层的最左结点的位置，那么我们使用一个数组start，由于数组是从0开始的，我们就姑且认定根结点的深度为0，不影响结果。我们从根结点进入，深度为0，位置为1，进入递归函数。</p>
<p>首先判断，如果当前结点为空，那么直接返回，然后判断如果当前深度大于start数组的长度，说明当前到了新的一层的最左结点，我们将当前位置存入start数组中。然后我们用idx - start[h] + 1来更新结果res。这里idx是当前结点的位置，start[h]是当前层最左结点的位置。然后对左右子结点分别调用递归函数，注意左右子结点的位置可以直接计算出来，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> widthOfBinaryTree(TreeNode*<span style="color: #000000;"> root) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> start;
        helper(root, </span><span style="color: #800080;">0</span>, <span style="color: #800080;">1</span><span style="color: #000000;">, start, res);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">void</span> helper(TreeNode* node, <span style="color: #0000ff;">int</span> h, <span style="color: #0000ff;">int</span> idx, vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; start, <span style="color: #0000ff;">int</span>&amp;<span style="color: #000000;"> res) {
        </span><span style="color: #0000ff;">if</span> (!node) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (h &gt;=<span style="color: #000000;"> start.size()) start.push_back(idx);
        res </span>= max(res, idx - start[h] + <span style="color: #800080;">1</span><span style="color: #000000;">);
        helper(node</span>-&gt;left, h + <span style="color: #800080;">1</span>, idx * <span style="color: #800080;">2</span><span style="color: #000000;">, start, res);
        helper(node</span>-&gt;right, h + <span style="color: #800080;">1</span>, idx * <span style="color: #800080;">2</span> + <span style="color: #800080;">1</span><span style="color: #000000;">, start, res);
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种解法还是递归，比上面的解法稍微简洁一些，没有用结果res变量，而是递归函数直接返回最大宽度了，但是解题思路没有啥区别，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> widthOfBinaryTree(TreeNode*<span style="color: #000000;"> root) {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> start;
        </span><span style="color: #0000ff;">return</span> helper(root, <span style="color: #800080;">0</span>, <span style="color: #800080;">1</span><span style="color: #000000;">, start);
    }
    </span><span style="color: #0000ff;">int</span> helper(TreeNode* node, <span style="color: #0000ff;">int</span> h, <span style="color: #0000ff;">int</span> idx, vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> start) {
        </span><span style="color: #0000ff;">if</span> (!node) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (h &gt;=<span style="color: #000000;"> start.size()) start.push_back(idx);
        </span><span style="color: #0000ff;">return</span> max({idx - start[h] + <span style="color: #800080;">1</span>, helper(node-&gt;left, h + <span style="color: #800080;">1</span>, idx * <span style="color: #800080;">2</span>, start), helper(node-&gt;right, h + <span style="color: #800080;">1</span>, idx * <span style="color: #800080;">2</span> + <span style="color: #800080;">1</span><span style="color: #000000;">, start)});
    }
};</span></pre>
</div>
<p> </p>
<p>下面这个解法用的是层序遍历，迭代的方法来写的，注意这里使用了队列queue来辅助运算，queue里存的是一个pair，结点和其当前位置，在进入新一层的循环时，首先将首结点的位置保存出来当作最左位置，然后对于遍历到的结点，都更新右结点的位置，遍历一层的结点后来计算宽度更新结果res，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> widthOfBinaryTree(TreeNode*<span style="color: #000000;"> root) {
        </span><span style="color: #0000ff;">if</span> (!root) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        queue</span>&lt;pair&lt;TreeNode*,<span style="color: #0000ff;">int</span>&gt;&gt;<span style="color: #000000;"> q;
        q.push({root, </span><span style="color: #800080;">1</span><span style="color: #000000;">});
        </span><span style="color: #0000ff;">while</span> (!<span style="color: #000000;">q.empty()) {
            </span><span style="color: #0000ff;">int</span> left = q.front().second, right = left, n =<span style="color: #000000;"> q.size();
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
                auto t </span>=<span style="color: #000000;"> q.front().first; 
                right </span>=<span style="color: #000000;"> q.front().second; q.pop();
                </span><span style="color: #0000ff;">if</span> (t-&gt;left) q.push({t-&gt;left, right * <span style="color: #800080;">2</span><span style="color: #000000;">});
                </span><span style="color: #0000ff;">if</span> (t-&gt;right) q.push({t-&gt;right, right * <span style="color: #800080;">2</span> + <span style="color: #800080;">1</span><span style="color: #000000;">});
            }
            res </span>= max(res, right - left + <span style="color: #800080;">1</span><span style="color: #000000;">);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/100145/java-c-very-simple-dfs-solution">https://discuss.leetcode.com/topic/100145/java-c-very-simple-dfs-solution</a></p>
<p><a href="https://discuss.leetcode.com/topic/100149/c-java-bfs-dfs-3liner-clean-code-with-explanation">https://discuss.leetcode.com/topic/100149/c-java-bfs-dfs-3liner-clean-code-with-explanation</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-09-18 00:05</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7538821" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7538821);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7535354.html" id="cb_post_title_url">[LeetCode] Image Smoother 图片平滑器</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a 2D integer matrix M representing the gray scale of an image, you need to design a smoother to make the gray scale of each cell becomes the average gray scale (rounding down) of all the 8 surrounding cells and itself. If a cell has less than 8 surrounding cells, then use as many as you can.</p>
<p>Example 1:</p>
<pre>Input:
[[1,1,1],
 [1,0,1],
 [1,1,1]]
Output:
[[0, 0, 0],
 [0, 0, 0],
 [0, 0, 0]]
Explanation:
For the point (0,0), (0,2), (2,0), (2,2): floor(3/4) = floor(0.75) = 0
For the point (0,1), (1,0), (1,2), (2,1): floor(5/6) = floor(0.83333333) = 0
For the point (1,1): floor(8/9) = floor(0.88888889) = 0
</pre>
<p> </p>
<p>Note:</p>
<ol>
<li>The value in the given matrix is in the range of [0, 255].</li>
<li>The length and width of the given matrix are in the range of [1, 150].</li>
</ol>
<p> </p>
<p>这道题让我们给一个图片进行平滑处理，博主其实还是有一些图像处理的背景的，一般来说都是用算子来跟图片进行卷积，但是由于这道题只是个Easy的题目，我们直接用土办法就能解了，就直接对于每一个点统计其周围点的个数，然后累加像素值，做个除法就行了，注意边界情况的处理，参见代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; imageSmoother(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> M) {
        </span><span style="color: #0000ff;">if</span> (M.empty() || M[<span style="color: #800080;">0</span>].empty()) <span style="color: #0000ff;">return</span><span style="color: #000000;"> {};
        </span><span style="color: #0000ff;">int</span> m = M.size(), n = M[<span style="color: #800080;">0</span><span style="color: #000000;">].size();
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; res = M, dirs{{<span style="color: #800080;">0</span>,-<span style="color: #800080;">1</span>},{-<span style="color: #800080;">1</span>,-<span style="color: #800080;">1</span>},{-<span style="color: #800080;">1</span>,<span style="color: #800080;">0</span>},{-<span style="color: #800080;">1</span>,<span style="color: #800080;">1</span>},{<span style="color: #800080;">0</span>,<span style="color: #800080;">1</span>},{<span style="color: #800080;">1</span>,<span style="color: #800080;">1</span>},{<span style="color: #800080;">1</span>,<span style="color: #800080;">0</span>},{<span style="color: #800080;">1</span>,-<span style="color: #800080;">1</span><span style="color: #000000;">}};
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; m; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; n; ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">int</span> cnt = M[i][j], all = <span style="color: #800080;">1</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto dir : dirs) {
                    </span><span style="color: #0000ff;">int</span> x = i + dir[<span style="color: #800080;">0</span>], y = j + dir[<span style="color: #800080;">1</span><span style="color: #000000;">];
                    </span><span style="color: #0000ff;">if</span> (x &lt; <span style="color: #800080;">0</span> || x &gt;= m || y &lt; <span style="color: #800080;">0</span> || y &gt;= n) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                    </span>++<span style="color: #000000;">all;
                    cnt </span>+=<span style="color: #000000;"> M[x][y];
                }
                res[i][j] </span>= cnt /<span style="color: #000000;"> all;
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-09-17 13:38</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7535354" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7535354);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/8261714.html" id="cb_post_title_url">[LeetCode] Remove 9 移除9</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="question-description">
<div>
<p>Start from integer 1, remove any integer that contains 9 such as 9, 19, 29...</p>
<p>So now, you will have a new integer sequence: 1, 2, 3, 4, 5, 6, 7, 8, 10, 11, ...</p>
<p>Given a positive integer <code>n</code>, you need to return the n-th integer after removing. Note that 1 will be the first integer.</p>
<p><strong>Example 1:</strong><br/>
</p>
<pre><strong>Input:</strong> 9
<strong>Output:</strong> 10
</pre>
<p><strong> Hint</strong>: n will not exceed <code>9 x 10^8</code>.</p>
</div>
</div>
<p> </p>
<p>这道题让我们移除所有包含数字9的数字，然后得到一个新的数列，给我们一个数字n，让我们求在这个新的数组中第n个数字。我们多写些数字来看看：</p>
<p>0，1，2，3，4，5，6，7，8 （移除了9）</p>
<p>10，11，12，13，14，15，16，17，18 （移除了19）</p>
<p>.....</p>
<p>80，81，82，83，84，85，86，87，88 （移除了89）</p>
<p>（移除了 90 - 99 ）</p>
<p>100，101，102，103，104，105，106，107，108 （移除了109）</p>
<p>我们可以发现，8的下一位就是10了，18的下一位是20，88的下一位是100，实际上这就是九进制的数字的规律，那么这道题就变成了将十进制数n转为九进制数，这个就没啥难度了，就每次对9取余，然后乘以base，n每次自除以9，base每次扩大10倍，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
   </span><span style="color: #0000ff;">int</span> newInteger(<span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, <span style="color: #0000ff;">base</span> = <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (n &gt; <span style="color: #800080;">0</span><span style="color: #000000;">) {
            res </span>+= n % <span style="color: #800080;">9</span> * <span style="color: #0000ff;">base</span><span style="color: #000000;">;
            n </span>/= <span style="color: #800080;">9</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">base</span> *= <span style="color: #800080;">10</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
   }
};</span></pre>
</div>
<p> </p>
<p>我们也可以写的更简洁一些，不用base变量，将结果res先当作字符串来处理，最后再转回整型数，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
   </span><span style="color: #0000ff;">int</span> newInteger(<span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        </span><span style="color: #0000ff;">string</span> res = <span style="color: #800000;">""</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (n &gt; <span style="color: #800080;">0</span><span style="color: #000000;">) {
            res </span>= to_string(n % <span style="color: #800080;">9</span>) +<span style="color: #000000;"> res;
            n </span>/= <span style="color: #800080;">9</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> stoi(res);
   }
};</span></pre>
</div>
<p> </p>
<p>将十进制数转为九进制只能算Easy的题目，既然这道题标记了Hard，我们就不应该只满足于此。因为数字9是个特例，可以用上面的巧妙的解法，但如果要移除1到8中间的任意一个呢？上面的方法就不好使了，我们还是要来看看通用的解法。又来读<a href="https://discuss.leetcode.com/topic/99481/alternative-solution-applicable-to-the-general-case" target="_blank">fun4LeetCode大神的paper</a>了，这次大神收着写的，不算太长，还是可以好好读一读的，首先我们知道，不管是移出那个数字，新数组中的第n个数字的值m，都是要大于n本身的，我们将多出的数的个数用f(1, m)表示，则有：</p>
<div class="cnblogs_code">
<pre>m - f(<span style="color: #800080;">1</span>, m) = n</pre>
</div>
<p>要求m的话，我们就要先求出 f(1, m) 的值，然后加上n的值，就能得到m了。这道题无法直接求出m的值，而是采用一种迭代逼近的方法来算m。最开始的时候，我们让m为n，先求 f(1, n) 的值，比如说结果为k，然后我们再算 f(1, n + k)的值，用得到的结果k'来更新k，再带入算 f(1, n + k)，直到 k == f(1, n + k) 为止，那么此时的 n + k 就是我们要求的m。</p>
<p>下面来看我们如何计算 f(1, m)，我们当然不可能遍历所有的数字，一位一位来查看有没有要移除的数字了，太不高效了。我们再来看看开头列举的前99个数字中移除9后剩下的数字，统计一下，总共去掉了19个包含9的数字。那我们想，如果前99个数字中要移除所有包含2的数字，会去掉多少个？其实还是19个，我们发现，前99个数字，不论去掉哪个数字，都会去掉19个数字。这是一个很重要的发现，我们再来看看这19个数是怎么分布的，首先每10个数都一定会包含一个要移除的数，比如要移除的是9，每10个数都会有一个9出现，而在90几那一行，10个数都会包含9，所以都要移除，那么我们可以总结出规律，非移除数开头的其他9行，各移除1个，移除数开头的10个都要移除，所以就有10+9=19个。好，那么这是前99个数的情况，那么前999个数又是什么情况呢？其实很类似，非移除数开头的9行各有19个，移除数开头的有10x19个，所以整个就是19x19个，所以19这个基数很重要。</p>
<p>好，下面来看看各位上的数字a跟要移除数d之间的关系。有三种关系，分别是小于，等于，大于：</p>
<p>1）当 a &lt; d 时，比如说我们要移除的数字是6，那么a就是1到5中的数，我们知道，每10个数中只含有一个6，所以就要移除a个6就行了，如果a在百位上，就是是a * 19个，然后再加上下一位上移除的值，用等式来写就是：</p>
<div class="cnblogs_code">
<pre>T(<span style="color: #800080;">1</span>, m) = a_i * (<span style="color: #800080;">10</span>^i - <span style="color: #800080;">9</span>^i) + T(<span style="color: #800080;">1</span>, m % <span style="color: #800080;">10</span>^i)</pre>
</div>
<p>2）当 a = d 时，那么a此时为6，如果a是十位上的数，那么前面[1, 59]中的5个6要先移除掉，然后此时下一位有多少个数移除多个数，还要加上1。比如m如果是63，那么60, 61, 62, 63这四个数要移除，怎么算的，通过m%10 + 1来计算，所以整个用等式来写就是：</p>
<div class="cnblogs_code">
<pre>T(<span style="color: #800080;">1</span>, m) = a_i * (<span style="color: #800080;">10</span>^i - <span style="color: #800080;">9</span>^i) + m % <span style="color: #800080;">10</span>^i + <span style="color: #800080;">1</span></pre>
</div>
<p>3）当 a &gt; d 时，比如此时a为8，要移除的数字还是6，那么[60, 69]这10个数都要移除，那么实际上还要再移除7个6，分别是[1,9], [10,19], [21,29], [31,39], [41,49], [51,59], [71,79] 这7个区间中的6，那么是怎么算的，通过a - 1来算，实际上是情况1的值再加上 10^i 个数，用等式来写就是：</p>
<div class="cnblogs_code">
<pre>T(<span style="color: #800080;">1</span>, m) = (a_i - <span style="color: #800080;">1</span>) * (<span style="color: #800080;">10</span>^i - <span style="color: #800080;">9</span>^i) + <span style="color: #800080;">10</span>^i + T(<span style="color: #800080;">1</span>, m % <span style="color: #800080;">10</span>^i) = a_i * (<span style="color: #800080;">10</span>^i - <span style="color: #800080;">9</span>^i) + <span style="color: #800080;">9</span>^i + T(<span style="color: #800080;">1</span>, m % <span style="color: #800080;">10</span>^i)</pre>
</div>
<p>参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> newInteger(<span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        </span><span style="color: #0000ff;">long</span> d = <span style="color: #800080;">9</span>, pre = <span style="color: #800080;">0</span>, cur = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (<span style="color: #0000ff;">true</span><span style="color: #000000;">) {
            pre </span>=<span style="color: #000000;"> cur;
            cur </span>= helper(n +<span style="color: #000000;"> cur, d);
            </span><span style="color: #0000ff;">if</span> (cur == pre) <span style="color: #0000ff;">break</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> n +<span style="color: #000000;"> cur;
    }
    </span><span style="color: #0000ff;">long</span> helper(<span style="color: #0000ff;">long</span> m, <span style="color: #0000ff;">long</span><span style="color: #000000;"> d) {
        </span><span style="color: #0000ff;">long</span> res = <span style="color: #800080;">0</span>, p = <span style="color: #800080;">1</span>, q = <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">long</span> i = m; i &gt;= <span style="color: #800080;">10</span>; i /= <span style="color: #800080;">10</span><span style="color: #000000;">) {
            p </span>*= <span style="color: #800080;">10</span><span style="color: #000000;">;
            q </span>*= <span style="color: #800080;">9</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">long</span> i = m; i &gt;= d; i %= p, p /= <span style="color: #800080;">10</span>, q /= <span style="color: #800080;">9</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">long</span> a = i /<span style="color: #000000;"> p;
            res </span>+= a * (p -<span style="color: #000000;"> q);
            </span><span style="color: #0000ff;">if</span> (a ==<span style="color: #000000;"> d) {
                res </span>+= i % p + <span style="color: #800080;">1</span>; <span style="color: #0000ff;">break</span><span style="color: #000000;">;
            } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (a &gt;<span style="color: #000000;"> d) {
                res </span>+=<span style="color: #000000;"> q;
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/99195/one-line-java-solution">https://discuss.leetcode.com/topic/99195/one-line-java-solution</a></p>
<p><a href="https://discuss.leetcode.com/topic/99240/this-problem-nonary-base-9-short-java-solution">https://discuss.leetcode.com/topic/99240/this-problem-nonary-base-9-short-java-solution</a></p>
<p><a href="https://discuss.leetcode.com/topic/99481/alternative-solution-applicable-to-the-general-case">https://discuss.leetcode.com/topic/99481/alternative-solution-applicable-to-the-general-case</a></p>
<p><a href="https://discuss.leetcode.com/topic/99401/share-my-o-logn-c-solution-with-thinking-process-and-explanation">https://discuss.leetcode.com/topic/99401/share-my-o-logn-c-solution-with-thinking-process-and-explanation</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-01-10 23:13</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=8261714" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(8261714);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7525821.html" id="cb_post_title_url">[LeetCode] Split Array into Consecutive Subsequences 将数组分割成连续子序列</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="question-description">
<p>You are given an integer array sorted in ascending order (may contain duplicates), you need to split them into several subsequences, where each subsequences consist of at least 3 consecutive integers. Return whether you can make such a split.</p>
<p>Example 1:</p>
<pre>Input: [1,2,3,3,4,5]
Output: True
Explanation:
You can split them into two consecutive subsequences : 
1, 2, 3
3, 4, 5
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input: [1,2,3,3,4,4,5,5]
Output: True
Explanation:
You can split them into two consecutive subsequences : 
1, 2, 3, 4, 5
3, 4, 5
</pre>
<p> </p>
<p>Example 3:</p>
<pre>Input: [1,2,3,4,4,5]
Output: False
</pre>
<p> </p>
<p>Note:</p>
<ol>
<li>The length of the input is in range of [1, 10000]</li>
</ol>
<p> </p>
<p>博主第一眼看到这题，心想，我去，这不就是打牌么，什么挖坑，拐3，红桃4啊，3个起连，有时候排组合的好，就不用划单儿。这道题让我们将数组分割成多个连续递增的子序列，注意这里可能会产生歧义，实际上应该是分割成一个或多个连续递增的子序列，因为[1,2,3,4,5]也是正确的解。这道题就用贪婪解法就可以了，我们使用两个哈希表map，第一个map用来建立数字和其出现次数之间的映射freq，第二个用来建立可以加在某个连续子序列后的数字及其可以出现的次数之间的映射need。对于第二个map，举个例子来说，就是假如有个连，[1,2,3]，那么后面可以加上4，所以就建立4的映射。这样我们首先遍历一遍数组，统计每个数字出现的频率，然后我们开始遍历数组，对于每个遍历到的数字，首先看其当前出现的次数，如果为0，则继续循环；如果need中存在这个数字的非0映射，那么表示当前的数字可以加到某个连的末尾，我们将当前数字的映射值自减1，然后将下一个连续数字的映射值加1，因为当[1,2,3]连上4后变成[1,2,3,4]之后，就可以连上5了；如果不能连到其他子序列后面，我们来看其是否可以成为新的子序列的起点，可以通过看后面两个数字的映射值是否大于0，都大于0的话，说明可以组成3连儿，于是将后面两个数字的映射值都自减1，还有由于组成了3连儿，在need中将末尾的下一位数字的映射值自增1；如果上面情况都不满足，说明该数字是单牌，只能划单儿，直接返回false。最后别忘了将当前数字的freq映射值自减1。退出for循环后返回true，参见代码如下：</p>
<p> </p>
</div>
<div id="interviewed-div">
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> isPossible(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        unordered_map</span>&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> freq, need;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> num : nums) ++<span style="color: #000000;">freq[num];
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span><span style="color: #000000;"> num : nums) {
            </span><span style="color: #0000ff;">if</span> (freq[num] == <span style="color: #800080;">0</span>) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (need[num] &gt; <span style="color: #800080;">0</span><span style="color: #000000;">) {
                </span>--<span style="color: #000000;">need[num];
                </span>++need[num + <span style="color: #800080;">1</span><span style="color: #000000;">];
            } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (freq[num + <span style="color: #800080;">1</span>] &gt; <span style="color: #800080;">0</span> &amp;&amp; freq[num + <span style="color: #800080;">2</span>] &gt; <span style="color: #800080;">0</span><span style="color: #000000;">) {
                </span>--freq[num + <span style="color: #800080;">1</span><span style="color: #000000;">];
                </span>--freq[num + <span style="color: #800080;">2</span><span style="color: #000000;">];
                </span>++need[num + <span style="color: #800080;">3</span><span style="color: #000000;">];
            } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            </span>--<span style="color: #000000;">freq[num];
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/99187/java-o-n-time-o-n-space">https://discuss.leetcode.com/topic/99187/java-o-n-time-o-n-space</a></p>
 </div>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-09-15 12:40</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7525821" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7525821);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7519466.html" id="cb_post_title_url">[LeetCode] Find K Closest Elements 寻找K个最近元素</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="question-description">
<p>Given a sorted array, two integers <code>k</code> and <code>x</code>, find the <code>k</code> closest elements to <code>x</code> in the array. The result should also be sorted in ascending order. If there is a tie, the smaller elements are always preferred.</p>
<p>Example 1:</p>
<pre>Input: [1,2,3,4,5], k=4, x=3
Output: [1,2,3,4]
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input: [1,2,3,4,5], k=4, x=-1
Output: [1,2,3,4]
</pre>
<p> </p>
<p>Note:</p>
<ol>
<li>The value k is positive and will always be smaller than the length of the sorted array.</li>
<li>Length of the given array is positive and will not exceed 104</li>
<li>Absolute value of elements in the array and x will not exceed 104</li>
</ol>
<p> </p>
<p>这道题给我们了一个数组，还有两个变量k和x。让我们找数组中离x最近的k个元素，而且说明了数组是有序的，如果两个数字距离x相等的话，取较小的那个。从给定的例子可以分析出x不一定是数组中的数字，我们想，由于数组是有序的，所以最后返回的k个元素也一定是有序的，那么其实就是返回了原数组的一个长度为k的子数组，转化一下，实际上相当于在长度为n的数组中去掉n-k个数字，而且去掉的顺序肯定是从两头开始去，因为距离x最远的数字肯定在首尾出现。那么问题就变的明朗了，我们每次比较首尾两个数字跟x的距离，将距离大的那个数字删除，直到剩余的数组长度为k为止，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; findClosestElements(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; arr, <span style="color: #0000ff;">int</span> k, <span style="color: #0000ff;">int</span><span style="color: #000000;"> x) {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; res =<span style="color: #000000;"> arr;
        </span><span style="color: #0000ff;">while</span> (res.size() &gt;<span style="color: #000000;"> k) {
            </span><span style="color: #0000ff;">int</span> first  = <span style="color: #800080;">0</span>, last = res.size() - <span style="color: #800080;">1</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> (x - res.front() &lt;= res.back() -<span style="color: #000000;"> x) {
                res.pop_back();
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                res.erase(res.begin());
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种解法是论坛上的高分解法，用到了二分搜索法。其实博主最开始用的方法并不是帖子中的这两个方法，虽然也是用的二分搜索法，但博主搜的是第一个不小于x的数，然后同时向左右两个方向遍历，每次取和x距离最小的数加入结果res中，直到取满k个为止。但是下面这种方法更加巧妙一些，二分法的判定条件做了一些改变，就可以直接找到要返回的k的数字的子数组的起始位置，感觉非常的神奇。每次比较的是mid位置和x的距离跟mid+k跟x的距离，以这两者的大小关系来确定二分法折半的方向，最后找到最近距离子数组的起始位置，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; findClosestElements(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; arr, <span style="color: #0000ff;">int</span> k, <span style="color: #0000ff;">int</span><span style="color: #000000;"> x) {
        </span><span style="color: #0000ff;">int</span> left = <span style="color: #800080;">0</span>, right = arr.size() -<span style="color: #000000;"> k;
        </span><span style="color: #0000ff;">while</span> (left &lt;<span style="color: #000000;"> right) {
            </span><span style="color: #0000ff;">int</span> mid = left + (right - left) / <span style="color: #800080;">2</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> (x - arr[mid] &gt; arr[mid + k] - x) left = mid + <span style="color: #800080;">1</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">else</span> right =<span style="color: #000000;"> mid;
        }
        </span><span style="color: #0000ff;">return</span> vector&lt;<span style="color: #0000ff;">int</span>&gt;(arr.begin() + left, arr.begin() + left +<span style="color: #000000;"> k);
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/99281/o-log-n-java-1-line-o-log-n-k-python">https://discuss.leetcode.com/topic/99281/o-log-n-java-1-line-o-log-n-k-python</a> </p>
<p><a href="https://discuss.leetcode.com/topic/99274/very-simple-and-short-acc-solution-modifying-the-input-list">https://discuss.leetcode.com/topic/99274/very-simple-and-short-acc-solution-modifying-the-input-list</a></p>
</div>
<div id="interviewed-div"> </div>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-09-14 10:42</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7519466" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7519466);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7514416.html" id="cb_post_title_url">[LeetCode] Judge Route Circle 判断路线绕圈</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="question-description">
<p>Initially, there is a Robot at position (0, 0). Given a sequence of its moves, judge if this robot makes a circle, which means it moves back to the original place.</p>
<p>The move sequence is represented by a string. And each move is represent by a character. The valid robot moves are <code>R</code> (Right), <code>L</code>(Left), <code>U</code> (Up) and <code>D</code> (down). The output should be true or false representing whether the robot makes a circle.</p>
<p>Example 1:</p>
<pre>Input: "UD"
Output: true
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input: "LL"
Output: false
</pre>
<p> </p>
<p>这道题让我们判断一个路径是否绕圈，就是说有多少个U，就得对应多少个D。同理，L和R的个数也得相等。这不就是之前那道<a href="http://www.cnblogs.com/grandyang/p/4424587.html" target="_blank">Valid Parentheses</a>的变种么，这次博主终于举一反三了！这比括号那题还要简单，因为括号至少还有三种，这里就水平和竖直两种。比较简单的方法就是使用两个计数器，如果是U，则cnt1自增1；如果是D，cnt1自减1。同理，如果是L，则cnt1自增1；如果是R，cnt1自减1。最后只要看cnt1和cnt2是否同时为0即可，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> judgeCircle(<span style="color: #0000ff;">string</span><span style="color: #000000;"> moves) {
        </span><span style="color: #0000ff;">int</span> cnt1 = <span style="color: #800080;">0</span>, cnt2 = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span><span style="color: #000000;"> move : moves) {
            </span><span style="color: #0000ff;">if</span> (move == <span style="color: #800000;">'</span><span style="color: #800000;">U</span><span style="color: #800000;">'</span>) ++<span style="color: #000000;">cnt1;
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (move == <span style="color: #800000;">'</span><span style="color: #800000;">D</span><span style="color: #800000;">'</span>) --<span style="color: #000000;">cnt1;
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (move == <span style="color: #800000;">'</span><span style="color: #800000;">L</span><span style="color: #800000;">'</span>) ++<span style="color: #000000;">cnt2;
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (move == <span style="color: #800000;">'</span><span style="color: #800000;">R</span><span style="color: #800000;">'</span>) --<span style="color: #000000;">cnt2;
        }
        </span><span style="color: #0000ff;">return</span> cnt1 == <span style="color: #800080;">0</span> &amp;&amp; cnt2 == <span style="color: #800080;">0</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种解法使用了哈希表来建立字符和其出现的次数之间的映射，最后直接比较对应的字符出现的次数是否相等即可，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> judgeCircle(<span style="color: #0000ff;">string</span><span style="color: #000000;"> moves) {
        unordered_map</span>&lt;<span style="color: #0000ff;">char</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> m;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span> c : moves) ++<span style="color: #000000;">m[c];
        </span><span style="color: #0000ff;">return</span> m[<span style="color: #800000;">'</span><span style="color: #800000;">L</span><span style="color: #800000;">'</span>] == m[<span style="color: #800000;">'</span><span style="color: #800000;">R</span><span style="color: #800000;">'</span>] &amp;&amp; m[<span style="color: #800000;">'</span><span style="color: #800000;">U</span><span style="color: #800000;">'</span>] == m[<span style="color: #800000;">'</span><span style="color: #800000;">D</span><span style="color: #800000;">'</span><span style="color: #000000;">];
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4424587.html" target="_blank">Valid Parentheses</a></p>
<p> </p>
<p>参考资料： </p>
<p><a href="https://discuss.leetcode.com/topic/99256/c-counter-4-lines-solution">https://discuss.leetcode.com/topic/99256/c-counter-4-lines-solution</a> </p>
</div>
<div id="interviewed-div"> </div>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-09-13 13:20</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7514416" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7514416);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/8183477.html" id="cb_post_title_url">[LeetCode] Coin Path 硬币路径</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given an array <code>A</code> (index starts at <code>1</code>) consisting of N integers: A1, A2, ..., AN and an integer <code>B</code>. The integer <code>B</code>denotes that from any place (suppose the index is <code>i</code>) in the array <code>A</code>, you can jump to any one of the place in the array <code>A</code> indexed <code>i+1</code>, <code>i+2</code>, …, <code>i+B</code> if this place can be jumped to. Also, if you step on the index <code>i</code>, you have to pay Ai coins. If Ai is -1, it means you can’t jump to the place indexed <code>i</code> in the array.</p>
<p>Now, you start from the place indexed <code>1</code> in the array <code>A</code>, and your aim is to reach the place indexed <code>N</code> using the minimum coins. You need to return the path of indexes (starting from 1 to N) in the array you should take to get to the place indexed <code>N</code> using minimum coins.</p>
<p>If there are multiple paths with the same cost, return the lexicographically smallest such path.</p>
<p>If it's not possible to reach the place indexed N then you need to return an empty array.</p>
<p>Example 1:</p>
<pre>Input: [1,2,4,-1,2], 2
Output: [1,3,5]
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input: [1,2,4,-1,2], 1
Output: []
</pre>
<p> </p>
<p>Note:</p>
<ol>
<li>Path Pa1, Pa2, ..., Pan is lexicographically smaller than Pb1, Pb2, ..., Pbm, if and only if at the first <code>i</code> where Pai and Pbi differ, Pai &lt; Pbi; when no such <code>i</code> exists, then <code>n</code> &lt; <code>m</code>.</li>
<li>A1 &gt;= 0. A2, ..., AN (if exist) will in the range of [-1, 100].</li>
<li>Length of A is in the range of [1, 1000].</li>
<li>B is in the range of [1, 100].</li>
</ol>
<p> </p>
<p>这道题给了我们一个数组A，又给了我们一个整数B，表示能走的最大步数，数组上的每个数字都是cost值，如果到达某个位置，就要加上该位置上的数字，其实位置是在第一个数字上，目标是到达末尾位置，我们需要让总cost值最小，并输入路径，如果cos相同的话，输出字母顺序小的那个路径。还有就是如果数组上的某个位置为-1的话，表示到达该位置后不能再去下一个位置，而且数组末位置不能为-1。博主最开始写了一个递归的解法，结果MLE了，看来这道题对内存使用的管控极为苛刻。所以我们不能将所有的候选路径都存在内存中，而是应该建立祖先数组，即数组上每个位置放其父结点的位置，有点像联合查找Union Find中的root数组，再最后根据这个祖先数组来找出正确的路径。由于需要找出cost最小的路径，所以我们可以考虑用dp数组，其中dp[i]表示从开头到位置i的最小cost值，但是如果我们从后往前跳，那么dp[i]就是从末尾到位置i的最小cost值。</p>
<p>我们首先判断数组A的末尾数字是否为-1，是的话直接返回空集。否则就新建结果res数组，dp数组，和pos数组，其中dp数组都初始化为整型最大值，pos数组都初始化为-1。然后将dp数组的最后一个数字赋值为数组A的尾元素。因为我们要从后往前跳，那我们从后往前遍历，如果遇到数字-1，说明不能往前跳了，直接continue继续循环，然后对于每个遍历到的数字，我们都要遍历其上一步可能的位置的dp[j]值来更新当前dp[i]值，由于限制了步数B，所以最多能到i+B，为了防止越界，要取i+B和n-1中的较小值为界限，如果上一步dp[j]值为INT_MAX，说明上一个位置无法跳过来，直接continue，否则看上一个位置dp[j]值加上当前cost值A[i]，如果小于dp[i]，说明dp[i]需要更新，并且建立祖先数组的映射pos[i] = j。最后在循环结束后，我们判断dp[0]的值，如果是INT_MAX，说明没有跳到首位置，直接返回空集，否则我们就通过pos数组来取路径。我们从前往后遍历pos数组来取位置，直到遇到-1停止。另外要说明的就是，这种从后往前遍历的模式得到的路径一定是字母顺序最小的，<span class="username"><a href="https://discuss.leetcode.com/topic/98399/c-dp-o-nb-time-o-n-space" target="_blank"> zestypanda大神的帖子</a>中有证明，不过博主没太看懂-.-|||，可以带这个例子尝试：</span></p>
<p><span class="username">A = [0, 0, 0], B = 2</span></p>
<p><span class="username">上面这个例子得到的结果是[1, 2, 3]，是字母顺序最小的路径，而相同的cost路径[1, 3]，就不是字母顺序最小的路径，参见代码如下：</span></p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
   vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; cheapestJump(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; A, <span style="color: #0000ff;">int</span><span style="color: #000000;"> B) {
       </span><span style="color: #0000ff;">if</span> (A.back() == -<span style="color: #800080;">1</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;"> {};
        </span><span style="color: #0000ff;">int</span> n =<span style="color: #000000;"> A.size();
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; res, dp(n, INT_MAX), pos(n, -<span style="color: #800080;">1</span><span style="color: #000000;">);
        dp[n </span>- <span style="color: #800080;">1</span>] = A[n - <span style="color: #800080;">1</span><span style="color: #000000;">];
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = n - <span style="color: #800080;">2</span>; i &gt;= <span style="color: #800080;">0</span>; --<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (A[i] == -<span style="color: #800080;">1</span>) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = i + <span style="color: #800080;">1</span>; j &lt;= min(i + B, n - <span style="color: #800080;">1</span>); ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> (dp[j] == INT_MAX) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">if</span> (A[i] + dp[j] &lt;<span style="color: #000000;"> dp[i]) {
                    dp[i] </span>= A[i] +<span style="color: #000000;"> dp[j];
                    pos[i] </span>=<span style="color: #000000;"> j;
                }
            }
        }
        </span><span style="color: #0000ff;">if</span> (dp[<span style="color: #800080;">0</span>] == INT_MAX) <span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> cur = <span style="color: #800080;">0</span>; cur != -<span style="color: #800080;">1</span>; cur =<span style="color: #000000;"> pos[cur]) {
            res.push_back(cur </span>+ <span style="color: #800080;">1</span><span style="color: #000000;">);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
   }
};</span></pre>
</div>
<p> </p>
<p>下面这种方法是正向遍历的解法，正向跳的话就需要另一个数组len，len[i]表示从开头到达位置i的路径的长度，如果两个路径的cost相同，那么一定是路径长度大的字母顺序小，可以参见例子 <span class="username">A = [0, 0, 0], B = 2</span>。</p>
<p>具体的写法就不讲了，跟上面十分类似，参考上面的讲解，需要注意的就是更新的判定条件中多了一个t == dp[i] &amp;&amp; len[i] &lt; len[j] + 1，就是判断当cost相同时，我们取长度大路径当作结果保存。还有就是最后查找路径时要从末尾往前遍历，只要遇到-1时停止，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; cheapestJump(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; A, <span style="color: #0000ff;">int</span><span style="color: #000000;"> B) {
        </span><span style="color: #0000ff;">if</span> (A.back() == -<span style="color: #800080;">1</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;"> {};
        </span><span style="color: #0000ff;">int</span> n =<span style="color: #000000;"> A.size();
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; res, dp(n, INT_MAX), pos(n, -<span style="color: #800080;">1</span>), len(n, <span style="color: #800080;">0</span><span style="color: #000000;">);
        dp[</span><span style="color: #800080;">0</span>] = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (A[i] == -<span style="color: #800080;">1</span>) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = max(<span style="color: #800080;">0</span>, i - B); j &lt; i; ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> (dp[j] == INT_MAX) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">int</span> t = A[i] +<span style="color: #000000;"> dp[j];
                </span><span style="color: #0000ff;">if</span> (t &lt; dp[i] || (t == dp[i] &amp;&amp; len[i] &lt; len[j] + <span style="color: #800080;">1</span><span style="color: #000000;">)) {
                    dp[i] </span>=<span style="color: #000000;"> t;
                    pos[i] </span>=<span style="color: #000000;"> j;
                    len[i] </span>= len[j] + <span style="color: #800080;">1</span><span style="color: #000000;">;
                }
            }
        }
        </span><span style="color: #0000ff;">if</span> (dp[n - <span style="color: #800080;">1</span>] == INT_MAX) <span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> cur = n - <span style="color: #800080;">1</span>; cur != -<span style="color: #800080;">1</span>; cur =<span style="color: #000000;"> pos[cur]) {
            res.insert(res.begin(), cur </span>+ <span style="color: #800080;">1</span><span style="color: #000000;">);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4518674.html" target="_blank">House Robber II</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4383632.html" target="_blank">House Robber</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/5888439.html">Frog Jump</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4371526.html" target="_blank">Jump Game</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4373533.html" target="_blank">Jump Game II</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/98399/c-dp-o-nb-time-o-n-space" target="_blank">https://discuss.leetcode.com/topic/98399/c-dp-o-nb-time-o-n-space</a></p>
<p><a href="https://discuss.leetcode.com/topic/98491/java-22-lines-solution-with-proof" target="_blank">https://discuss.leetcode.com/topic/98491/java-22-lines-solution-with-proof</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-01-03 14:03</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=8183477" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(8183477);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7489097.html" id="cb_post_title_url">[LeetCode] Print Binary Tree 打印二叉树</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Print a binary tree in an m*n 2D string array following these rules:</p>
<ol>
<li>The row number <code>m</code> should be equal to the height of the given binary tree.</li>
<li>The column number <code>n</code> should always be an odd number.</li>
<li>The root node's value (in string format) should be put in the exactly middle of the first row it can be put. The column and the row where the root node belongs will separate the rest space into two parts (left-bottom part and right-bottom part). You should print the left subtree in the left-bottom part and print the right subtree in the right-bottom part. The left-bottom part and the right-bottom part should have the same size. Even if one subtree is none while the other is not, you don't need to print anything for the none subtree but still need to leave the space as large as that for the other subtree. However, if two subtrees are none, then you don't need to leave space for both of them.</li>
<li>Each unused space should contain an empty string <code>""</code>.</li>
<li>Print the subtrees following the same rules.</li>
</ol>
<p>Example 1:</p>
<pre>Input:
     1
    /
   2
Output:
[["", "1", ""],
 ["2", "", ""]]
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input:
     1
    / \
   2   3
    \
     4
Output:
[["", "", "", "1", "", "", ""],
 ["", "2", "", "", "", "3", ""],
 ["", "", "4", "", "", "", ""]]
</pre>
<p> </p>
<p>Example 3:</p>
<pre>Input:
      1
     / \
    2   5
   / 
  3 
 / 
4 
Output:

[["",  "",  "", "",  "", "", "", "1", "",  "",  "",  "",  "", "", ""]
 ["",  "",  "", "2", "", "", "", "",  "",  "",  "",  "5", "", "", ""]
 ["",  "3", "", "",  "", "", "", "",  "",  "",  "",  "",  "", "", ""]
 ["4", "",  "", "",  "", "", "", "",  "",  "",  "",  "",  "", "", ""]]
</pre>
<p> </p>
<p>Note: The height of binary tree is in the range of [1, 10].</p>
<p> </p>
<p>这道题给了我们一棵二叉树，让我们以数组的形式打印出来。数组每一行的宽度是二叉树的最底层数所能有的最多结点数，存在的结点需要填入到正确的位置上。那么这道题我们就应该首先要确定返回数组的宽度，由于宽度跟数组的深度有关，所以我们首先应该算出二叉树的最大深度，直接写一个子函数返回这个最大深度，从而计算出宽度。下面就是要遍历二叉树从而在数组中加入结点值。我们先来看第一行，由于根结点只有一个，所以第一行只需要插入一个数字，不管这一行多少个位置，我们都是在最中间的位置插入结点值。下面来看第二行，我们仔细观察可以发现，如果我们将这一行分为左右两部分，那么插入的位置还是在每一部分的中间位置，这样我们只要能确定分成的部分的左右边界位置，就知道插入结点的位置了，所以应该是使用分治法的思路。在递归函数中，如果当前node不存在或者当前深度超过了最大深度直接返回，否则就给中间位置赋值为结点值，然后对于左子结点，范围是左边界到中间位置，调用递归函数，注意当前深度加1；同理对于右子结点，范围是中间位置加1到右边界，调用递归函数，注意当前深度加1，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;vector&lt;<span style="color: #0000ff;">string</span>&gt;&gt; printTree(TreeNode*<span style="color: #000000;"> root) {
        </span><span style="color: #0000ff;">int</span> h = getHeight(root), w = pow(<span style="color: #800080;">2</span>, h) - <span style="color: #800080;">1</span><span style="color: #000000;">;
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">string</span>&gt;&gt; res(h, vector&lt;<span style="color: #0000ff;">string</span>&gt;(w, <span style="color: #800000;">""</span><span style="color: #000000;">));
        helper(root, </span><span style="color: #800080;">0</span>, w - <span style="color: #800080;">1</span>, <span style="color: #800080;">0</span><span style="color: #000000;">, h, res);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">void</span> helper(TreeNode* node, <span style="color: #0000ff;">int</span> i, <span style="color: #0000ff;">int</span> j, <span style="color: #0000ff;">int</span> curH, <span style="color: #0000ff;">int</span> height, vector&lt;vector&lt;<span style="color: #0000ff;">string</span>&gt;&gt;&amp;<span style="color: #000000;"> res) {
        </span><span style="color: #0000ff;">if</span> (!node || curH == height) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
        res[curH][(i </span>+ j) / <span style="color: #800080;">2</span>] = to_string(node-&gt;<span style="color: #000000;">val);
        helper(node</span>-&gt;left, i, (i + j) / <span style="color: #800080;">2</span>, curH + <span style="color: #800080;">1</span><span style="color: #000000;">, height, res);
        helper(node</span>-&gt;right, (i + j) / <span style="color: #800080;">2</span> + <span style="color: #800080;">1</span>, j, curH + <span style="color: #800080;">1</span><span style="color: #000000;">, height, res);
    }
    </span><span style="color: #0000ff;">int</span> getHeight(TreeNode*<span style="color: #000000;"> node) {
        </span><span style="color: #0000ff;">if</span> (!node) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">1</span> + max(getHeight(node-&gt;left), getHeight(node-&gt;<span style="color: #000000;">right));
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种方法是层序遍历二叉树，使用了两个辅助队列来做，思路都一样，只不过是迭代的写法而已，关键还是在于左右边界的处理上，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;vector&lt;<span style="color: #0000ff;">string</span>&gt;&gt; printTree(TreeNode*<span style="color: #000000;"> root) {
        </span><span style="color: #0000ff;">int</span> h = getHeight(root), w = pow(<span style="color: #800080;">2</span>, h) - <span style="color: #800080;">1</span>, curH = -<span style="color: #800080;">1</span><span style="color: #000000;">;
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">string</span>&gt;&gt; res(h, vector&lt;<span style="color: #0000ff;">string</span>&gt;(w, <span style="color: #800000;">""</span><span style="color: #000000;">));
        queue</span>&lt;TreeNode*&gt;<span style="color: #000000;"> q{{root}};
        queue</span>&lt;pair&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;&gt; idxQ{{{<span style="color: #800080;">0</span>, w - <span style="color: #800080;">1</span><span style="color: #000000;">}}};
        </span><span style="color: #0000ff;">while</span> (!<span style="color: #000000;">q.empty()) {
            </span><span style="color: #0000ff;">int</span> n =<span style="color: #000000;"> q.size();
            </span>++<span style="color: #000000;">curH;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
                auto t </span>=<span style="color: #000000;"> q.front(); q.pop();
                auto idx </span>=<span style="color: #000000;"> idxQ.front(); idxQ.pop();
                </span><span style="color: #0000ff;">if</span> (!t) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">int</span> left = idx.first, right =<span style="color: #000000;"> idx.second;
                </span><span style="color: #0000ff;">int</span> mid = left + (right - left) / <span style="color: #800080;">2</span><span style="color: #000000;">;
                res[curH][mid] </span>= to_string(t-&gt;<span style="color: #000000;">val);
                q.push(t</span>-&gt;<span style="color: #000000;">left);
                q.push(t</span>-&gt;<span style="color: #000000;">right);
                idxQ.push({left, mid});
                idxQ.push({mid </span>+ <span style="color: #800080;">1</span><span style="color: #000000;">, right});
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">int</span> getHeight(TreeNode*<span style="color: #000000;"> node) {
        </span><span style="color: #0000ff;">if</span> (!node) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">1</span> + max(getHeight(node-&gt;left), getHeight(node-&gt;<span style="color: #000000;">right));
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/98381/java-recursive-solution">https://discuss.leetcode.com/topic/98381/java-recursive-solution</a></p>
<p><a href="https://discuss.leetcode.com/topic/98503/java-iterative-level-order-traversal-with-queue">https://discuss.leetcode.com/topic/98503/java-iterative-level-order-traversal-with-queue</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-09-07 12:37</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7489097" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7489097);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7513099.html" id="cb_post_title_url">[LeetCode] Maximum Binary Tree 最大二叉树</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="question-description">
<p>Given an integer array with no duplicates. A maximum tree building on this array is defined as follow:</p>
<ol>
<li>The root is the maximum number in the array.</li>
<li>The left subtree is the maximum tree constructed from left part subarray divided by the maximum number.</li>
<li>The right subtree is the maximum tree constructed from right part subarray divided by the maximum number.</li>
</ol>
<p> </p>
<p>Construct the maximum tree by the given array and output the root node of this tree.</p>
<p>Example 1:</p>
<pre>Input: [3,2,1,6,0,5]
Output: return the tree root node representing the following tree:

      6
    /   \
   3     5
    \    / 
     2  0   
       \
        1
</pre>
<p> </p>
<p>Note:</p>
<ol>
<li>The size of the given array will be in the range [1,1000].</li>
</ol>
<p> </p>
<p>这道题给了我们一个数组，让我们创建一个最大二叉树，创建规则是数组中的最大值为根结点，然后分隔出的左右部分再分别创建最大二叉树。那么明眼人一看就知道这是分治法啊，果断上递归啊。首先就是要先找出数组中的最大值，由于数组是无序的，所以没啥好的办法，就直接遍历吧，找到了最大值，就创建一个结点，然后将左右两个子数组提取出来，分别调用递归函数并将结果连到该结点上，最后将结点返回即可，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    TreeNode</span>* constructMaximumBinaryTree(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        </span><span style="color: #0000ff;">if</span> (nums.empty()) <span style="color: #0000ff;">return</span><span style="color: #000000;"> NULL;
        </span><span style="color: #0000ff;">int</span> mx = INT_MIN, mx_idx = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; nums.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (mx &lt;<span style="color: #000000;"> nums[i]) {
                mx </span>=<span style="color: #000000;"> nums[i];
                mx_idx </span>=<span style="color: #000000;"> i;
            }
        }
        TreeNode </span>*node = <span style="color: #0000ff;">new</span><span style="color: #000000;"> TreeNode(mx);
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; leftArr = vector&lt;<span style="color: #0000ff;">int</span>&gt;(nums.begin(), nums.begin() +<span style="color: #000000;"> mx_idx);
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; rightArr = vector&lt;<span style="color: #0000ff;">int</span>&gt;(nums.begin() + mx_idx + <span style="color: #800080;">1</span><span style="color: #000000;">, nums.end());
        node</span>-&gt;left =<span style="color: #000000;"> constructMaximumBinaryTree(leftArr);
        node</span>-&gt;right =<span style="color: #000000;"> constructMaximumBinaryTree(rightArr);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> node;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种方法也是递归的解法，和上面的解法稍有不同的是不必提取子数组，而是用两个变量来指定子数组的范围，其他部分均和上面的解法相同，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    TreeNode</span>* constructMaximumBinaryTree(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        </span><span style="color: #0000ff;">if</span> (nums.empty()) <span style="color: #0000ff;">return</span><span style="color: #000000;"> NULL;
        </span><span style="color: #0000ff;">return</span> helper(nums, <span style="color: #800080;">0</span>, nums.size() - <span style="color: #800080;">1</span><span style="color: #000000;">);
    }
    TreeNode</span>* helper(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; nums, <span style="color: #0000ff;">int</span> left, <span style="color: #0000ff;">int</span><span style="color: #000000;"> right) {
        </span><span style="color: #0000ff;">if</span> (left &gt; right) <span style="color: #0000ff;">return</span><span style="color: #000000;"> NULL;
        </span><span style="color: #0000ff;">int</span> mid =<span style="color: #000000;"> left;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = left + <span style="color: #800080;">1</span>; i &lt;= right; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (nums[i] &gt;<span style="color: #000000;"> nums[mid]) {
                mid </span>=<span style="color: #000000;"> i;
            }
        }
        TreeNode </span>*node = <span style="color: #0000ff;">new</span><span style="color: #000000;"> TreeNode(nums[mid]);
        node</span>-&gt;left = helper(nums, left, mid - <span style="color: #800080;">1</span><span style="color: #000000;">);
        node</span>-&gt;right = helper(nums, mid + <span style="color: #800080;">1</span><span style="color: #000000;">, right);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> node;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种解法是论坛上的高分解法，使用到了一个辅助数组v来让保持降序。我们遍历数组，对于每个遍历到的数字，创建一个结点，然后进行循环，如果数组v不空，且末尾结点值小于当前数字，那么将末尾结点连到当前结点的左子结点，并且移除数组中的末尾结点，这样可以保证子结点都会小于父结点。循环结束后，如果此时数组v仍不为空，说明结点值很大，那么将当前结点连到数组末尾结点的右子结点上。之后别忘了将当前结点加入数组v中，最后返回数组v的首结点即可，如果不太容易理解的话，就把题目中的例子带入一步一步运行看一下吧，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    TreeNode</span>* constructMaximumBinaryTree(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        vector</span>&lt;TreeNode*&gt;<span style="color: #000000;"> v;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span><span style="color: #000000;"> num : nums) {
            TreeNode </span>*cur = <span style="color: #0000ff;">new</span><span style="color: #000000;"> TreeNode(num);
            </span><span style="color: #0000ff;">while</span> (!v.empty() &amp;&amp; v.back()-&gt;val &lt;<span style="color: #000000;"> num) {
                cur</span>-&gt;left =<span style="color: #000000;"> v.back();
                v.pop_back();
            }
            </span><span style="color: #0000ff;">if</span> (!<span style="color: #000000;">v.empty()) {
                v.back()</span>-&gt;right =<span style="color: #000000;"> cur;
            }
            v.push_back(cur);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> v.front();
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料： </p>
</div>
<div id="interviewed-div"><a href="https://discuss.leetcode.com/topic/98509/c-o-n-solution">https://discuss.leetcode.com/topic/98509/c-o-n-solution</a></div>
<p><a href="https://discuss.leetcode.com/topic/98457/java-c-simple-recursive-method">https://discuss.leetcode.com/topic/98457/java-c-simple-recursive-method</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-09-13 03:27</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7513099" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7513099);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7508169.html" id="cb_post_title_url">[LeetCode] Two Sum IV - Input is a BST 两数之和之四 - 输入是二叉搜索树</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a Binary Search Tree and a target number, return true if there exist two elements in the BST such that their sum is equal to the given target.</p>
<p>Example 1:</p>
<pre>Input: 
    5
   / \
  3   6
 / \   \
2   4   7

Target = 9

Output: True
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input: 
    5
   / \
  3   6
 / \   \
2   4   7

Target = 28

Output: False</pre>
<p> </p>
<p>这道题又是一道2sum的变种题，博主一直强调，平生不识TwoSum，刷尽LeetCode也枉然！只要是两数之和的题，一定要记得用哈希表来做，这道题只不过是把数组变成了一棵二叉树而已，换汤不换药，我们遍历二叉树就行，然后用一个哈希set，在递归函数函数中，如果node为空，返回false。如果k减去当前结点值在哈希set中存在，直接返回true；否则就将当前结点值加入哈希set，然后对左右子结点分别调用递归函数并且或起来返回即可，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> findTarget(TreeNode* root, <span style="color: #0000ff;">int</span><span style="color: #000000;"> k) {
        </span><span style="color: #0000ff;">if</span> (!root) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        unordered_set</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> s;
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> helper(root, k, s);
    }
    </span><span style="color: #0000ff;">bool</span> helper(TreeNode* node, <span style="color: #0000ff;">int</span> k, unordered_set&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> s) {
        </span><span style="color: #0000ff;">if</span> (!node) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (s.count(k - node-&gt;val)) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        s.insert(node</span>-&gt;<span style="color: #000000;">val);
        </span><span style="color: #0000ff;">return</span> helper(node-&gt;left, k, s) || helper(node-&gt;<span style="color: #000000;">right, k, s);
    }
};</span></pre>
</div>
<p> </p>
<p>我们也可以用层序遍历来做，这样就是迭代的写法了，但是利用哈希表的精髓还是没变的，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> findTarget(TreeNode* root, <span style="color: #0000ff;">int</span><span style="color: #000000;"> k) {
        </span><span style="color: #0000ff;">if</span> (!root) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        unordered_set</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> s;
        queue</span>&lt;TreeNode*&gt;<span style="color: #000000;"> q{{root}};
        </span><span style="color: #0000ff;">while</span> (!<span style="color: #000000;">q.empty()) {
          auto t </span>=<span style="color: #000000;"> q.front(); q.pop();
          </span><span style="color: #0000ff;">if</span> (s.count(k - t-&gt;val)) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
          s.insert(t</span>-&gt;<span style="color: #000000;">val);
          </span><span style="color: #0000ff;">if</span> (t-&gt;left) q.push(t-&gt;<span style="color: #000000;">left);
          </span><span style="color: #0000ff;">if</span> (t-&gt;right) q.push(t-&gt;<span style="color: #000000;">right);
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/5184143.html" target="_blank">Two Sum III - Data structure design</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/5185815.html" target="_blank">Two Sum II - Input array is sorted</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4130379.html" target="_blank">Two Sum</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/98440/java-c-three-simple-methods-choose-one-you-like">https://discuss.leetcode.com/topic/98440/java-c-three-simple-methods-choose-one-you-like</a></p>
<p><a href="https://discuss.leetcode.com/topic/100110/my-c-non-recursive-solution-using-unordered_set-and-stack">https://discuss.leetcode.com/topic/100110/my-c-non-recursive-solution-using-unordered_set-and-stack</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-09-12 03:42</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7508169" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7508169);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7500082.html" id="cb_post_title_url">[LeetCode] Find Duplicate Subtrees 寻找重复树</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="question-description">
<p>Given a binary tree, return all duplicate subtrees. For each kind of duplicate subtrees, you only need to return the root node of any oneof them.</p>
<p>Two trees are duplicate if they have the same structure with same node values.</p>
<p>Example 1: </p>
<pre>        1
       / \
      2   3
     /   / \
    4   2   4
       /
      4
</pre>
The following are two duplicate subtrees:
<pre>      2
     /
    4
</pre>
and
<pre>    4
</pre>
Therefore, you need to return above trees' root in the form of a list.
<p> </p>
<p>这道题让我们寻找重复树，博主开始的思路是遍历每个结点，将结点值相同的结点放到一起，如果再遇到相同的结点值，则调用一个判断是否是相同树的子函数，但是这样会有大量的重复运算，会TLE。后来去网上看大神们的解法，发现果然是很叼啊，用到了后序遍历，还有数组序列化，并且建立序列化跟其出现次数的映射，这样如果我们得到某个结点的序列化字符串，而该字符串正好出现的次数为1，说明之前已经有一个重复树了，我们将当前结点存入结果res，这样保证了多个重复树只会存入一个结点，参见代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;TreeNode*&gt; findDuplicateSubtrees(TreeNode*<span style="color: #000000;"> root) {
        vector</span>&lt;TreeNode*&gt;<span style="color: #000000;"> res;
        unordered_map</span>&lt;<span style="color: #0000ff;">string</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> m;
        helper(root, m, res);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">string</span> helper(TreeNode* node, unordered_map&lt;<span style="color: #0000ff;">string</span>, <span style="color: #0000ff;">int</span>&gt;&amp; m, vector&lt;TreeNode*&gt;&amp;<span style="color: #000000;"> res) {
        </span><span style="color: #0000ff;">if</span> (!node) <span style="color: #0000ff;">return</span> <span style="color: #800000;">"</span><span style="color: #800000;">#</span><span style="color: #800000;">"</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">string</span> str = to_string(node-&gt;val) + <span style="color: #800000;">"</span><span style="color: #800000;">,</span><span style="color: #800000;">"</span> + helper(node-&gt;left, m, res) + <span style="color: #800000;">"</span><span style="color: #800000;">,</span><span style="color: #800000;">"</span> + helper(node-&gt;<span style="color: #000000;">right, m, res);
        </span><span style="color: #0000ff;">if</span> (m[str] == <span style="color: #800080;">1</span><span style="color: #000000;">) res.push_back(node);
        </span>++<span style="color: #000000;">m[str];
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> str;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/97584/java-concise-postorder-traversal-solution">https://discuss.leetcode.com/topic/97584/java-concise-postorder-traversal-solution</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p>
</div></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-09-10 06:41</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7500082" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7500082);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7448390.html" id="cb_post_title_url">[LeetCode] 4 Keys Keyboard 四键的键盘</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="question-description">
<p>Imagine you have a special keyboard with the following keys:</p>
<p><code>Key 1: (A)</code>: Print one 'A' on screen.</p>
<p><code>Key 2: (Ctrl-A)</code>: Select the whole screen.</p>
<p><code>Key 3: (Ctrl-C)</code>: Copy selection to buffer.</p>
<p><code>Key 4: (Ctrl-V)</code>: Print buffer on screen appending it after what has already been printed.</p>
<p>Now, you can only press the keyboard for N times (with the above four keys), find out the maximum numbers of 'A' you can print on screen.</p>
<p>Example 1:</p>
<pre>Input: N = 3
Output: 3
Explanation: 
We can at most get 3 A's on screen by pressing following key sequence:
A, A, A
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input: N = 7
Output: 9
Explanation: 
We can at most get 9 A's on screen by pressing following key sequence:
A, A, A, Ctrl A, Ctrl C, Ctrl V, Ctrl V
</pre>
<p> </p>
<p>Note:</p>
<ol>
<li>1 &lt;= N &lt;= 50</li>
<li>Answers will be in the range of 32-bit signed integer.</li>
</ol>
<p> </p>
<p>这道题给了我们四个操作，分别是打印A，全选，复制，粘贴。每个操作都算一个步骤，给了我们一个数字N，问我们N个操作最多能输出多个A。我们可以分析题目中的例子可以发现，N步最少都能打印N个A出来，因为我们可以每步都是打印A。那么能超过N的情况肯定就是使用了复制粘贴，这里由于全选和复制要占用两步，所以能增加A的个数的操作其实只有N-2步，那么我们如何确定打印几个A，剩下都是粘贴呢，其实是个trade off，A打印的太多或太少，都不会得到最大结果，所以打印A和粘贴的次数要接近，最简单的方法就是遍历所有的情况然后取最大值，打印A的次数在[1, N-3]之间，粘贴的次数为N-2-i，加上打印出的部分，就是N-1-i了，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> maxA(<span style="color: #0000ff;">int</span><span style="color: #000000;"> N) {
        </span><span style="color: #0000ff;">int</span> res =<span style="color: #000000;"> N;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt; N - <span style="color: #800080;">2</span>; ++<span style="color: #000000;">i) {
            res </span>= max(res, maxA(i) * (N - <span style="color: #800080;">1</span> -<span style="color: #000000;"> i));
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>这道题也可以用DP来做，我们用一个一维数组dp，其中dp[i]表示步骤总数为i时，能打印出的最多A的个数，初始化为N+1个，然后我们来想递推公式怎么求。对于dp[i]来说，求法其实跟上面的方法一样，还是要遍历所有打印A的个数，然后乘以粘贴的次数加1，用来更新dp[i]，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> maxA(<span style="color: #0000ff;">int</span><span style="color: #000000;"> N) {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; dp(N + <span style="color: #800080;">1</span>, <span style="color: #800080;">0</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt;= N; ++<span style="color: #000000;">i) {
            dp[i] </span>=<span style="color: #000000;"> i;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">1</span>; j &lt; i - <span style="color: #800080;">2</span>; ++<span style="color: #000000;">j) {
                dp[i] </span>= max(dp[i], dp[j] * (i - j - <span style="color: #800080;">1</span><span style="color: #000000;">));
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> dp[N];
    }
};</span></pre>
</div>
<p> </p>
<p>这道题还有个O(1)时间复杂度的解法，好像利用了数学知识，不过博主貌似没太理解，参见<a href="https://discuss.leetcode.com/topic/97764/o-1-time-o-1-space-c-solution-possibly-shortest-and-fastest" target="_blank">这个帖子</a>，哪位大神给博主讲解一下？</p>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/7439616.html">2 Keys Keyboard</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/97764/o-1-time-o-1-space-c-solution-possibly-shortest-and-fastest">https://discuss.leetcode.com/topic/97764/o-1-time-o-1-space-c-solution-possibly-shortest-and-fastest</a></p>
<p><a href="https://discuss.leetcode.com/topic/97628/java-4-lines-recursion-with-step-by-step-explanation-to-derive-dp">https://discuss.leetcode.com/topic/97628/java-4-lines-recursion-with-step-by-step-explanation-to-derive-dp</a></p>
<p> </p>
</div>
<div id="interviewed-div"><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></div></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-08-29 15:18</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7448390" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7448390);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7439616.html" id="cb_post_title_url">[LeetCode] 2 Keys Keyboard 两键的键盘</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="question-description">
<p>Initially on a notepad only one character 'A' is present. You can perform two operations on this notepad for each step:</p>
<ol>
<li><code>Copy All</code>: You can copy all the characters present on the notepad (partial copy is not allowed).</li>
<li><code>Paste</code>: You can paste the characters which are copied last time.</li>
</ol>
<p> </p>
<p>Given a number <code>n</code>. You have to get exactly <code>n</code> 'A' on the notepad by performing the minimum number of steps permitted. Output the minimum number of steps to get <code>n</code> 'A'.</p>
<p>Example 1:</p>
<pre>Input: 3
Output: 3
Explanation:
Intitally, we have one character 'A'.
In step 1, we use Copy All operation.
In step 2, we use Paste operation to get 'AA'.
In step 3, we use Paste operation to get 'AAA'.
</pre>
<p> </p>
<p>Note:</p>
<ol>
<li>The <code>n</code> will be in the range [1, 1000].</li>
</ol>
<p> </p>
<p>这道题只给了我们两个按键，如果只能选择两个按键，那么博主一定会要复制和粘贴，此二键在手，天下我有！！！果然，这道题就是给了我们复制和粘贴这两个按键，然后给了我们了一个A，我们的目标时利用这两个键来打印出n个A，注意复制的时候时全部复制，不能选择部分来复制，然后复制和粘贴都算操作步骤，问我们打印出n个A需要多少步操作。对于这种有明显的递推特征的题，我们要有隐约的感觉，一定要尝试递归和DP。递归解法一般接近于暴力搜索，但是有时候是可以优化的，从而能够通过OJ。而一旦递归不行的话，那么一般来说DP这个大杀器都能解的。还有一点，对于这种题，找规律最重要，DP要找出递推公式，而如果无法发现内在的联系，那么递推公式就比较难写出来了。所以，我们需要从简单的例子开始分析，试图找规律：</p>
<p>当n = 1时，已经有一个A了，我们不需要其他操作，返回0</p>
<p>当n = 2时，我们需要复制一次，粘贴一次，返回2</p>
<p>当n = 3时，我们需要复制一次，粘贴两次，返回3</p>
<p>当n = 4时，这就有两种做法，一种是我们需要复制一次，粘贴三次，共4步，另一种是先复制一次，粘贴一次，得到AA，然后再复制一次，粘贴一次，得到AAAA，两种方法都是返回4</p>
<p>当n = 5时，我们需要复制一次，粘贴四次，返回5</p>
<p>当n = 6时，我们需要复制一次，粘贴两次，得到AAA，再复制一次，粘贴一次，得到AAAAAA，共5步，返回5</p>
<p>通过分析上面这6个简单的例子，我想我们已经可以总结出一些规律了，首先对于任意一个n(除了1以外)，我们最差的情况就是用n步，不会再多于n步，但是有可能是会小于n步的，比如n=6时，就只用了5步，仔细分析一下，发现时先拼成了AAA，再复制粘贴成了AAAAAA。那么什么情况下可以利用这种方法来减少步骤呢，分析发现，小模块的长度必须要能整除n，这样才能拆分。对于n=6，我们其实还可先拼出AA，然后再复制一次，粘贴两次，得到的还是5。分析到这里，我想解题的思路应该比较清晰了，我们要找出n的所有因子，然后这个因子可以当作模块的个数，我们再算出模块的长度n/i，调用递归，加上模块的个数i来更新结果res即可，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> minSteps(<span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        </span><span style="color: #0000ff;">if</span> (n == <span style="color: #800080;">1</span>) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> res =<span style="color: #000000;"> n;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = n - <span style="color: #800080;">1</span>; i &gt; <span style="color: #800080;">1</span>; --<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (n % i == <span style="color: #800080;">0</span><span style="color: #000000;">) {
                res </span>= min(res, minSteps(n / i) +<span style="color: #000000;"> i);
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种方法是用DP来做的，我们可以看出来，其实就是上面递归解法的迭代形式，思路没有任何区别，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> minSteps(<span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; dp(n + <span style="color: #800080;">1</span>, <span style="color: #800080;">0</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">2</span>; i &lt;= n; ++<span style="color: #000000;">i) {
            dp[i] </span>=<span style="color: #000000;"> i;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = i - <span style="color: #800080;">1</span>; j &gt; <span style="color: #800080;">1</span>; --<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> (i % j == <span style="color: #800080;">0</span><span style="color: #000000;">) {
                    dp[i] </span>= min(dp[i], dp[j] + i /<span style="color: #000000;"> j);
                }
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> dp[n];
    }
};</span></pre>
</div>
<p> </p>
<p>下面我们来看一种省空间的方法，我们不需要记录每一个中间值，而是通过改变n的值来实时累加结果res，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> minSteps(<span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">2</span>; i &lt;= n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">while</span> (n % i == <span style="color: #800080;">0</span><span style="color: #000000;">) {
                res </span>+=<span style="color: #000000;"> i;
                n </span>/=<span style="color: #000000;"> i;
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/97590/java-dp-solution">https://discuss.leetcode.com/topic/97590/java-dp-solution</a></p>
<p><a href="https://discuss.leetcode.com/topic/97623/loop-best-case-log-n-no-dp-no-extra-space-no-recursion-with-explanation">https://discuss.leetcode.com/topic/97623/loop-best-case-log-n-no-dp-no-extra-space-no-recursion-with-explanation</a></p>
</div>
<div id="interviewed-div"> </div>
<div id="cnblogs_post_body">
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p>
</div></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-08-27 09:27</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7439616" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7439616);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7439222.html" id="cb_post_title_url">[LeetCode] Dota2 Senate 刀塔二参议院</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>In the world of Dota2, there are two parties: the <code>Radiant</code> and the <code>Dire</code>.</p>
<p>The Dota2 senate consists of senators coming from two parties. Now the senate wants to make a decision about a change in the Dota2 game. The voting for this change is a round-based procedure. In each round, each senator can exercise <code>one</code> of the two rights:</p>
<ol>
<li><code>Ban one senator's right</code>: <br/>A senator can make another senator lose all his rights in this and all the following rounds.</li>
<li><code>Announce the victory</code>: <br/>If this senator found the senators who still have rights to vote are all from the same party, he can announce the victory and make the decision about the change in the game.</li>
</ol>
<p> </p>
<p>Given a string representing each senator's party belonging. The character 'R' and 'D' represent the <code>Radiant</code> party and the <code>Dire</code> party respectively. Then if there are <code>n</code> senators, the size of the given string will be <code>n</code>.</p>
<p>The round-based procedure starts from the first senator to the last senator in the given order. This procedure will last until the end of voting. All the senators who have lost their rights will be skipped during the procedure.</p>
<p>Suppose every senator is smart enough and will play the best strategy for his own party, you need to predict which party will finally announce the victory and make the change in the Dota2 game. The output should be <code>Radiant</code> or <code>Dire</code>.</p>
<p>Example 1:</p>
<pre>Input: "RD"
Output: "Radiant"
Explanation: The first senator comes from Radiant and he can just ban the next senator's right in the round 1. <br/>And the second senator can't exercise any rights any more since his right has been banned. <br/>And in the round 2, the first senator can just announce the victory since he is the only guy in the senate who can vote.
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input: "RDD"
Output: "Dire"
Explanation: 
The first senator comes from Radiant and he can just ban the next senator's right in the round 1. <br/>And the second senator can't exercise any rights anymore since his right has been banned. <br/>And the third senator comes from Dire and he can ban the first senator's right in the round 1. <br/>And in the round 2, the third senator can just announce the victory since he is the only guy in the senate who can vote.
</pre>
<p> </p>
<p>Note:</p>
<ol>
<li>The length of the given string will in the range [1, 10,000].</li>
</ol>
<p> </p>
<p>该来的总会来！！！自从上次LeetCode拿提莫出题<a href="http://www.cnblogs.com/grandyang/p/6399408.html">Teemo Attacking</a>后，我就知道刀塔早晚也难逃魔掌，这道题直接就搞起了刀塔二。不过话说如果你是从魔兽3无缝过渡到刀塔，那么应该熟悉了两个阵营的叫法，近卫和天灾。刀塔二里面不知道搞什么鬼，改成了光辉和梦魇，不管了，反正跟这道题的解法没什么关系。这道题模拟了刀塔类游戏开始之前的BP过程，两个阵营按顺序Ban掉对方的英雄，看最后谁剩下来了，就返回哪个阵营。那么博主能想到的简单暴力的方法就是先统计所有R和D的个数，然后从头开始遍历，如果遇到了R，就扫描之后所有的位置，然后还要扫描R前面的位置，这就要用到数组的环形遍历的知识了，其实就是坐标对总长度取余，使其不会越界，如果我们找到了下一个D，就将其标记为B，然后对应的计数器cntR自减1。对于D也是同样处理，我们的while循环的条件是cntR和cntD都要大于0，当有一个等于0了的话，那么推出循环，返回那个不为0的阵营即可，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> predictPartyVictory(<span style="color: #0000ff;">string</span><span style="color: #000000;"> senate) {
        </span><span style="color: #0000ff;">int</span> n = senate.size(), cntR = <span style="color: #800080;">0</span>, cntD = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span><span style="color: #000000;"> c : senate) {
            c </span>== <span style="color: #800000;">'</span><span style="color: #800000;">R</span><span style="color: #800000;">'</span> ? ++cntR : ++<span style="color: #000000;">cntD;
        }
        </span><span style="color: #0000ff;">if</span> (cntR == <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span> <span style="color: #800000;">"</span><span style="color: #800000;">Dire</span><span style="color: #800000;">"</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (cntD == <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span> <span style="color: #800000;">"</span><span style="color: #800000;">Radiant</span><span style="color: #800000;">"</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (cntR &gt; <span style="color: #800080;">0</span> &amp;&amp; cntD &gt; <span style="color: #800080;">0</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
                </span><span style="color: #0000ff;">if</span> (senate[i] == <span style="color: #800000;">'</span><span style="color: #800000;">R</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = i + <span style="color: #800080;">1</span>; j &lt; i + n; ++<span style="color: #000000;">j) {
                        </span><span style="color: #0000ff;">if</span> (senate[j % n] == <span style="color: #800000;">'</span><span style="color: #800000;">D</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                            senate[j </span>% n] = <span style="color: #800000;">'</span><span style="color: #800000;">B</span><span style="color: #800000;">'</span><span style="color: #000000;">;
                            </span>--<span style="color: #000000;">cntD;
                            </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                        }
                    }
                } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (senate[i] == <span style="color: #800000;">'</span><span style="color: #800000;">D</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = i + <span style="color: #800080;">1</span>; j &lt; i + n; ++<span style="color: #000000;">j) {
                        </span><span style="color: #0000ff;">if</span> (senate[j % n] == <span style="color: #800000;">'</span><span style="color: #800000;">R</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                            senate[j </span>% n] = <span style="color: #800000;">'</span><span style="color: #800000;">B</span><span style="color: #800000;">'</span><span style="color: #000000;">;
                            </span>--<span style="color: #000000;">cntR;
                            </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                        }
                    }
                }
            }
        }
        </span><span style="color: #0000ff;">return</span> cntR != <span style="color: #800080;">0</span> ? <span style="color: #800000;">"</span><span style="color: #800000;">Radiant</span><span style="color: #800000;">"</span> : <span style="color: #800000;">"</span><span style="color: #800000;">Dire</span><span style="color: #800000;">"</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>上面的暴力搜索的方法略显复杂，我们其实有更好的方法来做，我们可以用两个队列queue，把各自阵营的位置存入不同的队列里面，然后进行循环，每次从两个队列各取一个位置出来，看其大小关系，小的那个说明在前面，就可以把后面的那个Ban掉，所以我们要把小的那个位置要加回队列里面，但是不能直接加原位置，因为下一轮才能再轮到他来Ban，所以我们要加上一个n，再排入队列。这样当某个队列为空时，推出循环，我们返回不为空的那个阵营，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> predictPartyVictory(<span style="color: #0000ff;">string</span><span style="color: #000000;"> senate) {
        </span><span style="color: #0000ff;">int</span> n =<span style="color: #000000;"> senate.size();
        queue</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> q1, q2;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            (senate[i] </span>== <span style="color: #800000;">'</span><span style="color: #800000;">R</span><span style="color: #800000;">'</span>) ?<span style="color: #000000;"> q1.push(i) : q2.push(i);
        }
        </span><span style="color: #0000ff;">while</span> (!q1.empty() &amp;&amp; !<span style="color: #000000;">q2.empty()) {
            </span><span style="color: #0000ff;">int</span> i =<span style="color: #000000;"> q1.front(); q1.pop();
            </span><span style="color: #0000ff;">int</span> j =<span style="color: #000000;"> q2.front(); q2.pop();
            (i </span>&lt; j) ? q1.push(i + n) : q2.push(j +<span style="color: #000000;"> n);
        }
        </span><span style="color: #0000ff;">return</span> (q1.size() &gt; q2.size()) ? <span style="color: #800000;">"</span><span style="color: #800000;">Radiant</span><span style="color: #800000;">"</span> : <span style="color: #800000;">"</span><span style="color: #800000;">Dire</span><span style="color: #800000;">"</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/6399408.html">Teemo Attacking</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/97671/java-c-very-simple-greedy-solution-with-explanation">https://discuss.leetcode.com/topic/97671/java-c-very-simple-greedy-solution-with-explanation</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-08-27 07:17</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7439222" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7439222);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7423420.html" id="cb_post_title_url">[LeetCode] Replace Words 替换单词</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="question-description">
<p>In English, we have a concept called <code>root</code>, which can be followed by some other words to form another longer word - let's call this word <code>successor</code>. For example, the root <code>an</code>, followed by <code>other</code>, which can form another word <code>another</code>.</p>
<p>Now, given a dictionary consisting of many roots and a sentence. You need to replace all the <code>successor</code> in the sentence with the <code>root</code> forming it. If a <code>successor</code> has many <code>roots</code> can form it, replace it with the root with the shortest length.</p>
<p>You need to output the sentence after the replacement.</p>
<p>Example 1:</p>
<pre>Input: dict = ["cat", "bat", "rat"]
sentence = "the cattle was rattled by the battery"
Output: "the cat was rat by the bat"
</pre>
<p> </p>
<p>Note:</p>
<ol>
<li>The input will only have lower-case letters.</li>
<li>1 &lt;= dict words number &lt;= 1000</li>
<li>1 &lt;= sentence words number &lt;= 1000</li>
<li>1 &lt;= root length &lt;= 100</li>
<li>1 &lt;= sentence words length &lt;= 1000</li>
</ol>
<p> </p>
<p>这道题给了我们一个前缀字典，又给了一个句子，让我们将句子中较长的单词换成其前缀(如果在前缀字典中存在的话)。我们对于句子中的一个长单词如何找前缀呢，是不是可以根据第一个字母来快速定位呢，比如cattle这个单词的首字母是c，那么我们在前缀字典中找所有开头是c的前缀，为了方便查找，我们将首字母相同的前缀都放到同一个数组中，总共需要26个数组，所以我们可以定义一个二维数组来装这些前缀。还有，我们希望短前缀在长前缀的前面，因为题目中要求用最短的前缀来替换单词，所以我们可以先按单词的长度来给所有的前缀排序，然后再依次加入对应的数组中，这样就可以保证短的前缀在前面。</p>
<p>下面我们就要来遍历句子中的每一个单词了，由于C++中没有split函数，所以我们就采用字符串流来提取每一个单词，对于遍历到的单词，我们根据其首字母查找对应数组中所有以该首字母开始的前缀，然后直接用substr函数来提取单词中和前缀长度相同的子字符串来跟前缀比较，如果二者相等，说明可以用前缀来替换单词，然后break掉for循环。别忘了单词之前还要加上空格，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> replaceWords(vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp; dict, <span style="color: #0000ff;">string</span><span style="color: #000000;"> sentence) {
        </span><span style="color: #0000ff;">string</span> res = <span style="color: #800000;">""</span>, t = <span style="color: #800000;">""</span><span style="color: #000000;">;
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">string</span>&gt;&gt; v(<span style="color: #800080;">26</span><span style="color: #000000;">);
        istringstream </span><span style="color: #0000ff;">is</span><span style="color: #000000;">(sentence);
        sort(dict.begin(), dict.end(), [](</span><span style="color: #0000ff;">string</span> &amp;a, <span style="color: #0000ff;">string</span> &amp;b) {<span style="color: #0000ff;">return</span> a.size() &lt;<span style="color: #000000;"> b.size();});
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">string</span><span style="color: #000000;"> word : dict) {
            v[word[</span><span style="color: #800080;">0</span>] - <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span><span style="color: #000000;">].push_back(word);
        }
        </span><span style="color: #0000ff;">while</span> (<span style="color: #0000ff;">is</span> &gt;&gt;<span style="color: #000000;"> t) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">string</span> word : v[t[<span style="color: #800080;">0</span>] - <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span><span style="color: #000000;">]) {
                </span><span style="color: #0000ff;">if</span> (t.substr(<span style="color: #800080;">0</span>, word.size()) ==<span style="color: #000000;"> word) {
                    t </span>=<span style="color: #000000;"> word;
                    </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                }
            }
            res </span>+= t + <span style="color: #800000;">"</span> <span style="color: #800000;">"</span><span style="color: #000000;">;
        }
        res.pop_back();
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>你以为想出了上面的解法，这道题就算做完了？? Naive! ! ! 这道题最好的解法其实是用前缀树(Trie / Prefix Tree)来做，关于前缀树使用之前有一道很好的入门题<a href="http://www.cnblogs.com/grandyang/p/4491665.html" target="_blank">Implement Trie (Prefix Tree)</a>。了解了前缀树的原理机制，那么我们就可以发现这道题其实很适合前缀树的特点。我们要做的就是把所有的前缀都放到前缀树里面，而且在前缀的最后一个结点的地方将标示isWord设为true，表示从根节点到当前结点是一个前缀，然后我们在遍历单词中的每一个字母，我们都在前缀树查找，如果当前字母对应的结点的表示isWord是true，我们就返回这个前缀，如果当前字母对应的结点在前缀树中不存在，我们就返回原单词，这样就能完美的解决问题了。所以啊，以后遇到了有关前缀或者类似的问题，一定不要忘了前缀树这个神器哟～</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">class</span><span style="color: #000000;"> TrieNode {
    </span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
        </span><span style="color: #0000ff;">bool</span><span style="color: #000000;"> isWord;
        TrieNode </span>*child[<span style="color: #800080;">26</span><span style="color: #000000;">];
        TrieNode(): isWord(</span><span style="color: #0000ff;">false</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">for</span> (auto &amp;a : child) a =<span style="color: #000000;"> NULL;
        }
    };
    
    </span><span style="color: #0000ff;">string</span> replaceWords(vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp; dict, <span style="color: #0000ff;">string</span><span style="color: #000000;"> sentence) {
        </span><span style="color: #0000ff;">string</span> res = <span style="color: #800000;">""</span>, t = <span style="color: #800000;">""</span><span style="color: #000000;">;
        istringstream </span><span style="color: #0000ff;">is</span><span style="color: #000000;">(sentence);
        TrieNode </span>*root = <span style="color: #0000ff;">new</span><span style="color: #000000;"> TrieNode();
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">string</span><span style="color: #000000;"> word : dict) {
            insert(root, word);
        }
        </span><span style="color: #0000ff;">while</span> (<span style="color: #0000ff;">is</span> &gt;&gt;<span style="color: #000000;"> t) {
            </span><span style="color: #0000ff;">if</span> (!res.empty()) res += <span style="color: #800000;">"</span> <span style="color: #800000;">"</span><span style="color: #000000;">;
            res </span>+=<span style="color: #000000;"> findPrefix(root, t);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    
    </span><span style="color: #0000ff;">void</span> insert(TrieNode* node, <span style="color: #0000ff;">string</span><span style="color: #000000;"> word) {
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span><span style="color: #000000;"> c : word) {
            </span><span style="color: #0000ff;">if</span> (!node-&gt;child[c - <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span>]) node-&gt;child[c - <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span>] = <span style="color: #0000ff;">new</span><span style="color: #000000;"> TrieNode();
            node </span>= node-&gt;child[c - <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span><span style="color: #000000;">];
        }
        node</span>-&gt;isWord = <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
    
    </span><span style="color: #0000ff;">string</span> findPrefix(TrieNode* node, <span style="color: #0000ff;">string</span><span style="color: #000000;"> word) {
        </span><span style="color: #0000ff;">string</span> cur = <span style="color: #800000;">""</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span><span style="color: #000000;"> c : word) {
            </span><span style="color: #0000ff;">if</span> (!node-&gt;child[c - <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span>]) <span style="color: #0000ff;">break</span><span style="color: #000000;">;
            cur.push_back(c);
            node </span>= node-&gt;child[c - <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span><span style="color: #000000;">];
            </span><span style="color: #0000ff;">if</span> (node-&gt;isWord) <span style="color: #0000ff;">return</span><span style="color: #000000;"> cur;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> word;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4491665.html" target="_blank">Implement Trie (Prefix Tree)</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/97203/trie-tree-concise-java-solution-easy-to-understand">https://discuss.leetcode.com/topic/97203/trie-tree-concise-java-solution-easy-to-understand</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p>
</div></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-08-24 15:39</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7423420" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7423420);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7404777.html" id="cb_post_title_url">[LeetCode] Palindromic Substrings 回文子字符串</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a string, your task is to count how many palindromic substrings in this string.</p>
<p>The substrings with different start indexes or end indexes are counted as different substrings even they consist of same characters.</p>
<p>Example 1:</p>
<pre>Input: "abc"
Output: 3
Explanation: Three palindromic strings: "a", "b", "c".
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input: "aaa"
Output: 6
Explanation: Six palindromic strings: "a", "a", "a", "aa", "aa", "aaa".
</pre>
<p> </p>
<p>Note:</p>
<ol>
<li>The input string length won't exceed 1000.</li>
</ol>
<p> </p>
<p>这道题给了我们一个字符串，让我们计算有多少个回文子字符串。博主看到这个题，下意识的想着应该是用DP来做，哼哼哧哧写了半天，修修补补，终于通过了，但是博主写的DP不是最简便的方法，略显复杂，这里就不贴了。还是直接讲解大神们的解法好了。其实这道题也可以用递归来做，而且思路非常的简单粗暴。就是以字符串中的每一个字符都当作回文串中间的位置，然后向两边扩散，每当成功匹配两个左右两个字符，结果res自增1，然后再比较下一对。注意回文字符串有奇数和偶数两种形式，如果是奇数长度，那么i位置就是中间那个字符的位置，所以我们左右两遍都从i开始遍历；如果是偶数长度的，那么i是最中间两个字符的左边那个，右边那个就是i+1，这样就能cover所有的情况啦，而且都是不同的回文子字符串，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> countSubstrings(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        </span><span style="color: #0000ff;">if</span> (s.empty()) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> n = s.size(), res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            helper(s, i, i, res);
            helper(s, i, i </span>+ <span style="color: #800080;">1</span><span style="color: #000000;">, res);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">void</span> helper(<span style="color: #0000ff;">string</span> s, <span style="color: #0000ff;">int</span> i, <span style="color: #0000ff;">int</span> j, <span style="color: #0000ff;">int</span>&amp;<span style="color: #000000;"> res) {
        </span><span style="color: #0000ff;">while</span> (i &gt;= <span style="color: #800080;">0</span> &amp;&amp; j &lt; s.size() &amp;&amp; s[i] ==<span style="color: #000000;"> s[j]) {
            </span>--i; ++j; ++<span style="color: #000000;">res;
        }
    }
};</span></pre>
</div>
<p> </p>
<p>在刚开始的时候博主提到了自己写的DP的方法比较复杂，为什么呢，因为博主的dp[i][j]定义的是范围[i, j]之间的子字符串的个数，这样我们其实还需要一个二维数组来记录子字符串[i, j]是否是回文串，那么我们直接就将dp[i][j]定义成子字符串[i, j]是否是回文串就行了，然后我们i从n-1往0遍历，j从i往n-1遍历，然后我们看s[i]和s[j]是否相等，这时候我们需要留意一下，有了s[i]和s[j]相等这个条件后，i和j的位置关系很重要，如果i和j相等了，那么dp[i][j]肯定是true；如果i和j是相邻的，那么dp[i][j]也是true；如果i和j中间只有一个字符，那么dp[i][j]还是true；如果中间有多余一个字符存在，那么我们需要看dp[i+1][j-1]是否为true，若为true，那么dp[i][j]就是true。赋值dp[i][j]后，如果其为true，结果res自增1，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> countSubstrings(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        </span><span style="color: #0000ff;">int</span> n = s.size(), res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">bool</span>&gt;&gt; dp(n, vector&lt;<span style="color: #0000ff;">bool</span>&gt;(n, <span style="color: #0000ff;">false</span><span style="color: #000000;">));
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = n - <span style="color: #800080;">1</span>; i &gt;= <span style="color: #800080;">0</span>; --<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = i; j &lt; n; ++<span style="color: #000000;">j) {
                dp[i][j] </span>= (s[i] == s[j]) &amp;&amp; (j - i &lt;= <span style="color: #800080;">2</span> || dp[i + <span style="color: #800080;">1</span>][j - <span style="color: #800080;">1</span><span style="color: #000000;">]);
                </span><span style="color: #0000ff;">if</span> (dp[i][j]) ++<span style="color: #000000;">res;
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/6493182.html">Longest Palindromic Subsequence</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4464476.html" target="_blank">Longest Palindromic Substring</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/96819/java-solution-8-lines-extendpalindrome">https://discuss.leetcode.com/topic/96819/java-solution-8-lines-extendpalindrome</a></p>
<p><a href="https://discuss.leetcode.com/topic/96884/very-simple-java-solution-with-detail-explanation">https://discuss.leetcode.com/topic/96884/very-simple-java-solution-with-detail-explanation</a></p>
<p><a href="https://discuss.leetcode.com/topic/96821/java-dp-solution-based-on-longest-palindromic-substring">https://discuss.leetcode.com/topic/96821/java-dp-solution-based-on-longest-palindromic-substring</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-08-21 15:44</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7404777" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7404777);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7381633.html" id="cb_post_title_url">[LeetCode] Maximum Length of Pair Chain 链对的最大长度</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>You are given <code>n</code> pairs of numbers. In every pair, the first number is always smaller than the second number.</p>
<p>Now, we define a pair <code>(c, d)</code> can follow another pair <code>(a, b)</code> if and only if <code>b &lt; c</code>. Chain of pairs can be formed in this fashion.</p>
<p>Given a set of pairs, find the length longest chain which can be formed. You needn't use up all the given pairs. You can select pairs in any order.</p>
<p>Example 1:</p>
<pre>Input: [[1,2], [2,3], [3,4]]
Output: 2
Explanation: The longest chain is [1,2] -&gt; [3,4]
</pre>
<p> </p>
<p>Note:</p>
<ol>
<li>The number of given pairs will be in the range [1, 1000].</li>
</ol>
<p> </p>
<p>这道题给了我们一些链对，规定了如果后面链对的首元素大于前链对的末元素，那么这两个链对就可以链起来，问我们最大能链多少个。那么我们想，由于规定了链对的首元素一定小于尾元素，我们需要比较的是某个链表的首元素和另一个链表的尾元素之间的关系，如果整个链对数组是无序的，那么就很麻烦，所以我们需要做的是首先对链对数组进行排序，按链对的尾元素进行排序，小的放前面。这样我们就可以利用Greedy算法进行求解了。我们可以用一个栈，先将第一个链对压入栈，然后对于后面遍历到的每一个链对，我们看其首元素是否大于栈顶链对的尾元素，如果大于的话，就将当前链对压入栈，这样最后我们返回栈中元素的个数即可，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> findLongestChain(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> pairs) {
        stack</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;<span style="color: #000000;"> st;
        sort(pairs.begin(), pairs.end(), [](vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;&amp; a, vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> b) {
            </span><span style="color: #0000ff;">return</span> a[<span style="color: #800080;">1</span>] &lt; b[<span style="color: #800080;">1</span><span style="color: #000000;">];
        });
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto pair : pairs) {
            </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (st.empty()) st.push(pair);
            </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                auto t </span>=<span style="color: #000000;"> st.top();
                </span><span style="color: #0000ff;">if</span> (pair[<span style="color: #800080;">0</span>] &gt; t[<span style="color: #800080;">1</span><span style="color: #000000;">]) st.push(pair);
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> st.size();
    }
};</span></pre>
</div>
<p> </p>
<p>我们可以对上面解法的空间进行优化，并不需要用栈来记录最长链上的每一个链对。而是用一个变量end来记录当前比较到的尾元素的值，初始化为最小值，然后遍历的时候，如果当前链对的首元素大于end，那么结果res自增1，end更新为当前链对的尾元素，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> findLongestChain(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> pairs) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, end =<span style="color: #000000;"> INT_MIN;
        sort(pairs.begin(), pairs.end(), [](vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;&amp; a, vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> b) {
            </span><span style="color: #0000ff;">return</span> a[<span style="color: #800080;">1</span>] &lt; b[<span style="color: #800080;">1</span><span style="color: #000000;">];
        });
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto pair : pairs) {
            </span><span style="color: #0000ff;">if</span> (pair[<span style="color: #800080;">0</span>] &gt;<span style="color: #000000;"> end) {
                </span>++<span style="color: #000000;">res;
                end </span>= pair[<span style="color: #800080;">1</span><span style="color: #000000;">];
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>这道题论坛上最火的解法是用DP来做的，但是博主认为Greedy能解的就没有必要利用到DP，而且还不省空间，有点杀鸡用牛刀的感觉。不过话说这道题链来链去，为啥会让博主想到啥啥蜈蚣啊，什么鬼。。。</p>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/6388103.html">Increasing Subsequences</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4938187.html">Longest Increasing Subsequence</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/6017505.html">Non-overlapping Intervals</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/96966/earliest-deadline-first-algorithm-greedy-same-as-maximum-jobs-we-can-accomplish" target="_blank">https://discuss.leetcode.com/topic/96966/earliest-deadline-first-algorithm-greedy-same-as-maximum-jobs-we-can-accomplish</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-08-17 14:51</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7381633" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7381633);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7324242.html" id="cb_post_title_url">[LeetCode] Set Mismatch 设置不匹配</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>The set <code>S</code> originally contains numbers from 1 to <code>n</code>. But unfortunately, due to the data error, one of the numbers in the set got duplicated to another number in the set, which results in repetition of one number and loss of another number.</p>
<p>Given an array <code>nums</code> representing the data status of this set after the error. Your task is to firstly find the number occurs twice and then find the number that is missing. Return them in the form of an array.</p>
<p>Example 1:</p>
<pre>Input: nums = [1,2,2,4]
Output: [2,3]
</pre>
<p> </p>
<p>Note:</p>
<ol>
<li>The given array size will in the range [2, 10000].</li>
<li>The given array's numbers won't have any order.</li>
</ol>
<p> </p>
<p>这道题给了我们一个长度为n的数组，说里面的数字是从1到n，但是有一个数字重复出现了一次，从而造成了另一个数字的缺失，让我们找出重复的数字和缺失的数字。那么最直接的一种解法就是统计每个数字出现的次数了，然后再遍历次数数组，如果某个数字出现了两次就是重复数，如果出现了0次，就是缺失数，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; findErrorNums(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; res(<span style="color: #800080;">2</span>, <span style="color: #800080;">0</span>), cnt(nums.size(), <span style="color: #800080;">0</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> num : nums) ++cnt[num - <span style="color: #800080;">1</span><span style="color: #000000;">];
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; cnt.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (res[<span style="color: #800080;">0</span>] != <span style="color: #800080;">0</span> &amp;&amp; res[<span style="color: #800080;">1</span>] != <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
            </span><span style="color: #0000ff;">if</span> (cnt[i] == <span style="color: #800080;">2</span>) res[<span style="color: #800080;">0</span>] = i + <span style="color: #800080;">1</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (cnt[i] == <span style="color: #800080;">0</span>) res[<span style="color: #800080;">1</span>] = i + <span style="color: #800080;">1</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>我们来看一种更省空间的解法，这种解法思路相当巧妙，遍历每个数字，然后将其应该出现的位置上的数字变为其相反数，这样如果我们再变为其相反数之前已经成负数了，说明该数字是重复数，将其将入结果res中，然后再遍历原数组，如果某个位置上的数字为正数，说明该位置对应的数字没有出现过，加入res中即可，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; findErrorNums(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; res(<span style="color: #800080;">2</span>, -<span style="color: #800080;">1</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span><span style="color: #000000;"> i : nums) {
            </span><span style="color: #0000ff;">if</span> (nums[abs(i) - <span style="color: #800080;">1</span>] &lt; <span style="color: #800080;">0</span>) res[<span style="color: #800080;">0</span>] =<span style="color: #000000;"> abs(i);
            </span><span style="color: #0000ff;">else</span> nums[abs(i) - <span style="color: #800080;">1</span>] *= -<span style="color: #800080;">1</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; nums.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (nums[i] &gt; <span style="color: #800080;">0</span>) res[<span style="color: #800080;">1</span>] = i + <span style="color: #800080;">1</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种方法也很赞，首先我们把乱序的数字放到其正确的位置上，用while循环来不停的放，直到该数字在正确的位置上，那么一旦数组有序了，我们只要从头遍历就能直接找到重复的数字，然后缺失的数字同样也就知道了，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; findErrorNums(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; nums.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">while</span> (nums[i] != nums[nums[i] - <span style="color: #800080;">1</span>]) swap(nums[i], nums[nums[i] - <span style="color: #800080;">1</span><span style="color: #000000;">]);
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; nums.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (nums[i] != i + <span style="color: #800080;">1</span>) <span style="color: #0000ff;">return</span> {nums[i], i + <span style="color: #800080;">1</span><span style="color: #000000;">};
        }
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4843654.html" target="_blank">Find the Duplicate Number</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/96808/java-o-n-time-o-1-space" target="_blank">https://discuss.leetcode.com/topic/96808/java-o-n-time-o-1-space</a></p>
<p><a href="https://discuss.leetcode.com/topic/97091/c-6-lines-solution-with-explanation" target="_blank">https://discuss.leetcode.com/topic/97091/c-6-lines-solution-with-explanation</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-08-09 11:17</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7324242" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7324242);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/8021421.html" id="cb_post_title_url">[LeetCode] Maximum Average Subarray II 子数组的最大平均值之二</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given an array consisting of <code>n</code> integers, find the contiguous subarray whose length is greater than or equal to <code>k</code> that has the maximum average value. And you need to output the maximum average value.</p>
<p>Example 1:</p>
<pre>Input: [1,12,-5,-6,50,3], k = 4
Output: 12.75
Explanation:
when length is 5, maximum average value is 10.8,
when length is 6, maximum average value is 9.16667.
Thus return 12.75.
</pre>
<p> </p>
<p>Note:</p>
<ol>
<li>1 &lt;= <code>k</code> &lt;= <code>n</code> &lt;= 10,000.</li>
<li>Elements of the given array will be in range [-10,000, 10,000].</li>
<li>The answer with the calculation error less than 10-5 will be accepted.</li>
</ol>
<p> </p>
<p>这道题是之前那道<a href="http://www.cnblogs.com/grandyang/p/7294585.html" target="_blank">Maximum Average Subarray I</a>的拓展，那道题说是要找长度为k的子数组的最大平均值，而这道题要找长度大于等于k的子数组的最大平均值。加了个大于k的条件，那么情况就复杂很多了，之前只要遍历所有长度为k的子数组就行了，现在还要包括所有长度大于k的子数组。我们首先来看brute force的方法，就是遍历所有的长度大于等于k的子数组，并计算平均值并更新结果res。那么我们先建立累加和数组sums，结果res初始化为前k个数字的平均值，然后让i从k+1个数字开始遍历，那么此时的sums[i]就是前k+1个数组组成的子数组之和，我们用其平均数来更新结果res，然后要做的就是从开头开始去掉数字，直到子数组剩余k个数字为止，然后用其平均值来更新解结果res，通过这种方法，我们就遍历了所有长度大于等于k的子数组。这里需要注意的一点是，更新结果res的步骤不能写成res = min(res, t / (i + 1)) 这种形式，会TLE，必须要在if中判断 t &gt; res * (i + 1) 才能accept，写成t / (i + 1) &gt; res 也不行，必须要用乘法，这也说明了计算机不喜欢算除法吧，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">double</span> findMaxAverage(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; nums, <span style="color: #0000ff;">int</span><span style="color: #000000;"> k) {
        </span><span style="color: #0000ff;">int</span> n =<span style="color: #000000;"> nums.size();
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; sums =<span style="color: #000000;"> nums;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt; n; ++<span style="color: #000000;">i) {
            sums[i] </span>= sums[i - <span style="color: #800080;">1</span>] +<span style="color: #000000;"> nums[i];
        }
        </span><span style="color: #0000ff;">double</span> res = (<span style="color: #0000ff;">double</span>)sums[k - <span style="color: #800080;">1</span>] /<span style="color: #000000;"> k;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = k; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">double</span> t =<span style="color: #000000;"> sums[i];
            </span><span style="color: #0000ff;">if</span> (t &gt; res * (i + <span style="color: #800080;">1</span>)) res = t / (i + <span style="color: #800080;">1</span><span style="color: #000000;">);
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = i - k; j &gt;= <span style="color: #800080;">0</span>; --<span style="color: #000000;">j) {
                t </span>= sums[i] -<span style="color: #000000;">  sums[j];
                </span><span style="color: #0000ff;">if</span> (t &gt; res * (i - j)) res = t / (i -<span style="color: #000000;"> j);
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>我们再来看一种O(n<sup>2</sup>)时间复杂度的方法，这里对上面的解法进行了空间上的优化，并没有长度为n数组，而是使用了preSum和sum两个变量来代替，preSum初始化为前k个数字之和，sum初始化为preSum，结果res初始化为前k个数字的平均值，然后从第k+1个数字开始遍历，首先preSum加上这个数字，sum更新为preSum，然后此时用当前k+1个数字的平均值来更新结果res。和上面的方法一样，我们还是要从开头开始去掉数字，直到子数组剩余k个数字为止，然后用其平均值来更新解结果res，那么每次就用sum减去nums[j]，就可以不断的缩小子数组的长度了，用当前平均值更新结果res，注意还是要用乘法来判断大小，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">double</span> findMaxAverage(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; nums, <span style="color: #0000ff;">int</span><span style="color: #000000;"> k) {
        </span><span style="color: #0000ff;">double</span> preSum = accumulate(nums.begin(), nums.begin() + k, <span style="color: #800080;">0</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">double</span> sum = preSum, res = preSum /<span style="color: #000000;"> k;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = k; i &lt; nums.size(); ++<span style="color: #000000;">i) {
            preSum </span>+=<span style="color: #000000;"> nums[i];
            sum </span>=<span style="color: #000000;"> preSum;
            </span><span style="color: #0000ff;">if</span> (sum &gt; res * (i + <span style="color: #800080;">1</span>)) res = sum / (i + <span style="color: #800080;">1</span><span style="color: #000000;">);
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt;= i - k; ++<span style="color: #000000;">j) {
                sum </span>-=<span style="color: #000000;"> nums[j];
                </span><span style="color: #0000ff;">if</span> (sum &gt; res * (i - j)) res = sum / (i -<span style="color: #000000;"> j);
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>下面来看一种优化时间复杂度到O(nlg(max - min))的解法，其中max和min分别是数组中的最大值和最小值，是利用了二分搜索法，博主之前写了一篇<a data-ctbtn="0" data-cthref="/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;ved=0ahUKEwjtjZeBuYDYAhXikOAKHYHPAaAQFggqMAA&amp;url=http%3A%2F%2Fwww.cnblogs.com%2Fgrandyang%2Fp%2F6854825.html&amp;usg=AOvVaw1vzLoPulVw-9V5ExEOqnas" href="https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;ved=0ahUKEwjtjZeBuYDYAhXikOAKHYHPAaAQFggqMAA&amp;url=http%3A%2F%2Fwww.cnblogs.com%2Fgrandyang%2Fp%2F6854825.html&amp;usg=AOvVaw1vzLoPulVw-9V5ExEOqnas">LeetCode Binary Search Summary 二分搜索法小结</a>的博客，这里的二分法应该是小结的第四类，也是最难的那一类，因为判断折半的方向是一个子函数，这里我们没有用子函数，而是写到了一起，可以抽出来成为一个子函数，这一类的特点就是不再是简单的大小比较，而是需要一些复杂的操作来确定折半方向。这里主要借鉴了<a href="https://discuss.leetcode.com/topic/96228/c-clean-binary-search-solution-with-explanation" target="_blank">蔡文森特大神的帖子</a>，所求的最大平均值一定是介于原数组的最大值和最小值之间，所以我们的目标是用二分法来快速的在这个范围内找到我们要求的最大平均值，初始化left为原数组的最小值，right为原数组的最大值，然后mid就是left和right的中间值，难点就在于如何得到mid和要求的最大平均值之间的大小关系，从而判断折半方向。我们想，如果我们已经算出来了这个最大平均值maxAvg，那么对于任意一个长度大于等于k的数组，如果让每个数字都减去maxAvg，那么得到的累加差值一定是小于等于0的，这个不难理解，比如下面这个数组：</p>
<p>[1, 2, 3, 4]   k = 2</p>
<p>我们一眼就可以看出来最大平均值maxAvg = 3.5，所以任何一个长度大于等于2的子数组每个数字都减去maxAvg的差值累加起来都小于等于0，只有产生这个最大平均值的子数组[3, 4]，算出来才正好等于0，其他都是小于0的。那么我们可以根据这个特点来确定折半方向，我们通过left和right值算出来的mid，可以看作是maxAvg的一个candidate，所以我们就让数组中的每一个数字都减去mid，然后算差值的累加和，一旦发现累加和大于0了，那么说明我们mid比maxAvg小，这样就可以判断方向了。</p>
<p>我们建立一个累加和数组sums，然后求出原数组中最小值赋给left，最大值赋给right，题目中说了误差是1e-5，所以我们的循环条件就是right比left大1e-5，然后我们算出来mid，定义一个minSum初始化为0，布尔型变量check，初始化为false。然后开始遍历数组，先更新累加和数组sums，注意这个累加和数组不是原始数字的累加，而是它们和mid相减的差值累加。我们的目标是找长度大于等于k的子数组的平均值大于mid，由于我们每个数组都减去了mid，那么就转换为找长度大于等于k的子数组的差累积值大于0。我们建立差值累加数组的意义就在于通过sums[i] - sums[j]来快速算出j和i位置中间数字之和，那么我们只要j和i中间正好差k个数字即可，然后minSum就是用来保存j位置之前的子数组差累积的最小值，所以当i &gt;= k时，我们用sums[i - k]来更新minSum，这里的i - k就是j的位置，然后判断如果sums[i] - minSum &gt; 0了，说明我们找到了一段长度大于等k的子数组平均值大于mid了，就可以更新left为mid了，我们标记check为true，并退出循环。在for循环外面，当check为true的时候，left更新为mid，否则right更新为mid，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">double</span> findMaxAverage(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; nums, <span style="color: #0000ff;">int</span><span style="color: #000000;"> k) {
        </span><span style="color: #0000ff;">int</span> n =<span style="color: #000000;"> nums.size();
        vector</span>&lt;<span style="color: #0000ff;">double</span>&gt; sums(n + <span style="color: #800080;">1</span>, <span style="color: #800080;">0</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">double</span> left = *<span style="color: #000000;">min_element(nums.begin(), nums.end());
        </span><span style="color: #0000ff;">double</span> right = *<span style="color: #000000;">max_element(nums.begin(), nums.end());
        </span><span style="color: #0000ff;">while</span> (right - left &gt; 1e-<span style="color: #800080;">5</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">double</span> minSum = <span style="color: #800080;">0</span>, mid = left + (right - left) / <span style="color: #800080;">2</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">bool</span> check = <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt;= n; ++<span style="color: #000000;">i) {
                sums[i] </span>= sums[i - <span style="color: #800080;">1</span>] + nums[i - <span style="color: #800080;">1</span>] -<span style="color: #000000;"> mid;
                </span><span style="color: #0000ff;">if</span> (i &gt;=<span style="color: #000000;"> k) {
                    minSum </span>= min(minSum, sums[i -<span style="color: #000000;"> k]);
                }
                </span><span style="color: #0000ff;">if</span> (i &gt;= k &amp;&amp; sums[i] &gt; minSum) {check = <span style="color: #0000ff;">true</span>; <span style="color: #0000ff;">break</span><span style="color: #000000;">;} 
            }
            </span><span style="color: #0000ff;">if</span> (check) left =<span style="color: #000000;"> mid;
            </span><span style="color: #0000ff;">else</span> right =<span style="color: #000000;"> mid;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> left;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种解法对上面的方法优化了空间复杂度 ，使用preSum和sum来代替数组，思路和上面完全一样，可以参加上面的讲解，注意这里我们的第二个if中是判断i &gt;= k - 1，而上面的方法是判断i &gt;= k，这是因为上面的sums数组初始化了n + 1个元素，注意坐标的转换，而第一个if中i &gt;= k不变是因为j和i之间就差了k个，所以不需要考虑坐标的转换，参见代码如下：</p>
<p> </p>
<p>解法四：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">double</span> findMaxAverage(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; nums, <span style="color: #0000ff;">int</span><span style="color: #000000;"> k) {
        </span><span style="color: #0000ff;">double</span> left = *<span style="color: #000000;">min_element(nums.begin(), nums.end());
        </span><span style="color: #0000ff;">double</span> right = *<span style="color: #000000;">max_element(nums.begin(), nums.end());
        </span><span style="color: #0000ff;">while</span> (right - left &gt; 1e-<span style="color: #800080;">5</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">double</span> minSum = <span style="color: #800080;">0</span>, sum = <span style="color: #800080;">0</span>, preSum = <span style="color: #800080;">0</span>, mid = left + (right - left) / <span style="color: #800080;">2</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">bool</span> check = <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; nums.size(); ++<span style="color: #000000;">i) {
                sum </span>+= nums[i] -<span style="color: #000000;"> mid;
                </span><span style="color: #0000ff;">if</span> (i &gt;=<span style="color: #000000;"> k) {
                    preSum </span>+= nums[i - k] -<span style="color: #000000;"> mid;
                    minSum </span>=<span style="color: #000000;"> min(minSum, preSum);
                }
                </span><span style="color: #0000ff;">if</span> (i &gt;= k - <span style="color: #800080;">1</span> &amp;&amp; sum &gt; minSum) {check = <span style="color: #0000ff;">true</span>; <span style="color: #0000ff;">break</span><span style="color: #000000;">;}
            }
            </span><span style="color: #0000ff;">if</span> (check) left =<span style="color: #000000;"> mid;
            </span><span style="color: #0000ff;">else</span> right =<span style="color: #000000;"> mid;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> left;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/7294585.html" target="_blank">Maximum Average Subarray I</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/96095/c-solution-o-n-2/2">https://discuss.leetcode.com/topic/96095/c-solution-o-n-2</a></p>
<p><a href="https://discuss.leetcode.com/topic/96141/c-binary-search-130ms">https://discuss.leetcode.com/topic/96141/c-binary-search-130ms</a></p>
<p><a href="https://discuss.leetcode.com/topic/96199/10-line-c-ac-barely-solution-o-n-2">https://discuss.leetcode.com/topic/96199/10-line-c-ac-barely-solution-o-n-2</a></p>
<p><a href="https://discuss.leetcode.com/topic/96228/c-clean-binary-search-solution-with-explanation">https://discuss.leetcode.com/topic/96228/c-clean-binary-search-solution-with-explanation</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-12-11 06:41</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=8021421" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(8021421);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7294585.html" id="cb_post_title_url">[LeetCode] Maximum Average Subarray I 子数组的最大平均值</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="question-description">
<p>Given an array consisting of <code>n</code> integers, find the contiguous subarray of given length <code>k</code> that has the maximum average value. And you need to output the maximum average value.</p>
<p>Example 1:</p>
<pre>Input: [1,12,-5,-6,50,3], k = 4
Output: 12.75
Explanation: Maximum average is (12-5-6+50)/4 = 51/4 = 12.75
</pre>
<p> </p>
<p>Note:</p>
<ol>
<li>1 &lt;= <code>k</code> &lt;= <code>n</code> &lt;= 30,000.</li>
<li>Elements of the given array will be in the range [-10,000, 10,000].</li>
</ol>
<p> </p>
<p>这道题给了我们一个数组nums，还有一个数字k，让我们找长度为k且平均值最大的子数组。由于子数组必须是连续的，所以我们不能给数组排序。那么怎么办呢，在博主印象中，计算子数组之和的常用方法应该是建立累加数组，然后我们可以快速计算出任意一个长度为k的子数组，用来更新结果res，从而得到最大的那个，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">double</span> findMaxAverage(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; nums, <span style="color: #0000ff;">int</span><span style="color: #000000;"> k) {
        </span><span style="color: #0000ff;">int</span> n =<span style="color: #000000;"> nums.size();
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; sums =<span style="color: #000000;"> nums;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt; n; ++<span style="color: #000000;">i) {
            sums[i] </span>= sums[i - <span style="color: #800080;">1</span>] +<span style="color: #000000;"> nums[i];
        }
        </span><span style="color: #0000ff;">double</span> mx = sums[k - <span style="color: #800080;">1</span><span style="color: #000000;">];
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = k; i &lt; n; ++<span style="color: #000000;">i) {
            mx </span>= max(mx, (<span style="color: #0000ff;">double</span>)sums[i] - sums[i -<span style="color: #000000;"> k]);
        }
        </span><span style="color: #0000ff;">return</span> mx /<span style="color: #000000;"> k;
    }
};</span></pre>
</div>
<p> </p>
<p>由于这道题子数组的长度k是确定的，所以我们其实没有必要建立整个累加数组，而是先算出前k个数字的和，然后就像维护一个滑动窗口一样，将窗口向右移动一位，即加上一个右边的数字，减去一个左边的数字，就等同于加上右边数字减去左边数字的差值，然后每次更新结果res即可，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">double</span> findMaxAverage(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; nums, <span style="color: #0000ff;">int</span><span style="color: #000000;"> k) {
        </span><span style="color: #0000ff;">double</span> sum = accumulate(nums.begin(), nums.begin() + k, <span style="color: #800080;">0</span>), res =<span style="color: #000000;"> sum;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = k; i &lt; nums.size(); ++<span style="color: #000000;">i) {
            sum </span>+= nums[i] - nums[i -<span style="color: #000000;"> k];
            res </span>=<span style="color: #000000;"> max(res, sum);
        }
        </span><span style="color: #0000ff;">return</span> res /<span style="color: #000000;"> k;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/96134/c-simple-sliding-window-solution" target="_blank">https://discuss.leetcode.com/topic/96134/c-simple-sliding-window-solution</a></p>
<p><a href="https://discuss.leetcode.com/topic/96154/java-solution-sum-of-sliding-window" target="_blank">https://discuss.leetcode.com/topic/96154/java-solution-sum-of-sliding-window</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a> </p>
</div></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-08-06 13:54</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7294585" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7294585);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7897166.html" id="cb_post_title_url">[LeetCode] Design Search Autocomplete System 设计搜索自动补全系统</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Design a search autocomplete system for a search engine. Users may input a sentence (at least one word and end with a special character <code>'#'</code>). For each character they type except '#', you need to return the top 3historical hot sentences that have prefix the same as the part of sentence already typed. Here are the specific rules:</p>
<ol>
<li>The hot degree for a sentence is defined as the number of times a user typed the exactly same sentence before.</li>
<li>The returned top 3 hot sentences should be sorted by hot degree (The first is the hottest one). If several sentences have the same degree of hot, you need to use ASCII-code order (smaller one appears first).</li>
<li>If less than 3 hot sentences exist, then just return as many as you can.</li>
<li>When the input is a special character, it means the sentence ends, and in this case, you need to return an empty list.</li>
</ol>
<p>Your job is to implement the following functions:</p>
<p>The constructor function:</p>
<p><code>AutocompleteSystem(String[] sentences, int[] times):</code> This is the constructor. The input is historical data. <code>Sentences</code> is a string array consists of previously typed sentences. <code>Times</code> is the corresponding times a sentence has been typed. Your system should record these historical data.</p>
<p>Now, the user wants to input a new sentence. The following function will provide the next character the user types:</p>
<p><code>List&lt;String&gt; input(char c):</code> The input <code>c</code> is the next character typed by the user. The character will only be lower-case letters (<code>'a'</code> to <code>'z'</code>), blank space (<code>' '</code>) or a special character (<code>'#'</code>). Also, the previously typed sentence should be recorded in your system. The output will be the top 3 historical hot sentences that have prefix the same as the part of sentence already typed.</p>
<p> </p>
<p>Example:<br/>Operation: AutocompleteSystem(["i love you", "island","ironman", "i love leetcode"], [5,3,2,2]) <br/>The system have already tracked down the following sentences and their corresponding times: <br/><code>"i love you"</code> : <code>5</code> times <br/><code>"island"</code> : <code>3</code> times <br/><code>"ironman"</code> : <code>2</code> times <br/><code>"i love leetcode"</code> : <code>2</code> times <br/>Now, the user begins another search: <br/><br/>Operation: input('i') <br/>Output: ["i love you", "island","i love leetcode"] <br/>Explanation: <br/>There are four sentences that have prefix <code>"i"</code>. Among them, "ironman" and "i love leetcode" have same hot degree. Since <code>' '</code> has ASCII code 32 and <code>'r'</code> has ASCII code 114, "i love leetcode" should be in front of "ironman". Also we only need to output top 3 hot sentences, so "ironman" will be ignored. <br/><br/>Operation: input(' ') <br/>Output: ["i love you","i love leetcode"] <br/>Explanation: <br/>There are only two sentences that have prefix <code>"i "</code>. <br/><br/>Operation: input('a') <br/>Output: [] <br/>Explanation: <br/>There are no sentences that have prefix <code>"i a"</code>. <br/><br/>Operation: input('#') <br/>Output: [] <br/>Explanation: <br/>The user finished the input, the sentence <code>"i a"</code> should be saved as a historical sentence in system. And the following input will be counted as a new search. </p>
<p> </p>
<p>Note:</p>
<ol><ol>
<li>The input sentence will always start with a letter and end with '#', and only one blank space will exist between two words.</li>
<li>The number of complete sentences that to be searched won't exceed 100. The length of each sentence including those in the historical data won't exceed 100.</li>
<li>Please use double-quote instead of single-quote when you write test cases even for a character input.</li>
<li>Please remember to RESET your class variables declared in class AutocompleteSystem, as static/class variables are persisted across multiple test cases. Please see <a href="https://leetcode.com/faq/#different-output">here</a> for more details.</li>
</ol></ol>
<p> </p>
<p>这道题让我们实现一个简单的搜索自动补全系统，我们用谷歌或者百度进行搜索时，会有这样的体验，输入些单词，搜索框会弹出一些以你输入为开头的一些完整的句子供你选择，这就是一种搜索自动补全系统。根据题目的要求，补全的句子是按之前出现的频率排列的，高频率的出现在最上面，如果频率相同，就按字母顺序来显示。输入规则是每次输入一个字符，然后返回自动补全的句子，如果遇到井字符，表示完整句子结束。那么我们肯定需要一个哈希map，建立句子和其出现频率的映射，还需要一个字符串data，用来保存之前输入过的字符。在构造函数中，给了我们一些句子，和其出现的次数，那么我们就直接将其加入哈希map，然后data初始化为空字符串。在input函数中，我们首先判读输入字符是否为井字符，如果是的话，那么表明当前的data字符串已经是一个完整的句子，在哈希表中次数加1，并且data清空，返回空集。否则的话我们将当前字符加入data字符串中，现在就要找出包含data前缀的前三高频句子了，我们使用优先队列来做，设计的思路是，始终用优先队列保存频率最高的三个句子，那么我们就应该把频率低的或者是字母顺序大的放在队首，以便随时可以移出队列，所以应该是个最小堆，队列里放句子和其出现频率的pair，并且根据其频率大小进行排序，所以我们要重写优先队列的comparator。然后我们遍历哈希表中的所有句子，我们首先要验证当前data字符串是否是其前缀，没啥好的方法，就逐个字符比较，用标识符matched，初始化为true，如果发现不匹配，则matched标记为false，并break掉。然后判断如果matched为true的话，说明data字符串是前缀，那么就把这个pair加入优先队列中，如果此时队列中的元素大于三个，那把队首元素移除，因为我们设计的是最小堆，所以频率小的句子会被先移除。然后就是将优先队列的元素加到结果res中，由于先出队列的是频率小的句子，所以要加到结果res的末尾，参见代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> AutocompleteSystem {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    AutocompleteSystem(vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; sentences, vector&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> times) {
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; sentences.size(); ++<span style="color: #000000;">i) {
            freq[sentences[i]] </span>+=<span style="color: #000000;"> times[i]; 
        }
        data </span>= <span style="color: #800000;">""</span><span style="color: #000000;">;
    }
    
    vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; input(<span style="color: #0000ff;">char</span><span style="color: #000000;"> c) {
        </span><span style="color: #0000ff;">if</span> (c == <span style="color: #800000;">'</span><span style="color: #800000;">#</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
            </span>++<span style="color: #000000;">freq[data];
            data </span>= <span style="color: #800000;">""</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> {};
        }
        data.push_back(c);
        auto cmp </span>= [](pair&lt;<span style="color: #0000ff;">string</span>, <span style="color: #0000ff;">int</span>&gt;&amp; a, pair&lt;<span style="color: #0000ff;">string</span>, <span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> b) {
            </span><span style="color: #0000ff;">return</span> a.second &gt; b.second || (a.second == b.second &amp;&amp; a.first &lt;<span style="color: #000000;"> b.first);
        };
        priority_queue</span>&lt;pair&lt;<span style="color: #0000ff;">string</span>, <span style="color: #0000ff;">int</span>&gt;, vector&lt;pair&lt;<span style="color: #0000ff;">string</span>, <span style="color: #0000ff;">int</span>&gt;&gt;, decltype(cmp) &gt;<span style="color: #000000;"> q(cmp);
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto f : freq) {
            </span><span style="color: #0000ff;">bool</span> matched = <span style="color: #0000ff;">true</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; data.size(); ++<span style="color: #000000;">i) {
                </span><span style="color: #0000ff;">if</span> (data[i] !=<span style="color: #000000;"> f.first[i]) {
                    matched </span>= <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                }
            }
            </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (matched) {
                q.push(f);
                </span><span style="color: #0000ff;">if</span> (q.size() &gt; <span style="color: #800080;">3</span><span style="color: #000000;">) q.pop();
            }
        }
        vector</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> res(q.size());
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = q.size() - <span style="color: #800080;">1</span>; i &gt;= <span style="color: #800080;">0</span>; --<span style="color: #000000;">i) {
            res[i] </span>=<span style="color: #000000;"> q.top().first; q.pop();
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    
</span><span style="color: #0000ff;">private</span><span style="color: #000000;">:
    unordered_map</span>&lt;<span style="color: #0000ff;">string</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> freq;
    </span><span style="color: #0000ff;">string</span><span style="color: #000000;"> data;
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4491665.html" target="_blank">Implement Trie (Prefix Tree)</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/7689927.html">Top K Frequent Words</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/96090/straight-forward-hash-table-priority-queue-solution-in-c-no-trie">https://discuss.leetcode.com/topic/96090/straight-forward-hash-table-priority-queue-solution-in-c-no-trie</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-11-25 23:56</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7897166" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7897166);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/9899490.html" id="cb_post_title_url">[LeetCode] Design Circular Deque 设计环形双向队列</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="content__1c40">
<div>
<p>Design your implementation of the circular double-ended queue (deque).</p>
<p>Your implementation should support following operations:</p>
<ul>
<li><code>MyCircularDeque(k)</code>: Constructor, set the size of the deque to be k.</li>
<li><code>insertFront()</code>: Adds an item at the front of Deque. Return true if the operation is successful.</li>
<li><code>insertLast()</code>: Adds an item at the rear of Deque. Return true if the operation is successful.</li>
<li><code>deleteFront()</code>: Deletes an item from the front of Deque. Return true if the operation is successful.</li>
<li><code>deleteLast()</code>: Deletes an item from the rear of Deque. Return true if the operation is successful.</li>
<li><code>getFront()</code>: Gets the front item from the Deque. If the deque is empty, return -1.</li>
<li><code>getRear()</code>: Gets the last item from Deque. If the deque is empty, return -1.</li>
<li><code>isEmpty()</code>: Checks whether Deque is empty or not. </li>
<li><code>isFull()</code>: Checks whether Deque is full or not.</li>
</ul>
<p> </p>
<p>Example:</p>
<pre>MyCircularDeque circularDeque = new MycircularDeque(3); // set the size to be 3
circularDeque.insertLast(1);			// return true
circularDeque.insertLast(2);			// return true
circularDeque.insertFront(3);			// return true
circularDeque.insertFront(4);			// return false, the queue is full
circularDeque.getRear();  			// return 2
circularDeque.isFull();				// return true
circularDeque.deleteLast();			// return true
circularDeque.insertFront(4);			// return true
circularDeque.getFront();			// return 4
</pre>
<p> </p>
<p>Note:</p>
<ul>
<li>All values will be in the range of [0, 1000].</li>
<li>The number of operations will be in the range of [1, 1000].</li>
<li>Please do not use the built-in Deque library.</li>
</ul>
</div>
</div>
<div class="header__2cgQ"> </div>
<p>这道题让我们设计一个环形双向队列，由于之前刚做过一道<a href="https://www.cnblogs.com/grandyang/p/9899034.html">Design Circular Queue</a>，那道设计一个环形队列，其实跟这道题非常的类似，环形双向队列在环形队列的基础上多了几个函数而已，其实本质并没有啥区别，那么之前那道题的解法一改吧改吧也能用在这道题上，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> MyCircularDeque {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">* Initialize your data structure here. Set the size of the deque to be k. </span><span style="color: #008000;">*/</span><span style="color: #000000;">
    MyCircularDeque(</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> k) {
        size </span>=<span style="color: #000000;"> k;   
    }
    
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">* Adds an item at the front of Deque. Return true if the operation is successful. </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">bool</span> insertFront(<span style="color: #0000ff;">int</span><span style="color: #000000;"> value) {
        </span><span style="color: #0000ff;">if</span> (isFull()) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        data.insert(data.begin(), value);
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
    
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">* Adds an item at the rear of Deque. Return true if the operation is successful. </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">bool</span> insertLast(<span style="color: #0000ff;">int</span><span style="color: #000000;"> value) {
        </span><span style="color: #0000ff;">if</span> (isFull()) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        data.push_back(value);
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
    
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">* Deletes an item from the front of Deque. Return true if the operation is successful. </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">bool</span><span style="color: #000000;"> deleteFront() {
        </span><span style="color: #0000ff;">if</span> (isEmpty()) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        data.erase(data.begin());
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
    
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">* Deletes an item from the rear of Deque. Return true if the operation is successful. </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">bool</span><span style="color: #000000;"> deleteLast() {
        </span><span style="color: #0000ff;">if</span> (isEmpty()) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        data.pop_back();
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
    
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">* Get the front item from the deque. </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">int</span><span style="color: #000000;"> getFront() {
        </span><span style="color: #0000ff;">if</span> (isEmpty()) <span style="color: #0000ff;">return</span> -<span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> data.front();
    }
    
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">* Get the last item from the deque. </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">int</span><span style="color: #000000;"> getRear() {
        </span><span style="color: #0000ff;">if</span> (isEmpty()) <span style="color: #0000ff;">return</span> -<span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> data.back();
    }
    
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">* Checks whether the circular deque is empty or not. </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">bool</span><span style="color: #000000;"> isEmpty() {
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> data.empty();
    }
    
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">* Checks whether the circular deque is full or not. </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">bool</span><span style="color: #000000;"> isFull() {
        </span><span style="color: #0000ff;">return</span> data.size() &gt;=<span style="color: #000000;"> size;
    }

</span><span style="color: #0000ff;">private</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> data;
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> size;
};</span></pre>
</div>
<p> </p>
<p>就像前一道题中的分析的一样，上面的解法并不是本题真正想要考察的内容，我们要用上环形Circular的性质，我们除了使用size来记录环形队列的最大长度之外，还要使用三个变量，head，tail，cnt，分别来记录队首位置，队尾位置，和当前队列中数字的个数，这里我们将head初始化为k-1，tail初始化为0。还是从简单的做起，判空就看当前个数cnt是否为0，判满就看当前个数cnt是否等于size。接下来取首尾元素，先进行判空，然后根据head和tail分别向后和向前移动一位取即可，记得使用上循环数组的性质，要对size取余。再来看删除末尾函数，先进行判空，然后tail向前移动一位，使用循环数组的操作，然后cnt自减1。同理，删除开头函数，先进行判空，队首位置head要向后移动一位，同样进行加1之后对长度取余的操作，然后cnt自减1。再来看插入末尾函数，先进行判满，然后将新的数字加到当前的tail位置，tail移动到下一位，为了避免越界，我们使用环形数组的经典操作，加1之后对长度取余，然后cnt自增1即可。同样，插入开头函数，先进行判满，然后将新的数字加到当前的head位置，head移动到前一位，然后cnt自增1，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> MyCircularDeque {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">* Initialize your data structure here. Set the size of the deque to be k. </span><span style="color: #008000;">*/</span><span style="color: #000000;">
    MyCircularDeque(</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> k) {
        size </span>= k; head = k - <span style="color: #800080;">1</span>; tail = <span style="color: #800080;">0</span>, cnt = <span style="color: #800080;">0</span><span style="color: #000000;">;
        data.resize(k);
    }
    
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">* Adds an item at the front of Deque. Return true if the operation is successful. </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">bool</span> insertFront(<span style="color: #0000ff;">int</span><span style="color: #000000;"> value) {
        </span><span style="color: #0000ff;">if</span> (isFull()) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        data[head] </span>=<span style="color: #000000;"> value;
        head </span>= (head - <span style="color: #800080;">1</span> + size) %<span style="color: #000000;"> size;
        </span>++<span style="color: #000000;">cnt;
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
    
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">* Adds an item at the rear of Deque. Return true if the operation is successful. </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">bool</span> insertLast(<span style="color: #0000ff;">int</span><span style="color: #000000;"> value) {
        </span><span style="color: #0000ff;">if</span> (isFull()) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        data[tail] </span>=<span style="color: #000000;"> value;
        tail </span>= (tail + <span style="color: #800080;">1</span>)  %<span style="color: #000000;"> size;
        </span>++<span style="color: #000000;">cnt;
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
    
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">* Deletes an item from the front of Deque. Return true if the operation is successful. </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">bool</span><span style="color: #000000;"> deleteFront() {
        </span><span style="color: #0000ff;">if</span> (isEmpty()) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        head </span>= (head + <span style="color: #800080;">1</span>) %<span style="color: #000000;"> size;
        </span>--<span style="color: #000000;">cnt;
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
    
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">* Deletes an item from the rear of Deque. Return true if the operation is successful. </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">bool</span><span style="color: #000000;"> deleteLast() {
        </span><span style="color: #0000ff;">if</span> (isEmpty()) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        tail </span>= (tail - <span style="color: #800080;">1</span> + size) %<span style="color: #000000;"> size;
        </span>--<span style="color: #000000;">cnt;
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
    
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">* Get the front item from the deque. </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">int</span><span style="color: #000000;"> getFront() {
        </span><span style="color: #0000ff;">return</span> isEmpty() ? -<span style="color: #800080;">1</span> : data[(head + <span style="color: #800080;">1</span>) %<span style="color: #000000;"> size];
    }
    
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">* Get the last item from the deque. </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">int</span><span style="color: #000000;"> getRear() {
        </span><span style="color: #0000ff;">return</span> isEmpty() ? -<span style="color: #800080;">1</span> : data[(tail - <span style="color: #800080;">1</span> + size) %<span style="color: #000000;"> size];
    }
    
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">* Checks whether the circular deque is empty or not. </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">bool</span><span style="color: #000000;"> isEmpty() {
        </span><span style="color: #0000ff;">return</span> cnt == <span style="color: #800080;">0</span><span style="color: #000000;">;
    }
    
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">* Checks whether the circular deque is full or not. </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">bool</span><span style="color: #000000;"> isFull() {
        </span><span style="color: #0000ff;">return</span> cnt ==<span style="color: #000000;"> size;
    }

</span><span style="color: #0000ff;">private</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> data;
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> size, head, tail, cnt;
};</span></pre>
</div>
<p> </p>
<p> </p>
<p>类似题目：</p>
<p><a href="https://www.cnblogs.com/grandyang/p/9899034.html">Design Circular Queue</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-11-03 04:13</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=9899490" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(9899490);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7350578.html" id="cb_post_title_url">[LeetCode] Solve the Equation 解方程</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="question-description">
<p>Solve a given equation and return the value of <code>x</code> in the form of string "x=#value". The equation contains only '+', '-' operation, the variable <code>x</code> and its coefficient.</p>
<p>If there is no solution for the equation, return "No solution".</p>
<p>If there are infinite solutions for the equation, return "Infinite solutions".</p>
<p>If there is exactly one solution for the equation, we ensure that the value of <code>x</code> is an integer.</p>
<p>Example 1:</p>
<pre>Input: "x+5-3+x=6+x-2"
Output: "x=2"
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input: "x=x"
Output: "Infinite solutions"
</pre>
<p> </p>
<p>Example 3:</p>
<pre>Input: "2x=x"
Output: "x=0"
</pre>
<p> </p>
<p>Example 4:</p>
<pre>Input: "2x+3x-6x=x+2"
Output: "x=-1"
</pre>
<p> </p>
<p>Example 5:</p>
<pre>Input: "x=x+2"
Output: "No solution"
</pre>
<p> </p>
<p>这道题给了我们一个用字符串表示的方程式，让我们求出x的解，根据例子可知，还包括x有无穷多个解和x没有解的情况。解一元一次方程没什么难度，难点在于处理字符串，如何将x的系数合并起来，将常数合并起来，化简成ax=b的形式来求解。博主最开始的思路是先找到等号，然后左右两部分分开处理。由于要化成ax=b的格式，所以左半部分对于x的系数都是加，右半部分对于x的系数都是减。同理，左半部分对于常数是减，右半部分对于常数是加。</p>
<p>那么我们就开始处理字符串了，我们定义一个符号变量sign，初始化为1，数字变量num，初始化为-1，后面会提到为啥不能初始化为0。我们遍历每一个字符，如果遇到了符号位，我们看num的值，如果num是-1的话，说明是初始值，没有更新过，我们将其赋值为0；反之，如果不是-1，说明num已经更新过了，我们乘上当前的正负符号值sign。这是为了区分"-3"和"3+3"这种两种情况，遇到-3种的符号时，我们还不需要加到b中，所以num此时必须为0，而遇到3+3中的加号时，此时num已经为3了，我们要把前面的3加到b中。</p>
<p>遇到数字的时候，我们还是要看num的值，如果是初始值，那么就将其赋值为0，然后计算数字的时候要先给num乘10，再加上当前的数字。这样做的原因是常数不一定都是个位数字，有可能是两位数或者三位数，这样做才能正确的读入数字。我们在遇到数字的时候并不更新a或者b，我们只在遇到符号位或者x的时候才更新。这样如果最后一位是数字的话就会产生问题，所以我们要在字符串的末尾加上一个+号，这样确保了末尾数字会被处理。</p>
<p>遇到x的时候比较tricky，因为可能是x, 0x, -x这几种情况，我们还是首先要看num的值是否为初始值-1，如果是的话，那么就可能是x或-x这种情况，我们此时将num赋值为sign；如果num不是-1，说明num已经被更新了，可能是0x, -3x等等，所以我们要将num赋值为num*sign。这里应该就明白了为啥不能将num初始化为0了，因为一旦初始化为0了，就没法区分x和0x这两种情况了。</p>
<p>那么我们算完了a和b，得到了ax=b的等式，下面的步骤就很简单了，只要分情况讨论得出正确的返回结果即可，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> solveEquation(<span style="color: #0000ff;">string</span><span style="color: #000000;"> equation) {
        </span><span style="color: #0000ff;">int</span> a = <span style="color: #800080;">0</span>, b = <span style="color: #800080;">0</span><span style="color: #000000;">;
        auto found </span>= equation.find(<span style="color: #800000;">"</span><span style="color: #800000;">=</span><span style="color: #800000;">"</span><span style="color: #000000;">);
        helper(equation.substr(</span><span style="color: #800080;">0</span>, found), <span style="color: #0000ff;">true</span><span style="color: #000000;">, a, b);
        helper(equation.substr(found </span>+ <span style="color: #800080;">1</span>), <span style="color: #0000ff;">false</span><span style="color: #000000;">, a, b);
        </span><span style="color: #0000ff;">if</span> (a == <span style="color: #800080;">0</span> &amp;&amp; a == b) <span style="color: #0000ff;">return</span> <span style="color: #800000;">"</span><span style="color: #800000;">Infinite solutions</span><span style="color: #800000;">"</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (a == <span style="color: #800080;">0</span> &amp;&amp; a != b) <span style="color: #0000ff;">return</span> <span style="color: #800000;">"</span><span style="color: #800000;">No solution</span><span style="color: #800000;">"</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span> <span style="color: #800000;">"</span><span style="color: #800000;">x=</span><span style="color: #800000;">"</span> + to_string(b /<span style="color: #000000;"> a);
    }
    </span><span style="color: #0000ff;">void</span> helper(<span style="color: #0000ff;">string</span> e, <span style="color: #0000ff;">bool</span> isLeft, <span style="color: #0000ff;">int</span>&amp; a, <span style="color: #0000ff;">int</span>&amp;<span style="color: #000000;"> b) {
        </span><span style="color: #0000ff;">int</span> sign = <span style="color: #800080;">1</span>, num = -<span style="color: #800080;">1</span><span style="color: #000000;">;
        e </span>+= <span style="color: #800000;">"</span><span style="color: #800000;">+</span><span style="color: #800000;">"</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; e.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (e[i] == <span style="color: #800000;">'</span><span style="color: #800000;">-</span><span style="color: #800000;">'</span> || e[i] == <span style="color: #800000;">'</span><span style="color: #800000;">+</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                num </span>= (num == -<span style="color: #800080;">1</span>) ? <span style="color: #800080;">0</span> : (num *<span style="color: #000000;"> sign);
                b </span>+= isLeft ? -<span style="color: #000000;">num : num;
                num </span>= -<span style="color: #800080;">1</span><span style="color: #000000;">;
                sign </span>= (e[i] == <span style="color: #800000;">'</span><span style="color: #800000;">+</span><span style="color: #800000;">'</span>) ? <span style="color: #800080;">1</span> : -<span style="color: #800080;">1</span><span style="color: #000000;">;
            } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (e[i] &gt;= <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span> &amp;&amp; e[i] &lt;= <span style="color: #800000;">'</span><span style="color: #800000;">9</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                </span><span style="color: #0000ff;">if</span> (num == -<span style="color: #800080;">1</span>) num = <span style="color: #800080;">0</span><span style="color: #000000;">;
                num </span>= num * <span style="color: #800080;">10</span> + e[i] - <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span><span style="color: #000000;">;
            } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (e[i] == <span style="color: #800000;">'</span><span style="color: #800000;">x</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                num </span>= (num == -<span style="color: #800080;">1</span>) ? sign : (num *<span style="color: #000000;"> sign);
                a </span>+= isLeft ? num : -<span style="color: #000000;">num;
                num </span>= -<span style="color: #800080;">1</span><span style="color: #000000;">;
            }
        }
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种解法也很不错，也是求ax=b等式中的a和b，但是没有根据等号拆分为左右两部分，而是用一个变量sign来控制是对a和b加还是减，这跟上面解法中的的sign不一样。这里没有专门管正负的变量，而是通过双指针，指向数字的范围，这个数字可以是x的系数，也可以是常量，可以带着正负号，然后通过stoi函数将字符串直接转为整型数，然后乘以sign加到a或b中。变量j会指向数字或者符号，当i大于j时，我们就提取出范围内的数字。当我们遇到x的时候，跟上面一样，要处理+x, -x, 0x的情况，我们看前一位的字符，如果是符号，那么我们直接给a加上符号值；如果是数字，就用上面的办法提取出数字乘以sign加到a中。如果遇到了等号，那么先处理前面的数字(如果有的话)，然后flip sign。最后循环结束后，还要考虑最后一位是数字的情况，要加到b中。后面分情况讨论就不多说了，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> solveEquation(<span style="color: #0000ff;">string</span><span style="color: #000000;"> equation) {
        </span><span style="color: #0000ff;">int</span> n = equation.size(), a = <span style="color: #800080;">0</span>, b = <span style="color: #800080;">0</span>, sign = <span style="color: #800080;">1</span>, j = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (equation[i] == <span style="color: #800000;">'</span><span style="color: #800000;">+</span><span style="color: #800000;">'</span> || equation[i] == <span style="color: #800000;">'</span><span style="color: #800000;">-</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                </span><span style="color: #0000ff;">if</span> (i &gt; j) b += stoi(equation.substr(j, i - j)) *<span style="color: #000000;"> sign;
                j </span>=<span style="color: #000000;"> i;
            } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (equation[i] == <span style="color: #800000;">'</span><span style="color: #800000;">x</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                </span><span style="color: #0000ff;">if</span> (i == j || equation[i - <span style="color: #800080;">1</span>] == <span style="color: #800000;">'</span><span style="color: #800000;">+</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                    a </span>+=<span style="color: #000000;"> sign;                 
                } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (equation[i - <span style="color: #800080;">1</span>] == <span style="color: #800000;">'</span><span style="color: #800000;">-</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                    a </span>-=<span style="color: #000000;"> sign;
                } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    a </span>+= stoi(equation.substr(j, i - j)) *<span style="color: #000000;"> sign;
                }
                j </span>= i + <span style="color: #800080;">1</span><span style="color: #000000;">;
            } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (equation[i] == <span style="color: #800000;">'</span><span style="color: #800000;">=</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                </span><span style="color: #0000ff;">if</span> (i &gt; j) b += stoi(equation.substr(j, i - j)) *<span style="color: #000000;"> sign;
                sign </span>= -<span style="color: #800080;">1</span><span style="color: #000000;">;
                j </span>= i + <span style="color: #800080;">1</span><span style="color: #000000;">;
            }
        }
        </span><span style="color: #0000ff;">if</span> (j &lt; n) b += stoi(equation.substr(j)) *<span style="color: #000000;"> sign;
        </span><span style="color: #0000ff;">if</span> (a == <span style="color: #800080;">0</span> &amp;&amp; a == b) <span style="color: #0000ff;">return</span> <span style="color: #800000;">"</span><span style="color: #800000;">Infinite solutions</span><span style="color: #800000;">"</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (a == <span style="color: #800080;">0</span> &amp;&amp; a != b) <span style="color: #0000ff;">return</span> <span style="color: #800000;">"</span><span style="color: #800000;">No solution</span><span style="color: #800000;">"</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span> <span style="color: #800000;">"</span><span style="color: #800000;">x=</span><span style="color: #800000;">"</span> + to_string(-b /<span style="color: #000000;"> a);
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/6954197.html">Fraction Addition and Subtraction</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/95203/concise-java-solution" target="_blank">https://discuss.leetcode.com/topic/95203/concise-java-solution</a></p>
<p><a href="https://discuss.leetcode.com/topic/95279/c-two-pointers-concise-solution" target="_blank">https://discuss.leetcode.com/topic/95279/c-two-pointers-concise-solution</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a> </p>
</div></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-08-12 16:02</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7350578" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7350578);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7279152.html" id="cb_post_title_url">[LeetCode] Decode Ways II 解码方法之二</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>A message containing letters from <code>A-Z</code> is being encoded to numbers using the following mapping way:</p>
<pre>'A' -&gt; 1
'B' -&gt; 2
...
'Z' -&gt; 26
</pre>
<p>Beyond that, now the encoded string can also contain the character '*', which can be treated as one of the numbers from 1 to 9.</p>
<p>Given the encoded message containing digits and the character '*', return the total number of ways to decode it.</p>
<p>Also, since the answer may be very large, you should return the output mod 109 + 7.</p>
<p>Example 1:</p>
<pre>Input: "*"
Output: 9
Explanation: The encoded message can be decoded to the string: "A", "B", "C", "D", "E", "F", "G", "H", "I".
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input: "1*"
Output: 9 + 9 = 18
</pre>
<p> </p>
<p>Note:</p>
<ol>
<li>The length of the input string will fit in range [1, 105].</li>
<li>The input string will only contain the character '*' and digits '0' - '9'.</li>
</ol>
<p> </p>
<p>这道解码的题是之前那道<a href="http://www.cnblogs.com/grandyang/p/4313384.html" target="_blank">Decode Ways</a>的拓展，难度提高了不少，引入了星号，可以代表1到9之间的任意数字，是不是有点外卡匹配的感觉。有了星号以后，整个题就变得异常的复杂，所以结果才让我们对一个很大的数求余，避免溢出。这道题的难点就是要分情况种类太多，一定要全部理通顺才行。我们还是用DP来做，建立一个一维dp数组，其中dp[i]表示前i个字符的解码方法等个数，长度为字符串的长度加1。将dp[0]初始化为1，然后我们判断，如果字符串第一个字符是0，那么直接返回0，如果是*，则dp[1]初始化为9，否则初始化为1。下面就来计算一般情况下的dp[i]了，我们从i=2开始遍历，由于要分的情况种类太多，我们先选一个大分支，就是当前遍历到的字符s[i-1]，只有三种情况，要么是0，要么是1到9的数字，要么是星号。我们一个一个来分析：</p>
<p>首先来看s[i-1]为0的情况，这种情况相对来说比较简单，因为0不能单独拆开，只能跟前面的数字一起，而且前面的数字只能是1或2，其他的直接返回0即可。那么当前面的数字是1或2的时候，dp[i]的种类数就跟dp[i-2]相等，可以参见之前那道<a href="http://www.cnblogs.com/grandyang/p/4313384.html" target="_blank">Decode Ways</a>的讲解，因为后两数无法单独拆分开，就无法产生新的解码方法，所以只保持住原来的拆分数量就不错了；如果前面的数是星号的时候，那么前面的数可以为1或者2，这样就相等于两倍的dp[i-2]；如果前面的数也为0，直接返回0即可。</p>
<p>再来看s[i-1]为1到9之间的数字的情况，首先搞清楚当前数字是可以单独拆分出来的，那么dp[i]至少是等于dp[i-1]的，不会拖后腿，还要看其能不能和前面的数字组成两位数进一步增加解码方法。那么就要分情况讨论前面一个数字的种类，如果当前数字可以跟前面的数字组成一个小于等于26的两位数的话，dp[i]还需要加上dp[i-2]；如果前面的数字为星号的话，那么要看当前的数字是否小于等于6，如果是小于等于6，那么前面的数字就可以是1或者2了，此时dp[i]需要加上两倍的dp[i-2]，如果大于6，那么前面的数字只能是1，所以dp[i]只能加上dp[i-2]。</p>
<p>最后来看s[i-1]为星号的情况，如果当前数字为星号，那么就创造9种可以单独拆分的方法，所以那么dp[i]至少是等于9倍的dp[i-1]，还要看其能不能和前面的数字组成两位数进一步增加解码方法。那么就要分情况讨论前面一个数字的种类，如果前面的数字是1，那么当前的9种情况都可以跟前面的数字组成两位数，所以dp[i]需要加上9倍的dp[i-2]；如果前面的数字是2，那么只有小于等于6的6种情况都可以跟前面的数字组成两位数，所以dp[i]需要加上6倍的dp[i-2]；如果前面的数字是星号，那么就是上面两种情况的总和，dp[i]需要加上15倍的dp[i-2]。</p>
<p>每次算完dp[i]别忘了对超大数取余，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> numDecodings(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        </span><span style="color: #0000ff;">int</span> n = s.size(), M = 1e9 + <span style="color: #800080;">7</span><span style="color: #000000;">;
        vector</span>&lt;<span style="color: #0000ff;">long</span>&gt; dp(n + <span style="color: #800080;">1</span>, <span style="color: #800080;">0</span><span style="color: #000000;">);
        dp[</span><span style="color: #800080;">0</span>] = <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (s[<span style="color: #800080;">0</span>] == <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span>) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        dp[</span><span style="color: #800080;">1</span>] = (s[<span style="color: #800080;">0</span>] == <span style="color: #800000;">'</span><span style="color: #800000;">*</span><span style="color: #800000;">'</span>) ? <span style="color: #800080;">9</span> : <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">2</span>; i &lt;= n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (s[i - <span style="color: #800080;">1</span>] == <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                </span><span style="color: #0000ff;">if</span> (s[i - <span style="color: #800080;">2</span>] == <span style="color: #800000;">'</span><span style="color: #800000;">1</span><span style="color: #800000;">'</span> || s[i - <span style="color: #800080;">2</span>] == <span style="color: #800000;">'</span><span style="color: #800000;">2</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                    dp[i] </span>+= dp[i - <span style="color: #800080;">2</span><span style="color: #000000;">];
                } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (s[i - <span style="color: #800080;">2</span>] == <span style="color: #800000;">'</span><span style="color: #800000;">*</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                    dp[i] </span>+= <span style="color: #800080;">2</span> * dp[i - <span style="color: #800080;">2</span><span style="color: #000000;">];
                } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
                }
            } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (s[i - <span style="color: #800080;">1</span>] &gt;= <span style="color: #800000;">'</span><span style="color: #800000;">1</span><span style="color: #800000;">'</span> &amp;&amp; s[i - <span style="color: #800080;">1</span>] &lt;= <span style="color: #800000;">'</span><span style="color: #800000;">9</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                dp[i] </span>+= dp[i - <span style="color: #800080;">1</span><span style="color: #000000;">];
                </span><span style="color: #0000ff;">if</span> (s[i - <span style="color: #800080;">2</span>] == <span style="color: #800000;">'</span><span style="color: #800000;">1</span><span style="color: #800000;">'</span> || (s[i - <span style="color: #800080;">2</span>] == <span style="color: #800000;">'</span><span style="color: #800000;">2</span><span style="color: #800000;">'</span> &amp;&amp; s[i - <span style="color: #800080;">1</span>] &lt;= <span style="color: #800000;">'</span><span style="color: #800000;">6</span><span style="color: #800000;">'</span><span style="color: #000000;">)) {
                    dp[i] </span>+= dp[i - <span style="color: #800080;">2</span><span style="color: #000000;">];
                } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (s[i - <span style="color: #800080;">2</span>] == <span style="color: #800000;">'</span><span style="color: #800000;">*</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                    dp[i] </span>+= (s[i - <span style="color: #800080;">1</span>] &lt;= <span style="color: #800000;">'</span><span style="color: #800000;">6</span><span style="color: #800000;">'</span>) ? (<span style="color: #800080;">2</span> * dp[i - <span style="color: #800080;">2</span>]) : dp[i - <span style="color: #800080;">2</span><span style="color: #000000;">];
                }
            } </span><span style="color: #0000ff;">else</span> { <span style="color: #008000;">//</span><span style="color: #008000;"> s[i - 1] == '*'</span>
                dp[i] += <span style="color: #800080;">9</span> * dp[i - <span style="color: #800080;">1</span><span style="color: #000000;">];
                </span><span style="color: #0000ff;">if</span> (s[i - <span style="color: #800080;">2</span>] == <span style="color: #800000;">'</span><span style="color: #800000;">1</span><span style="color: #800000;">'</span>) dp[i] += <span style="color: #800080;">9</span> * dp[i - <span style="color: #800080;">2</span><span style="color: #000000;">];
                </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (s[i - <span style="color: #800080;">2</span>] == <span style="color: #800000;">'</span><span style="color: #800000;">2</span><span style="color: #800000;">'</span>) dp[i] += <span style="color: #800080;">6</span> * dp[i - <span style="color: #800080;">2</span><span style="color: #000000;">];
                </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (s[i - <span style="color: #800080;">2</span>] == <span style="color: #800000;">'</span><span style="color: #800000;">*</span><span style="color: #800000;">'</span>) dp[i] += <span style="color: #800080;">15</span> * dp[i - <span style="color: #800080;">2</span><span style="color: #000000;">];
            }
            dp[i] </span>%=<span style="color: #000000;"> M;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> dp[n];
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种解法是论坛上排名最高的解法，常数级的空间复杂度，写法非常简洁，思路也巨牛逼，博主是无论如何也想不出来的，只能继续当搬运工了。这里定义了一系列的变量e0, e1, e2, f0, f1, f2。其中：</p>
<p>e0表示当前可以获得的解码的次数，当前数字可以为任意数 (也就是上面解法中的dp[i])</p>
<p>e1表示当前可以获得的解码的次数，当前数字为1</p>
<p>e2表示当前可以获得的解码的次数，当前数字为2</p>
<p>f0, f1, f2分别为处理完当前字符c的e0, e1, e2的值</p>
<p>那么下面我们来进行分类讨论，当c为星号的时候，f0的值就是9*e0 + 9*e1 + 6*e2，这个应该不难理解了，可以参考上面解法中的讲解，这里的e0就相当于dp[i-1]，e1和e2相当于两种不同情况的dp[i-2]，此时f1和f2都赋值为e0，因为要和后面的数字组成两位数的话，不会增加新的解码方法，所以解码总数跟之前的一样，为e0, 即dp[i-1]。</p>
<p>当c不为星号的时候，如果c不为0，则f0首先应该加上e0。然后不管c为何值，e1都需要加上，总能和前面的1组成两位数；如果c小于等于6，可以和前面的2组成两位数，可以加上e2。然后我们更新f1和f2，如果c为1，则f1为e0；如果c为2，则f2为e0。</p>
<p>最后别忘了将f0，f1，f2赋值给e0，e1，e2，其中f0需要对超大数取余，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> numDecodings(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        </span><span style="color: #0000ff;">long</span> e0 = <span style="color: #800080;">1</span>, e1 = <span style="color: #800080;">0</span>, e2 = <span style="color: #800080;">0</span>, f0, f1, f2, M = 1e9 + <span style="color: #800080;">7</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span><span style="color: #000000;"> c : s) {
            </span><span style="color: #0000ff;">if</span> (c == <span style="color: #800000;">'</span><span style="color: #800000;">*</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                f0 </span>= <span style="color: #800080;">9</span> * e0 + <span style="color: #800080;">9</span> * e1 + <span style="color: #800080;">6</span> *<span style="color: #000000;"> e2;
                f1 </span>=<span style="color: #000000;"> e0;
                f2 </span>=<span style="color: #000000;"> e0;
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                f0 </span>= (c &gt; <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span>) * e0 + e1 + (c &lt;= <span style="color: #800000;">'</span><span style="color: #800000;">6</span><span style="color: #800000;">'</span>) *<span style="color: #000000;"> e2;
                f1 </span>= (c == <span style="color: #800000;">'</span><span style="color: #800000;">1</span><span style="color: #800000;">'</span>) *<span style="color: #000000;"> e0;
                f2 </span>= (c == <span style="color: #800000;">'</span><span style="color: #800000;">2</span><span style="color: #800000;">'</span>) *<span style="color: #000000;"> e0;
            }
            e0 </span>= f0 %<span style="color: #000000;"> M;
            e1 </span>=<span style="color: #000000;"> f1;
            e2 </span>=<span style="color: #000000;"> f2;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> e0;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这解法由热心网友edyyy提供，在解法二的基础上去掉了两个变量，节省了行数，很符合博主的极简风格，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> numDecodings(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        </span><span style="color: #0000ff;">long</span> e0 = <span style="color: #800080;">1</span>, e1 = <span style="color: #800080;">0</span>, e2 = <span style="color: #800080;">0</span>, f0 = <span style="color: #800080;">0</span>, M = 1e9 + <span style="color: #800080;">7</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span><span style="color: #000000;"> c : s) {
            </span><span style="color: #0000ff;">if</span> (c == <span style="color: #800000;">'</span><span style="color: #800000;">*</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                f0 </span>= <span style="color: #800080;">9</span> * e0 + <span style="color: #800080;">9</span> * e1 + <span style="color: #800080;">6</span> *<span style="color: #000000;"> e2;
                e1 </span>=<span style="color: #000000;"> e0;
                e2 </span>=<span style="color: #000000;"> e0;
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                f0 </span>= (c &gt; <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span>) * e0 + e1 + (c &lt;= <span style="color: #800000;">'</span><span style="color: #800000;">6</span><span style="color: #800000;">'</span>) *<span style="color: #000000;"> e2;
                e1 </span>= (c == <span style="color: #800000;">'</span><span style="color: #800000;">1</span><span style="color: #800000;">'</span>) *<span style="color: #000000;"> e0;
                e2 </span>= (c == <span style="color: #800000;">'</span><span style="color: #800000;">2</span><span style="color: #800000;">'</span>) *<span style="color: #000000;"> e0;
            }
            e0 </span>= f0 %<span style="color: #000000;"> M;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> e0;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4313384.html" target="_blank">Decode Ways</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/95301/python-straightforward-with-explanation">https://discuss.leetcode.com/topic/95301/python-straightforward-with-explanation</a></p>
<p><a href="https://discuss.leetcode.com/topic/95518/java-o-n-by-general-solution-for-all-dp-problems">https://discuss.leetcode.com/topic/95518/java-o-n-by-general-solution-for-all-dp-problems</a></p>
<p><a href="https://discuss.leetcode.com/topic/95204/java-dp-solution-o-n-time-and-space-some-explanations">https://discuss.leetcode.com/topic/95204/java-dp-solution-o-n-time-and-space-some-explanations</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-08-03 13:07</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7279152" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7279152);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7261663.html" id="cb_post_title_url">[LeetCode] Shopping Offers 购物优惠</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>In LeetCode Store, there are some kinds of items to sell. Each item has a price.</p>
<p>However, there are some special offers, and a special offer consists of one or more different kinds of items with a sale price.</p>
<p>You are given the each item's price, a set of special offers, and the number we need to buy for each item. The job is to output the lowest price you have to pay for exactly certain items as given, where you could make optimal use of the special offers.</p>
<p>Each special offer is represented in the form of an array, the last number represents the price you need to pay for this special offer, other numbers represents how many specific items you could get if you buy this offer.</p>
<p>You could use any of special offers as many times as you want.</p>
<p>Example 1:</p>
<pre>Input: [2,5], [[3,0,5],[1,2,10]], [3,2]
Output: 14
Explanation: 
There are two kinds of items, A and B. Their prices are $2 and $5 respectively. 
In special offer 1, you can pay $5 for 3A and 0B
In special offer 2, you can pay $10 for 1A and 2B. 
You need to buy 3A and 2B, so you may pay $10 for 1A and 2B (special offer #2), and $4 for 2A.
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input: [2,3,4], [[1,1,0,4],[2,2,1,9]], [1,2,1]
Output: 11
Explanation: 
The price of A is $2, and $3 for B, $4 for C. 
You may pay $4 for 1A and 1B, and $9 for 2A ,2B and 1C. 
You need to buy 1A ,2B and 1C, so you may pay $4 for 1A and 1B (special offer #1), and $3 for 1B, $4 for 1C. 
You cannot add more items, though only $9 for 2A ,2B and 1C.
</pre>
<p> </p>
<p>Note:</p>
<ol>
<li>There are at most 6 kinds of items, 100 special offers.</li>
<li>For each item, you need to buy at most 6 of them.</li>
<li>You are not allowed to buy more items than you want, even if that would lower the overall price.</li>
</ol>
<p> </p>
<p>这道题说有一些商品，各自有不同的价格，然后给我们了一些优惠券，可以在优惠的价格买各种商品若干个，要求我们每个商品要买特定的个数，问我们使用优惠券能少花多少钱，注意优惠券可以重复使用，而且商品不能多买。那么我们可以先求出不使用任何商品需要花的钱数作为结果res的初始值，然后我们遍历每一个coupon，定义一个变量isValid表示当前coupon可以使用，然后遍历每一个商品，如果某个商品需要的个数小于coupon中提供的个数，说明当前coupon不可用，isValid标记为false。如果遍历完了发现isValid还为true的话，表明该coupon可用，我们可以更新结果res，对剩余的needs调用递归并且加上使用该coupon需要付的钱数。最后别忘了恢复needs的状态，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> shoppingOffers(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; price, vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp; special, vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> needs) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, n =<span style="color: #000000;"> price.size();
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            res </span>+= price[i] *<span style="color: #000000;"> needs[i];
        }
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto offer : special) {
            </span><span style="color: #0000ff;">bool</span> isValid = <span style="color: #0000ff;">true</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; n; ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> (needs[j] - offer[j] &lt; <span style="color: #800080;">0</span>) isValid = <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                needs[j] </span>-=<span style="color: #000000;"> offer[j];
            }
            </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (isValid) {
                res </span>= min(res, shoppingOffers(price, special, needs) +<span style="color: #000000;"> offer.back());
            }
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; n; ++<span style="color: #000000;">j) {
                needs[j] </span>+=<span style="color: #000000;"> offer[j];
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种解法也是递归的写法，总的来说思路跟上面没有啥差别，应该不难理解，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> shoppingOffers(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; price, vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp; special, vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> needs) {
        </span><span style="color: #0000ff;">int</span> res = inner_product(price.begin(), price.end(), needs.begin(), <span style="color: #800080;">0</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto offer : special) {
            vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; r =<span style="color: #000000;"> helper(offer, needs);
            </span><span style="color: #0000ff;">if</span> (r.empty()) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
            res </span>= min(res, shoppingOffers(price, special, r) +<span style="color: #000000;"> offer.back());
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; helper(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; offer, vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> needs) {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; r(needs.size(), <span style="color: #800080;">0</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; needs.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (offer[i] &gt; needs[i]) <span style="color: #0000ff;">return</span><span style="color: #000000;"> {};
            r[i] </span>= needs[i] -<span style="color: #000000;"> offer[i];
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> r;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/95201/c-solution">https://discuss.leetcode.com/topic/95201/c-solution</a></p>
<p><a href="https://discuss.leetcode.com/topic/95200/simple-java-recursive-solution">https://discuss.leetcode.com/topic/95200/simple-java-recursive-solution</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a> </p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-07-31 10:05</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7261663" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7261663);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7259209.html" id="cb_post_title_url">[LeetCode] Average of Levels in Binary Tree 二叉树的层平均值</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="question-description">
<p>Given a non-empty binary tree, return the average value of the nodes on each level in the form of an array.</p>
<p>Example 1:</p>
<pre>Input:
    3
   / \
  9  20
    /  \
   15   7
Output: [3, 14.5, 11]
Explanation:
The average value of nodes on level 0 is 3,  on level 1 is 14.5, and on level 2 is 11. Hence return [3, 14.5, 11].
</pre>
<p> </p>
<p>Note:</p>
<ol>
<li>The range of node's value is in the range of 32-bit signed integer.</li>
</ol>
<p> </p>
<p>这道题让我们求一个二叉树每层的平均值，那么一看就是要进行层序遍历了，直接上queue啊，如果熟悉层序遍历的方法，那么这题就没有什么难度了，直接将每层的值累计加起来，除以该层的结点个数，存入结果res中即可，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">double</span>&gt; averageOfLevels(TreeNode*<span style="color: #000000;"> root) {
        </span><span style="color: #0000ff;">if</span> (!root) <span style="color: #0000ff;">return</span><span style="color: #000000;"> {};
        vector</span>&lt;<span style="color: #0000ff;">double</span>&gt;<span style="color: #000000;"> res;
        queue</span>&lt;TreeNode*&gt;<span style="color: #000000;"> q{{root}};
        </span><span style="color: #0000ff;">while</span> (!<span style="color: #000000;">q.empty()) {
            </span><span style="color: #0000ff;">int</span> n =<span style="color: #000000;"> q.size();
            </span><span style="color: #0000ff;">double</span> sum = <span style="color: #800080;">0</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
                TreeNode </span>*t =<span style="color: #000000;"> q.front(); q.pop();
                sum </span>+= t-&gt;<span style="color: #000000;">val;
                </span><span style="color: #0000ff;">if</span> (t-&gt;left) q.push(t-&gt;<span style="color: #000000;">left);
                </span><span style="color: #0000ff;">if</span> (t-&gt;right) q.push(t-&gt;<span style="color: #000000;">right);
            }
            res.push_back(sum </span>/<span style="color: #000000;"> n);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种方法虽然是利用的递归形式的先序遍历，但是其根据判断当前层数level跟结果res中已经初始化的层数之间的关系对比，能把当前结点值累计到正确的位置，而且该层的结点数也自增1，这样我们分别求了两个数组，一个数组保存了每行的所有结点值，另一个保存了每行结点的个数，这样对应位相除就是我们要求的结果了，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">double</span>&gt; averageOfLevels(TreeNode*<span style="color: #000000;"> root) {
        vector</span>&lt;<span style="color: #0000ff;">double</span>&gt;<span style="color: #000000;"> res, cnt;
        helper(root, </span><span style="color: #800080;">0</span><span style="color: #000000;">, cnt, res);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; res.size(); ++<span style="color: #000000;">i) {
            res[i] </span>/=<span style="color: #000000;"> cnt[i];
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">void</span> helper(TreeNode* node, <span style="color: #0000ff;">int</span> level, vector&lt;<span style="color: #0000ff;">double</span>&gt;&amp; cnt, vector&lt;<span style="color: #0000ff;">double</span>&gt;&amp;<span style="color: #000000;"> res) {
        </span><span style="color: #0000ff;">if</span> (!node) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (res.size() &lt;=<span style="color: #000000;"> level) {
            res.push_back(</span><span style="color: #800080;">0</span><span style="color: #000000;">);
            cnt.push_back(</span><span style="color: #800080;">0</span><span style="color: #000000;">);
        }
        res[level] </span>+= node-&gt;<span style="color: #000000;">val;
        </span>++<span style="color: #000000;">cnt[level];
        helper(node</span>-&gt;left, level + <span style="color: #800080;">1</span><span style="color: #000000;">, cnt, res);
        helper(node</span>-&gt;right, level + <span style="color: #800080;">1</span><span style="color: #000000;">, cnt, res);
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4051326.html" target="_blank">Binary Tree Level Order Traversal II</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4051321.html" target="_blank">Binary Tree Level Order Traversal</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/95567/java-solution-using-dfs-with-full-comments" target="_blank">https://discuss.leetcode.com/topic/95567/java-solution-using-dfs-with-full-comments</a></p>
</div>
<div id="interviewed-div"> </div>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a> </p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-07-30 15:08</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7259209" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7259209);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7244767.html" id="cb_post_title_url">[LeetCode] Exclusive Time of Functions 函数的独家时间</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given the running logs of n functions that are executed in a nonpreemptive single threaded CPU, find the exclusive time of these functions.</p>
<p>Each function has a unique id, start from 0 to n-1. A function may be called recursively or by another function.</p>
<p>A log is a string has this format : <code>function_id:start_or_end:timestamp</code>. For example, <code>"0:start:0"</code> means function 0 starts from the very beginning of time 0. <code>"0:end:0"</code> means function 0 ends to the very end of time 0.</p>
<p>Exclusive time of a function is defined as the time spent within this function, the time spent by calling other functions should not be considered as this function's exclusive time. You should return the exclusive time of each function sorted by their function id.</p>
<p>Example 1:</p>
<pre>Input:
n = 2
logs = 
["0:start:0",
 "1:start:2",
 "1:end:5",
 "0:end:6"]
Output:[3, 4]
Explanation:
Function 0 starts at time 0, then it executes 2 units of time and reaches the end of time 1. 
Now function 0 calls function 1, function 1 starts at time 2, executes 4 units of time and end at time 5.
Function 0 is running again at time 6, and also end at the time 6, thus executes 1 unit of time. 
So function 0 totally execute 2 + 1 = 3 units of time, and function 1 totally execute 4 units of time.
</pre>
<p> </p>
<p>Note:</p>
<ol>
<li>Input logs will be sorted by timestamp, NOT log id.</li>
<li>Your output should be sorted by function id, which means the 0th element of your output corresponds to the exclusive time of function 0.</li>
<li>Two functions won't start or end at the same time.</li>
<li>Functions could be called recursively, and will always end.</li>
<li>1 &lt;= n &lt;= 100</li>
</ol>
<p> </p>
<p>这道题让我们函数的独家运行的时间，没错，exclusive就是要翻译成独家，要让每个函数都成为码农的独家记忆～哈～根据题目中给的例子，我们可以看出来，当一个函数start了之后，并不需要必须有end，可以直接被另一个程序start的时候强行关闭。而且，在某个时间点上调用end时，也不需要前面非得调用start，可以直接在某个时间点来个end，这样也算执行了1秒，得+1秒～咳咳，本站禁“苟”，请勿轻易吟诗。博主自以为了解了这个题的逻辑，自己写了一个，结果跪在了下面这个test case：</p>
<p>2<br/>["0:start:0","0:start:2","0:end:5","1:start:7","1:end:7","0:end:8"]</p>
<p>Expected:<br/>[8,1]</p>
<p>这个结果很confusing啊，你想啊，函数0运行了时间点0，1，2，3，4，5，8，共7秒，函数1运行了时间点7，共1秒，为啥答案不是[7,1]而是[8,1]呢？</p>
<p>根据分析网上大神们的解法，貌似时间点6还是函数0在执行。这是为啥呢，说明博主之前的理解有误，当函数0在时间点2时再次开启时，前面那个函数0应该没有被强制关闭，所以现在实际上有两个函数0在执行，所以当我们在时间点5关掉一个函数0时，还有另一个函数0在跑，所以时间点6还是函数0的，还得给函数0续1秒。这样才能解释的通这个case啊。这样的话用栈stack就比较合适了，函数开启了就压入栈，结束了就出栈，不会有函数被漏掉。这样的我们可以遍历每个log，然后把三部分分开，函数idx，类型type，时间点time。如果此时栈不空，说明之前肯定有函数在跑，那么不管当前时start还是end，之前函数时间都得增加，增加的值为time - preTime，这里的preTime是上一个时间点。然后我们更新preTime为当前时间点time。然后我们判断log的类型，如果是start，我们将当前函数压入栈；如果是end，那么我们将栈顶元素取出，对其加1秒，并且preTime也要加1秒，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; exclusiveTime(<span style="color: #0000ff;">int</span> n, vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp;<span style="color: #000000;"> logs) {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; res(n, <span style="color: #800080;">0</span><span style="color: #000000;">);
        stack</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> st;
        </span><span style="color: #0000ff;">int</span> preTime = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">string</span><span style="color: #000000;"> log : logs) {
            </span><span style="color: #0000ff;">int</span> found1 = log.find(<span style="color: #800000;">"</span><span style="color: #800000;">:</span><span style="color: #800000;">"</span><span style="color: #000000;">);
            </span><span style="color: #0000ff;">int</span> found2 = log.find_last_of(<span style="color: #800000;">"</span><span style="color: #800000;">:</span><span style="color: #800000;">"</span><span style="color: #000000;">);
            </span><span style="color: #0000ff;">int</span> idx = stoi(log.substr(<span style="color: #800080;">0</span><span style="color: #000000;">, found1));
            </span><span style="color: #0000ff;">string</span> type = log.substr(found1 + <span style="color: #800080;">1</span>, found2 - found1 - <span style="color: #800080;">1</span><span style="color: #000000;">);
            </span><span style="color: #0000ff;">int</span> time = stoi(log.substr(found2 + <span style="color: #800080;">1</span><span style="color: #000000;">));
            </span><span style="color: #0000ff;">if</span> (!<span style="color: #000000;">st.empty()) {
                res[st.top()] </span>+= time -<span style="color: #000000;"> preTime;
            }
            preTime </span>=<span style="color: #000000;"> time;
            </span><span style="color: #0000ff;">if</span> (type == <span style="color: #800000;">"</span><span style="color: #800000;">start</span><span style="color: #800000;">"</span><span style="color: #000000;">) st.push(idx);
            </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                auto t </span>=<span style="color: #000000;"> st.top(); st.pop();
                </span>++<span style="color: #000000;">res[t];
                </span>++<span style="color: #000000;">preTime;
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种方法比较叼的地方是在于使用了C语言的sscanf函数来一步读取了三个变量，注意这里面的"[^:]"，表示copy所有字符，直到遇到':'，这样就能把中间的start或者end拷到type中去了。而且接下来的写法跟上面也不太相同，这里先判断了type的类型，如果是start，那么再看如果栈不为空，那么栈顶函数加上时间差，这个上面讲过了，然后将当前函数压入栈；如果是end，那么栈顶元素加上时间差，还要再加1秒，这个在上面也提到了加了1秒的事，然后再将栈顶元素出栈。最后更新preTime为当前时间点。讲解中加了这么多秒，博主已经尽力了。。。</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; exclusiveTime(<span style="color: #0000ff;">int</span> n, vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp;<span style="color: #000000;"> logs) {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; res(n, <span style="color: #800080;">0</span><span style="color: #000000;">);
        stack</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> st;
        </span><span style="color: #0000ff;">int</span> preTime = <span style="color: #800080;">0</span>, idx = <span style="color: #800080;">0</span>, time = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">char</span> type[<span style="color: #800080;">10</span><span style="color: #000000;">];
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">string</span><span style="color: #000000;"> log : logs) {
            sscanf(log.c_str(), </span><span style="color: #800000;">"</span><span style="color: #800000;">%d:%[^:]:%d</span><span style="color: #800000;">"</span>, &amp;idx, type, &amp;<span style="color: #000000;">time);
            </span><span style="color: #0000ff;">if</span> (type[<span style="color: #800080;">0</span>] == <span style="color: #800000;">'</span><span style="color: #800000;">s</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                </span><span style="color: #0000ff;">if</span> (!<span style="color: #000000;">st.empty()) {
                    res[st.top()] </span>+= time -<span style="color: #000000;"> preTime;
                }
                st.push(idx);
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                res[st.top()] </span>+= ++time -<span style="color: #000000;"> preTime;
                st.pop();
            }
            preTime </span>=<span style="color: #000000;"> time;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/96120/simple-c-using-stack">https://discuss.leetcode.com/topic/96120/simple-c-using-stack</a></p>
<p><a href="https://discuss.leetcode.com/topic/96068/java-stack-solution-o-n-time-o-n-space">https://discuss.leetcode.com/topic/96068/java-stack-solution-o-n-time-o-n-space</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-07-27 14:42</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7244767" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7244767);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7224525.html" id="cb_post_title_url">[LeetCode] Design Log Storage System 设计日志存储系统</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>You are given several logs that each log contains a unique id and timestamp. Timestamp is a string that has the following format: <code>Year:Month:Day:Hour:Minute:Second</code>, for example, <code>2017:01:01:23:59:59</code>. All domains are zero-padded decimal numbers.</p>
<p>Design a log storage system to implement the following functions:</p>
<p><code>void Put(int id, string timestamp)</code>: Given a log's unique id and timestamp, store the log in your storage system.</p>
<p> </p>
<p><code>int[] Retrieve(String start, String end, String granularity)</code>: Return the id of logs whose timestamps are within the range from start to end. Start and end all have the same format as timestamp. However, granularity means the time level for consideration. For example, start = "2017:01:01:23:59:59", end = "2017:01:02:23:59:59", granularity = "Day", it means that we need to find the logs within the range from Jan. 1st 2017 to Jan. 2nd 2017.</p>
<p>Example 1:</p>
<pre>put(1, "2017:01:01:23:59:59");
put(2, "2017:01:01:22:59:59");
put(3, "2016:01:01:00:00:00");
retrieve("2016:01:01:01:01:01","2017:01:01:23:00:00","Year"); // return [1,2,3], because you need to return all logs within 2016 and 2017.
retrieve("2016:01:01:01:01:01","2017:01:01:23:00:00","Hour"); // return [1,2], because you need to return all logs start from 2016:01:01:01 to 2017:01:01:23, where log 3 is left outside the range.
</pre>
<p> </p>
<p>Note:</p>
<ol>
<li>There will be at most 300 operations of Put or Retrieve.</li>
<li>Year ranges from [2000,2017]. Hour ranges from [00,23].</li>
<li>Output for Retrieve has no order required.</li>
</ol>
<p> </p>
<p>这道题让我们设计一个日志存储系统，给了日志的生成时间和日志编号，日志的生成时间是精确到秒的，然后我们主要需要完成一个retrieve函数，这个函数会给一个起始时间，结束时间，还有一个granularity精确度，可以精确到任意的年月日时分秒，可以分析下题目中的例子，应该不难理解。我们首先需要一个数据结构来存储每个日志的编号和时间戳，那么这里我们就用一个数组，里面存pair，这样就能存下日志的数据了。然后由于我们要用到精确度，所以我们用一个units数组来列出所有可能的精确度了。下面就是本题的难点了，如何能正确的在时间范围内取出日志。由于精确度的存在，比如精确度是Day，那么我们就不关心后面的时分秒是多少了，只需要比到天就行了。判断是否在给定的时间范围内的方法也很简单，看其是否大于起始时间，且小于结束时间，我们甚至可以直接用字符串相比较，不用换成秒啥的太麻烦。所以我们可以根据时间精度确定要比的子字符串的位置，然后直接相比就行了。所以我们需要一个indices数组，来对应我们的units数组，记录下每个时间精度下取出的字符的个数。然后在retrieve函数中，遍历所有的日志，快速的根据时间精度取出对应的时间戳并且和起始结束时间相比，在其之间的就把序号加入结果res即可，参见代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> LogSystem {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    LogSystem() {
        units </span>= {<span style="color: #800000;">"</span><span style="color: #800000;">Year</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">Month</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">Day</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">Hour</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">Minute</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">Second</span><span style="color: #800000;">"</span><span style="color: #000000;">};
        indices </span>= {<span style="color: #800080;">4</span>, <span style="color: #800080;">7</span>, <span style="color: #800080;">10</span>, <span style="color: #800080;">13</span>, <span style="color: #800080;">16</span>, <span style="color: #800080;">19</span><span style="color: #000000;">}; 
    }
    
    </span><span style="color: #0000ff;">void</span> put(<span style="color: #0000ff;">int</span> id, <span style="color: #0000ff;">string</span><span style="color: #000000;"> timestamp) {
        timestamps.push_back({id, timestamp});
    }
    
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; retrieve(<span style="color: #0000ff;">string</span> s, <span style="color: #0000ff;">string</span> e, <span style="color: #0000ff;">string</span><span style="color: #000000;"> gra) {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">int</span> idx = indices[find(units.begin(), units.end(), gra) -<span style="color: #000000;"> units.begin()];
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto p : timestamps) {
            </span><span style="color: #0000ff;">string</span> t =<span style="color: #000000;"> p.second;
            </span><span style="color: #0000ff;">if</span> (t.substr(<span style="color: #800080;">0</span>, idx).compare(s.substr(<span style="color: #800080;">0</span>, idx)) &gt;= <span style="color: #800080;">0</span> &amp;&amp; t.substr(<span style="color: #800080;">0</span>, idx).compare(e.substr(<span style="color: #800080;">0</span>, idx)) &lt;= <span style="color: #800080;">0</span><span style="color: #000000;">) {
                res.push_back(p.first);
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }

</span><span style="color: #0000ff;">private</span><span style="color: #000000;">:
    vector</span>&lt;pair&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">string</span>&gt;&gt;<span style="color: #000000;"> timestamps;
    vector</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> units;
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> indices;
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/6944331.html">Design In-Memory File System</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/94449/concise-java-solution">https://discuss.leetcode.com/topic/94449/concise-java-solution</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-07-23 14:01</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7224525" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7224525);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7210929.html" id="cb_post_title_url">[LeetCode] Find the Derangement of An Array 找数组的错排</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>In combinatorial mathematics, a derangement is a permutation of the elements of a set, such that no element appears in its original position.</p>
<p>There's originally an array consisting of <code>n</code> integers from 1 to <code>n</code> in ascending order, you need to find the number of derangement it can generate.</p>
<p>Also, since the answer may be very large, you should return the output mod 10<sup>9</sup> + 7.</p>
<p>Example 1:</p>
<pre>Input: 3
Output: 2
Explanation: The original array is [1,2,3]. The two derangements are [2,3,1] and [3,1,2].
</pre>
<p> </p>
<p>Note:<br/><code>n</code> is in the range of [1, 106].</p>
<p> </p>
<p>这道题给了我们一个数组，让我们求其错排的个数，所谓错排就是1到n中的每个数字都不在其原有的位置上，全部打乱了，问能有多少种错排的方式。博主注意到了这道题又让对一个很大的数取余，而且每次那个很大的数都是10<sup>9</sup> + 7，为啥大家都偏爱这个数呢，有啥特别之处吗？根据博主之前的经验，这种结果很大很大的题十有八九都是用dp来做的，那么就建一个一维的dp数组吧，其中dp[i]表示1到i中的错位排列的个数。那么难点就是找递推公式啦，先从最简单的情况来看:</p>
<p>n = 1 时有 0 种错排</p>
<p>n = 2 时有 1 种错排 [2, 1]</p>
<p>n = 3 时有 2 种错排 [3, 1, 2], [2, 3, 1]</p>
<p>然后博主就在想知道了dp[2]，能求出dp[3]吗，又在考虑是不是算加入数字3的情况的个数。结果左看右看发现没有啥特别的规律，又在想是不是有啥隐含的信息需要挖掘，还是没想出来。于是看了一眼标签，发现是Math，我的天，难道又是小学奥数的题？挣扎了半天最后还是放弃了，上网去搜大神们的解法。其实这道题是组合数学种的<a href="https://zh.wikipedia.org/wiki/%E9%94%99%E6%8E%92%E9%97%AE%E9%A2%98" target="_blank">错排问题</a>，是有专门的递归公式的。</p>
<p>我们来想n = 4时该怎么求，我们假设把4排在了第k位，这里我们就让k = 3吧，那么我们就把4放到了3的位置，变成了：</p>
<p>x x 4 x</p>
<p>我们看被4占了位置的3，应该放到哪里，这里分两种情况，如果3放到了4的位置，那么有：</p>
<p>x x 4 3</p>
<p>那么此时4和3的位置都确定了，实际上只用排1和2了，那么就相当于只排1和2，就是dp[2]的值，是已知的。那么再来看第二种情况，3不在4的位置，那么此时我们把4去掉的话，就又变成了：</p>
<p>x x x</p>
<p>这里3不能放在第3个x的位置，在去掉4之前，这里是移动4之前的4的位置，那么实际上这又变成了排1，2，3的情况了，就是dp[3]的值。</p>
<p>再回到最开始我们选k的时候，我们当时选了k = 3，其实k可以等于1,2,3，也就是有三种情况，所以dp[4] = 3 * (dp[3] + dp[2])。</p>
<p>那么递推公式也就出来了：</p>
<p>dp[i] = (i - 1) * (dp[i - 1] + dp[i - 2])</p>
<p>有了递推公式，代码就不难写了吧，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> findDerangement(<span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        </span><span style="color: #0000ff;">if</span> (n &lt; <span style="color: #800080;">2</span>) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        vector</span>&lt;<span style="color: #0000ff;">long</span> <span style="color: #0000ff;">long</span>&gt; dp(n + <span style="color: #800080;">1</span>, <span style="color: #800080;">0</span><span style="color: #000000;">);
        dp[</span><span style="color: #800080;">1</span>] = <span style="color: #800080;">0</span>; dp[<span style="color: #800080;">2</span>] = <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">3</span>; i &lt;= n; ++<span style="color: #000000;">i) {
            dp[i] </span>= (dp[i - <span style="color: #800080;">1</span>] + dp[i - <span style="color: #800080;">2</span>]) * (i - <span style="color: #800080;">1</span>) % <span style="color: #800080;">1000000007</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> dp[n];
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种解法精简了空间，因为当前值只跟前两个值有关系，所以没必要保留整个数组，只用两个变量来记录前两个值，并每次更新一下就好了，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> findDerangement(<span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        </span><span style="color: #0000ff;">long</span> <span style="color: #0000ff;">long</span> a = <span style="color: #800080;">0</span>, b = <span style="color: #800080;">1</span>, res = <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">3</span>; i &lt;= n; ++<span style="color: #000000;">i) {
            res </span>= (i - <span style="color: #800080;">1</span>) * (a + b) % <span style="color: #800080;">1000000007</span><span style="color: #000000;">;
            a </span>=<span style="color: #000000;"> b;
            b </span>=<span style="color: #000000;"> res;
        }
        </span><span style="color: #0000ff;">return</span> (n == <span style="color: #800080;">1</span>) ? <span style="color: #800080;">0</span><span style="color: #000000;"> : res;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种方法是对之前的递推公式进行了推导变形，使其只跟前一个数有关，具体的推导步骤是这样的：</p>
<p>我们假设 e[i] = dp[i] - i * dp[i - 1]</p>
<p>递推公式为:  dp[i] = (i - 1) * (dp[i - 1] + dp[i - 2])</p>
<p>将递推公式带入假设，得到：</p>
<p>e[i] = -dp[i - 1] + (n - 1) * dp[i - 2] = -e[i - 1]</p>
<p>从而得到 e[i] = (-1)^n</p>
<p>那么带回假设公式，可得: dp[i] = i * dp[i - 1] + (-1)^n</p>
<p>根据这个新的递推公式，可以写出代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> findDerangement(<span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        </span><span style="color: #0000ff;">long</span> <span style="color: #0000ff;">long</span> res = <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt;= n; ++<span style="color: #000000;">i) {
            res </span>= (i * res + (i % <span style="color: #800080;">2</span> == <span style="color: #800080;">0</span> ? <span style="color: #800080;">1</span> : -<span style="color: #800080;">1</span>)) % <span style="color: #800080;">1000000007</span><span style="color: #000000;">; 
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/94429/o-n-short-java-code" target="_blank">https://discuss.leetcode.com/topic/94429/o-n-short-java-code</a></p>
<p><a href="https://discuss.leetcode.com/topic/94767/java-dp-solution-with-explanation" target="_blank">https://discuss.leetcode.com/topic/94767/java-dp-solution-with-explanation</a></p>
<p><a href="https://discuss.leetcode.com/topic/94421/java-solution-with-explanation-by-using-staggered-formula" target="_blank">https://discuss.leetcode.com/topic/94421/java-solution-with-explanation-by-using-staggered-formula</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-07-20 14:05</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7210929" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7210929);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7190506.html" id="cb_post_title_url">[LeetCode] Sum of Square Numbers 平方数之和</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a non-negative integer <code>c</code>, your task is to decide whether there're two integers <code>a</code> and <code>b</code> such that a2 + b2 = c.</p>
<p>Example 1:</p>
<pre>Input: 5
Output: True
Explanation: 1 * 1 + 2 * 2 = 5
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input: 3
Output: False</pre>
<p> </p>
<p>这道题让我们求一个数是否能由平方数之和组成，刚开始博主没仔细看题，没有看到必须要是两个平方数之和，博主以为任意一个就可以。所以写了个带优化的递归解法，楼主已经不是上来就无脑暴力破解的辣个青葱骚年了，直接带优化。可是居然对14返回false，难道14不等于1+4+9吗，结果仔细一看，必须要两个平方数之和。好吧，那么递归都省了，直接判断两次就行了。我们可以从c的平方根，注意即使c不是平方数，也会返回一个整型数。然后我们判断如果i*i等于c，说明c就是个平方数，只要再凑个0，就是两个平方数之和，返回true；如果不等于的话，那么算出差值c - i*i，如果这个差值也是平方数的话，返回true。遍历结束后返回false，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> judgeSquareSum(<span style="color: #0000ff;">int</span><span style="color: #000000;"> c) {
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = sqrt(c); i &gt;= <span style="color: #800080;">0</span>; --<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (i * i == c) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">int</span> d = c - i * i, t =<span style="color: #000000;"> sqrt(d);
            </span><span style="color: #0000ff;">if</span> (t * t == d) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种方法用到了集合set，从0遍历到c的平方根，对于每个i*i，都加入集合set中，然后计算c - i*i，如果这个差值也在集合set中，返回true，遍历结束返回false，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> judgeSquareSum(<span style="color: #0000ff;">int</span><span style="color: #000000;"> c) {
        unordered_set</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> s;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt;= sqrt(c); ++<span style="color: #000000;">i) {
            s.insert(i </span>*<span style="color: #000000;"> i);
            </span><span style="color: #0000ff;">if</span> (s.count(c - i * i)) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>上面两种方法都不是很高效，来看下面这种高效的解法。论坛上有人称之为二分解法，但是博主怎么觉得不是呢，虽然样子很像，但是并没有折半的操作啊。这里用a和b代表了左右两个范围，分别为0和c的平方根，然后while循环遍历，如果a*a + b*b刚好等于c，那么返回true；如果小于c，则a增大1；反之如果大于c，则b自减1，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> judgeSquareSum(<span style="color: #0000ff;">int</span><span style="color: #000000;"> c) {
        </span><span style="color: #0000ff;">int</span> a = <span style="color: #800080;">0</span>, b =<span style="color: #000000;"> sqrt(c);
        </span><span style="color: #0000ff;">while</span> (a &lt;=<span style="color: #000000;"> b) {
            </span><span style="color: #0000ff;">if</span> (a * a + b * b == c) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (a * a + b * b &lt; c) ++<span style="color: #000000;">a;
            </span><span style="color: #0000ff;">else</span> --<span style="color: #000000;">b;
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/5619296.html">Valid Perfect Square</a> </p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/94568/simple-c-solution" target="_blank">https://discuss.leetcode.com/topic/94568/simple-c-solution</a></p>
<p><a href="https://discuss.leetcode.com/topic/94435/java-two-pointers-solution" target="_blank">https://discuss.leetcode.com/topic/94435/java-two-pointers-solution</a></p>
<p><a href="https://discuss.leetcode.com/topic/94453/hashset-java-quick-solution-one-for-loop" target="_blank">https://discuss.leetcode.com/topic/94453/hashset-java-quick-solution-one-for-loop</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-07-16 14:43</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7190506" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7190506);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7200016.html" id="cb_post_title_url">[LeetCode] Smallest Range 最小的范围</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>You have <code>k</code> lists of sorted integers in ascending order. Find the smallest range that includes at least one number from each of the <code>k</code> lists.</p>
<p>We define the range [a,b] is smaller than range [c,d] if <code>b-a &lt; d-c</code> or <code>a &lt; c</code> if <code>b-a == d-c</code>.</p>
<p>Example 1:</p>
<pre>Input:[[4,10,15,24,26], [0,9,12,20], [5,18,22,30]]
Output: [20,24]
Explanation: 
List 1: [4, 10, 15, 24,26], 24 is in range [20,24].
List 2: [0, 9, 12, 20], 20 is in range [20,24].
List 3: [5, 18, 22, 30], 22 is in range [20,24].
</pre>
<p> </p>
<p>Note:</p>
<ol>
<li>The given list may contain duplicates, so ascending order means &gt;= here.</li>
<li>1 &lt;= <code>k</code> &lt;= 3500</li>
<li>-105 &lt;= <code>value of elements</code> &lt;= 105.</li>
<li>For Java users, please note that the input type has been changed to List&lt;List&lt;Integer&gt;&gt;. And after you reset the code template, you'll see this point.</li>
</ol>
<p> </p>
<p>这道题给了我们一些数组，都是排好序的，让我们求一个最小的范围，使得这个范围内至少会包括每个数组中的一个数字。虽然每个数组都是有序的，但是考虑到他们之间的数字差距可能很大，所以我们最好还是合并成一个数组统一处理比较好，但是合并成一个大数组还需要保留其原属数组的序号，所以我们大数组中存pair对，同时保存数字和原数组的序号。然后我们重新按照数字大小进行排序，这样我们的问题实际上就转换成了求一个最小窗口，使其能够同时包括所有数组中的至少一个数字。这不就变成了那道<a href="http://www.cnblogs.com/grandyang/p/4340948.html" target="_blank">Minimum Window Substring</a>。所以说啊，这些题目都是换汤不换药的，总能变成我们见过的类型。我们用两个指针left和right来确定滑动窗口的范围，我们还要用一个哈希表来建立每个数组与其数组中数字出现的个数之间的映射，变量cnt表示当前窗口中的数字覆盖了几个数组，diff为窗口的大小，我们让right向右滑动，然后判断如果right指向的数字所在数组没有被覆盖到，cnt自增1，然后哈希表中对应的数组出现次数自增1，然后我们循环判断如果cnt此时为k(数组的个数)且left不大于right，那么我们用当前窗口的范围来更新结果，然后此时我们想缩小窗口，通过将left向右移，移动之前需要减小哈希表中的映射值，因为我们去除了数字，如果此时映射值为0了，说明我们有个数组无法覆盖到了，cnt就要自减1。这样遍历后我们就能得到最小的范围了，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; smallestRange(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> nums) {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> res;
        vector</span>&lt;pair&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;&gt;<span style="color: #000000;"> v;
        unordered_map</span>&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> m;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; nums.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span><span style="color: #000000;"> num : nums[i]) {
                v.push_back({num, i});
            }
        }
        sort(v.begin(), v.end());
        </span><span style="color: #0000ff;">int</span> left = <span style="color: #800080;">0</span>, n = v.size(), k = nums.size(), cnt = <span style="color: #800080;">0</span>, diff =<span style="color: #000000;"> INT_MAX;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> right = <span style="color: #800080;">0</span>; right &lt; n; ++<span style="color: #000000;">right) {
            </span><span style="color: #0000ff;">if</span> (m[v[right].second] == <span style="color: #800080;">0</span>) ++<span style="color: #000000;">cnt;
            </span>++<span style="color: #000000;">m[v[right].second];
            </span><span style="color: #0000ff;">while</span> (cnt == k &amp;&amp; left &lt;=<span style="color: #000000;"> right) {
                </span><span style="color: #0000ff;">if</span> (diff &gt; v[right].first -<span style="color: #000000;"> v[left].first) {
                    diff </span>= v[right].first -<span style="color: #000000;"> v[left].first;
                    res </span>=<span style="color: #000000;"> {v[left].first, v[right].first};
                } 
                </span><span style="color: #0000ff;">if</span> (--m[v[left].second] == <span style="color: #800080;">0</span>) --<span style="color: #000000;">cnt;
                </span>++<span style="color: #000000;">left;
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>这道题还有一种使用priority_queue来做的，优先队列默认情况是最大堆，但是这道题我们需要使用最小堆，我们可以重新写一下comparator就行了。解题的主要思路很上面的解法很相似，只是具体的数据结构的使用上略有不同，这curMax表示当前遇到的最大数字，用一个idx数组表示每个list中遍历到的位置，然后就是我们的优先队列了，里面放一个pair，是数字和其所属list组成的对儿。然后我们遍历所有的list，将每个list的首元素和该list序号组成pair放入队列中，然后idx数组中每个位置都赋值为1，因为0的位置已经放入队列了，所以指针向后移一个位置，还要更新当前最大值curMax。此时我们的queue中是每个list各有一个数字，由于是最小堆，所以最小的数字就在队首，再加上最大值curMax，就可以初始化结果res了。然后我们进行循环，注意这里循环的条件不是队列不为空，而是当某个list的数字遍历完了就结束循环，因为我们的范围要cover每个list至少一个数字。所以我们的while循环条件即是队首数字所在的list的遍历位置小于该list的总个数，在循环中，取出队首数字所在的list序号t，然后将该list中下一个位置的数字和该list序号t组成pair，加入队列中，然后用这个数字更新curMax，同时idx中t对应的位置也自增1。现在来更新结果res，如果结果res中两数之差大于curMax和队首数字之差，则我们更新结果res，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; smallestRange(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> nums) {
        </span><span style="color: #0000ff;">int</span> curMax = INT_MIN, n =<span style="color: #000000;"> nums.size();
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; idx(n, <span style="color: #800080;">0</span><span style="color: #000000;">);
        auto cmp </span>= [](pair&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;&amp; a, pair&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;&amp; b) {<span style="color: #0000ff;">return</span> a.first &gt;<span style="color: #000000;"> b.first;};
        priority_queue</span>&lt;pair&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;, vector&lt;pair&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;&gt;, decltype(cmp) &gt;<span style="color: #000000;"> q(cmp);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            q.push({nums[i][</span><span style="color: #800080;">0</span><span style="color: #000000;">], i});
            idx[i] </span>= <span style="color: #800080;">1</span><span style="color: #000000;">;
            curMax </span>= max(curMax, nums[i][<span style="color: #800080;">0</span><span style="color: #000000;">]);
        }
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> res{q.top().first, curMax};
        </span><span style="color: #0000ff;">while</span> (idx[q.top().second] &lt;<span style="color: #000000;"> nums[q.top().second].size()) {
            </span><span style="color: #0000ff;">int</span> t =<span style="color: #000000;"> q.top().second; q.pop();
            q.push({nums[t][idx[t]], t});
            curMax </span>=<span style="color: #000000;"> max(curMax, nums[t][idx[t]]);
            </span>++<span style="color: #000000;">idx[t];
            </span><span style="color: #0000ff;">if</span> (res[<span style="color: #800080;">1</span>] - res[<span style="color: #800080;">0</span>] &gt; curMax -<span style="color: #000000;"> q.top().first) {
                res </span>=<span style="color: #000000;"> {q.top().first, curMax};
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4340948.html" target="_blank">Minimum Window Substring</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/94448/c-solution-with-priority_queue">https://discuss.leetcode.com/topic/94448/c-solution-with-priority_queue</a></p>
<p><a href="https://discuss.leetcode.com/topic/96509/c-45ms-o-n-space-o-n-time-sol-without-priority-queue-iterators-just-vectors">https://discuss.leetcode.com/topic/96509/c-45ms-o-n-space-o-n-time-sol-without-priority-queue-iterators-just-vectors</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-07-18 13:26</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7200016" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7200016);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7170238.html" id="cb_post_title_url">[LeetCode] Design Excel Sum Formula 设计Excel表格求和公式</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Your task is to design the basic function of Excel and implement the function of sum formula. Specifically, you need to implement the following functions:</p>
<p><code>Excel(int H, char W):</code> This is the constructor. The inputs represents the height and width of the Excel form. His a positive integer, range from 1 to 26. It represents the height. W is a character range from 'A' to 'Z'. It represents that the width is the number of characters from 'A' to W. The Excel form content is represented by a height * width 2D integer array <code>C</code>, it should be initialized to zero. You should assume that the first row of <code>C</code> starts from 1, and the first column of <code>C</code> starts from 'A'.</p>
<p> </p>
<p><code>void Set(int row, char column, int val):</code> Change the value at <code>C(row, column)</code> to be val.</p>
<p> </p>
<p><code>int Get(int row, char column):</code> Return the value at <code>C(row, column)</code>.</p>
<p> </p>
<p><code>int Sum(int row, char column, List of Strings : numbers):</code> This function calculate and set the value at <code>C(row, column)</code>, where the value should be the sum of cells represented by <code>numbers</code>. This function return the sum result at <code>C(row, column)</code>. This sum formula should exist until this cell is overlapped by another value or another sum formula.</p>
<p><code>numbers</code> is a list of strings that each string represent a cell or a range of cells. If the string represent a single cell, then it has the following format : <code>ColRow</code>. For example, "F7" represents the cell at (7, F).</p>
<p>If the string represent a range of cells, then it has the following format : <code>ColRow1:ColRow2</code>. The range will always be a rectangle, and ColRow1 represent the position of the top-left cell, and ColRow2 represents the position of the bottom-right cell.</p>
<p> </p>
<p>Example 1:</p>
<pre>Excel(3,"C"); 
// construct a 3*3 2D array with all zero.
//   A B C
// 1 0 0 0
// 2 0 0 0
// 3 0 0 0

Set(1, "A", 2);
// set C(1,"A") to be 2.
//   A B C
// 1 2 0 0
// 2 0 0 0
// 3 0 0 0

Sum(3, "C", ["A1", "A1:B2"]);
// set C(3,"C") to be the sum of value at C(1,"A") and the values sum of the rectangle range whose top-left cell is C(1,"A") and bottom-right cell is C(2,"B"). Return 4. 
//   A B C
// 1 2 0 0
// 2 0 0 0
// 3 0 0 4

Set(2, "B", 2);
// set C(2,"B") to be 2. Note C(3, "C") should also be changed.
//   A B C
// 1 2 0 0
// 2 0 2 0
// 3 0 0 6
</pre>
<p> </p>
<p>Note:</p>
<ol>
<li>You could assume that there won't be any circular sum reference. For example, A1 = sum(B1) and B1 = sum(A1).</li>
<li>The test cases are using double-quotes to represent a character.</li>
<li>Please remember to RESET your class variables declared in class Excel, as static/class variables are persisted across multiple test cases. Please see <a href="https://leetcode.com/faq/#different-output">here</a> for more details.</li>
</ol>
<p> </p>
<p>这道题让我们设计Excel表格的求和公式，Excel表格想必大家都用过，还是比较熟悉的，这里让我们对单元格进行求和运算。由于这道题里要求二维数组的局部和，而且又会经常更新数组的值，博主第一反应觉得应该用之前那题<a href="http://www.cnblogs.com/grandyang/p/5300458.html" target="_blank">Range Sum Query 2D - Mutable</a>中的树状数组来做，结果哼哼哧哧的写完后，发现下面这个test case没通过：</p>
<p>["Excel","sum","set","get"]<br/>[[3,"C"],[1,"A",["A2"]],[2,"A",1],[1,"A"]]<br/>Expected:<br/>[null,0,null,1]</p>
<p>仔细分析一下发现，这个case先把A2的值赋给了A1，此时A1和A2都是0，然后给A2赋值为1，求A1的值。大家的第一印象肯定是觉得A1还是0啊，其实在Excel中，相当于已经把A1和A2关联起来了，只要A2点值发生了改变，A1的值也会跟着变，所以A1的值此时也为1。而树状数组的主要功能的优化区域和的计算速度，并没有建立关联的步骤，难怪不能通过OJ呢。这道题标记为Hard还是有道理的，我们要模拟出Excel表中的这种关联方式，这里参考的是<a href="https://discuss.leetcode.com/topic/93819/c-3-ms-solution-easy-to-understand" target="_blank">yupinglu大神的帖子</a>，首先我们肯定需要一个二维数组mat来保存数据，然后需要一个map来建立单元格和区域和之间的映射，这里的区域和就是sum函数中的字符串数组表示的内容，可参见题目中的例子，有可能单个单元格或者多个。</p>
<p>我们来看set函数，如果我们改变了某个单元格的内容，那么如果作为结果单元格，那么对应的链接就会断开。比如我们有三个单元格A1, B1, C1，我们设置的关联是A1 + B1 = C1，那么我们改变A1和B1的值都是OK的，C1的值会自动更新。但如果我们改变了C1的值，那么这个关联就不复存在了，Excel中也是这样的。所以我们在改变某个单元格的时候，要将其的关联删除。</p>
<p>我们再来看get函数，我们在获取某个单元格的值的时候，一定要先看其有没有和其他单元格关联，如果有的话，要重新计算一下关联，有可能关联的单元格的值已经发生改变了，那么当前作为结果单元格的值也需要改变；如果该单元格没有任何关联，那么就直接从数组mat中取值即可。</p>
<p>最后看本题的难点sum函数，要根据关联格求出结果格的值，首先这个字符串数组可能有多个字符串，每个字符串有两个可能，一种是单个的单元格，一种是两个单元格中间用冒号隔开。那么我们需要分情况讨论，区别这两种情况的方法就是看冒号是否存在，如果不存在，就说明只有一个单元格，我们将其数字和字母都提取出来，调用get函数，将该位置的值加入结果res中；如果冒号存在，我们根据冒号的位置，分别将两个单元格的字母和数字提取出来，然后遍历这两个单元格之间所有的单元格，调用get函数并将返回值加入结果res中。这个遍历相加的过程可能可以用树状数组来优化，但由于这不是此题的考察重点，所以直接遍历就OK。最后别忘了建立目标单元格和区域字符串数组之间的映射，并返回结果res即可。</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Excel {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    Excel(</span><span style="color: #0000ff;">int</span> H, <span style="color: #0000ff;">char</span><span style="color: #000000;"> W) {
        m.clear();
        mat.resize(H, vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;(W - <span style="color: #800000;">'</span><span style="color: #800000;">A</span><span style="color: #800000;">'</span>, <span style="color: #800080;">0</span><span style="color: #000000;">));
    }
    
    </span><span style="color: #0000ff;">void</span> <span style="color: #0000ff;">set</span>(<span style="color: #0000ff;">int</span> r, <span style="color: #0000ff;">char</span> c, <span style="color: #0000ff;">int</span><span style="color: #000000;"> v) {
        </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (m.count({r, c})) m.erase({r, c});
        mat[r </span>- <span style="color: #800080;">1</span>][c - <span style="color: #800000;">'</span><span style="color: #800000;">A</span><span style="color: #800000;">'</span>] =<span style="color: #000000;"> v;
    }
    
    </span><span style="color: #0000ff;">int</span> <span style="color: #0000ff;">get</span>(<span style="color: #0000ff;">int</span> r, <span style="color: #0000ff;">char</span><span style="color: #000000;"> c) {
        </span><span style="color: #0000ff;">if</span> (m.count({r, c})) <span style="color: #0000ff;">return</span><span style="color: #000000;"> sum(r, c, m[{r, c}]);
        </span><span style="color: #0000ff;">return</span> mat[r - <span style="color: #800080;">1</span>][c - <span style="color: #800000;">'</span><span style="color: #800000;">A</span><span style="color: #800000;">'</span><span style="color: #000000;">];
    }
    
    </span><span style="color: #0000ff;">int</span> sum(<span style="color: #0000ff;">int</span> r, <span style="color: #0000ff;">char</span> c, vector&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> strs) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">string</span><span style="color: #000000;"> str : strs) {
            auto found </span>= str.find_last_of(<span style="color: #800000;">"</span><span style="color: #800000;">:</span><span style="color: #800000;">"</span><span style="color: #000000;">);
            </span><span style="color: #0000ff;">if</span> (found == <span style="color: #0000ff;">string</span><span style="color: #000000;">::npos) {
                </span><span style="color: #0000ff;">char</span> y = str[<span style="color: #800080;">0</span><span style="color: #000000;">];
                </span><span style="color: #0000ff;">int</span> x = stoi(str.substr(<span style="color: #800080;">1</span><span style="color: #000000;">));
                res </span>+= <span style="color: #0000ff;">get</span><span style="color: #000000;">(x, y);
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                </span><span style="color: #0000ff;">int</span> x1 = stoi(str.substr(<span style="color: #800080;">1</span>, (<span style="color: #0000ff;">int</span>)found - <span style="color: #800080;">1</span>)), y1 = str[<span style="color: #800080;">0</span>] - <span style="color: #800000;">'</span><span style="color: #800000;">A</span><span style="color: #800000;">'</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">int</span> x2 = stoi(str.substr(found + <span style="color: #800080;">2</span>)), y2 = str[found + <span style="color: #800080;">1</span>] - <span style="color: #800000;">'</span><span style="color: #800000;">A</span><span style="color: #800000;">'</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = x1; i &lt;= x2; ++<span style="color: #000000;">i) {
                    </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = y1; j &lt;= y2; ++<span style="color: #000000;">j) {
                        res </span>+= <span style="color: #0000ff;">get</span>(i, j + <span style="color: #800000;">'</span><span style="color: #800000;">A</span><span style="color: #800000;">'</span><span style="color: #000000;">);
                    }
                }
            }
        }
        m[{r, c}] </span>=<span style="color: #000000;"> strs;
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }

</span><span style="color: #0000ff;">private</span><span style="color: #000000;">:
    vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;<span style="color: #000000;"> mat;
    map</span>&lt;pair&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">char</span>&gt;, vector&lt;<span style="color: #0000ff;">string</span>&gt;&gt;<span style="color: #000000;"> m;
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/93819/c-3-ms-solution-easy-to-understand" target="_blank">https://discuss.leetcode.com/topic/93819/c-3-ms-solution-easy-to-understand</a></p>
<p><a href="https://discuss.leetcode.com/topic/93812/c-3-ms-concise-and-easy-to-understand" target="_blank">https://discuss.leetcode.com/topic/93812/c-3-ms-concise-and-easy-to-understand</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-07-14 14:42</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7170238" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7170238);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7126289.html" id="cb_post_title_url">[LeetCode] Course Schedule III 课程清单之三</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>There are <code>n</code> different online courses numbered from <code>1</code> to <code>n</code>. Each course has some duration(course length) <code>t</code>and closed on <code>dth</code> day. A course should be taken continuously for <code>t</code> days and must be finished before or on the <code>dth</code> day. You will start at the <code>1st</code> day.</p>
<p>Given <code>n</code> online courses represented by pairs <code>(t,d)</code>, your task is to find the maximal number of courses that can be taken.</p>
<p>Example:</p>
<pre>Input: [[100, 200], [200, 1300], [1000, 1250], [2000, 3200]]
Output: 3
Explanation: 
There're totally 4 courses, but you can take 3 courses at most:
First, take the 1st course, it costs 100 days so you will finish it on the 100th day, and ready to take the next course on the 101st day.
Second, take the 3rd course, it costs 1000 days so you will finish it on the 1100th day, and ready to take the next course on the 1101st day. 
Third, take the 2nd course, it costs 200 days so you will finish it on the 1300th day. 
The 4th course cannot be taken now, since you will finish it on the 3300th day, which exceeds the closed date.
</pre>
<p> </p>
<p>Note:</p>
<ol>
<li>The integer 1 &lt;= d, t, n &lt;= 10,000.</li>
<li>You can't take two courses simultaneously.</li>
</ol>
<p> </p>
<p>这道题给了我们许多课程，每个课程有两个参数，第一个是课程的持续时间，第二个是课程的最晚结束日期，让我们求最多能上多少门课。博主尝试了递归的暴力破解，TLE了。这道题给的提示是用贪婪算法，那么我们首先给课程排个序，按照结束时间的顺序来排序，我们维护一个当前的时间，初始化为0，再建立一个优先数组，然后我们遍历每个课程，对于每一个遍历到的课程，当前时间加上该课程的持续时间，然后将该持续时间放入优先数组中，然后我们判断如果当前时间大于课程的结束时间，说明这门课程无法被完成，我们并不是直接减去当前课程的持续时间，而是取出优先数组的顶元素，即用时最长的一门课，这也make sense，因为我们的目标是尽可能的多上课，既然非要去掉一门课，那肯定是去掉耗时最长的课，这样省下来的时间说不定能多上几门课呢，最后返回优先队列中元素的个数就是能完成的课程总数啦，参见代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> scheduleCourse(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> courses) {
        </span><span style="color: #0000ff;">int</span> curTime = <span style="color: #800080;">0</span><span style="color: #000000;">;
        priority_queue</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> q;
        sort(courses.begin(), courses.end(), [](vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;&amp; a, vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; b) {<span style="color: #0000ff;">return</span> a[<span style="color: #800080;">1</span>] &lt; b[<span style="color: #800080;">1</span><span style="color: #000000;">];});
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto course : courses) {
            curTime </span>+= course[<span style="color: #800080;">0</span><span style="color: #000000;">];
            q.push(course[</span><span style="color: #800080;">0</span><span style="color: #000000;">]);
            </span><span style="color: #0000ff;">if</span> (curTime &gt; course[<span style="color: #800080;">1</span><span style="color: #000000;">]) {
                curTime </span>-=<span style="color: #000000;"> q.top(); q.pop();
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> q.size();
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4504793.html" target="_blank">Course Schedule II</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4484571.html" target="_blank">Course Schedule</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/93790/short-java-code-using-priorityqueue" target="_blank">https://discuss.leetcode.com/topic/93790/short-java-code-using-priorityqueue</a></p>
<p><a href="https://discuss.leetcode.com/topic/93712/python-straightforward-with-explanation" target="_blank">https://discuss.leetcode.com/topic/93712/python-straightforward-with-explanation</a></p>
<p><a href="https://discuss.leetcode.com/topic/93884/c-short-elegant-o-nlogn-time-o-k-space-solution/2" target="_blank">https://discuss.leetcode.com/topic/93884/c-short-elegant-o-nlogn-time-o-k-space-solution/2</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-07-06 14:44</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7126289" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7126289);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7111385.html" id="cb_post_title_url">[LeetCode] K Inverse Pairs Array K个翻转对数组</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given two integers <code>n</code> and <code>k</code>, find how many different arrays consist of numbers from <code>1</code> to <code>n</code> such that there are exactly <code>k</code> inverse pairs.</p>
<p>We define an inverse pair as following: For <code>ith</code> and <code>jth</code> element in the array, if <code>i</code> &lt; <code>j</code> and <code>a[i]</code> &gt; <code>a[j]</code> then it's an inverse pair; Otherwise, it's not.</p>
<p>Since the answer may very large, the answer should be modulo 109 + 7.</p>
<p>Example 1:</p>
<pre>Input: n = 3, k = 0
Output: 1
Explanation: 
Only the array [1,2,3] which consists of numbers from 1 to 3 has exactly 0 inverse pair.
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input: n = 3, k = 1
Output: 2
Explanation: 
The array [1,3,2] and [2,1,3] have exactly 1 inverse pair.
</pre>
<p> </p>
<p>Note:</p>
<ol>
<li>The integer <code>n</code> is in the range [1, 1000] and <code>k</code> is in the range [0, 1000].</li>
</ol>
<p> </p>
<p>这道题给了我们1到n总共n个数字，让我们任意排列数组的顺序，使其刚好存在k个翻转对，所谓的翻转对，就是位置在前面的数字值大，而且题目中表明了结果会很大很大，要我们对一个很大的数字取余。对于这种结果巨大的题目，劝君放弃暴力破解或者是无脑递归，想都不用想，那么最先应该考虑的就是DP的解法了。我们需要一个二维的DP数组，其中dp[i][j]表示1到i的数字中有j个翻转对的排列总数，那么我们要求的就是dp[n][k]了，即1到n的数字中有k个翻转对的排列总数。现在难点就是要求递推公式了。我们想如果我们已经知道dp[n][k]了，怎么求dp[n+1][k]，先来看dp[n+1][k]的含义，是1到n+1点数字中有k个翻转对的个数，那么实际上在1到n的数字中的某个位置加上了n+1这个数，为了简单起见，我们先让n=4，那么实际上相当于要在某个位置加上5，那么加5的位置就有如下几种情况：</p>
<p>xxxx5</p>
<p>xxx5x</p>
<p>xx5xx</p>
<p>x5xxx</p>
<p>5xxxx</p>
<p>这里xxxx表示1到4的任意排列，那么第一种情况xxxx5不会增加任何新的翻转对，因为xxxx中没有比5大的数字，而 xxx5x会新增加1个翻转对，xx5xx，x5xxx，5xxxx分别会增加2，3，4个翻转对。那么xxxx5就相当于dp[n][k]，即dp[4][k]，那么依次往前类推，就是dp[n][k-1], dp[n][k-2]...dp[n][k-n]，这样我们就可以得出dp[n+1][k]的求法了:</p>
<p>dp[n+1][k] = dp[n][k] + dp[n][k-1] + ... + dp[n][k - n]</p>
<p>那么dp[n][k]的求法也就一目了然了:</p>
<p>dp[n][k] = dp[n - 1][k] + dp[n - 1][k-1] + ... + dp[n - 1][k - n + 1]</p>
<p>那么我们就可以写出代码如下了：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> kInversePairs(<span style="color: #0000ff;">int</span> n, <span style="color: #0000ff;">int</span><span style="color: #000000;"> k) {
        </span><span style="color: #0000ff;">int</span> M = <span style="color: #800080;">1000000007</span><span style="color: #000000;">;
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; dp(n + <span style="color: #800080;">1</span>, vector&lt;<span style="color: #0000ff;">int</span>&gt;(k + <span style="color: #800080;">1</span>, <span style="color: #800080;">0</span><span style="color: #000000;">));
        dp[</span><span style="color: #800080;">0</span>][<span style="color: #800080;">0</span>] = <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt;= n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; i; ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> m = <span style="color: #800080;">0</span>; m &lt;= k; ++<span style="color: #000000;">m) {
                    </span><span style="color: #0000ff;">if</span> (m - j &gt;= <span style="color: #800080;">0</span> &amp;&amp; m - j &lt;=<span style="color: #000000;"> k) {
                        dp[i][m] </span>= (dp[i][m] + dp[i - <span style="color: #800080;">1</span>][m - j]) %<span style="color: #000000;"> M;
                    }
                }
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> dp[n][k];
    }
};</span></pre>
</div>
<p> </p>
<p>我们可以对上面的解法进行时间上的优化，还是来看我们的递推公式: </p>
<p>dp[n][k] = dp[n - 1][k] + dp[n - 1][k-1] + ... + dp[n - 1][k - n + 1]</p>
<p>我们可以用k+1代替k，得到：</p>
<p>dp[n][k+1] = dp[n - 1][k+1] + dp[n - 1][k] + ... + dp[n - 1][k + 1 - n + 1]</p>
<p>用第二个等式减去第一个等式可以得到：</p>
<p>dp[n][k+1] = dp[n][k] + dp[n - 1][k+1] - dp[n - 1][k - n + 1]</p>
<p>将k+1换回成k，可以得到：</p>
<p>dp[n][k] = dp[n][k-1] + dp[n - 1][k] - dp[n - 1][k - n]</p>
<p>我们可以发现当k&gt;=n的时候，最后一项的数组坐标才能为非负数，从而最后一项才有值，所以我们再更新的时候只需要判断一下k和n的关系，如果k&gt;=n的话，就要减去最后一项，这种递推式算起来更高效，减少了一个循环，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> kInversePairs(<span style="color: #0000ff;">int</span> n, <span style="color: #0000ff;">int</span><span style="color: #000000;"> k) {
        </span><span style="color: #0000ff;">int</span> M = <span style="color: #800080;">1000000007</span><span style="color: #000000;">;
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; dp(n + <span style="color: #800080;">1</span>, vector&lt;<span style="color: #0000ff;">int</span>&gt;(k + <span style="color: #800080;">1</span>, <span style="color: #800080;">0</span><span style="color: #000000;">));
        dp[</span><span style="color: #800080;">0</span>][<span style="color: #800080;">0</span>] = <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt;= n; ++<span style="color: #000000;">i) {
            dp[i][</span><span style="color: #800080;">0</span>] = <span style="color: #800080;">1</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">1</span>; j &lt;= k; ++<span style="color: #000000;">j) {
                dp[i][j] </span>= (dp[i - <span style="color: #800080;">1</span>][j] + dp[i][j - <span style="color: #800080;">1</span>]) %<span style="color: #000000;"> M;
                </span><span style="color: #0000ff;">if</span> (j &gt;=<span style="color: #000000;"> i) {
                    dp[i][j] </span>= (dp[i][j] - dp[i - <span style="color: #800080;">1</span>][j - i] + M) %<span style="color: #000000;"> M;
                }
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> dp[n][k];
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/93815/java-dp-o-nk-solution/2" target="_blank">https://discuss.leetcode.com/topic/93815/java-dp-o-nk-solution/2</a></p>
<p><a href="https://discuss.leetcode.com/topic/93765/shared-my-c-o-n-k-solution-with-explanation" target="_blank">https://discuss.leetcode.com/topic/93765/shared-my-c-o-n-k-solution-with-explanation</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a> </p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-07-03 15:33</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7111385" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7111385);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7084957.html" id="cb_post_title_url">[LeetCode] Maximum Product of Three Numbers 三个数字的最大乘积</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="question-description">
<p>Given an integer array, find three numbers whose product is maximum and output the maximum product.</p>
<p>Example 1:</p>
<pre>Input: [1,2,3]
Output: 6
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input: [1,2,3,4]
Output: 24
</pre>
<p> </p>
<p>Note:</p>
<ol>
<li>The length of the given array will be in range [3,104] and all elements are in the range [-1000, 1000].</li>
<li>Multiplication of any three numbers in the input won't exceed the range of 32-bit signed integer.</li>
</ol>
<p> </p>
<p>这道题博主刚开始看的时候，心想直接排序，然后最后三个数字相乘不就完了，心想不会这么Easy吧，果然被OJ无情打脸，没有考虑到负数和0的情况。这道题给了数组的范围，至少三个，那么如果是三个的话，就无所谓了，直接相乘返回即可，但是如果超过了3个，而且有负数存在的话，情况就可能不一样，我们来考虑几种情况，如果全是负数，三个负数相乘还是负数，为了让负数最大，那么其绝对值就该最小，而负数排序后绝对值小的都在末尾，所以是末尾三个数字相乘，这个跟全是正数的情况一样。那么重点在于前半段是负数，后半段是正数，那么最好的情况肯定是两个最小的负数相乘得到一个正数，然后跟一个最大的正数相乘，这样得到的肯定是最大的数，所以我们让前两个数相乘，再和数组的最后一个数字相乘，就可以得到这种情况下的最大的乘积。实际上我们并不用分情况讨论数组的正负，只要把这两种情况的乘积都算出来，比较二者取较大值，就能涵盖所有的情况，从而得到正确的结果，参见代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> maximumProduct(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        </span><span style="color: #0000ff;">int</span> n =<span style="color: #000000;"> nums.size();
        sort(nums.begin(), nums.end());
        </span><span style="color: #0000ff;">int</span> p = nums[<span style="color: #800080;">0</span>] * nums[<span style="color: #800080;">1</span>] * nums[n - <span style="color: #800080;">1</span><span style="color: #000000;">];
        </span><span style="color: #0000ff;">return</span> max(p, nums[n - <span style="color: #800080;">1</span>] * nums[n - <span style="color: #800080;">2</span>] * nums[n - <span style="color: #800080;">3</span><span style="color: #000000;">]);
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种方法由网友hello_world00提供，找出3个最大的数 || 找出一个最大的和两个最小的，相乘对比也能得到结果，而且是O(n)的时间复杂度，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> maximumProduct(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        </span><span style="color: #0000ff;">int</span> mx1 = INT_MIN, mx2 = INT_MIN, mx3 =<span style="color: #000000;"> INT_MIN;
        </span><span style="color: #0000ff;">int</span> mn1 = INT_MAX, mn2 =<span style="color: #000000;"> INT_MAX;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span><span style="color: #000000;"> num : nums) {
            </span><span style="color: #0000ff;">if</span> (num &gt;<span style="color: #000000;"> mx1) {
                mx3 </span>= mx2; mx2 = mx1; mx1 =<span style="color: #000000;"> num;
            } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (num &gt;<span style="color: #000000;"> mx2) {
                mx3 </span>= mx2; mx2 =<span style="color: #000000;"> num;
            } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (num &gt;<span style="color: #000000;"> mx3) {
                mx3 </span>=<span style="color: #000000;"> num;
            }
            </span><span style="color: #0000ff;">if</span> (num &lt;<span style="color: #000000;"> mn1) {
                mn2 </span>= mn1; mn1 =<span style="color: #000000;"> num;
            } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (num &lt;<span style="color: #000000;"> mn2) {
                mn2 </span>=<span style="color: #000000;"> num;
            }
        }
        </span><span style="color: #0000ff;">return</span> max(mx1 * mx2 * mx3, mx1 * mn1 *<span style="color: #000000;"> mn2);
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/93690/java-easy-ac" target="_blank">https://discuss.leetcode.com/topic/93690/java-easy-ac</a></p>
</div>
<div id="interviewed-div"> </div>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-06-27 14:25</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7084957" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7084957);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7076026.html" id="cb_post_title_url">[LeetCode] Minimum Factorization 最小因数分解</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="question-description">
<p>Given a positive integer <code>a</code>, find the smallest positive integer <code>b</code> whose multiplication of each digit equals to <code>a</code>.</p>
<p>If there is no answer or the answer is not fit in 32-bit signed integer, then return 0.</p>
<p>Example 1<br/>Input:</p>
<pre>48 </pre>
Output:
<pre>68</pre>
<p> </p>
<p>Example 2<br/>Input:</p>
<pre>15</pre>
Output:
<pre>35</pre>
<p> </p>
<p>这道题给了我们一个数字，让我们进行因数分解，让我们找出因数组成的最小的数字。从题目中的例子可以看出，分解出的因数一定是个位数字，即范围是[2, 9]。那我们就可以从大到小开始找因数，首先查找9是否是因数，是要能整除a，就是其因数，如果是的话，就加入到结果res的开头，a自除以9，我们用while循环查找9，直到取出所有的9，然后取8，7，6...以此类推，如果a能成功的被分解的话，最后a的值应该为1，如果a值大于1，说明无法被分解，返回true。最后还要看我们结果res字符转为整型是否越界，越界的话还是返回0，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> smallestFactorization(<span style="color: #0000ff;">int</span><span style="color: #000000;"> a) {
        </span><span style="color: #0000ff;">if</span> (a == <span style="color: #800080;">1</span>) <span style="color: #0000ff;">return</span> <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">string</span> res = <span style="color: #800000;">""</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> k = <span style="color: #800080;">9</span>; k &gt;= <span style="color: #800080;">2</span>; --<span style="color: #000000;">k) {
            </span><span style="color: #0000ff;">while</span> (a % k == <span style="color: #800080;">0</span><span style="color: #000000;">) {
                res </span>= to_string(k) +<span style="color: #000000;"> res;
                a </span>/=<span style="color: #000000;"> k;
            }
        }
        </span><span style="color: #0000ff;">if</span> (a &gt; <span style="color: #800080;">1</span>) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">long</span> <span style="color: #0000ff;">long</span> num =<span style="color: #000000;"> stoll(res);
        </span><span style="color: #0000ff;">return</span> num &gt; INT_MAX ? <span style="color: #800080;">0</span><span style="color: #000000;"> : num;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种方法跟上面解法思路很像，只是结果res没有用字符串，而是直接用的长整型，我们每次在更新完res的结果后，判断一次是否越整型的界，越了就直接返回0，其他部分和上面没有什么区别，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> smallestFactorization(<span style="color: #0000ff;">int</span><span style="color: #000000;"> a) {
        </span><span style="color: #0000ff;">if</span> (a &lt; <span style="color: #800080;">10</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;"> a;
        </span><span style="color: #0000ff;">long</span> <span style="color: #0000ff;">long</span> res = <span style="color: #800080;">0</span>, cnt = <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">9</span>; i &gt;= <span style="color: #800080;">2</span>; --<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">while</span> (a % i == <span style="color: #800080;">0</span><span style="color: #000000;">) {
                res </span>+= cnt *<span style="color: #000000;"> i;
                </span><span style="color: #0000ff;">if</span> (res &gt; INT_MAX) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
                a </span>/=<span style="color: #000000;"> i;
                cnt </span>*= <span style="color: #800080;">10</span><span style="color: #000000;">;
            }
        }
        </span><span style="color: #0000ff;">return</span> (a == <span style="color: #800080;">1</span>) ? res : <span style="color: #800080;">0</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料： </p>
<p><a href="https://discuss.leetcode.com/topic/92920/concise-c-solution-10-lines-3ms" target="_blank">https://discuss.leetcode.com/topic/92920/concise-c-solution-10-lines-3ms</a></p>
<p><a href="https://discuss.leetcode.com/topic/92998/c-clean-code-7-line-3-solutions/2" target="_blank">https://discuss.leetcode.com/topic/92998/c-clean-code-7-line-3-solutions/2</a></p>
</div>
<div id="interviewed-div"> </div>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-06-25 05:27</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7076026" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7076026);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7073343.html" id="cb_post_title_url">[LeetCode] Maximum Distance in Arrays 数组中的最大距离</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="question-description">
<p>Given <code>m</code> arrays, and each array is sorted in ascending order. Now you can pick up two integers from two different arrays (each array picks one) and calculate the distance. We define the distance between two integers <code>a</code> and <code>b</code> to be their absolute difference <code>|a-b|</code>. Your task is to find the maximum distance.</p>
<p>Example 1:</p>
<pre>Input: 
[[1,2,3],
 [4,5],
 [1,2,3]]
Output: 4
Explanation: 
One way to reach the maximum distance 4 is to pick 1 in the first or third array and pick 5 in the second array.
</pre>
<p> </p>
<p>Note:</p>
<ol>
<li>Each given array will have at least 1 number. There will be at least two non-empty arrays.</li>
<li>The total number of the integers in all the <code>m</code> arrays will be in the range of [2, 10000].</li>
<li>The integers in the <code>m</code> arrays will be in the range of [-10000, 10000].</li>
</ol>
<p> </p>
<p>这道题给我们了一些数组，每个数组都是有序的，让我们从不同的数组中各取一个数字，使得这两个数字的差的绝对值最大，让我们求这个最大值。那么我们想，既然数组都是有序的，那么差的绝对值最大的两个数字肯定是分别位于数组的首和尾，注意题目中说要从不同的数组中取数，那么即使某个数组的首尾差距很大，也不行。博主最先考虑的是用堆来做，一个最大堆，一个最小堆，最大堆存每个数组的尾元素，最小堆存每个数组的首元素，由于最大的数字和最小的数字有可能来自于同一个数组，所以我们在堆中存数字的时候还要存入当前数字所在的数组的序号，最后我们其实要分别在最大堆和最小堆中各取两个数字，如果最大的数字和最小的数字不在一个数组，那么直接返回二者的绝对差即可，如果在的话，那么要返回第二大数字和最小数字绝对差跟最大数字和第二小数字绝对差中的较大值，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> maxDistance(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> arrays) {
        priority_queue</span>&lt;pair&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;&gt;<span style="color: #000000;"> mx, mn;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; arrays.size(); ++<span style="color: #000000;">i) {
            mn.push({</span>-arrays[i][<span style="color: #800080;">0</span><span style="color: #000000;">], i});
            mx.push({arrays[i].back(), i});
        }
        auto a1 </span>=<span style="color: #000000;"> mx.top(); mx.pop();
        auto b1 </span>=<span style="color: #000000;"> mn.top(); mn.pop();
        </span><span style="color: #0000ff;">if</span> (a1.second != b1.second) <span style="color: #0000ff;">return</span> a1.first +<span style="color: #000000;"> b1.first;
        </span><span style="color: #0000ff;">return</span> max(a1.first + mn.top().first, mx.top().first +<span style="color: #000000;"> b1.first);
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种方法还是很不错的，并没有用到堆，而是用两个变量start和end分别表示当前遍历过的数组中最小的首元素，和最大的尾元素，那么每当我们遍历到一个新的数组时，只需计算新数组尾元素和start绝对差，跟end和新数组首元素的绝对差，取二者之间的较大值来更新结果res即可，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> maxDistance(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> arrays) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, start = arrays[<span style="color: #800080;">0</span>][<span style="color: #800080;">0</span>], end = arrays[<span style="color: #800080;">0</span><span style="color: #000000;">].back();
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt; arrays.size(); ++<span style="color: #000000;">i) {
            res </span>= max(res, max(abs(arrays[i].back() - start), abs(end - arrays[i][<span style="color: #800080;">0</span><span style="color: #000000;">])));
            start </span>= min(start, arrays[i][<span style="color: #800080;">0</span><span style="color: #000000;">]);
            end </span>=<span style="color: #000000;"> max(end, arrays[i].back());
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/92858/c-o-n" target="_blank">https://discuss.leetcode.com/topic/92858/c-o-n</a></p>
</div>
<div id="interviewed-div"><a href="https://discuss.leetcode.com/topic/92859/java-solution-min-and-max" target="_blank">https://discuss.leetcode.com/topic/92859/java-solution-min-and-max </a></div>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-06-24 14:33</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7073343" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7073343);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7070182.html" id="cb_post_title_url">[LeetCode] Add One Row to Tree 二叉树中增加一行</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given the root of a binary tree, then value <code>v</code> and depth <code>d</code>, you need to add a row of nodes with value <code>v</code> at the given depth <code>d</code>. The root node is at depth 1.</p>
<p>The adding rule is: given a positive integer depth <code>d</code>, for each NOT null tree nodes <code>N</code> in depth <code>d-1</code>, create two tree nodes with value <code>v</code> as <code>N's</code> left subtree root and right subtree root. And <code>N's</code> original left subtree should be the left subtree of the new left subtree root, its original right subtree should be the right subtree of the new right subtree root. If depth <code>d</code> is 1 that means there is no depth d-1 at all, then create a tree node with value v as the new root of the whole original tree, and the original tree is the new root's left subtree.</p>
<p>Example 1:</p>
<pre>Input: 
A binary tree as following:
       4
     /   \
    2     6
   / \   / 
  3   1 5   

v = 1

d = 2

Output: 
       4
      / \
     1   1
    /     \
   2       6
  / \     / 
 3   1   5   

</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input: 
A binary tree as following:
      4
     /   
    2    
   / \   
  3   1    

v = 1

d = 3

Output: 
      4
     /   
    2
   / \    
  1   1
 /     \  
3       1
</pre>
<p> </p>
<p>Note:</p>
<ol>
<li>The given d is in range [1, maximum depth of the given tree + 1].</li>
<li>The given binary tree has at least one tree node.</li>
</ol>
<p> </p>
<p>这道题让我们给二叉树增加一行，给了我们需要增加的值，还有需要增加的位置深度，题目中给的例子也比较能清晰的说明问题。但是漏了一种情况，那就是当d=1时，这该怎么加？这时候就需要替换根结点了。其他情况的处理方法都一样，这里博主第一映像觉得应该用层序遍历来做，没遍历完一层，d自减1，我们探测，当d==1时，那么我们需要对于当前层的每一个结点，首先用临时变量保存其原有的左右子结点，然后新建值为v的左右子结点，将原有的左子结点连到新建的左子结点的左子结点上，将原有的右子结点连到新建的右子结点的右子结点，是不是很绕-.-|||。如果d不为1，那么就是层序遍历原有的排入队列操作，记得当检测到d为0时，直接返回，因为添加操作已经完成，没有必要遍历完剩下的结点，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    TreeNode</span>* addOneRow(TreeNode* root, <span style="color: #0000ff;">int</span> v, <span style="color: #0000ff;">int</span><span style="color: #000000;"> d) {
        </span><span style="color: #0000ff;">if</span> (!root) <span style="color: #0000ff;">return</span><span style="color: #000000;"> NULL;
        </span><span style="color: #0000ff;">if</span> (d == <span style="color: #800080;">1</span><span style="color: #000000;">) {
            TreeNode </span>*newRoot = <span style="color: #0000ff;">new</span><span style="color: #000000;"> TreeNode(v);
            newRoot</span>-&gt;left =<span style="color: #000000;"> root;
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> newRoot;
        }
        queue</span>&lt;TreeNode*&gt;<span style="color: #000000;"> q{{root}};
        </span><span style="color: #0000ff;">while</span> (!<span style="color: #000000;">q.empty()) {
            </span><span style="color: #0000ff;">if</span> (--d == <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;"> root;
            </span><span style="color: #0000ff;">int</span> n =<span style="color: #000000;"> q.size();
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
                auto t </span>=<span style="color: #000000;"> q.front(); q.pop();
                </span><span style="color: #0000ff;">if</span> (d == <span style="color: #800080;">1</span><span style="color: #000000;">) {
                    TreeNode </span>*left = t-&gt;<span style="color: #000000;">left;
                    TreeNode </span>*right = t-&gt;<span style="color: #000000;">right;
                    t</span>-&gt;left = <span style="color: #0000ff;">new</span><span style="color: #000000;"> TreeNode(v);
                    t</span>-&gt;right = <span style="color: #0000ff;">new</span><span style="color: #000000;"> TreeNode(v);
                    t</span>-&gt;left-&gt;left =<span style="color: #000000;"> left;
                    t</span>-&gt;right-&gt;right =<span style="color: #000000;"> right;
                } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    </span><span style="color: #0000ff;">if</span> (t-&gt;left) q.push(t-&gt;<span style="color: #000000;">left);
                    </span><span style="color: #0000ff;">if</span> (t-&gt;right) q.push(t-&gt;<span style="color: #000000;">right);
                }
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> root;
    }
};</span></pre>
</div>
<p> </p>
<p>虽然博主一贯的理念是二叉树问题肯定首选递归来解，但是这道题博主刚开始以为递归没法解，结果看了大神们的帖子，才发现自己还是图样图森破，难道二叉树的问题皆可递归？反正这道题是可以的，而且写法so简洁，乍一看上去，会有疑问，题目中明明d的范围是从1开始的，为何要考虑d为0的情况，后来读懂了整个解法后，才为原作者的聪慧叹服。这里d的0和1，其实相当于一种flag，如果d为1的话，那么将root连到新建的结点的左子结点上；反之如果d为0，那么将root连到新建的结点的右子结点上，然后返回新建的结点。如果root存在且d大于1的话，那么对root的左子结点调用递归函数，注意此时若d的值正好为2，那么我们就不能直接减1，而是根据左右子结点的情况分别赋值1和0，这样才能起到flag的作用嘛，叼的飞起，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    TreeNode</span>* addOneRow(TreeNode* root, <span style="color: #0000ff;">int</span> v, <span style="color: #0000ff;">int</span><span style="color: #000000;"> d) {
        </span><span style="color: #0000ff;">if</span> (d == <span style="color: #800080;">0</span> || d == <span style="color: #800080;">1</span><span style="color: #000000;">) {
            TreeNode </span>*newRoot = <span style="color: #0000ff;">new</span><span style="color: #000000;"> TreeNode(v);
            (d </span>? newRoot-&gt;left : newRoot-&gt;right) =<span style="color: #000000;"> root;
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> newRoot;
        }
        </span><span style="color: #0000ff;">if</span> (root &amp;&amp; d &gt; <span style="color: #800080;">1</span><span style="color: #000000;">) {
            root</span>-&gt;left = addOneRow(root-&gt;left, v, d &gt; <span style="color: #800080;">2</span> ? d - <span style="color: #800080;">1</span> : <span style="color: #800080;">1</span><span style="color: #000000;">);
            root</span>-&gt;right = addOneRow(root-&gt;right, v, d &gt; <span style="color: #800080;">2</span> ? d - <span style="color: #800080;">1</span> : <span style="color: #800080;">0</span><span style="color: #000000;">);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> root;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/92876/c-java-10-line-solution-no-helper" target="_blank">https://discuss.leetcode.com/topic/92876/c-java-10-line-solution-no-helper</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-06-23 15:35</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7070182" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7070182);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/9899034.html" id="cb_post_title_url">[LeetCode] Design Circular Queue 设计环形队列</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Design your implementation of the circular queue. The circular queue is a linear data structure in which the operations are performed based on FIFO (First In First Out) principle and the last position is connected back to the first position to make a circle. It is also called "Ring Buffer".</p>
<p>One of the benefits of the circular queue is that we can make use of the spaces in front of the queue. In a normal queue, once the queue becomes full, we cannot insert the next element even if there is a space in front of the queue. But using the circular queue, we can use the space to store new values.</p>
<p>Your implementation should support following operations:</p>
<ul>
<li><code>MyCircularQueue(k)</code>: Constructor, set the size of the queue to be k.</li>
<li><code>Front</code>: Get the front item from the queue. If the queue is empty, return -1.</li>
<li><code>Rear</code>: Get the last item from the queue. If the queue is empty, return -1.</li>
<li><code>enQueue(value)</code>: Insert an element into the circular queue. Return true if the operation is successful.</li>
<li><code>deQueue()</code>: Delete an element from the circular queue. Return true if the operation is successful.</li>
<li><code>isEmpty()</code>: Checks whether the circular queue is empty or not.</li>
<li><code>isFull()</code>: Checks whether the circular queue is full or not.</li>
</ul>
<p> </p>
<p>Example:</p>
<pre>MyCircularQueue circularQueue = new MyCircularQueue(3); // set the size to be 3
circularQueue.enQueue(1);  // return true
circularQueue.enQueue(2);  // return true
circularQueue.enQueue(3);  // return true
circularQueue.enQueue(4);  // return false, the queue is full
circularQueue.Rear();  // return 3
circularQueue.isFull();  // return true
circularQueue.deQueue();  // return true
circularQueue.enQueue(4);  // return true
circularQueue.Rear();  // return 4
</pre>
<p> </p>
<p>Note:</p>
<ul>
<li>All values will be in the range of [0, 1000].</li>
<li>The number of operations will be in the range of [1, 1000].</li>
<li>Please do not use the built-in Queue library.</li>
</ul>
<p> </p>
<p>这道题让我们设计一个环形的队列，说是不能使用内置的queue类，并且让我们实现一系列的成员函数，如进队，出队，取首尾元素，以及判空，判满等等。那么博主最先想到的就是用一个数组data来实现，并且用一个变量size来保存我们的环形队列的大小。先来实现最简单的判空和判满函数吧，判空就是判断data数组是否为空，判满就是看data数组的大小是否等于size。然后是取首尾元素，需要先对数组判空，然后取首尾元素即可。进队列函数先要判满，然后加入data数组，出队列函数，先要判空，然后去掉数组的首元素即可，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> MyCircularQueue {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">* Initialize your data structure here. Set the size of the queue to be k. </span><span style="color: #008000;">*/</span><span style="color: #000000;">
    MyCircularQueue(</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> k) {
        size </span>=<span style="color: #000000;"> k;
    }
    
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">* Insert an element into the circular queue. Return true if the operation is successful. </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">bool</span> enQueue(<span style="color: #0000ff;">int</span><span style="color: #000000;"> value) {
        </span><span style="color: #0000ff;">if</span> (isFull()) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        data.push_back(value);
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
    
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">* Delete an element from the circular queue. Return true if the operation is successful. </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">bool</span><span style="color: #000000;"> deQueue() {
        </span><span style="color: #0000ff;">if</span> (isEmpty()) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        data.erase(data.begin());
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
    
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">* Get the front item from the queue. </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">int</span><span style="color: #000000;"> Front() {
        </span><span style="color: #0000ff;">if</span> (isEmpty()) <span style="color: #0000ff;">return</span> -<span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> data.front();
    }
    
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">* Get the last item from the queue. </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">int</span><span style="color: #000000;"> Rear() {
        </span><span style="color: #0000ff;">if</span> (isEmpty()) <span style="color: #0000ff;">return</span> -<span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> data.back();
    }
    
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">* Checks whether the circular queue is empty or not. </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">bool</span><span style="color: #000000;"> isEmpty() {
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> data.empty();
    }
    
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">* Checks whether the circular queue is full or not. </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">bool</span><span style="color: #000000;"> isFull() {
        </span><span style="color: #0000ff;">return</span> data.size() &gt;=<span style="color: #000000;"> size;
    }
    
</span><span style="color: #0000ff;">private</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> data;
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> size;
};</span></pre>
</div>
<p> </p>
<p>做完上面的方法有没有一种感觉，这跟环形Circular有毛线关系，还有题目要求中的第二段话里的“我们可以使用队列前面的空间”，完全没有用到啊。其实上面的解法并不是本题真正想要考察的内容，我们要用上环形Circular的性质，之前我们貌似应该做过环形数组的题目吧，提到环形数组，博主最先想到的就是坐标加1，再对数组长度取余。这是数组能够环形的关键，那么这里也一样，我们除了使用size来记录环形队列的最大长度之外，还要使用三个变量，head，tail，cnt，分别来记录队首位置，队尾位置，和当前队列中数字的个数，这里我们将head初始化为k-1，tail初始化为0。还是从简单的做起，判空就看当前个数cnt是否为0，判满就看当前个数cnt是否等于size。接下来取首尾元素，先进行判空，然后根据head和tail分别向后和向前移动一位取即可，记得使用上循环数组的性质，要对size取余。再来看进队列函数，先进行判满，然后将新的数字加到当前的tail位置，tail移动到下一位，为了避免越界，我们使用环形数组的经典操作，加1之后对长度取余，然后cnt自增1即可。同样，出队列函数先进行判空，队首位置head要向后移动一位，同样进行加1之后对长度取余的操作，到这里就可以了，不用真正的去删除数字，因为head和tail限定了我们的当前队列的范围，然后cnt自减1，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> MyCircularQueue {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">* Initialize your data structure here. Set the size of the queue to be k. </span><span style="color: #008000;">*/</span><span style="color: #000000;">
    MyCircularQueue(</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> k) {
        size </span>= k; head = k - <span style="color: #800080;">1</span>; tail = <span style="color: #800080;">0</span>; cnt = <span style="color: #800080;">0</span><span style="color: #000000;">;
        data.resize(k);
    }
    
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">* Insert an element into the circular queue. Return true if the operation is successful. </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">bool</span> enQueue(<span style="color: #0000ff;">int</span><span style="color: #000000;"> value) {
        </span><span style="color: #0000ff;">if</span> (isFull()) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        data[tail] </span>=<span style="color: #000000;"> value;
        tail </span>= (tail + <span style="color: #800080;">1</span>) %<span style="color: #000000;"> size;
        </span>++<span style="color: #000000;">cnt;
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
    
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">* Delete an element from the circular queue. Return true if the operation is successful. </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">bool</span><span style="color: #000000;"> deQueue() {
        </span><span style="color: #0000ff;">if</span> (isEmpty()) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        head </span>= (head + <span style="color: #800080;">1</span>) %<span style="color: #000000;"> size;
        </span>--<span style="color: #000000;">cnt;
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
    
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">* Get the front item from the queue. </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">int</span><span style="color: #000000;"> Front() {
        </span><span style="color: #0000ff;">return</span> isEmpty() ? -<span style="color: #800080;">1</span> : data[(head + <span style="color: #800080;">1</span>) %<span style="color: #000000;"> size];
    }
    
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">* Get the last item from the queue. </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">int</span><span style="color: #000000;"> Rear() {
        </span><span style="color: #0000ff;">return</span> isEmpty() ? -<span style="color: #800080;">1</span> : data[(tail - <span style="color: #800080;">1</span> + size) %<span style="color: #000000;"> size];
    }
    
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">* Checks whether the circular queue is empty or not. </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">bool</span><span style="color: #000000;"> isEmpty() {
        </span><span style="color: #0000ff;">return</span> cnt == <span style="color: #800080;">0</span><span style="color: #000000;">;
    }
    
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">* Checks whether the circular queue is full or not. </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">bool</span><span style="color: #000000;"> isFull() {
        </span><span style="color: #0000ff;">return</span> cnt ==<span style="color: #000000;"> size;
    }
    
</span><span style="color: #0000ff;">private</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> data;
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> size, cnt, head, tail;
};</span></pre>
</div>
<p> </p>
<p> </p>
<p>类似题目：</p>
<p><a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/9899490.html" id="homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0">Design Circular Deque</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a> </p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-11-02 23:08</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=9899034" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(9899034);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7098764.html" id="cb_post_title_url">[LeetCode] Task Scheduler 任务行程表</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a char array representing tasks CPU need to do. It contains capital letters A to Z where different letters represent different tasks.Tasks could be done without original order. Each task could be done in one interval. For each interval, CPU could finish one task or just be idle.</p>
<p>However, there is a non-negative cooling interval n that means between two same tasks, there must be at least n intervals that CPU are doing different tasks or just be idle.</p>
<p>You need to return the least number of intervals the CPU will take to finish all the given tasks.</p>
<p>Example 1:</p>
<pre>Input: tasks = ['A','A','A','B','B','B'], n = 2
Output: 8
Explanation: A -&gt; B -&gt; idle -&gt; A -&gt; B -&gt; idle -&gt; A -&gt; B.
</pre>
<p> </p>
<p>Note:</p>
<ol>
<li>The number of tasks is in the range [1, 10000].</li>
<li>The integer n is in the range [0, 100].</li>
</ol>
<p> </p>
<p>这道题让我们安排CPU的任务，规定在两个相同任务之间至少隔n个时间点。说实话，刚开始博主并没有完全理解题目的意思，后来看了大神们的解法才悟出个道理来。下面这种解法参考了<a href="https://discuss.leetcode.com/topic/92852/concise-java-solution-o-n-time-o-26-space" target="_blank">大神fatalme的帖子</a>，由于题目中规定了两个相同任务之间至少隔n个时间点，那么我们首先应该处理的出现次数最多的那个任务，先确定好这些高频任务，然后再来安排那些低频任务。如果任务F的出现频率最高，为k次，那么我们用n个空位将每两个F分隔开，然后我们按顺序加入其他低频的任务，来看一个例子：</p>
<p>AAAABBBEEFFGG 3</p>
<p>我们发现任务A出现了4次，频率最高，于是我们在每个A中间加入三个空位，如下：</p>
<p>A---A---A---A</p>
<p>AB--AB--AB--A   (加入B)</p>
<p>ABE-ABE-AB--A   (加入E)</p>
<p>ABEFABE-ABF-A   (加入F，每次尽可能填满或者是均匀填充)</p>
<p>ABEFABEGABFGA   (加入G)</p>
<p>再来看一个例子：</p>
<p>ACCCEEE 2</p>
<p>我们发现任务C和E都出现了三次，那么我们就将CE看作一个整体，在中间加入一个位置即可：</p>
<p>CE-CE-CE</p>
<p>CEACE-CE   (加入A)</p>
<p>注意最后面那个idle不能省略，不然就不满足相同两个任务之间要隔2个时间点了。</p>
<p>这道题好在没有让我们输出任务安排结果，而只是问所需的时间总长，那么我们就想个方法来快速计算出所需时间总长即可。我们仔细观察上面两个例子可以发现，都分成了(mx - 1)块，再加上最后面的字母，其中mx为最大出现次数。比如例子1中，A出现了4次，所以有A---模块出现了3次，再加上最后的A，每个模块的长度为4。例子2中，CE-出现了2次，再加上最后的CE，每个模块长度为3。我们可以发现，模块的次数为任务最大次数减1，模块的长度为n+1，最后加上的字母个数为出现次数最多的任务，可能有多个并列。这样三个部分都搞清楚了，写起来就不难了，我们统计每个大写字母出现的次数，然后排序，这样出现次数最多的字母就到了末尾，然后我们向前遍历，找出出现次数一样多的任务个数，就可以迅速求出总时间长了，下面这段代码可能最不好理解的可能就是最后一句了，那么我们特别来讲解一下。先看括号中的第二部分，前面分析说了mx是出现的最大次数，mx-1是可以分为的块数，n+1是每块中的个数，而后面的 25-i 是还需要补全的个数，用之前的例子来说明：</p>
<p>AAAABBBEEFFGG 3</p>
<p>A出现了4次，最多，mx=4，那么可以分为mx-1=3块，如下：</p>
<p>A---A---A---</p>
<p>每块有n+1=4个，最后还要加上末尾的一个A，也就是25-24=1个任务，最终结果为13：</p>
<p>ABEFABEGABFGA</p>
<p>再来看另一个例子：</p>
<p>ACCCEEE 2</p>
<p>C和E都出现了3次，最多，mx=3，那么可以分为mx-1=2块，如下：</p>
<p>CE-CE-</p>
<p>每块有n+1=3个，最后还要加上末尾的一个CE，也就是25-23=2个任务，最终结果为8：</p>
<p>CEACE-CE</p>
<p>好，那么此时你可能会有疑问，为啥还要跟原任务个数len相比，取较大值呢？我们再来看一个例子：</p>
<p>AAABBB 0</p>
<p>A和B都出现了3次，最多，mx=3，那么可以分为mx-1=2块，如下：</p>
<p>ABAB</p>
<p>每块有n+1=1个？你会发现有问题，这里明明每块有两个啊，为啥这里算出来n+1=1呢，因为给的n=0，这有没有矛盾呢，没有！因为n表示相同的任务间需要间隔的个数，那么既然这里为0了，说明相同的任务可以放在一起，这里就没有任何限制了，我们只需要执行完所有的任务就可以了，所以我们最终的返回结果一定不能小于任务的总个数len的，这就是要对比取较大值的原因了。</p>
<p>参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> leastInterval(vector&lt;<span style="color: #0000ff;">char</span>&gt;&amp; tasks, <span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; cnt(<span style="color: #800080;">26</span>, <span style="color: #800080;">0</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span><span style="color: #000000;"> task : tasks) {
            </span>++cnt[task - <span style="color: #800000;">'</span><span style="color: #800000;">A</span><span style="color: #800000;">'</span><span style="color: #000000;">];
        }
        sort(cnt.begin(), cnt.end());
        </span><span style="color: #0000ff;">int</span> i = <span style="color: #800080;">25</span>, mx = cnt[<span style="color: #800080;">25</span>], len =<span style="color: #000000;"> tasks.size();
        </span><span style="color: #0000ff;">while</span> (i &gt;= <span style="color: #800080;">0</span> &amp;&amp; cnt[i] == mx) --<span style="color: #000000;">i;
        </span><span style="color: #0000ff;">return</span> max(len, (mx - <span style="color: #800080;">1</span>) * (n + <span style="color: #800080;">1</span>) + <span style="color: #800080;">25</span> -<span style="color: #000000;"> i);
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种解法是根据<a href="https://discuss.leetcode.com/topic/92966/java-o-n-time-o-1-space-1-pass-no-sorting-solution-with-detailed-explanation/2" target="_blank">大神</a><span class="username"><a href="https://discuss.leetcode.com/topic/92966/java-o-n-time-o-1-space-1-pass-no-sorting-solution-with-detailed-explanation/2" target="_blank">jinzhou的帖子</a>，优点是代码更容易读懂，而且变量命名很reasonable，前半部分都是一样的，求出最多的次数mx，还有同时出现mx次的不同任务的个数mxCnt。这个解法的思想是先算出所有空出来的位置，然后计算出所有需要填入的task的个数，如果超出了空位的个数，就需要最后再补上相应的个数。注意这里如果有多个任务出现次数相同，那么将其整体放一起，就像上面的第二个例子中的CE一样，那么此时每个part中的空位个数就是n - (mxCnt - 1)，那么空位的总数就是part的总数乘以每个part中空位的个数了，那么我们此时除去已经放入part中的，还剩下的task的个数就是task的总个数减去mx * mxCnt，然后此时和之前求出的空位数相比较，如果空位数要大于剩余的task数，那么则说明还需补充多余的空位，否则就直接返回task的总数即可，参见代码如下：<br/></span></p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> leastInterval(vector&lt;<span style="color: #0000ff;">char</span>&gt;&amp; tasks, <span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        </span><span style="color: #0000ff;">int</span> mx = <span style="color: #800080;">0</span>, mxCnt = <span style="color: #800080;">0</span><span style="color: #000000;">;
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; cnt(<span style="color: #800080;">26</span>, <span style="color: #800080;">0</span><span style="color: #000000;">);        
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span><span style="color: #000000;"> task : tasks) {
            </span>++cnt[task - <span style="color: #800000;">'</span><span style="color: #800000;">A</span><span style="color: #800000;">'</span><span style="color: #000000;">];
            </span><span style="color: #0000ff;">if</span> (mx == cnt[task - <span style="color: #800000;">'</span><span style="color: #800000;">A</span><span style="color: #800000;">'</span><span style="color: #000000;">]) {
                </span>++<span style="color: #000000;">mxCnt;
            } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (mx &lt; cnt[task - <span style="color: #800000;">'</span><span style="color: #800000;">A</span><span style="color: #800000;">'</span><span style="color: #000000;">]) {
                mx </span>= cnt[task - <span style="color: #800000;">'</span><span style="color: #800000;">A</span><span style="color: #800000;">'</span><span style="color: #000000;">];
                mxCnt </span>= <span style="color: #800080;">1</span><span style="color: #000000;">;
            }
        }
        </span><span style="color: #0000ff;">int</span> partCnt = mx - <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> partLen = n - (mxCnt - <span style="color: #800080;">1</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">int</span> emptySlots = partCnt *<span style="color: #000000;"> partLen;
        </span><span style="color: #0000ff;">int</span> taskLeft = tasks.size() - mx *<span style="color: #000000;"> mxCnt;
        </span><span style="color: #0000ff;">int</span> idles = max(<span style="color: #800080;">0</span>, emptySlots -<span style="color: #000000;"> taskLeft);
        </span><span style="color: #0000ff;">return</span> tasks.size() +<span style="color: #000000;"> idles;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种解法是参考的<a href="https://discuss.leetcode.com/topic/92873/c-java-clean-code-priority-queue/2" target="_blank">大神</a><span class="username"><a href="https://discuss.leetcode.com/topic/92873/c-java-clean-code-priority-queue/2" target="_blank">alexander的解法</a>，思路是建立一个优先队列，然后把统计好的个数都存入优先队列中，那么大的次数会在队列的前面。这题还是要分块，每块能装n+1个任务，装任务是从优先队列中取，每个任务取一个，装到一个临时数组中，然后遍历取出的任务，对于每个任务，将其哈希表映射的次数减1，如果减1后，次数仍大于0，则将此任务次数再次排入队列中，遍历完后如果队列不为空，说明该块全部被填满，则结果加上n+1。我们之前在队列中取任务是用个变量cnt来记录取出任务的个数，我们想取出n+1个，如果队列中任务数少于n+1个，那就用cnt来记录真实取出的个数，当队列为空时，就加上cnt的个数，参见代码如下：</span></p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> leastInterval(vector&lt;<span style="color: #0000ff;">char</span>&gt;&amp; tasks, <span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, cycle = n + <span style="color: #800080;">1</span><span style="color: #000000;">;
        unordered_map</span>&lt;<span style="color: #0000ff;">char</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> m;
        priority_queue</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> q;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span> c : tasks) ++<span style="color: #000000;">m[c];
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto a : m) q.push(a.second);
        </span><span style="color: #0000ff;">while</span> (!<span style="color: #000000;">q.empty()) {
            </span><span style="color: #0000ff;">int</span> cnt = <span style="color: #800080;">0</span><span style="color: #000000;">;
            vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> t;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; cycle; ++<span style="color: #000000;">i) {
                </span><span style="color: #0000ff;">if</span> (!<span style="color: #000000;">q.empty()) {
                    t.push_back(q.top()); q.pop();
                    </span>++<span style="color: #000000;">cnt;
                }
            }
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span><span style="color: #000000;"> d : t) {
                </span><span style="color: #0000ff;">if</span> (--d &gt; <span style="color: #800080;">0</span><span style="color: #000000;">) q.push(d);
            }
            res </span>+= q.empty() ?<span style="color: #000000;"> cnt : cycle;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/5586009.html">Rearrange String k Distance Apart</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/8799483.html" target="_blank">Reorganize String</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-06-30 14:43</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7098764" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7098764);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7058935.html" id="cb_post_title_url">[LeetCode] Merge Two Binary Trees 合并二叉树</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not.</p>
<p>You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree.</p>
<p>Example 1:</p>
<pre>Input: 
	Tree 1                     Tree 2                  
          1                         2                             
         / \                       / \                            
        3   2                     1   3                        
       /                           \   \                      
      5                             4   7                  
Output: 
Merged tree:
	     3
	    / \
	   4   5
	  / \   \ 
	 5   4   7
</pre>
<p> </p>
<p>Note: The merging process must start from the root nodes of both trees.</p>
<p> </p>
<p>这道题给了我们两个二叉树，让我们合并成一个，规则是，都存在的结点，就将结点值加起来，否则空的位置就由另一个树的结点来代替。那么根据过往经验，处理二叉树问题的神器就是递归，那么我们来看递归函数如何去写。根据题目中的规则，我们知道如果要处理的相同位置上的两个结点都不存在的话，直接返回即可，如果t1存在，t2不存在，那么我们就以t1的结点值建立一个新结点，然后分别对t1的左右子结点和空结点调用递归函数，反之，如果t1不存在，t2存在，那么我们就以t2的结点值建立一个新结点，然后分别对t2的左右子结点和空结点调用递归函数。如果t1和t2都存在，那么我们就以t1和t2的结点值之和建立一个新结点，然后分别对t1的左右子结点和t2的左右子结点调用递归函数，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    TreeNode</span>* mergeTrees(TreeNode* t1, TreeNode*<span style="color: #000000;"> t2) {
        TreeNode </span>*res =<span style="color: #000000;"> NULL;
        helper(t1, t2, res);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">void</span> helper(TreeNode* t1, TreeNode* t2, TreeNode*&amp;<span style="color: #000000;"> res) {
        </span><span style="color: #0000ff;">if</span> (!t1 &amp;&amp; !t2) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (t1 &amp;&amp; !<span style="color: #000000;">t2) {
            res </span>= <span style="color: #0000ff;">new</span> TreeNode(t1-&gt;<span style="color: #000000;">val);
            helper(t1</span>-&gt;left, NULL, res-&gt;<span style="color: #000000;">left);
            helper(t1</span>-&gt;right, NULL, res-&gt;<span style="color: #000000;">right);   
        } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (!t1 &amp;&amp;<span style="color: #000000;"> t2) {
            res </span>= <span style="color: #0000ff;">new</span> TreeNode(t2-&gt;<span style="color: #000000;">val);
            helper(NULL, t2</span>-&gt;left, res-&gt;<span style="color: #000000;">left);
            helper(NULL, t2</span>-&gt;right, res-&gt;<span style="color: #000000;">right);
        } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            res </span>= <span style="color: #0000ff;">new</span> TreeNode(t1-&gt;val + t2-&gt;<span style="color: #000000;">val);
            helper(t1</span>-&gt;left, t2-&gt;left, res-&gt;<span style="color: #000000;">left);
            helper(t1</span>-&gt;right, t2-&gt;right, res-&gt;<span style="color: #000000;">right);
        }
    }
};</span></pre>
</div>
<p> </p>
<p>其实远不用写的像上面那么复杂，我们连额外的函数都不用写，直接递归调用给定的函数即可，我们首先判断，如果t1不存在，则直接返回t2，反之，如果t2不存在，则直接返回t1。如果上面两种情况都不满足，那么以t1和t2的结点值之和建立新结点t，然后对t1和t2的左子结点调用递归并赋给t的左子结点，再对t1和t2的右子结点调用递归并赋给t的右子结点，返回t结点即可，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    TreeNode</span>* mergeTrees(TreeNode* t1, TreeNode*<span style="color: #000000;"> t2) {
        </span><span style="color: #0000ff;">if</span> (!t1) <span style="color: #0000ff;">return</span><span style="color: #000000;"> t2;
        </span><span style="color: #0000ff;">if</span> (!t2) <span style="color: #0000ff;">return</span><span style="color: #000000;"> t1;
        TreeNode </span>*t = <span style="color: #0000ff;">new</span> TreeNode(t1-&gt;val + t2-&gt;<span style="color: #000000;">val);
        t</span>-&gt;left = mergeTrees(t1-&gt;left, t2-&gt;<span style="color: #000000;">left);
        t</span>-&gt;right = mergeTrees(t1-&gt;right, t2-&gt;<span style="color: #000000;">right);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> t;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/92105/java-solution-6-lines-tree-traversal" target="_blank">https://discuss.leetcode.com/topic/92105/java-solution-6-lines-tree-traversal</a></p>
<p><a href="https://discuss.leetcode.com/topic/92222/runtime-beat-100-6-lines-java-recursive-solution" target="_blank">https://discuss.leetcode.com/topic/92222/runtime-beat-100-6-lines-java-recursive-solution</a></p>
<p> </p>
<p><a href="http://www.cnblogs.com/grandyang/p/4606334.html" target="_blank">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-06-21 12:18</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7058935" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7058935);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7043394.html" id="cb_post_title_url">[LeetCode] Add Bold Tag in String 字符串中增添加粗标签</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a string s and a list of strings dict, you need to add a closed pair of bold tag <code>&lt;b&gt;</code> and <code>&lt;/b&gt;</code> to wrap the substrings in s that exist in dict. If two such substrings overlap, you need to wrap them together by only one pair of closed bold tag. Also, if two substrings wrapped by bold tags are consecutive, you need to combine them.</p>
<p>Example 1:</p>
<pre>Input: 
s = "abcxyz123"
dict = ["abc","123"]
Output:
"&lt;b&gt;abc&lt;/b&gt;xyz&lt;b&gt;123&lt;/b&gt;"
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input: 
s = "aaabbcc"
dict = ["aaa","aab","bc"]
Output:
"&lt;b&gt;aaabbc&lt;/b&gt;c"
</pre>
<p> </p>
<p>Note:</p>
<ol>
<li>The given dict won't contain duplicates, and its length won't exceed 100.</li>
<li>All the strings in input have length in range [1, 1000].</li>
</ol>
<p> </p>
<p>这道题给我们了一个字符串，还有一个字典，让我们把字符串中在字典中的单词加粗，注意如果两个单词有交集或者相接，就放到同一个加粗标签中。博主刚开始的想法是，既然需要匹配字符串，那么就上KMP大法，然后得到每个单词在字符串匹配的区间位置，然后再合并区间，再在合并后的区间两头加标签。但是一看题目难度，Medium，中等难度的题不至于要祭出KMP大法吧，于是去网上扫了一眼众神们的解法，发现大多都是暴力匹配啊，既然OJ能过去，那么就一起暴力吧。这题参考的是高神<a data-uid="15398" data-username="shawngao" href="https://discuss.leetcode.com/user/shawngao">shawngao</a>的解法，高神可是集了一千五百多个赞的男人，叼到飞起！思路是建一个和字符串s等长的bold布尔型数组，表示如果该字符在单词里面就为true，那么最后我们就可以根据bold数组的真假值来添加标签了。我们遍历字符串s中的每一个字符，把遍历到的每一个字符当作起始位置，我们都匹配一遍字典中的所有单词，如果能匹配上，我们就用i + len来更新end，len是当前单词的长度，end表示字典中的单词在字符串s中结束的位置，那么如果i小于end，bold[i]就要赋值为true了。最后我们更新完bold数组了，就再遍历一遍字符串s，如果bold[i]为false，直接将s[i]加入结果res中；如果bold[i]为true，那么我们用while循环来找出所有连续为true的个数，然后在左右两端加上标签，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> addBoldTag(<span style="color: #0000ff;">string</span> s, vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp;<span style="color: #000000;"> dict) {
        </span><span style="color: #0000ff;">string</span> res = <span style="color: #800000;">""</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> n = s.size(), end = <span style="color: #800080;">0</span><span style="color: #000000;">;
        vector</span>&lt;<span style="color: #0000ff;">bool</span>&gt; bold(n, <span style="color: #0000ff;">false</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">string</span><span style="color: #000000;"> word : dict) {
                </span><span style="color: #0000ff;">int</span> len =<span style="color: #000000;"> word.size();
                </span><span style="color: #0000ff;">if</span> (i + len &lt;= n &amp;&amp; s.substr(i, len) ==<span style="color: #000000;"> word) {
                    end </span>= max(end, i +<span style="color: #000000;"> len);
                }
            }
            bold[i] </span>= end &gt;<span style="color: #000000;"> i;
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (!<span style="color: #000000;">bold[i]) {
                res.push_back(s[i]);
                </span><span style="color: #0000ff;">continue</span><span style="color: #000000;">;
            }
            </span><span style="color: #0000ff;">int</span> j =<span style="color: #000000;"> i;
            </span><span style="color: #0000ff;">while</span> (j &lt; n &amp;&amp; bold[j]) ++<span style="color: #000000;">j;
            res </span>+= <span style="color: #800000;">"</span><span style="color: #800000;">&lt;b&gt;</span><span style="color: #800000;">"</span> + s.substr(i, j - i) + <span style="color: #800000;">"</span><span style="color: #800000;">&lt;/b&gt;</span><span style="color: #800000;">"</span><span style="color: #000000;">;
            i </span>= j - <span style="color: #800080;">1</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>这道题跟之后的那道<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/8531642.html" id="homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0">Bold Words in String</a>是一模一样的题，那么解法当然是可以互通的了，这里我们把那道题中解法二也贴过来吧，由于解法一和解法二实在是太相似了，就贴一个吧，具体讲解可以参见<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/8531642.html" id="homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0">Bold Words in String</a>这篇帖子，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> addBoldTag(<span style="color: #0000ff;">string</span> s, vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp;<span style="color: #000000;"> dict) {
        </span><span style="color: #0000ff;">string</span> res = <span style="color: #800000;">""</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> n =<span style="color: #000000;"> s.size();
        unordered_set</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> bold;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">string</span><span style="color: #000000;"> word : dict) {
            </span><span style="color: #0000ff;">int</span> len =<span style="color: #000000;"> word.size();
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt;= n - len; ++<span style="color: #000000;">i) {
                </span><span style="color: #0000ff;">if</span> (s[i] == word[<span style="color: #800080;">0</span>] &amp;&amp; s.substr(i, len) ==<span style="color: #000000;"> word) {
                    </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = i; j &lt; i + len; ++<span style="color: #000000;">j) bold.insert(j);
                }
            }
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (bold.count(i) &amp;&amp; !bold.count(i - <span style="color: #800080;">1</span>)) res += <span style="color: #800000;">"</span><span style="color: #800000;">&lt;b&gt;</span><span style="color: #800000;">"</span><span style="color: #000000;">;
            res </span>+=<span style="color: #000000;"> s[i];
            </span><span style="color: #0000ff;">if</span> (bold.count(i) &amp;&amp; !bold.count(i + <span style="color: #800080;">1</span>)) res += <span style="color: #800000;">"</span><span style="color: #800000;">&lt;/b&gt;</span><span style="color: #800000;">"</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/7016476.html" id="homepage1_HomePageDays_DaysList_ctl04_DayList_TitleUrl_0">Tag Validator</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4370601.html" target="_blank">Merge Intervals</a></p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/8531642.html" id="homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0">Bold Words in String</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/92112/java-solution-boolean-array" target="_blank">https://discuss.leetcode.com/topic/92112/java-solution-boolean-array</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-06-18 07:02</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7043394" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7043394);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7053730.html" id="cb_post_title_url">[LeetCode] Valid Triangle Number 合法的三角形个数</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given an array consists of non-negative integers, your task is to count the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle.</p>
<p>Example 1:</p>
<pre>Input: [2,2,3,4]
Output: 3
Explanation:
Valid combinations are: 
2,3,4 (using the first 2)
2,3,4 (using the second 2)
2,2,3
</pre>
<p> </p>
<p>Note:</p>
<ol>
<li>The length of the given array won't exceed 1000.</li>
<li>The integers in the given array are in the range of [0, 1000].</li>
</ol>
<p> </p>
<p>这道题给了我们一堆数字，问我们能组成多少个正确的三角形，我们初中就知道三角形的性质，任意两条边之和要大于第三边。那么问题其实就变成了找出所有这样的三个数字，使得任意两个数字之和都大于第三个数字。那么可以转变一下，三个数字中如果较小的两个数字之和大于第三个数字，那么任意两个数字之和都大于第三个数字，这很好证明，因为第三个数字是最大的，所以它加上任意一个数肯定大于另一个数。这样，我们就先要给数组排序，博主最先尝试了暴力破解法，结果TLE了(不要吐槽博主哈，博主就是喜欢霸王硬上弓～)，后来优化的方法是先确定前两个数，将这两个数之和sum作为目标值，然后用二分查找法来快速确定第一个小于目标值的数，这种情况属于博主之前的博客<a href="http://www.cnblogs.com/grandyang/p/6854825.html" target="_blank">LeetCode Binary Search Summary 二分搜索法小结</a>中总结的第二类的变形，我们找到这个临界值，那么这之前一直到j的位置之间的数都满足题意，直接加起来即可，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> triangleNumber(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, n =<span style="color: #000000;"> nums.size();
        sort(nums.begin(), nums.end());
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = i + <span style="color: #800080;">1</span>; j &lt; n; ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">int</span> sum = nums[i] + nums[j], left = j + <span style="color: #800080;">1</span>, right =<span style="color: #000000;"> n;
                </span><span style="color: #0000ff;">while</span> (left &lt;<span style="color: #000000;"> right) {
                    </span><span style="color: #0000ff;">int</span> mid = left + (right - left) / <span style="color: #800080;">2</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">if</span> (nums[mid] &lt; sum) left = mid + <span style="color: #800080;">1</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">else</span> right =<span style="color: #000000;"> mid;
                }
                res </span>+= right - <span style="color: #800080;">1</span> -<span style="color: #000000;"> j;
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>其实还有更进一步优化的方法，用的是博主之前那篇<a href="http://www.cnblogs.com/grandyang/p/5235086.html" target="_blank">3Sum Smaller</a>里面的解法二，明明博主以前都总结过，换个题目情景就又没想到，看来博主的举一反三能力还是有所欠缺啊。没办法，只能继续刻意练习了。这种方法能将时间复杂度优化到O(n<sup>2</sup>), 感觉很叼了。思路是排序之后，从数字末尾开始往前遍历，将left指向首数字，将right之前遍历到的数字的前面一个数字，然后如果left小于right就进行循环，循环里面判断如果left指向的数加上right指向的数大于当前的数字的话，那么right到left之间的数字都可以组成三角形，这是为啥呢，相当于此时确定了i和right的位置，可以将left向右移到right的位置，中间经过的数都大于left指向的数，所以都能组成三角形，就说这思路叼不叼！加完之后，right自减一，即向左移动一位。如果left和right指向的数字之和不大于nums[i]，那么left自增1，即向右移动一位，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> triangleNumber(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, n =<span style="color: #000000;"> nums.size();
        sort(nums.begin(), nums.end());
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = n - <span style="color: #800080;">1</span>; i &gt;= <span style="color: #800080;">2</span>; --<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">int</span> left = <span style="color: #800080;">0</span>, right = i - <span style="color: #800080;">1</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">while</span> (left &lt;<span style="color: #000000;"> right) {
                </span><span style="color: #0000ff;">if</span> (nums[left] + nums[right] &gt;<span style="color: #000000;"> nums[i]) {
                    res </span>+= right -<span style="color: #000000;"> left;
                    </span>--<span style="color: #000000;">right;
                } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    </span>++<span style="color: #000000;">left;
                }
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/5235086.html" target="_blank">3Sum Smaller</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/92099/java-o-n-2-time-o-1-space" target="_blank">https://discuss.leetcode.com/topic/92099/java-o-n-2-time-o-1-space</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-06-20 13:02</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7053730" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7053730);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7007974.html" id="cb_post_title_url">[LeetCode] Find Duplicate File in System 在系统中寻找重复文件</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a list of directory info including directory path, and all the files with contents in this directory, you need to find out all the groups of duplicate files in the file system in terms of their paths.</p>
<p>A group of duplicate files consists of at least two files that have exactly the same content.</p>
<p>A single directory info string in the input list has the following format:</p>
<p><code>"root/d1/d2/.../dm f1.txt(f1_content) f2.txt(f2_content) ... fn.txt(fn_content)"</code></p>
<p>It means there are n files (<code>f1.txt</code>, <code>f2.txt</code> ... <code>fn.txt</code> with content <code>f1_content</code>, <code>f2_content</code> ... <code>fn_content</code>, respectively) in directory <code>root/d1/d2/.../dm</code>. Note that n &gt;= 1 and m &gt;= 0. If m = 0, it means the directory is just the root directory.</p>
<p>The output is a list of group of duplicate file paths. For each group, it contains all the file paths of the files that have the same content. A file path is a string that has the following format:</p>
<p><code>"directory_path/file_name.txt"</code></p>
<p>Example 1:</p>
<pre>Input:
["root/a 1.txt(abcd) 2.txt(efgh)", "root/c 3.txt(abcd)", "root/c/d 4.txt(efgh)", "root 4.txt(efgh)"]
Output:  
[["root/a/2.txt","root/c/d/4.txt","root/4.txt"],["root/a/1.txt","root/c/3.txt"]]
</pre>
<p> </p>
<p>Note:</p>
<ol>
<li>No order is required for the final output.</li>
<li>You may assume the directory name, file name and file content only has letters and digits, and the length of file content is in the range of [1,50].</li>
<li>The number of files given is in the range of [1,20000].</li>
<li>You may assume no files or directories share the same name in the same directory.</li>
<li>You may assume each given directory info represents a unique directory. Directory path and file info are separated by a single blank space.</li>
</ol>
<p> </p>
<p>Follow-up beyond contest:</p>
<ol>
<li>Imagine you are given a real file system, how will you search files? DFS or BFS?</li>
<li>If the file content is very large (GB level), how will you modify your solution?</li>
<li>If you can only read the file by 1kb each time, how will you modify your solution?</li>
<li>What is the time complexity of your modified solution? What is the most time-consuming part and memory consuming part of it? How to optimize?</li>
<li>How to make sure the duplicated files you find are not false positive?</li>
</ol>
<p> </p>
<p>LeetCode的主页又改版了，放了一些五颜六色的按钮上去了，博主个人觉得风格不太搭，还是比较喜欢之前深沉低调的风格，不过也许看久了就习惯了。来看题吧，这道题给了我们一堆字符串数组，每个字符串中包含了文件路径，文件名称和内容，让我们找到重复的文件，这里只要文件内容相同即可，不用管文件名是否相同，而且返回结果中要带上文件的路径。博主个人感觉这实际上应该算是字符串操作的题目，因为思路上并不是很难想，就是要处理字符串，把路径，文件名，和文件内容从一个字符串中拆出来，我们这里建立一个文件内容和文件路径加文件名组成的数组的映射，因为会有多个文件有相同的内容，所以我们要用数组。然后把分离出的路径和文件名拼接到一起，最后我们只要看哪些映射的数组元素个数多于1个的，就说明有重复文件，我们把整个数组加入结果res中，参见代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;vector&lt;<span style="color: #0000ff;">string</span>&gt;&gt; findDuplicate(vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp;<span style="color: #000000;"> paths) {
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">string</span>&gt;&gt;<span style="color: #000000;"> res;
        unordered_map</span>&lt;<span style="color: #0000ff;">string</span>, vector&lt;<span style="color: #0000ff;">string</span>&gt;&gt;<span style="color: #000000;"> m;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">string</span><span style="color: #000000;"> path : paths) {
            istringstream </span><span style="color: #0000ff;">is</span><span style="color: #000000;">(path);
            </span><span style="color: #0000ff;">string</span> pre = <span style="color: #800000;">""</span>, t = <span style="color: #800000;">""</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">is</span> &gt;&gt;<span style="color: #000000;"> pre;
            </span><span style="color: #0000ff;">while</span> (<span style="color: #0000ff;">is</span> &gt;&gt;<span style="color: #000000;"> t) {
                </span><span style="color: #0000ff;">int</span> idx = t.find_last_of(<span style="color: #800000;">'</span><span style="color: #800000;">(</span><span style="color: #800000;">'</span><span style="color: #000000;">);
                </span><span style="color: #0000ff;">string</span> dir = pre + <span style="color: #800000;">"</span><span style="color: #800000;">/</span><span style="color: #800000;">"</span> + t.substr(<span style="color: #800080;">0</span><span style="color: #000000;">, idx);
                </span><span style="color: #0000ff;">string</span> content = t.substr(idx + <span style="color: #800080;">1</span>, t.size() - idx - <span style="color: #800080;">2</span><span style="color: #000000;">);
                m[content].push_back(dir);
            }
        }
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto a : m) {
            </span><span style="color: #0000ff;">if</span> (a.second.size() &gt; <span style="color: #800080;">1</span><span style="color: #000000;">)res.push_back(a.second);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/91430/c-clean-solution-answers-to-follow-up" target="_blank">https://discuss.leetcode.com/topic/91430/c-clean-solution-answers-to-follow-up</a></p>
<p><a href="https://discuss.leetcode.com/topic/91301/straight-forward-solution-with-a-tiny-bit-of-java8" target="_blank">https://discuss.leetcode.com/topic/91301/straight-forward-solution-with-a-tiny-bit-of-java8</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-06-14 11:35</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7007974" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7007974);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7000040.html" id="cb_post_title_url">[LeetCode] Construct String from Binary Tree 根据二叉树创建字符串</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="col-md-12">
<div class="question-content">
<p>You need to construct a string consists of parenthesis and integers from a binary tree with the preorder traversing way.</p>
<p>The null node needs to be represented by empty parenthesis pair "()". And you need to omit all the empty parenthesis pairs that don't affect the one-to-one mapping relationship between the string and the original binary tree.</p>
<p>Example 1:</p>
<pre>Input: Binary tree: [1,2,3,4]
       1
     /   \
    2     3
   /    
  4     

Output: "1(2(4))(3)"
<br/>Explanation: Originallay it needs to be "1(2(4)())(3()())", <br/>but you need to omit all the unnecessary empty parenthesis pairs. <br/>And it will be "1(2(4))(3)".
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input: Binary tree: [1,2,3,null,4]
       1
     /   \
    2     3
     \  
      4 

Output: "1(2()(4))(3)"
<br/>Explanation: Almost the same as the first example, <br/>except we can't omit the first parenthesis pair to break the one-to-one mapping relationship between the input and the output.
</pre>
<p> </p>
<p>这道题给我们了一个二叉树，让我们创建对应的字符串，之前有一道正好反过来的题<a href="http://www.cnblogs.com/grandyang/p/6793904.html" target="_blank">Construct Binary Tree from String</a>。对于二叉树的处理，递归肯定是王道啊。想想如何来实现递归函数，我们观察到题目中的例子，发现如果左子结点为空，右子结点不为空时，需要在父结点后加上个空括号，而右子结点如果不存在，或者左右子结点都不存在就不需要这么做。那我们在递归函数中，如果当前结点不存在，直接返回，然后要在当前结点值前面加上左括号，然后判断，如果左子结点不存在，而右子结点存在的话，要在结果res后加上个空括号，然后分别对左右子结点调用递归函数，调用完之后要加上右括号，形成封闭的括号。由于最外面一层的括号不需要，所以我们再返回最终结果之前要去掉首尾的括号，参见代码如下：</p>
<p> </p>
</div>
</div>
<div class="col-md-12" id="interviewed-div">解法一：</div>
<div class="col-md-12">
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> tree2str(TreeNode*<span style="color: #000000;"> t) {
        </span><span style="color: #0000ff;">if</span> (!t) <span style="color: #0000ff;">return</span> <span style="color: #800000;">""</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">string</span> res = <span style="color: #800000;">""</span><span style="color: #000000;">;
        helper(t, res);
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">string</span>(res.begin() + <span style="color: #800080;">1</span>, res.end() - <span style="color: #800080;">1</span><span style="color: #000000;">);
    }
    </span><span style="color: #0000ff;">void</span> helper(TreeNode* t, <span style="color: #0000ff;">string</span>&amp;<span style="color: #000000;"> res) {
        </span><span style="color: #0000ff;">if</span> (!t) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
        res </span>+= <span style="color: #800000;">"</span><span style="color: #800000;">(</span><span style="color: #800000;">"</span> + to_string(t-&gt;<span style="color: #000000;">val);
        </span><span style="color: #0000ff;">if</span> (!t-&gt;left &amp;&amp; t-&gt;right) res += <span style="color: #800000;">"</span><span style="color: #800000;">()</span><span style="color: #800000;">"</span><span style="color: #000000;">;
        helper(t</span>-&gt;<span style="color: #000000;">left, res);
        helper(t</span>-&gt;<span style="color: #000000;">right, res);
        res </span>+= <span style="color: #800000;">"</span><span style="color: #800000;">)</span><span style="color: #800000;">"</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>下面来看一种不用额外函数的递归写法，这种做法是一开始调用递归函数求出左右子结点的返回字符串，如果左右结果串均为空，则直接返回当前结点值；如果左子结果串为空，那么返回当前结果res，加上一个空括号，再加上放在括号中的右子结果串；如果右子结果串为空，那么发返回当前结果res，加上放在括号中的左子结果串；如果左右子结果串都存在，那么返回当前结果，加上分别放在括号中的左右子结果串，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> tree2str(TreeNode*<span style="color: #000000;"> t) {
        </span><span style="color: #0000ff;">if</span> (!t) <span style="color: #0000ff;">return</span> <span style="color: #800000;">""</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">string</span> res = to_string(t-&gt;<span style="color: #000000;">val);
        </span><span style="color: #0000ff;">string</span> left = tree2str(t-&gt;left), right = tree2str(t-&gt;<span style="color: #000000;">right);
        </span><span style="color: #0000ff;">if</span> (left == <span style="color: #800000;">""</span> &amp;&amp; right == <span style="color: #800000;">""</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">if</span> (left == <span style="color: #800000;">""</span>) <span style="color: #0000ff;">return</span> res + <span style="color: #800000;">"</span><span style="color: #800000;">()</span><span style="color: #800000;">"</span> + <span style="color: #800000;">"</span><span style="color: #800000;">(</span><span style="color: #800000;">"</span> + right + <span style="color: #800000;">"</span><span style="color: #800000;">)</span><span style="color: #800000;">"</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (right == <span style="color: #800000;">""</span>) <span style="color: #0000ff;">return</span> res + <span style="color: #800000;">"</span><span style="color: #800000;">(</span><span style="color: #800000;">"</span> + left + <span style="color: #800000;">"</span><span style="color: #800000;">)</span><span style="color: #800000;">"</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span> res + <span style="color: #800000;">"</span><span style="color: #800000;">(</span><span style="color: #800000;">"</span> + left + <span style="color: #800000;">"</span><span style="color: #800000;">)</span><span style="color: #800000;">"</span> + <span style="color: #800000;">"</span><span style="color: #800000;">(</span><span style="color: #800000;">"</span> + right + <span style="color: #800000;">"</span><span style="color: #800000;">)</span><span style="color: #800000;">"</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种解法更加简洁，由热心网友<a href="http://home.cnblogs.com/u/1090659/" id="a_comment_author_3831971" target="_blank">edyyy</a>提供，思路和上面解法相同，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> tree2str(TreeNode*<span style="color: #000000;"> t) {
        </span><span style="color: #0000ff;">if</span> (!t) <span style="color: #0000ff;">return</span> <span style="color: #800000;">""</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">string</span> res = to_string(t-&gt;<span style="color: #000000;">val);
        </span><span style="color: #0000ff;">if</span> (!t-&gt;left &amp;&amp; !t-&gt;right) <span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
        res </span>+= <span style="color: #800000;">"</span><span style="color: #800000;">(</span><span style="color: #800000;">"</span> + tree2str(t-&gt;left) + <span style="color: #800000;">"</span><span style="color: #800000;">)</span><span style="color: #800000;">"</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (t-&gt;right) res += <span style="color: #800000;">"</span><span style="color: #800000;">(</span><span style="color: #800000;">"</span> + tree2str(t-&gt;right) + <span style="color: #800000;">"</span><span style="color: #800000;">)</span><span style="color: #800000;">"</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/6793904.html" target="_blank">Construct Binary Tree from String</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/91308/java-solution-tree-traversal" target="_blank">https://discuss.leetcode.com/topic/91308/java-solution-tree-traversal</a></p>
</div>
<div class="col-md-12"> </div>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-06-13 11:01</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7000040" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7000040);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7000040.html" id="cb_post_title_url">[LeetCode] Construct String from Binary Tree 根据二叉树创建字符串</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="col-md-12">
<div class="question-content">
<p>You need to construct a string consists of parenthesis and integers from a binary tree with the preorder traversing way.</p>
<p>The null node needs to be represented by empty parenthesis pair "()". And you need to omit all the empty parenthesis pairs that don't affect the one-to-one mapping relationship between the string and the original binary tree.</p>
<p>Example 1:</p>
<pre>Input: Binary tree: [1,2,3,4]
       1
     /   \
    2     3
   /    
  4     

Output: "1(2(4))(3)"
<br/>Explanation: Originallay it needs to be "1(2(4)())(3()())", <br/>but you need to omit all the unnecessary empty parenthesis pairs. <br/>And it will be "1(2(4))(3)".
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input: Binary tree: [1,2,3,null,4]
       1
     /   \
    2     3
     \  
      4 

Output: "1(2()(4))(3)"
<br/>Explanation: Almost the same as the first example, <br/>except we can't omit the first parenthesis pair to break the one-to-one mapping relationship between the input and the output.
</pre>
<p> </p>
<p>这道题给我们了一个二叉树，让我们创建对应的字符串，之前有一道正好反过来的题<a href="http://www.cnblogs.com/grandyang/p/6793904.html" target="_blank">Construct Binary Tree from String</a>。对于二叉树的处理，递归肯定是王道啊。想想如何来实现递归函数，我们观察到题目中的例子，发现如果左子结点为空，右子结点不为空时，需要在父结点后加上个空括号，而右子结点如果不存在，或者左右子结点都不存在就不需要这么做。那我们在递归函数中，如果当前结点不存在，直接返回，然后要在当前结点值前面加上左括号，然后判断，如果左子结点不存在，而右子结点存在的话，要在结果res后加上个空括号，然后分别对左右子结点调用递归函数，调用完之后要加上右括号，形成封闭的括号。由于最外面一层的括号不需要，所以我们再返回最终结果之前要去掉首尾的括号，参见代码如下：</p>
<p> </p>
</div>
</div>
<div class="col-md-12" id="interviewed-div">解法一：</div>
<div class="col-md-12">
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> tree2str(TreeNode*<span style="color: #000000;"> t) {
        </span><span style="color: #0000ff;">if</span> (!t) <span style="color: #0000ff;">return</span> <span style="color: #800000;">""</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">string</span> res = <span style="color: #800000;">""</span><span style="color: #000000;">;
        helper(t, res);
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">string</span>(res.begin() + <span style="color: #800080;">1</span>, res.end() - <span style="color: #800080;">1</span><span style="color: #000000;">);
    }
    </span><span style="color: #0000ff;">void</span> helper(TreeNode* t, <span style="color: #0000ff;">string</span>&amp;<span style="color: #000000;"> res) {
        </span><span style="color: #0000ff;">if</span> (!t) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
        res </span>+= <span style="color: #800000;">"</span><span style="color: #800000;">(</span><span style="color: #800000;">"</span> + to_string(t-&gt;<span style="color: #000000;">val);
        </span><span style="color: #0000ff;">if</span> (!t-&gt;left &amp;&amp; t-&gt;right) res += <span style="color: #800000;">"</span><span style="color: #800000;">()</span><span style="color: #800000;">"</span><span style="color: #000000;">;
        helper(t</span>-&gt;<span style="color: #000000;">left, res);
        helper(t</span>-&gt;<span style="color: #000000;">right, res);
        res </span>+= <span style="color: #800000;">"</span><span style="color: #800000;">)</span><span style="color: #800000;">"</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>下面来看一种不用额外函数的递归写法，这种做法是一开始调用递归函数求出左右子结点的返回字符串，如果左右结果串均为空，则直接返回当前结点值；如果左子结果串为空，那么返回当前结果res，加上一个空括号，再加上放在括号中的右子结果串；如果右子结果串为空，那么发返回当前结果res，加上放在括号中的左子结果串；如果左右子结果串都存在，那么返回当前结果，加上分别放在括号中的左右子结果串，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> tree2str(TreeNode*<span style="color: #000000;"> t) {
        </span><span style="color: #0000ff;">if</span> (!t) <span style="color: #0000ff;">return</span> <span style="color: #800000;">""</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">string</span> res = to_string(t-&gt;<span style="color: #000000;">val);
        </span><span style="color: #0000ff;">string</span> left = tree2str(t-&gt;left), right = tree2str(t-&gt;<span style="color: #000000;">right);
        </span><span style="color: #0000ff;">if</span> (left == <span style="color: #800000;">""</span> &amp;&amp; right == <span style="color: #800000;">""</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">if</span> (left == <span style="color: #800000;">""</span>) <span style="color: #0000ff;">return</span> res + <span style="color: #800000;">"</span><span style="color: #800000;">()</span><span style="color: #800000;">"</span> + <span style="color: #800000;">"</span><span style="color: #800000;">(</span><span style="color: #800000;">"</span> + right + <span style="color: #800000;">"</span><span style="color: #800000;">)</span><span style="color: #800000;">"</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (right == <span style="color: #800000;">""</span>) <span style="color: #0000ff;">return</span> res + <span style="color: #800000;">"</span><span style="color: #800000;">(</span><span style="color: #800000;">"</span> + left + <span style="color: #800000;">"</span><span style="color: #800000;">)</span><span style="color: #800000;">"</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span> res + <span style="color: #800000;">"</span><span style="color: #800000;">(</span><span style="color: #800000;">"</span> + left + <span style="color: #800000;">"</span><span style="color: #800000;">)</span><span style="color: #800000;">"</span> + <span style="color: #800000;">"</span><span style="color: #800000;">(</span><span style="color: #800000;">"</span> + right + <span style="color: #800000;">"</span><span style="color: #800000;">)</span><span style="color: #800000;">"</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种解法更加简洁，由热心网友<a href="http://home.cnblogs.com/u/1090659/" id="a_comment_author_3831971" target="_blank">edyyy</a>提供，思路和上面解法相同，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> tree2str(TreeNode*<span style="color: #000000;"> t) {
        </span><span style="color: #0000ff;">if</span> (!t) <span style="color: #0000ff;">return</span> <span style="color: #800000;">""</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">string</span> res = to_string(t-&gt;<span style="color: #000000;">val);
        </span><span style="color: #0000ff;">if</span> (!t-&gt;left &amp;&amp; !t-&gt;right) <span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
        res </span>+= <span style="color: #800000;">"</span><span style="color: #800000;">(</span><span style="color: #800000;">"</span> + tree2str(t-&gt;left) + <span style="color: #800000;">"</span><span style="color: #800000;">)</span><span style="color: #800000;">"</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (t-&gt;right) res += <span style="color: #800000;">"</span><span style="color: #800000;">(</span><span style="color: #800000;">"</span> + tree2str(t-&gt;right) + <span style="color: #800000;">"</span><span style="color: #800000;">)</span><span style="color: #800000;">"</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/6793904.html" target="_blank">Construct Binary Tree from String</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/91308/java-solution-tree-traversal" target="_blank">https://discuss.leetcode.com/topic/91308/java-solution-tree-traversal</a></p>
</div>
<div class="col-md-12"> </div>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-06-13 11:01</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7000040" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7000040);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/6983982.html" id="cb_post_title_url">[LeetCode] Can Place Flowers 可以放置花</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Suppose you have a long flowerbed in which some of the plots are planted and some are not. However, flowers cannot be planted in adjacent plots - they would compete for water and both would die.</p>
<p>Given a flowerbed (represented as an array containing 0 and 1, where 0 means empty and 1 means not empty), and a number n, return if n new flowers can be planted in it without violating the no-adjacent-flowers rule.</p>
<p>Example 1:</p>
<pre>Input: flowerbed = [1,0,0,0,1], n = 1
Output: True
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input: flowerbed = [1,0,0,0,1], n = 2
Output: False
</pre>
<p> </p>
<p>Note:</p>
<ol>
<li>The input array won't violate no-adjacent-flowers rule.</li>
<li>The input array size is in the range of [1, 20000].</li>
<li>n is a non-negative integer which won't exceed the input array size.</li>
</ol>
<p> </p>
<p>这道题给了我们一个01数组，其中1表示已经放了花，0表示可以放花的位置，但是有个限制条件是不能有相邻的花。那么我们来看如果是一些简单的例子，如果有3个连续的零，000，能放几盆花呢，其实是要取决约左右的位置的，如果是10001，那么只能放1盆，如果左右是边界的花，那么就能放两盆，101，所以如果我们想通过计算连续0的个数，然后直接算出能放花的个数，就必须要对边界进行处理，处理方法是如果首位置是0，那么前面再加上个0，如果末位置是0，就在最后面再加上个0。这样处理之后我们就默认连续0的左右两边都是1了，这样如果有k个连续0，那么就可以通过(k-1)/2来快速计算出能放的花的数量，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> canPlaceFlowers(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; flowerbed, <span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        </span><span style="color: #0000ff;">if</span> (flowerbed.empty()) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (flowerbed[<span style="color: #800080;">0</span>] == <span style="color: #800080;">0</span>) flowerbed.insert(flowerbed.begin(), <span style="color: #800080;">0</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">if</span> (flowerbed.back() == <span style="color: #800080;">0</span>) flowerbed.push_back(<span style="color: #800080;">0</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">int</span> len = flowerbed.size(), cnt = <span style="color: #800080;">0</span>, sum = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt;= len; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (i &lt; len &amp;&amp; flowerbed[i] == <span style="color: #800080;">0</span>) ++<span style="color: #000000;">cnt;
            </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                sum </span>+= (cnt - <span style="color: #800080;">1</span>) / <span style="color: #800080;">2</span><span style="color: #000000;">;
                cnt </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
            }
        }
        </span><span style="color: #0000ff;">return</span> sum &gt;=<span style="color: #000000;"> n;
    }
};</span></pre>
</div>
<p> </p>
<p>我们也可以直接通过修改flowerbed的值来做，我们遍历花床，如果某个位置为0，我们就看其前面一个和后面一个位置的值，注意处理首位置和末位置的情况，如果pre和next均为0，那么说明当前位置可以放花，我们修改flowerbed的值，并且n自减1，最后看n是否小于等于0，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> canPlaceFlowers(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; flowerbed, <span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; flowerbed.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (n == <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> (flowerbed[i] == <span style="color: #800080;">0</span><span style="color: #000000;">) {
                </span><span style="color: #0000ff;">int</span> next = (i == flowerbed.size() - <span style="color: #800080;">1</span> ? <span style="color: #800080;">0</span> : flowerbed[i + <span style="color: #800080;">1</span><span style="color: #000000;">]);
                </span><span style="color: #0000ff;">int</span> pre = (i == <span style="color: #800080;">0</span> ? <span style="color: #800080;">0</span> : flowerbed[i - <span style="color: #800080;">1</span><span style="color: #000000;">]);
                </span><span style="color: #0000ff;">if</span> (next + pre == <span style="color: #800080;">0</span><span style="color: #000000;">) {
                    flowerbed[i] </span>= <span style="color: #800080;">1</span><span style="color: #000000;">;
                    </span>--<span style="color: #000000;">n;
                }
            }
        }
        </span><span style="color: #0000ff;">return</span> n &lt;= <span style="color: #800080;">0</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种方法跟上面的方法类似，为了不特殊处理首末位置，直接先在首尾各加了一个0，然后就三个三个的来遍历，如果找到了三个连续的0，那么n自减1，i自增1，这样相当于i一下向后跨了两步，可以自行带例子检验，最后还是看n是否小于等于0，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> canPlaceFlowers(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; flowerbed, <span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        flowerbed.insert(flowerbed.begin(), </span><span style="color: #800080;">0</span><span style="color: #000000;">);
        flowerbed.push_back(</span><span style="color: #800080;">0</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt; flowerbed.size() - <span style="color: #800080;">1</span>; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (n == <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> (flowerbed[i - <span style="color: #800080;">1</span>] + flowerbed[i] + flowerbed[i + <span style="color: #800080;">1</span>] == <span style="color: #800080;">0</span><span style="color: #000000;">) {
                </span>--<span style="color: #000000;">n;
                </span>++<span style="color: #000000;">i;
            }
        }
        </span><span style="color: #0000ff;">return</span> n &lt;= <span style="color: #800080;">0</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/6399408.html">Teemo Attacking</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/91376/simplest-c-code" target="_blank">https://discuss.leetcode.com/topic/91376/simplest-c-code</a></p>
<p><a href="https://discuss.leetcode.com/topic/91303/java-greedy-solution-o-flowerbed-beats-100" target="_blank">https://discuss.leetcode.com/topic/91303/java-greedy-solution-o-flowerbed-beats-100</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-06-11 03:55</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=6983982" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(6983982);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7026999.html" id="cb_post_title_url">[LeetCode] Design Compressed String Iterator 设计压缩字符串的迭代器</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Design and implement a data structure for a compressed string iterator. It should support the following operations: <code>next</code> and <code>hasNext</code>.</p>
<p>The given compressed string will be in the form of each letter followed by a positive integer representing the number of this letter existing in the original uncompressed string.</p>
<p><code>next()</code> - if the original string still has uncompressed characters, return the next letter; Otherwise return a white space.<br/><code>hasNext()</code> - Judge whether there is any letter needs to be uncompressed.</p>
<p>Note:<br/>Please remember to RESET your class variables declared in StringIterator, as static/class variables are persisted across multiple test cases. Please see <a href="https://leetcode.com/faq/#different-output">here</a> for more details.</p>
<p>Example:</p>
<pre>StringIterator iterator = new StringIterator("L1e2t1C1o1d1e1");

iterator.next(); // return 'L'
iterator.next(); // return 'e'
iterator.next(); // return 'e'
iterator.next(); // return 't'
iterator.next(); // return 'C'
iterator.next(); // return 'o'
iterator.next(); // return 'd'
iterator.hasNext(); // return true
iterator.next(); // return 'e'
iterator.hasNext(); // return false
iterator.next(); // return ' '</pre>
<p> </p>
<p>这道题给了我们一个压缩字符串，就是每个字符后面跟上其出现的次数，这里就算只出现一次，后面还是要加上1，那么其实如果当字符串很好有连续字符的时候，压缩字符串反而要比原字符串长。不过这题的重点不在于压缩字符串本身，而是让我们设计一个压缩字符串的迭代器，那么实际上是要我们根据压缩字符串来输出原字符串中的所有字符。那么我们关键就是要取出每个字符和其出现的次数，每当调用一次next，次数减1，如果减到0了，我们就要取出下一个字符和其出现的次数。我们要用个私有变量s来保存原字符串，然后用个变量i来记录当前遍历到的位置，变量c为当前处理的字符，变量cnt为字符c的当前次数。变量i的初始化为0，指向第一个字符，我们在hasNext()函数中，现将s[i]存入c，然后i自增1，然后我们用while循环取出所有的数字，存入cnt中。在next()函数中，如果hasNext()返回true，那么cnt就自减1，返回c；如果hasNext()返回false，那么字节返回空字符。在hasNext()函数中首先判断cnt的值，如果大于0，直接返回true，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> StringIterator {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    StringIterator(</span><span style="color: #0000ff;">string</span><span style="color: #000000;"> compressedString) {
        s </span>=<span style="color: #000000;"> compressedString;
        n </span>=<span style="color: #000000;"> s.size();
        i </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
        cnt </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
        c </span>= <span style="color: #800000;">'</span> <span style="color: #800000;">'</span><span style="color: #000000;">;
    }
    
    </span><span style="color: #0000ff;">char</span><span style="color: #000000;"> next() {
        </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (hasNext()) {
            </span>--<span style="color: #000000;">cnt;
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> c;
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #800000;">'</span> <span style="color: #800000;">'</span><span style="color: #000000;">;
    }
    
    </span><span style="color: #0000ff;">bool</span><span style="color: #000000;"> hasNext() {
        </span><span style="color: #0000ff;">if</span> (cnt &gt; <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (i &gt;= n) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        c </span>= s[i++<span style="color: #000000;">];
        </span><span style="color: #0000ff;">while</span> (i &lt; n &amp;&amp; s[i] &gt;= <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span> &amp;&amp; s[i] &lt;= <span style="color: #800000;">'</span><span style="color: #800000;">9</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
            cnt </span>= cnt * <span style="color: #800080;">10</span> + s[i++] - <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }

</span><span style="color: #0000ff;">private</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span><span style="color: #000000;"> s;
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> n, i, cnt;
    </span><span style="color: #0000ff;">char</span><span style="color: #000000;"> c;
};</span></pre>
</div>
<p> </p>
<p>我们可以用C++中的字符流类来处理字符串，写法非常的简洁，可以少定义一些变量，在hasNext()函数中，如果cnt为0了，那么我们用字符流类直接读出下一个字符和次数，然后看是否能读出大于0的次数来返回真假值，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> StringIterator {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    StringIterator(</span><span style="color: #0000ff;">string</span><span style="color: #000000;"> compressedString) {
        </span><span style="color: #0000ff;">is</span> =<span style="color: #000000;"> istringstream(compressedString);
        cnt </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
        c </span>= <span style="color: #800000;">'</span> <span style="color: #800000;">'</span><span style="color: #000000;">;
    }
    
    </span><span style="color: #0000ff;">char</span><span style="color: #000000;"> next() {
        </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (hasNext()) {
            </span>--<span style="color: #000000;">cnt;
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> c;
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #800000;">'</span> <span style="color: #800000;">'</span><span style="color: #000000;">;
    }
    
    </span><span style="color: #0000ff;">bool</span><span style="color: #000000;"> hasNext() {
        </span><span style="color: #0000ff;">if</span> (cnt == <span style="color: #800080;">0</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">is</span> &gt;&gt; c &gt;&gt;<span style="color: #000000;"> cnt;
        }
        </span><span style="color: #0000ff;">return</span> cnt &gt; <span style="color: #800080;">0</span><span style="color: #000000;">;
    }

</span><span style="color: #0000ff;">private</span><span style="color: #000000;">:
    istringstream </span><span style="color: #0000ff;">is</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> cnt;
    </span><span style="color: #0000ff;">char</span><span style="color: #000000;"> c;
};</span></pre>
</div>
<p> </p>
<p>下面这种解法还是用字符流类，和上面方法不同的地方是，在构建函数中完成了所有字符和次数的拆分，然后字符和其次数组成一个pair，加入一个队列queue中，这样我们每次处理的时候就直接去queue中取值就行了，这样hasNext()函数就变的非常简洁，只需要判断队列queue是否为空即可，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> StringIterator {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    StringIterator(</span><span style="color: #0000ff;">string</span><span style="color: #000000;"> compressedString) {
        istringstream </span><span style="color: #0000ff;">is</span><span style="color: #000000;">(compressedString);
        </span><span style="color: #0000ff;">int</span> cnt = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">char</span> c = <span style="color: #800000;">'</span> <span style="color: #800000;">'</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (<span style="color: #0000ff;">is</span> &gt;&gt; c &gt;&gt;<span style="color: #000000;"> cnt) {
            q.push({c, cnt});
        }
    }
    
    </span><span style="color: #0000ff;">char</span><span style="color: #000000;"> next() {
        </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (hasNext()) {
            auto </span>&amp;t =<span style="color: #000000;"> q.front();
            </span><span style="color: #0000ff;">if</span> (--t.second == <span style="color: #800080;">0</span><span style="color: #000000;">) q.pop();
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> t.first;
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #800000;">'</span> <span style="color: #800000;">'</span><span style="color: #000000;">;
    }
    
    </span><span style="color: #0000ff;">bool</span><span style="color: #000000;"> hasNext() {
        </span><span style="color: #0000ff;">return</span> !<span style="color: #000000;">q.empty();
    }

</span><span style="color: #0000ff;">private</span><span style="color: #000000;">:
    queue</span>&lt;pair&lt;<span style="color: #0000ff;">char</span>, <span style="color: #0000ff;">int</span>&gt;&gt;<span style="color: #000000;"> q;
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/92098/java-concise-single-queue-solution" target="_blank">https://discuss.leetcode.com/topic/92098/java-concise-single-queue-solution</a></p>
<p><a href="https://discuss.leetcode.com/topic/92159/short-solution-of-c-using-stringstream-python-using-re" target="_blank">https://discuss.leetcode.com/topic/92159/short-solution-of-c-using-stringstream-python-using-re</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-06-16 13:14</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7026999" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7026999);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/6959585.html" id="cb_post_title_url">[LeetCode] Non-negative Integers without Consecutive Ones 非负整数不包括连续的1</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a positive integer n, find the number of non-negative integers less than or equal to n, whose binary representations do NOT contain consecutive ones.</p>
<p>Example 1:</p>
<pre>Input: 5
Output: 5
Explanation: 
Here are the non-negative integers &lt;= 5 with their corresponding binary representations:
0 : 0
1 : 1
2 : 10
3 : 11
4 : 100
5 : 101
Among them, only integer 3 disobeys the rule (two consecutive ones) and the other 5 satisfy the rule. 
</pre>
<p> </p>
<p>Note: 1 &lt;= n &lt;= 109</p>
<p> </p>
<p>这道题给了我们一个数字，让我们求不大于这个数字的所有数字中，其二进制的表示形式中没有连续1的个数。根据题目中的例子也不难理解题意。我们首先来考虑二进制的情况，对于1来说，有0和1两种，对于11来说，有00，01，10，三种情况，那么有没有规律可寻呢，其实是有的，我们可以<a href="http://www.geeksforgeeks.org/count-number-binary-strings-without-consecutive-1s/" target="_blank">参见这个帖子</a>，这样我们就可以通过DP的方法求出长度为k的二进制数的无连续1的数字个数。由于题目给我们的并不是一个二进制数的长度，而是一个二进制数，比如100，如果我们按长度为3的情况计算无连续1点个数个数，就会多计算101这种情况。所以我们的目标是要将大于num的情况去掉。下面从头来分析代码，首先我们要把十进制数转为二进制数，将二进制数存在一个字符串中，并统计字符串的长度。然后我们利用<a href="http://www.geeksforgeeks.org/count-number-binary-strings-without-consecutive-1s/" target="_blank">这个帖子</a>中的方法，计算该字符串长度的二进制数所有无连续1的数字个数，然后我们从倒数第二个字符开始往前遍历这个二进制数字符串，如果当前字符和后面一个位置的字符均为1，说明我们并没有多计算任何情况，不明白的可以带例子来看。如果当前字符和后面一个位置的字符均为0，说明我们有多计算一些情况，就像之前举的100这个例子，我们就多算了101这种情况。我们怎么确定多了多少种情况呢，假如给我们的数字是8，二进制为1000，我们首先按长度为4算出所有情况，共8种。仔细观察我们十进制转为二进制字符串的写法，发现转换结果跟真实的二进制数翻转了一下，所以我们的t为"0001"，那么我们从倒数第二位开始往前遍历，到i=1时，发现有两个连续的0出现，那么i=1这个位置上能出现1的次数，就到one数组中去找，那么我们减去1，减去的就是0101这种情况，再往前遍历，i=0时，又发现两个连续0，那么i=0这个位置上能出1的次数也到one数组中去找，我们再减去1，减去的是1001这种情况，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> findIntegers(<span style="color: #0000ff;">int</span><span style="color: #000000;"> num) {
        </span><span style="color: #0000ff;">int</span> cnt = <span style="color: #800080;">0</span>, n =<span style="color: #000000;"> num;
        </span><span style="color: #0000ff;">string</span> t = <span style="color: #800000;">""</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (n &gt; <span style="color: #800080;">0</span><span style="color: #000000;">) {
            </span>++<span style="color: #000000;">cnt;
            t </span>+= (n &amp; <span style="color: #800080;">1</span>) ? <span style="color: #800000;">"</span><span style="color: #800000;">1</span><span style="color: #800000;">"</span> : <span style="color: #800000;">"</span><span style="color: #800000;">0</span><span style="color: #800000;">"</span><span style="color: #000000;">; 
            n </span>&gt;&gt;= <span style="color: #800080;">1</span><span style="color: #000000;">;
        }
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> zero(cnt), one(cnt);
        zero[</span><span style="color: #800080;">0</span>] = <span style="color: #800080;">1</span>; one[<span style="color: #800080;">0</span>] = <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt; cnt; ++<span style="color: #000000;">i) {
            zero[i] </span>= zero[i - <span style="color: #800080;">1</span>] + one[i - <span style="color: #800080;">1</span><span style="color: #000000;">];
            one[i] </span>= zero[i - <span style="color: #800080;">1</span><span style="color: #000000;">];
        }
        </span><span style="color: #0000ff;">int</span> res = zero[cnt - <span style="color: #800080;">1</span>] + one[cnt - <span style="color: #800080;">1</span><span style="color: #000000;">];
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = cnt - <span style="color: #800080;">2</span>; i &gt;= <span style="color: #800080;">0</span>; --<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (t[i] == <span style="color: #800000;">'</span><span style="color: #800000;">1</span><span style="color: #800000;">'</span> &amp;&amp; t[i + <span style="color: #800080;">1</span>] == <span style="color: #800000;">'</span><span style="color: #800000;">1</span><span style="color: #800000;">'</span>) <span style="color: #0000ff;">break</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> (t[i] == <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span> &amp;&amp; t[i + <span style="color: #800080;">1</span>] == <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span>) res -=<span style="color: #000000;"> one[i];
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种解法其实蛮有意思的，其实长度为k的二进制数字符串没有连续的1的个数是一个斐波那契数列f(k)。比如当k=5时，二进制数的范围是00000-11111，我们可以将其分为两个部分，00000-01111和10000-10111，因为任何大于11000的数字都是不成立的，因为有开头已经有了两个连续1。而我们发现其实00000-01111就是f(4)，而10000-10111就是f(3)，所以f(5) = f(4) + f(3)，这就是一个斐波那契数列啦。那么我们要做的首先就是建立一个这个数组，方便之后直接查值。我们从给定数字的最高位开始遍历，如果某一位是1，后面有k位，就加上f(k)，因为如果我们把当前位变成0，那么后面k位就可以直接从斐波那契数列中取值了。然后标记pre为1，再往下遍历，如果遇到0位，则pre标记为0。如果当前位是1，pre也是1，那么直接返回结果。最后循环退出后我们要加上数字本身这种情况，参见代码如下： </p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> findIntegers(<span style="color: #0000ff;">int</span><span style="color: #000000;"> num) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, k = <span style="color: #800080;">31</span>, pre = <span style="color: #800080;">0</span><span style="color: #000000;">;
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; f(<span style="color: #800080;">32</span>, <span style="color: #800080;">0</span><span style="color: #000000;">);
        f[</span><span style="color: #800080;">0</span>] = <span style="color: #800080;">1</span>; f[<span style="color: #800080;">1</span>] = <span style="color: #800080;">2</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">2</span>; i &lt; <span style="color: #800080;">31</span>; ++<span style="color: #000000;">i) {
            f[i] </span>= f[i - <span style="color: #800080;">2</span>] + f[i - <span style="color: #800080;">1</span><span style="color: #000000;">];
        }
        </span><span style="color: #0000ff;">while</span> (k &gt;= <span style="color: #800080;">0</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">if</span> (num &amp; (<span style="color: #800080;">1</span> &lt;&lt;<span style="color: #000000;"> k)) {
                res </span>+=<span style="color: #000000;"> f[k];
                </span><span style="color: #0000ff;">if</span> (pre) <span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
                pre </span>= <span style="color: #800080;">1</span><span style="color: #000000;">;
            } </span><span style="color: #0000ff;">else</span> pre = <span style="color: #800080;">0</span><span style="color: #000000;">;
            </span>--<span style="color: #000000;">k;
        }
        </span><span style="color: #0000ff;">return</span> res + <span style="color: #800080;">1</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4518674.html" target="_blank">House Robber II</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4383632.html" target="_blank">House Robber</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/6188893.html">Ones and Zeroes</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/90571/java-solution-dp" target="_blank">https://discuss.leetcode.com/topic/90571/java-solution-dp</a></p>
<p><a href="https://discuss.leetcode.com/topic/90639/c-non-dp-o-32-fibonacci-solution" target="_blank">https://discuss.leetcode.com/topic/90639/c-non-dp-o-32-fibonacci-solution</a></p>
<p><a href="https://discuss.leetcode.com/topic/90671/java-o-1-time-o-1-space-dp-solution" target="_blank">https://discuss.leetcode.com/topic/90671/java-o-1-time-o-1-space-dp-solution</a></p>
<p><a href="http://www.geeksforgeeks.org/count-number-binary-strings-without-consecutive-1s/">http://www.geeksforgeeks.org/count-number-binary-strings-without-consecutive-1s/</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-06-07 23:14</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=6959585" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(6959585);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/6978646.html" id="cb_post_title_url">[LeetCode] Minimum Index Sum of Two Lists 两个表单的最小坐标和</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Suppose Andy and Doris want to choose a restaurant for dinner, and they both have a list of favorite restaurants represented by strings.</p>
<p>You need to help them find out their common interest with the least list index sum. If there is a choice tie between answers, output all of them with no order requirement. You could assume there always exists an answer.</p>
<p>Example 1:</p>
<pre>Input:
["Shogun", "Tapioca Express", "Burger King", "KFC"]
["Piatti", "The Grill at Torrey Pines", "Hungry Hunter Steakhouse", "Shogun"]
Output: ["Shogun"]
Explanation: The only restaurant they both like is "Shogun".
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input:
["Shogun", "Tapioca Express", "Burger King", "KFC"]
["KFC", "Shogun", "Burger King"]
Output: ["Shogun"]
Explanation: The restaurant they both like and have the least index sum is "Shogun" with index sum 1 (0+1).
</pre>
<p> </p>
<p>Note:</p>
<ol>
<li>The length of both lists will be in the range of [1, 1000].</li>
<li>The length of strings in both lists will be in the range of [1, 30].</li>
<li>The index is starting from 0 to the list length minus 1.</li>
<li>No duplicates in both lists.</li>
</ol>
<p> </p>
<p>这道题给了我们两个字符串数组，让我们找到坐标位置之和最小的相同的字符串。那么对于这种数组项和其坐标之间关系的题，最先考虑到的就是要建立数据和其位置坐标之间的映射。我们建立list1的值和坐标的之间的映射，然后遍历list2，如果当前遍历到的字符串在list1中也出现了，那么我们计算两个的坐标之和，如果跟我们维护的最小坐标和mn相同，那么将这个字符串加入结果res中，如果比mn小，那么mn更新为这个较小值，然后将结果res清空并加入这个字符串，参见代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; findRestaurant(vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp; list1, vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp;<span style="color: #000000;"> list2) {
        vector</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> res;
        unordered_map</span>&lt;<span style="color: #0000ff;">string</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> m;
        </span><span style="color: #0000ff;">int</span> mn = INT_MAX, n1 = list1.size(), n2 =<span style="color: #000000;"> list2.size();
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n1; ++i) m[list1[i]] =<span style="color: #000000;"> i;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n2; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (m.count(list2[i])) {
                </span><span style="color: #0000ff;">int</span> sum = i +<span style="color: #000000;"> m[list2[i]];
                </span><span style="color: #0000ff;">if</span> (sum ==<span style="color: #000000;"> mn) res.push_back(list2[i]);
                </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (sum &lt;<span style="color: #000000;"> mn) {
                    mn </span>=<span style="color: #000000;"> sum;
                    res </span>=<span style="color: #000000;"> {list2[i]};
                }
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4128461.html" target="_blank">Intersection of Two Linked Lists</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/90534/java-o-n-m-time-o-n-space" target="_blank">https://discuss.leetcode.com/topic/90534/java-o-n-m-time-o-n-space</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-06-10 14:19</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=6978646" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(6978646);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/6974232.html" id="cb_post_title_url">[LeetCode] Range Addition II 范围相加之二</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given an m * n matrix M initialized with all 0's and several update operations.</p>
<p>Operations are represented by a 2D array, and each operation is represented by an array with two positive integers a and b, which means M[i][j] should be added by one for all 0 &lt;= i &lt; a and 0 &lt;= j &lt; b.</p>
<p>You need to count and return the number of maximum integers in the matrix after performing all the operations.</p>
<p>Example 1:</p>
<pre>Input: 
m = 3, n = 3
operations = [[2,2],[3,3]]
Output: 4
Explanation: 
Initially, M = 
[[0, 0, 0],
 [0, 0, 0],
 [0, 0, 0]]

After performing [2,2], M = 
[[1, 1, 0],
 [1, 1, 0],
 [0, 0, 0]]

After performing [3,3], M = 
[[2, 2, 1],
 [2, 2, 1],
 [1, 1, 1]]

So the maximum integer in M is 2, and there are four of it in M. So return 4.
</pre>
<p> </p>
<p>Note:</p>
<ol>
<li>The range of m and n is [1,40000].</li>
<li>The range of a is [1,m], and the range of b is [1,n].</li>
<li>The range of operations size won't exceed 10,000.</li>
</ol>
<p> </p>
<p>这道题看起来像是之前那道<a href="http://www.cnblogs.com/grandyang/p/5628786.html">Range Addition</a>的拓展，但是感觉实际上更简单一些。每次在ops中给定我们一个横纵坐标，将这个子矩形范围内的数字全部自增1，让我们求最大数字的个数。原数组初始化均为0，那么如果ops为空，没有任何操作，那么直接返回m*n即可，我们可以用一个优先队列来保存最大数字矩阵的横纵坐标，我们可以通过举些例子发现，只有最小数字组成的边界中的数字才会被每次更新，所以我们想让最小的数字到队首，更优先队列的排序机制是大的数字在队首，所以我们对其取相反数，这样我们最后取出两个队列的队首数字相乘即为结果，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> maxCount(<span style="color: #0000ff;">int</span> m, <span style="color: #0000ff;">int</span> n, vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> ops) {
        </span><span style="color: #0000ff;">if</span> (ops.empty() || ops[<span style="color: #800080;">0</span>].empty()) <span style="color: #0000ff;">return</span> m *<span style="color: #000000;"> n;
        priority_queue</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> r, c;
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto op : ops) {
            r.push(</span>-op[<span style="color: #800080;">0</span><span style="color: #000000;">]);
            c.push(</span>-op[<span style="color: #800080;">1</span><span style="color: #000000;">]);
        }
        </span><span style="color: #0000ff;">return</span> r.top() *<span style="color: #000000;"> c.top();
    }
};</span></pre>
</div>
<p> </p>
<p>我们可以对空间进行优化，不使用优先队列，而是每次用ops中的值来更新m和n，取其中较小值，这样遍历完成后，m和n就是最大数矩阵的边界了，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> maxCount(<span style="color: #0000ff;">int</span> m, <span style="color: #0000ff;">int</span> n, vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> ops) {
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto op : ops) {
            m </span>= min(m, op[<span style="color: #800080;">0</span><span style="color: #000000;">]);
            n </span>= min(n, op[<span style="color: #800080;">1</span><span style="color: #000000;">]);
        }
        </span><span style="color: #0000ff;">return</span> m *<span style="color: #000000;"> n;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/5628786.html">Range Addition</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/90540/c-java-clean-code" target="_blank">https://discuss.leetcode.com/topic/90540/c-java-clean-code</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-06-09 23:42</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=6974232" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(6974232);return false;">收藏</a></div>
</div>
</html>