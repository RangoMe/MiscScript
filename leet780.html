<html lang="zh-cn">
<head>
<meta charset="utf-8"/>
<div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4329295.html" id="cb_post_title_url">[LeetCode] Remove Duplicates from Sorted Array II 有序数组中去除重复项之二</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Follow up for "Remove Duplicates":<br/>What if duplicates are allowed at most <em>twice</em>?</p>
<p>For example,<br/>Given sorted array A = <code>[1,1,1,2,2,3]</code>,</p>
<p>Your function should return length = <code>5</code>, and A is now <code>[1,1,2,2,3]</code>.</p>
<p> </p>
<p>这道题是之前那道<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4329128.html" id="homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0"> Remove Duplicates from Sorted Array 有序数组中去除重复项</a> 的延续，这里允许最多重复的次数是两次，那么我们就需要用一个变量count来记录还允许有几次重复，count初始化为1，如果出现过一次重复，则count递减1，那么下次再出现重复，快指针直接前进一步，如果这时候不是重复的，则count恢复1，由于整个数组是有序的，所以一旦出现不重复的数，则一定比这个数大，此数之后不会再有重复项。理清了上面的思路，则代码很好写了：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> removeDuplicates(<span style="color: #0000ff;">int</span> A[], <span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        </span><span style="color: #0000ff;">if</span> (n &lt;= <span style="color: #800080;">2</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;"> n;
        </span><span style="color: #0000ff;">int</span> pre = <span style="color: #800080;">0</span>, cur = <span style="color: #800080;">1</span>, count = <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (cur &lt;<span style="color: #000000;"> n) {
            </span><span style="color: #0000ff;">if</span> (A[pre] == A[cur] &amp;&amp; count == <span style="color: #800080;">0</span>) ++<span style="color: #000000;">cur;
            </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                </span><span style="color: #0000ff;">if</span> (A[pre] == A[cur]) --<span style="color: #000000;">count;
                </span><span style="color: #0000ff;">else</span> count = <span style="color: #800080;">1</span><span style="color: #000000;">;
                A[</span>++pre] = A[cur++<span style="color: #000000;">];
            }
        }
        </span><span style="color: #0000ff;">return</span> pre + <span style="color: #800080;">1</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-03-11 11:02</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4329295" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4329295);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4332313.html" id="cb_post_title_url">[LeetCode] Word Search 词语搜索</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a 2D board and a word, find if the word exists in the grid.</p>
<p>The word can be constructed from letters of sequentially adjacent cell, where "adjacent" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.</p>
<p>For example,<br/>Given board =</p>
<pre>[
  ["ABCE"],
  ["SFCS"],
  ["ADEE"]
]
</pre>
<p>word = <code>"ABCCED"</code>, -&gt; returns <code>true</code>,<br/>word = <code>"SEE"</code>, -&gt; returns <code>true</code>,<br/>word = <code>"ABCB"</code>, -&gt; returns <code>false</code>.</p>
<p> </p>
<p>这道题是典型的深度优先遍历DFS的应用，原二维数组就像是一个迷宫，可以上下左右四个方向行走，我们以二维数组中每一个数都作为起点和给定字符串做匹配，我们还需要一个和原数组等大小的visited数组，是bool型的，用来记录当前位置是否已经被访问过，因为题目要求一个cell只能被访问一次。如果二维数组board的当前字符和目标字符串word对应的字符相等，则对其上下左右四个邻字符分别调用DFS的递归函数，只要有一个返回true，那么就表示可以找到对应的字符串，否则就不能找到，具体看代码实现如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> exist(vector&lt;vector&lt;<span style="color: #0000ff;">char</span>&gt;&gt;&amp; board, <span style="color: #0000ff;">string</span><span style="color: #000000;"> word) {
        </span><span style="color: #0000ff;">if</span> (board.empty() || board[<span style="color: #800080;">0</span>].empty()) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> m = board.size(), n = board[<span style="color: #800080;">0</span><span style="color: #000000;">].size();
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">bool</span>&gt;&gt; visited(m, vector&lt;<span style="color: #0000ff;">bool</span>&gt;(n, <span style="color: #0000ff;">false</span><span style="color: #000000;">));
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; m; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; n; ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> (search(board, word, <span style="color: #800080;">0</span>, i, j, visited)) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
            }
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
    }
    </span><span style="color: #0000ff;">bool</span> search(vector&lt;vector&lt;<span style="color: #0000ff;">char</span>&gt;&gt;&amp; board, <span style="color: #0000ff;">string</span> word, <span style="color: #0000ff;">int</span> idx, <span style="color: #0000ff;">int</span> i, <span style="color: #0000ff;">int</span> j, vector&lt;vector&lt;<span style="color: #0000ff;">bool</span>&gt;&gt;&amp;<span style="color: #000000;"> visited) {
        </span><span style="color: #0000ff;">if</span> (idx == word.size()) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> m = board.size(), n = board[<span style="color: #800080;">0</span><span style="color: #000000;">].size();
        </span><span style="color: #0000ff;">if</span> (i &lt; <span style="color: #800080;">0</span> || j &lt; <span style="color: #800080;">0</span> || i &gt;= m || j &gt;= n || visited[i][j] || board[i][j] != word[idx]) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        visited[i][j] </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">bool</span> res = search(board, word, idx + <span style="color: #800080;">1</span>, i - <span style="color: #800080;">1</span><span style="color: #000000;">, j, visited) 
                 </span>|| search(board, word, idx + <span style="color: #800080;">1</span>, i + <span style="color: #800080;">1</span><span style="color: #000000;">, j, visited)
                 </span>|| search(board, word, idx + <span style="color: #800080;">1</span>, i, j - <span style="color: #800080;">1</span><span style="color: #000000;">, visited)
                 </span>|| search(board, word, idx + <span style="color: #800080;">1</span>, i, j + <span style="color: #800080;">1</span><span style="color: #000000;">, visited);
        visited[i][j] </span>= <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>我们还可以不用visited数组，直接对board数组进行修改，将其遍历过的位置改为井号，记得递归调用完后需要恢复之前的状态，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> exist(vector&lt;vector&lt;<span style="color: #0000ff;">char</span>&gt;&gt;&amp; board, <span style="color: #0000ff;">string</span><span style="color: #000000;"> word) {
        </span><span style="color: #0000ff;">if</span> (board.empty() || board[<span style="color: #800080;">0</span>].empty()) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> m = board.size(), n = board[<span style="color: #800080;">0</span><span style="color: #000000;">].size();
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; m; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; n; ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> (search(board, word, <span style="color: #800080;">0</span>, i, j)) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
            }
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
    }
    </span><span style="color: #0000ff;">bool</span> search(vector&lt;vector&lt;<span style="color: #0000ff;">char</span>&gt;&gt;&amp; board, <span style="color: #0000ff;">string</span> word, <span style="color: #0000ff;">int</span> idx, <span style="color: #0000ff;">int</span> i, <span style="color: #0000ff;">int</span><span style="color: #000000;"> j) {
        </span><span style="color: #0000ff;">if</span> (idx == word.size()) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> m = board.size(), n =<span style="color: #000000;"> board[i].size();
        </span><span style="color: #0000ff;">if</span> (i &lt; <span style="color: #800080;">0</span> || j &lt; <span style="color: #800080;">0</span> || i &gt;= m || j &gt;= n || board[i][j] != word[idx]) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">char</span> c =<span style="color: #000000;"> board[i][j];
        board[i][j] </span>= <span style="color: #800000;">'</span><span style="color: #800000;">#</span><span style="color: #800000;">'</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">bool</span> res = search(board, word, idx + <span style="color: #800080;">1</span>, i - <span style="color: #800080;">1</span><span style="color: #000000;">, j) 
                 </span>|| search(board, word, idx + <span style="color: #800080;">1</span>, i + <span style="color: #800080;">1</span><span style="color: #000000;">, j)
                 </span>|| search(board, word, idx + <span style="color: #800080;">1</span>, i, j - <span style="color: #800080;">1</span><span style="color: #000000;">)
                 </span>|| search(board, word, idx + <span style="color: #800080;">1</span>, i, j + <span style="color: #800080;">1</span><span style="color: #000000;">);
        board[i][j] </span>=<span style="color: #000000;"> c;
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4516013.html" target="_blank">Word Search II</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-03-12 14:24</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4332313" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4332313);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4309345.html" id="cb_post_title_url">[LeetCode] Subsets 子集合</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a set of distinct integers, <em>S</em>, return all possible subsets.</p>
<p>Note:</p>
<ul>
<li>Elements in a subset must be in non-descending order.</li>
<li>The solution set must not contain duplicate subsets.</li>
</ul>
<p> </p>
<p>For example,<br/>If <em>S</em> = <code>[1,2,3]</code>, a solution is:</p>
<pre>[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]</pre>
<p> </p>
<p>这道求子集合的问题，由于其要列出所有结果，按照以往的经验，肯定要是要用递归来做。这道题其实它的非递归解法相对来说更简单一点，下面我们先来看非递归的解法，由于题目要求子集合中数字的顺序是非降序排列的，所有我们需要预处理，先给输入数组排序，然后再进一步处理，最开始我在想的时候，是想按照子集的长度由少到多全部写出来，比如子集长度为0的就是空集，空集是任何集合的子集，满足条件，直接加入。下面长度为1的子集，直接一个循环加入所有数字，子集长度为2的话可以用两个循环，但是这种想法到后面就行不通了，因为循环的个数不能无限的增长，所以我们必须换一种思路。我们可以一位一位的网上叠加，比如对于题目中给的例子[1,2,3]来说，最开始是空集，那么我们现在要处理1，就在空集上加1，为[1]，现在我们有两个自己[]和[1]，下面我们来处理2，我们在之前的子集基础上，每个都加个2，可以分别得到[2]，[1, 2]，那么现在所有的子集合为[], [1], [2], [1, 2]，同理处理3的情况可得[3], [1, 3], [2, 3], [1, 2, 3], 再加上之前的子集就是所有的子集合了，代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> Non-recursion</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt; &gt; subsets(vector&lt;<span style="color: #0000ff;">int</span>&gt; &amp;<span style="color: #000000;">S) {
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt; &gt; res(<span style="color: #800080;">1</span><span style="color: #000000;">);
        sort(S.begin(), S.end());
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; S.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">int</span> size =<span style="color: #000000;"> res.size();
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; size; ++<span style="color: #000000;">j) {
                res.push_back(res[j]);
                res.back().push_back(S[i]);
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>整个添加的顺序为：</p>
<p>[]<br/>[1]<br/>[2]<br/>[1 2]<br/>[3]<br/>[1 3]<br/>[2 3]<br/>[1 2 3]</p>
<p> </p>
<p>下面来看递归的解法，相当于一种深度优先搜索，参见网友<a href="http://www.cnblogs.com/TenosDoIt/p/3451902.html" target="_blank">JustDoIt的博客</a>，由于原集合每一个数字只有两种状态，要么存在，要么不存在，那么在构造子集时就有选择和不选择两种情况，所以可以构造一棵二叉树，左子树表示选择该层处理的节点，右子树表示不选择，最终的叶节点就是所有子集合，树的结构如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">                        []        
                   </span>/<span style="color: #000000;">          \        
                  </span>/<span style="color: #000000;">            \     
                 </span>/<span style="color: #000000;">              \
              [</span><span style="color: #800080;">1</span><span style="color: #000000;">]                []
           </span>/       \           /<span style="color: #000000;">    \
          </span>/         \         /<span style="color: #000000;">      \        
       [</span><span style="color: #800080;">1</span> <span style="color: #800080;">2</span>]       [<span style="color: #800080;">1</span>]       [<span style="color: #800080;">2</span><span style="color: #000000;">]     []
      </span>/     \     /   \     /   \    /<span style="color: #000000;"> \
  [</span><span style="color: #800080;">1</span> <span style="color: #800080;">2</span> <span style="color: #800080;">3</span>] [<span style="color: #800080;">1</span> <span style="color: #800080;">2</span>] [<span style="color: #800080;">1</span> <span style="color: #800080;">3</span>] [<span style="color: #800080;">1</span>] [<span style="color: #800080;">2</span> <span style="color: #800080;">3</span>] [<span style="color: #800080;">2</span>] [<span style="color: #800080;">3</span>] []    </pre>
</div>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> Recursion</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt; &gt; subsets(vector&lt;<span style="color: #0000ff;">int</span>&gt; &amp;<span style="color: #000000;">S) {
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt; &gt;<span style="color: #000000;"> res;
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; <span style="color: #0000ff;">out</span><span style="color: #000000;">;
        sort(S.begin(), S.end());
        getSubsets(S, </span><span style="color: #800080;">0</span>, <span style="color: #0000ff;">out</span><span style="color: #000000;">, res);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">void</span> getSubsets(vector&lt;<span style="color: #0000ff;">int</span>&gt; &amp;S, <span style="color: #0000ff;">int</span> pos, vector&lt;<span style="color: #0000ff;">int</span>&gt; &amp;<span style="color: #0000ff;">out</span>, vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt; &gt; &amp;<span style="color: #000000;">res) {
        res.push_back(</span><span style="color: #0000ff;">out</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = pos; i &lt; S.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">out</span><span style="color: #000000;">.push_back(S[i]);
            getSubsets(S, i </span>+ <span style="color: #800080;">1</span>, <span style="color: #0000ff;">out</span><span style="color: #000000;">, res);
            </span><span style="color: #0000ff;">out</span><span style="color: #000000;">.pop_back();
        }
    }
};</span></pre>
</div>
<p> </p>
<p>整个添加的顺序为：</p>
<p>[]<br/>[1]<br/>[1 2]<br/>[1 2 3]<br/>[1 3]<br/>[2]<br/>[2 3]<br/>[3]</p>
<p> </p>
<p>最后我们再来看一种解法，这种解法是CareerCup书上给的一种解法，想法也比较巧妙，把数组中所有的数分配一个状态，true表示这个数在子集中出现，false表示在子集中不出现，那么对于一个长度为n的数组，每个数字都有出现与不出现两种情况，所以共有2<sup>n</sup>中情况，那么我们把每种情况都转换出来就是子集了，我们还是用题目中的例子, [1 2 3]这个数组共有8个子集，每个子集的序号的二进制表示，把是1的位对应原数组中的数字取出来就是一个子集，八种情况都取出来就是所有的子集了，参见代码如下：</p>
<table border="0">
<tbody>
<tr>
<td> </td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>Subset</td>
</tr>
<tr>
<td>0</td>
<td>F</td>
<td>F</td>
<td>F</td>
<td>[]</td>
</tr>
<tr>
<td>1</td>
<td>F</td>
<td>F</td>
<td>T</td>
<td>3</td>
</tr>
<tr>
<td>2</td>
<td>F</td>
<td>T</td>
<td>F</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>F</td>
<td>T</td>
<td>T</td>
<td>23</td>
</tr>
<tr>
<td>4</td>
<td>T</td>
<td>F</td>
<td>F</td>
<td>1</td>
</tr>
<tr>
<td>5</td>
<td>T</td>
<td>F</td>
<td>T</td>
<td>13</td>
</tr>
<tr>
<td>6</td>
<td>T</td>
<td>T</td>
<td>F</td>
<td>12</td>
</tr>
<tr>
<td>7</td>
<td>T</td>
<td>T</td>
<td>T</td>
<td>123</td>
</tr>
</tbody>
</table>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt; &gt; subsets(vector&lt;<span style="color: #0000ff;">int</span>&gt; &amp;<span style="color: #000000;">S) {
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt; &gt;<span style="color: #000000;"> res;
        sort(S.begin(), S.end());
        </span><span style="color: #0000ff;">int</span> max = <span style="color: #800080;">1</span> &lt;&lt;<span style="color: #000000;"> S.size();
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> k = <span style="color: #800080;">0</span>; k &lt; max; ++<span style="color: #000000;">k) {
            vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; <span style="color: #0000ff;">out</span> =<span style="color: #000000;"> convertIntToSet(S, k);
            res.push_back(</span><span style="color: #0000ff;">out</span><span style="color: #000000;">);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; convertIntToSet(vector&lt;<span style="color: #0000ff;">int</span>&gt; &amp;S, <span style="color: #0000ff;">int</span><span style="color: #000000;"> k) {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> sub;
        </span><span style="color: #0000ff;">int</span> idx = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = k; i &gt; <span style="color: #800080;">0</span>; i &gt;&gt;= <span style="color: #800080;">1</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">if</span> ((i &amp; <span style="color: #800080;">1</span>) == <span style="color: #800080;">1</span><span style="color: #000000;">) {
                sub.push_back(S[idx]);
            }
            </span>++<span style="color: #000000;">idx;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> sub;
    }
};</span></pre>
</div>
<p> </p>
<p>此题的拓展请参见我的另一篇博客<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4310964.html" id="cb_post_title_url">Subsets II 子集合之二</a>。</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-03-02 17:29</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4309345" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4309345);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4332522.html" id="cb_post_title_url">[LeetCode] Combinations 组合项</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given two integers <em>n</em> and <em>k</em>, return all possible combinations of <em>k</em> numbers out of 1 ... <em>n</em>.</p>
<p>For example,<br/>If <em>n</em> = 4 and <em>k</em> = 2, a solution is:</p>
<pre>[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]</pre>
<p>这道题让求1到n共n个数字里k个数的组合数的所有情况，还是要用深度优先搜索DFS来解，根据以往的经验，像这种要求出所有结果的集合，一般都是用DFS调用递归来解。那么我们建立一个保存最终结果的大集合res，还要定义一个保存每一个组合的小集合out，每次放一个数到out里，如果out里数个数到了k个，则把out保存到最终结果中，否则在下一层中继续调用递归。网友<a href="http://blog.csdn.net/u010500263/article/details/18435495" target="_blank">u010500263的博客</a>里有一张图很好的说明了递归调用的顺序，请点击<a href="http://blog.csdn.net/u010500263/article/details/18435495" target="_blank">这里</a>。根据上面分析，可写出代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; combine(<span style="color: #0000ff;">int</span> n, <span style="color: #0000ff;">int</span><span style="color: #000000;"> k) {
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;<span style="color: #000000;"> res;
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; <span style="color: #0000ff;">out</span><span style="color: #000000;">;
        helper(n, k, </span><span style="color: #800080;">1</span>, <span style="color: #0000ff;">out</span><span style="color: #000000;">, res);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">void</span> helper(<span style="color: #0000ff;">int</span> n, <span style="color: #0000ff;">int</span> k, <span style="color: #0000ff;">int</span> level, vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; <span style="color: #0000ff;">out</span>, vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> res) {
        </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">out</span>.size() == k) {res.push_back(<span style="color: #0000ff;">out</span>); <span style="color: #0000ff;">return</span><span style="color: #000000;">;}
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = level; i &lt;= n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">out</span><span style="color: #000000;">.push_back(i);
            helper(n, k, i </span>+ <span style="color: #800080;">1</span>, <span style="color: #0000ff;">out</span><span style="color: #000000;">, res);
            </span><span style="color: #0000ff;">out</span><span style="color: #000000;">.pop_back();
        }
    }
};</span></pre>
</div>
<p> </p>
<p>对于n = 5, k = 3, 处理的结果如下：</p>
<p>1 2 3 <br/>1	2	4<br/>1	2	5<br/>1	3	4<br/>1	3	5<br/>1	4	5<br/>2	3	4<br/>2	3	5<br/>2	4	5<br/>3	4	5</p>
<p> </p>
<p>我们再来看一种递归的写法，此解法没用helper当递归函数，而是把本身就当作了递归函数，写起来十分的简洁，也是非常有趣的一种解法。这个解法用到了一个重要的性质 C(n, k) = C(n-1, k-1) + C(n-1, k)，这应该在我们高中时候学排列组合的时候学过吧，博主也记不清了。总之，翻译一下就是，在n个数中取k个数的组合项个数，等于在n-1个数中取k-1个数的组合项个数再加上在n-1个数中取k个数的组合项个数之和。这里博主就不证明了，因为我也不会，就直接举题目中的例子来说明吧：</p>
<p>C(4, 2) = C(3, 1) + C(3, 2)</p>
<p>我们不难写出 C(3, 1) 的所有情况：[1], [2], [3]，还有 C(3, 2) 的所有情况：[1, 2], [1, 3], [2, 3]。我们发现二者加起来为6，正好是 C(4, 2) 的个数之和。但是我们仔细看会发现，C(3, 2)的所有情况包含在 C(4, 2) 之中，但是 C(3, 1) 的每种情况只有一个数字，而我们需要的结果k=2，其实很好办，每种情况后面都加上4，于是变成了：[1, 4], [2, 4], [3, 4]，加上C(3, 2) 的所有情况：[1, 2], [1, 3], [2, 3]，正好就得到了 n=4, k=2 的所有情况了。参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; combine(<span style="color: #0000ff;">int</span> n, <span style="color: #0000ff;">int</span><span style="color: #000000;"> k) {
        </span><span style="color: #0000ff;">if</span> (k &gt; n || k &lt; <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;"> {};
        </span><span style="color: #0000ff;">if</span> (k == <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;"> {{}};
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; res = combine(n - <span style="color: #800080;">1</span>, k - <span style="color: #800080;">1</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">for</span> (auto &amp;<span style="color: #000000;">a : res) a.push_back(n);
        </span><span style="color: #0000ff;">for</span> (auto &amp;a : combine(n - <span style="color: #800080;">1</span><span style="color: #000000;">, k)) res.push_back(a);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>我们再来看一种迭代的写法，也是一种比较巧妙的方法。这里每次先递增最右边的数字，存入结果res中，当右边的数字超过了n，则增加其左边的数字，然后将当前数组赋值为左边的数字，再逐个递增，直到最左边的数字也超过了n，停止循环。对于n=4, k=2时，遍历的顺序如下所示：</p>
<pre class="markdown-highlight"><code class="hljs php"><span class="hljs-number"><span style="color: #000000;">0 </span><span class="hljs-number"><span style="color: #000000;">0 </span><span class="hljs-comment"><span style="color: #000000;">#initialization
</span><span class="hljs-number"><span style="color: #000000;">1 </span><span class="hljs-number"><span style="color: #000000;">0
</span><span class="hljs-number"><span style="color: #000000;">1 </span><span class="hljs-number"><span style="color: #000000;">1 </span><span class="hljs-comment">
<span class="hljs-number"><span style="color: #000000;">1 </span><span class="hljs-number"><span style="color: #000000;">2 </span><span class="hljs-comment"><span style="color: #000000;">#push_back
</span><span class="hljs-number"><span style="color: #000000;">1 </span><span class="hljs-number"><span style="color: #000000;">3 </span><span class="hljs-comment"><span style="color: #000000;">#push_back
</span><span class="hljs-number"><span style="color: #000000;">1 </span><span class="hljs-number"><span style="color: #000000;">4 </span><span class="hljs-comment"><span style="color: #000000;">#push_back
</span><span class="hljs-number"><span style="color: #000000;">1 </span><span class="hljs-number"><span style="color: #000000;">5
</span><span class="hljs-number"><span style="color: #000000;">2 </span><span class="hljs-number"><span style="color: #000000;">5
</span><span class="hljs-number"><span style="color: #000000;">2 </span><span class="hljs-number"><span style="color: #000000;">2 </span><span class="hljs-comment">
<span class="hljs-number"><span style="color: #000000;">2 </span><span class="hljs-number"><span style="color: #000000;">3 </span><span class="hljs-comment"><span style="color: #000000;">#push_back
</span><span class="hljs-number"><span style="color: #000000;">2 </span><span class="hljs-number"><span style="color: #000000;">4 </span><span class="hljs-comment"><span style="color: #000000;">#push_back
...
</span><span class="hljs-number"><span style="color: #000000;">3 </span><span class="hljs-number"><span style="color: #000000;">4 </span><span class="hljs-comment"><span style="color: #000000;">#push_back
</span><span class="hljs-number"><span style="color: #000000;">3 </span><span class="hljs-number"><span style="color: #000000;">5
</span><span class="hljs-number"><span style="color: #000000;">4 </span><span class="hljs-number"><span style="color: #000000;">5
</span><span class="hljs-number"><span style="color: #000000;">4 </span><span class="hljs-number"><span style="color: #000000;">4
</span><span class="hljs-number"><span style="color: #000000;">4 </span><span class="hljs-number"><span style="color: #000000;">5
</span><span class="hljs-number"><span style="color: #000000;">5 </span><span class="hljs-number"><span style="color: #000000;">5 </span><span class="hljs-comment"><span style="color: #000000;">#stop</span> <br/></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; combine(<span style="color: #0000ff;">int</span> n, <span style="color: #0000ff;">int</span><span style="color: #000000;"> k) {
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;<span style="color: #000000;"> res;
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; <span style="color: #0000ff;">out</span>(k, <span style="color: #800080;">0</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (i &gt;= <span style="color: #800080;">0</span><span style="color: #000000;">) {
            </span>++<span style="color: #0000ff;">out</span><span style="color: #000000;">[i];
            </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">out</span>[i] &gt; n) --<span style="color: #000000;">i;
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (i == k - <span style="color: #800080;">1</span>) res.push_back(<span style="color: #0000ff;">out</span><span style="color: #000000;">);
            </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                </span>++<span style="color: #000000;">i;
                </span><span style="color: #0000ff;">out</span>[i] = <span style="color: #0000ff;">out</span>[i - <span style="color: #800080;">1</span><span style="color: #000000;">];
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4419259.html" target="_blank">Combination Sum</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4358848.html" target="_blank">Permutations</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-03-12 15:23</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4332522" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4332522);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4340948.html" id="cb_post_title_url">[LeetCode] Minimum Window Substring 最小窗口子串</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).</p>
<p>Example:</p>
<pre>Input: S = "ADOBECODEBANC", T = "ABC"
Output: "BANC"
</pre>
<p>Note:</p>
<ul>
<li>If there is no such window in S that covers all characters in T, return the empty string <code>""</code>.</li>
<li>If there is such window, you are guaranteed that there will always be only one unique minimum window in S.</li>
</ul>
<p> </p>
<p>这道题给了我们一个原字符串S，还有一个目标字符串T，让我们在S中找到一个最短的子串，使得其包含了T中的所有的字母，并且限制了时间复杂度为O(n)。这道题的要求是要在O(n)的时间度里实现找到这个最小窗口字串，那么暴力搜索Brute Force肯定是不能用的，因为遍历所有的子串的时间复杂度是平方级的。那么我们想，时间复杂度卡的这么严，说明我们必须在一次遍历中完成任务，当然遍历若干次也是O(n)，但不一定有这个必要，尝试就一次遍历拿下！那么再来想，既然既然要包含T中所有的字母，那么肯定对于T中的每个字母，肯定要快速查找是否在子串中，既然总时间都卡在了O(n)，我们肯定不想在这里还浪费时间，那么就空间换时间（也就算法题中可以这么干了，七老八十的富翁就算用大别野也换不来时间啊。依依东望，望的就是时间呐T.T），使用HashMap，建立T中每个字母与其出现次数之间的映射，那么你可能会有疑问，为啥不用HashSet呢，别急，讲到后面你就知道用HashMap有多妙，简直妙不可言～</p>
<p>目前在脑子一片浆糊的情况下，我们还是从简单的例子来分析吧，题目例子中的S有点长，我们换个短的 S = "ADBANC"，T = "ABC"，那么我们肉眼遍历一遍S呗，首先第一个是A，嗯很好，T中有，第二个是D，T中没有，不理它，第三个是B，嗯很好，T中有，第四个又是A，多了一个，礼多人不怪嘛，收下啦，第五个是N，一边凉快去，第六个终于是C了，那么貌似好像需要整个S串，其实不然，我们注意之前有多一个A，但么我们就算去掉第一个A，也没事，因为第四个A可以代替之，第二个D也可以去掉，因为不在T串中，第三个B就不能再去掉了，不然就没有B了。所以最终的答案就"BANC"了。通过上面的描述，你有没有发现一个有趣的现象，我们是先扩展，再收缩，就好像一个窗口一样，先扩大右边界，然后再收缩左边界，上面的例子中我们是右边界无法扩大了后才开始收缩左边界，实际上对于复杂的例子，有可能是扩大右边界，然后缩小一下左边界，然后再扩大右边界等等。这就很像一个不停滑动的窗口了，这就是大名鼎鼎的滑动窗口Sliding Window了，简直是神器啊，能解很多子串，子数组，子序列等等的问题，是必须要熟练掌握的啊！</p>
<p>下面我们来考虑用代码来实现，先来回答一下前面埋下的伏笔，为啥要用HashMap，而不是HashSet，现在应该很显而易见了吧，因为要统计T串中字母的个数，而不是仅仅看某个字母是否在T串中出现。统计好T串中字母的个数了之后，我们开始遍历S串，对于S中的每个遍历到的字母，都在HashMap中的映射值减1，如果减1后的映射值仍大于等于0，说明当前遍历到的字母是T串中的字母，我们使用一个计数器cnt，使其自增1。当cnt和T串字母个数相等时，说明此时的窗口已经包含了T串中的所有字母，此时更新一个minLen和结果res，这里的minLen是我们维护的一个全局变量，用来记录出现过的包含T串所有字母的最短的子串的长度，结果res就是这个最短的子串。然后我们要开始收缩左边界，由于我们遍历的时候，对映射值减了1，所以此时去除字母的时候，就要把减去的1加回来，此时如果加1后的值大于0了，说明此时我们少了一个T中的字母，那么cnt值就要减1了，然后移动左边界left。那么你可能会疑问，对于不在T串中的字母的映射值也这么加呀减呀的，真的大丈夫（带脚布）吗？其实没啥事，因为对于不在T串中的字母，我们减1后，变-1，cnt不会增加，之后收缩左边界的时候，映射值加1后为0，cnt也不会减少，所以并没有什么影响啦，下面是具体的步骤啦：</p>
<p>- 我们最开始先扫描一遍T，把对应的字符及其出现的次数存到HashMap中。</p>
<p>- 然后开始遍历S，就把遍历到的字母对应的HashMap中的value减一，如果减1后仍大于等于0，cnt自增1。</p>
<p>- 如果cnt等于T串长度时，开始循环，纪录一个字串并更新最小字串值。然后将子窗口的左边界向右移，如果某个移除掉的字母是T串中不可缺少的字母，那么cnt自减1，表示此时T串并没有完全匹配。</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> minWindow(<span style="color: #0000ff;">string</span> s, <span style="color: #0000ff;">string</span><span style="color: #000000;"> t) {
        </span><span style="color: #0000ff;">string</span> res = <span style="color: #800000;">""</span><span style="color: #000000;">;
        unordered_map</span>&lt;<span style="color: #0000ff;">char</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> letterCnt;
        </span><span style="color: #0000ff;">int</span> left = <span style="color: #800080;">0</span>, cnt = <span style="color: #800080;">0</span>, minLen =<span style="color: #000000;"> INT_MAX;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span> c : t) ++<span style="color: #000000;">letterCnt[c];
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; s.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (--letterCnt[s[i]] &gt;= <span style="color: #800080;">0</span>) ++<span style="color: #000000;">cnt;
            </span><span style="color: #0000ff;">while</span> (cnt ==<span style="color: #000000;"> t.size()) {
                </span><span style="color: #0000ff;">if</span> (minLen &gt; i - left + <span style="color: #800080;">1</span><span style="color: #000000;">) {
                    minLen </span>= i - left + <span style="color: #800080;">1</span><span style="color: #000000;">;
                    res </span>=<span style="color: #000000;"> s.substr(left, minLen);
                }
                </span><span style="color: #0000ff;">if</span> (++letterCnt[s[left]] &gt; <span style="color: #800080;">0</span>) --<span style="color: #000000;">cnt;
                </span>++<span style="color: #000000;">left;
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>这道题也可以不用HashMap，直接用个int的数组来代替，因为ASCII只有256个字符，所以用个大小为256的int数组即可代替HashMap，但由于一般输入字母串的字符只有128个，所以也可以只用128，其余部分的思路完全相同，虽然只改了一个数据结构，但是运行速度提高了一倍，说明数组还是比HashMap快啊，代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> minWindow(<span style="color: #0000ff;">string</span> s, <span style="color: #0000ff;">string</span><span style="color: #000000;"> t) {
        </span><span style="color: #0000ff;">string</span> res = <span style="color: #800000;">""</span><span style="color: #000000;">;
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; letterCnt(<span style="color: #800080;">128</span>, <span style="color: #800080;">0</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">int</span> left = <span style="color: #800080;">0</span>, cnt = <span style="color: #800080;">0</span>, minLen =<span style="color: #000000;"> INT_MAX;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span> c : t) ++<span style="color: #000000;">letterCnt[c];
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; s.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (--letterCnt[s[i]] &gt;= <span style="color: #800080;">0</span>) ++<span style="color: #000000;">cnt;
            </span><span style="color: #0000ff;">while</span> (cnt ==<span style="color: #000000;"> t.size()) {
                </span><span style="color: #0000ff;">if</span> (minLen &gt; i - left + <span style="color: #800080;">1</span><span style="color: #000000;">) {
                    minLen </span>= i - left + <span style="color: #800080;">1</span><span style="color: #000000;">;
                    res </span>=<span style="color: #000000;"> s.substr(left, minLen);
                }
                </span><span style="color: #0000ff;">if</span> (++letterCnt[s[left]] &gt; <span style="color: #800080;">0</span>) --<span style="color: #000000;">cnt;
                </span>++<span style="color: #000000;">left;
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4521224.html" target="_blank">Substring with Concatenation of All Words</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4501934.html" target="_blank">Minimum Size Subarray Sum</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4656517.html">Sliding Window Maximum</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/6815227.html">Permutation in String</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/7200016.html">Smallest Range</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/8684817.html" target="_blank">Minimum Window Subsequence</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-03-16 07:13</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4340948" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4340948);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4341243.html" id="cb_post_title_url">[LeetCode] Sort Colors 颜色排序</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given an array with <em>n</em> objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue.</p>
<p>Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.</p>
<p>Note:<br/>You are not suppose to use the library's sort function for this problem.</p>
<div class="spoilers">
<p>Follow up:<br/>A rather straight forward solution is a two-pass algorithm using counting sort.<br/>First, iterate the array counting number of 0's, 1's, and 2's, then overwrite array with total number of 0's, then 1's and followed by 2's.</p>
<p>Could you come up with an one-pass algorithm using only constant space?</p>
</div>
<p> </p>
<p>这道题的本质还是一道排序的题，题目中给出提示说可以用计数排序，需要遍历数组两遍，那么先来看这种方法，因为数组中只有三个不同的元素，所以实现起来很容易。</p>
<p>- 首先遍历一遍原数组，分别记录0,1,2的个数<br/>- 然后更新原数组，按个数分别赋上0，1，2</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">void</span> sortColors(<span style="color: #0000ff;">int</span> A[], <span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        </span><span style="color: #0000ff;">int</span> count[<span style="color: #800080;">3</span>] = {<span style="color: #800080;">0</span>}, idx = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++i) ++<span style="color: #000000;">count[A[i]];
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; <span style="color: #800080;">3</span>; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; count[i]; ++<span style="color: #000000;">j) {
                A[idx</span>++] =<span style="color: #000000;"> i;
            }
        }
    }
};</span></pre>
</div>
<p> </p>
<p>题目中还要让只遍历一次数组来求解，那么我需要用双指针来做，分别从原数组的首尾往中心移动。</p>
<p>- 定义red指针指向开头位置，blue指针指向末尾位置</p>
<p>- 从头开始遍历原数组，如果遇到0，则交换该值和red指针指向的值，并将red指针后移一位。若遇到2，则交换该值和blue指针指向的值，并将blue指针前移一位。若遇到1，则继续遍历。</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">void</span> sortColors(<span style="color: #0000ff;">int</span> A[], <span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {</span><span style="color: #0000ff;">int</span> red = <span style="color: #800080;">0</span>, blue = n - <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt;= blue; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (A[i] == <span style="color: #800080;">0</span><span style="color: #000000;">) {
                swap(A[i], A[red</span>++<span style="color: #000000;">]);
            } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (A[i] == <span style="color: #800080;">2</span><span style="color: #000000;">) {
                swap(A[i</span>--], A[blue--<span style="color: #000000;">]);
            } 
        }
    }
};</span></pre>
</div>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-03-16 10:50</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4341243" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4341243);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4323301.html" id="cb_post_title_url">[LeetCode] Search a 2D Matrix  搜索一个二维矩阵</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Write an efficient algorithm that searches for a value in an <em>m</em> x <em>n</em> matrix. This matrix has the following properties:</p>
<p> </p>
<ul>
<li>Integers in each row are sorted from left to right.</li>
<li>The first integer of each row is greater than the last integer of the previous row.</li>
</ul>
<p> </p>
<p>For example,</p>
<p>Consider the following matrix:</p>
<pre>[
  [1,   3,  5,  7],
  [10, 11, 16, 20],
  [23, 30, 34, 50]
]
</pre>
<p>Given target = <code>3</code>, return <code>true</code>.</p>
<p> </p>
<p>这道题要求搜索一个二维矩阵，由于给的矩阵是有序的，所以很自然的想到要用<a href="http://zh.wikipedia.org/wiki/%E6%8A%98%E5%8D%8A%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95" target="_blank">二分查找法</a>，我们可以在第一列上先用一次二分查找法找到目标值所在的行的位置，然后在该行上再用一次二分查找法来找是否存在目标值，代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> Two binary search</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> searchMatrix(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt; &gt; &amp;matrix, <span style="color: #0000ff;">int</span><span style="color: #000000;"> target) {
        </span><span style="color: #0000ff;">if</span> (matrix.empty() || matrix[<span style="color: #800080;">0</span>].empty()) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (target &lt; matrix[<span style="color: #800080;">0</span>][<span style="color: #800080;">0</span>] || target &gt; matrix.back().back()) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> left = <span style="color: #800080;">0</span>, right = matrix.size() - <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (left &lt;=<span style="color: #000000;"> right) {
            </span><span style="color: #0000ff;">int</span> mid = (left + right) / <span style="color: #800080;">2</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> (matrix[mid][<span style="color: #800080;">0</span>] == target) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (matrix[mid][<span style="color: #800080;">0</span>] &lt; target) left = mid + <span style="color: #800080;">1</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">else</span> right = mid - <span style="color: #800080;">1</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">int</span> tmp =<span style="color: #000000;"> right;
        left </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
        right </span>= matrix[tmp].size() - <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (left &lt;=<span style="color: #000000;"> right) {
            </span><span style="color: #0000ff;">int</span> mid = (left + right) / <span style="color: #800080;">2</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> (matrix[tmp][mid] == target) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (matrix[tmp][mid] &lt; target) left = mid + <span style="color: #800080;">1</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">else</span> right = mid - <span style="color: #800080;">1</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>当然这道题也可以使用一次二分查找法，如果我们按S型遍历该二维数组，可以得到一个有序的一维数组，那么我们只需要用一次二分查找法，而关键就在于坐标的转换，如何把二维坐标和一维坐标转换是关键点，把一个长度为n的一维数组转化为m*n的二维数组(m*n = n)后，那么原一维数组中下标为i的元素将出现在二维数组中的[i/n][i%n]的位置，有了这一点，代码很好写出来了：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> One binary search</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> searchMatrix(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt; &gt; &amp;matrix, <span style="color: #0000ff;">int</span><span style="color: #000000;"> target) {
        </span><span style="color: #0000ff;">if</span> (matrix.empty() || matrix[<span style="color: #800080;">0</span>].empty()) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (target &lt; matrix[<span style="color: #800080;">0</span>][<span style="color: #800080;">0</span>] || target &gt; matrix.back().back()) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> m = matrix.size(), n = matrix[<span style="color: #800080;">0</span><span style="color: #000000;">].size();
        </span><span style="color: #0000ff;">int</span> left = <span style="color: #800080;">0</span>, right = m * n - <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (left &lt;=<span style="color: #000000;"> right) {
            </span><span style="color: #0000ff;">int</span> mid = (left + right) / <span style="color: #800080;">2</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> (matrix[mid / n][mid % n] == target) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (matrix[mid / n][mid % n] &lt; target) left = mid + <span style="color: #800080;">1</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">else</span> right = mid - <span style="color: #800080;">1</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-03-09 12:53</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4323301" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4323301);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4341590.html" id="cb_post_title_url">[LeetCode] Set Matrix Zeroes 矩阵赋零</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a <em>m</em> x <em>n</em> matrix, if an element is 0, set its entire row and column to 0. Do it in place.</p>
<div class="spoilers">Follow up:
<p>Did you use extra space?<br/>A straight forward solution using O(<em>m</em><em>n</em>) space is probably a bad idea.<br/>A simple improvement uses O(<em>m</em> + <em>n</em>) space, but still not the best solution.<br/>Could you devise a constant space solution?</p>
</div>
<p> </p>
<p>据说这题是CareerCup上的原题，我还没有刷CareerCup，所以不知道啦，不过这题也不算难，虽然我也是看了网上的解法照着写的，但是下次遇到绝对想的起来。这道题中说的空间复杂度为O(mn)的解法自不用多说，直接新建一个和matrix等大小的矩阵，然后一行一行的扫，只要有0，就将新建的矩阵的对应行全赋0，行扫完再扫列，然后把更新完的矩阵赋给matrix即可，这个算法的空间复杂度太高。将其优化到O(m+n)的方法是，用一个长度为m的一维数组记录各行中是否有0，用一个长度为n的一维数组记录各列中是否有0，最后直接更新matrix数组即可。这道题的要求是用O(1)的空间，那么我们就不能新建数组，我们考虑就用原数组的第一行第一列来记录各行各列是否有0.</p>
<p>- 先扫描第一行第一列，如果有0，则将各自的flag设置为true<br/>- 然后扫描除去第一行第一列的整个数组，如果有0，则将对应的第一行和第一列的数字赋0<br/>- 再次遍历除去第一行第一列的整个数组，如果对应的第一行和第一列的数字有一个为0，则将当前值赋0<br/>- 最后根据第一行第一列的flag来更新第一行第一列</p>
<p>代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">void</span> setZeroes(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt; &gt; &amp;<span style="color: #000000;">matrix) {
        </span><span style="color: #0000ff;">if</span> (matrix.empty() || matrix[<span style="color: #800080;">0</span>].empty()) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> m = matrix.size(), n = matrix[<span style="color: #800080;">0</span><span style="color: #000000;">].size();
        </span><span style="color: #0000ff;">bool</span> rowZero = <span style="color: #0000ff;">false</span>, colZero = <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; m; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (matrix[i][<span style="color: #800080;">0</span>] == <span style="color: #800080;">0</span>) colZero = <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (matrix[<span style="color: #800080;">0</span>][i] == <span style="color: #800080;">0</span>) rowZero = <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        } 
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt; m; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">1</span>; j &lt; n; ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> (matrix[i][j] == <span style="color: #800080;">0</span><span style="color: #000000;">) {
                    matrix[</span><span style="color: #800080;">0</span>][j] = <span style="color: #800080;">0</span><span style="color: #000000;">;
                    matrix[i][</span><span style="color: #800080;">0</span>] = <span style="color: #800080;">0</span><span style="color: #000000;">;
                }
            }
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt; m; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">1</span>; j &lt; n; ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> (matrix[<span style="color: #800080;">0</span>][j] == <span style="color: #800080;">0</span> || matrix[i][<span style="color: #800080;">0</span>] == <span style="color: #800080;">0</span><span style="color: #000000;">) {
                    matrix[i][j] </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
                }
            }
        }
        </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (rowZero) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++i) matrix[<span style="color: #800080;">0</span>][i] = <span style="color: #800080;">0</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (colZero) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; m; ++i) matrix[i][<span style="color: #800080;">0</span>] = <span style="color: #800080;">0</span><span style="color: #000000;">;
        }
    }
};</span></pre>
</div>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-03-16 13:18</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4341590" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4341590);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4344107.html" id="cb_post_title_url">[LeetCode] Edit Distance 编辑距离</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given two words <em>word1</em> and <em>word2</em>, find the minimum number of steps required to convert <em>word1</em> to <em>word2</em>. (each operation is counted as 1 step.)</p>
<p>You have the following 3 operations permitted on a word:</p>
<p>a) Insert a character<br/>b) Delete a character<br/>c) Replace a character</p>
<p> </p>
<p>这道题让求从一个字符串转变到另一个字符串需要的变换步骤，共有三种变换方式，插入一个字符，删除一个字符，和替换一个字符。根据以往的经验，对于字符串相关的题目十有八九都是用动态规划Dynamic Programming来解，这道题也不例外。这道题我们需要维护一个二维的数组dp，其中dp[i][j]表示从word1的前i个字符转换到word2的前j个字符所需要的步骤。那我们可以先给这个二维数组dp的第一行第一列赋值，这个很简单，因为第一行和第一列对应的总有一个字符串是空串，于是转换步骤完全是另一个字符串的长度。跟以往的DP题目类似，难点还是在于找出递推式，我们可以举个例子来看，比如word1是“bbc"，word2是”abcd“，那么我们可以得到dp数组如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">  Ø a b c d
Ø </span><span style="color: #800080;">0</span> <span style="color: #800080;">1</span> <span style="color: #800080;">2</span> <span style="color: #800080;">3</span> <span style="color: #800080;">4</span><span style="color: #000000;">
b </span><span style="color: #800080;">1</span> <span style="color: #800080;">1</span> <span style="color: #ff0000;">1</span> <span style="color: #800080;">2</span> <span style="color: #800080;">3</span><span style="color: #000000;">
b </span><span style="color: #800080;">2</span> <span style="color: #800080;">2</span> <span style="color: #ff0000;">1</span> <span style="color: #800080;">2</span> <span style="color: #800080;">3</span><span style="color: #000000;">
c </span><span style="color: #800080;">3</span> <span style="color: #800080;">3</span> <span style="color: #800080;">2</span> <span style="color: #ff0000;">1</span> <span style="color: #800080;">2</span></pre>
</div>
<p> </p>
<p>我们通过观察可以发现，当word1[i] == word2[j]时，dp[i][j] = dp[i - 1][j - 1]，其他情况时，dp[i][j]是其左，左上，上的三个值中的最小值加1，那么可以得到递推式为：</p>
<p>dp[i][j] =      /    dp[i - 1][j - 1]                                                                   if word1[i - 1] == word2[j - 1]</p>
<p>                  \    min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1])) + 1            else</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> minDistance(<span style="color: #0000ff;">string</span> word1, <span style="color: #0000ff;">string</span><span style="color: #000000;"> word2) {
        </span><span style="color: #0000ff;">int</span> n1 = word1.size(), n2 =<span style="color: #000000;"> word2.size();
        </span><span style="color: #0000ff;">int</span> dp[n1 + <span style="color: #800080;">1</span>][n2 + <span style="color: #800080;">1</span><span style="color: #000000;">];
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt;= n1; ++i) dp[i][<span style="color: #800080;">0</span>] =<span style="color: #000000;"> i;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt;= n2; ++i) dp[<span style="color: #800080;">0</span>][i] =<span style="color: #000000;"> i;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt;= n1; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">1</span>; j &lt;= n2; ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> (word1[i - <span style="color: #800080;">1</span>] == word2[j - <span style="color: #800080;">1</span><span style="color: #000000;">]) {
                    dp[i][j] </span>= dp[i - <span style="color: #800080;">1</span>][j - <span style="color: #800080;">1</span><span style="color: #000000;">];
                } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    dp[i][j] </span>= min(dp[i - <span style="color: #800080;">1</span>][j - <span style="color: #800080;">1</span>], min(dp[i - <span style="color: #800080;">1</span>][j], dp[i][j - <span style="color: #800080;">1</span>])) + <span style="color: #800080;">1</span><span style="color: #000000;">;
                }
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> dp[n1][n2];
    }
};</span></pre>
</div>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-03-17 13:00</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4344107" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4344107);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4347125.html" id="cb_post_title_url">[LeetCode] Simplify Path 简化路径</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given an absolute path for a file (Unix-style), simplify it.</p>
<p>For example,<br/>path = <code>"/home/"</code>, =&gt; <code>"/home"</code><br/>path = <code>"/a/./b/../../c/"</code>, =&gt; <code>"/c"</code></p>
<div class="spoilers">Corner Cases:
<p> </p>
<ul>
<li>Did you consider the case where path = <code>"/../"</code>?<br/>In this case, you should return <code>"/"</code>.</li>
<li>Another corner case is the path might contain multiple slashes <code>'/'</code> together, such as <code>"/home//foo/"</code>.<br/>In this case, you should ignore redundant slashes and return <code>"/home/foo"</code>.</li>
</ul>
</div>
<p> </p>
<p>这道题让简化给定的路径，光根据题目中给的那一个例子还真不太好总结出规律，应该再加上两个例子 path = <code>"/a/./b/../c/"</code>, =&gt; <code>"/a/c"和path = <code>"/a/./b/c/"</code>, =&gt; <code>"/a/b/c"，</code> 这样我们就可以知道中间是"."的情况直接去掉，是".."时删掉它上面挨着的一个路径，而下面的边界条件给的一些情况中可以得知，如果是空的话返回"/"，如果有多个"/"只保留一个。那么我们可以把路径看做是由一个或多个"/"分割开的众多子字符串，把它们分别提取出来一一处理即可，代码如下：</code></p>
<p> </p>
<p>C++ 解法一:</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> simplifyPath(<span style="color: #0000ff;">string</span><span style="color: #000000;"> path) {
        vector</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> v;
        </span><span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (i &lt;<span style="color: #000000;"> path.size()) {
            </span><span style="color: #0000ff;">while</span> (path[i] == <span style="color: #800000;">'</span><span style="color: #800000;">/</span><span style="color: #800000;">'</span> &amp;&amp; i &lt; path.size()) ++<span style="color: #000000;">i;
            </span><span style="color: #0000ff;">if</span> (i == path.size()) <span style="color: #0000ff;">break</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">int</span> start =<span style="color: #000000;"> i;
            </span><span style="color: #0000ff;">while</span> (path[i] != <span style="color: #800000;">'</span><span style="color: #800000;">/</span><span style="color: #800000;">'</span> &amp;&amp; i &lt; path.size()) ++<span style="color: #000000;">i;
            </span><span style="color: #0000ff;">int</span> end = i - <span style="color: #800080;">1</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">string</span> s = path.substr(start, end - start + <span style="color: #800080;">1</span><span style="color: #000000;">);
            </span><span style="color: #0000ff;">if</span> (s == <span style="color: #800000;">"</span><span style="color: #800000;">..</span><span style="color: #800000;">"</span><span style="color: #000000;">) {
                </span><span style="color: #0000ff;">if</span> (!<span style="color: #000000;">v.empty()) v.pop_back(); 
            } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (s != <span style="color: #800000;">"</span><span style="color: #800000;">.</span><span style="color: #800000;">"</span><span style="color: #000000;">) {
                v.push_back(s);
            }
        }
        </span><span style="color: #0000ff;">if</span> (v.empty()) <span style="color: #0000ff;">return</span> <span style="color: #800000;">"</span><span style="color: #800000;">/</span><span style="color: #800000;">"</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">string</span><span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; v.size(); ++<span style="color: #000000;">i) {
            res </span>+= <span style="color: #800000;">'</span><span style="color: #800000;">/</span><span style="color: #800000;">'</span> +<span style="color: #000000;"> v[i];
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>还有一种解法是利用了C语言中的函数strtok来分隔字符串，但是需要把string和char*类型相互转换，转换方法请猛戳<a href="http://www.cnblogs.com/grandyang/p/4312273.html" target="_blank">这里</a>。除了这块不同，其余的思想和上面那种解法相同，代码如下：</p>
<p> </p>
<p>C 解法一:</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> simplifyPath(<span style="color: #0000ff;">string</span><span style="color: #000000;"> path) {
        vector</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> v;
        </span><span style="color: #0000ff;">char</span> *cstr = <span style="color: #0000ff;">new</span> <span style="color: #0000ff;">char</span>[path.length() + <span style="color: #800080;">1</span><span style="color: #000000;">];
        strcpy(cstr, path.c_str());
        </span><span style="color: #0000ff;">char</span> *pch = strtok(cstr, <span style="color: #800000;">"</span><span style="color: #800000;">/</span><span style="color: #800000;">"</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">while</span> (pch !=<span style="color: #000000;"> NULL) {
            </span><span style="color: #0000ff;">string</span> p = <span style="color: #0000ff;">string</span><span style="color: #000000;">(pch);
            </span><span style="color: #0000ff;">if</span> (p == <span style="color: #800000;">"</span><span style="color: #800000;">..</span><span style="color: #800000;">"</span><span style="color: #000000;">) {
                </span><span style="color: #0000ff;">if</span> (!<span style="color: #000000;">v.empty()) v.pop_back();
            } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (p != <span style="color: #800000;">"</span><span style="color: #800000;">.</span><span style="color: #800000;">"</span><span style="color: #000000;">) {
                v.push_back(p);
            }
            pch </span>= strtok(NULL, <span style="color: #800000;">"</span><span style="color: #800000;">/</span><span style="color: #800000;">"</span><span style="color: #000000;">);
        }
        </span><span style="color: #0000ff;">if</span> (v.empty()) <span style="color: #0000ff;">return</span> <span style="color: #800000;">"</span><span style="color: #800000;">/</span><span style="color: #800000;">"</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">string</span><span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; v.size(); ++<span style="color: #000000;">i) {
            res </span>+= <span style="color: #800000;">'</span><span style="color: #800000;">/</span><span style="color: #800000;">'</span> +<span style="color: #000000;"> v[i];
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>C++中也有专门处理字符串的机制，我们可以使用stringstream来分隔字符串，然后对每一段分别处理，思路和上面的方法相似，参见代码如下：</p>
<p> </p>
<p>C++ 解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> simplifyPath(<span style="color: #0000ff;">string</span><span style="color: #000000;"> path) {
        </span><span style="color: #0000ff;">string</span><span style="color: #000000;"> res, t;
        stringstream ss(path);
        vector</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> v;
        </span><span style="color: #0000ff;">while</span> (getline(ss, t, <span style="color: #800000;">'</span><span style="color: #800000;">/</span><span style="color: #800000;">'</span><span style="color: #000000;">)) {
            </span><span style="color: #0000ff;">if</span> (t == <span style="color: #800000;">""</span> || t == <span style="color: #800000;">"</span><span style="color: #800000;">.</span><span style="color: #800000;">"</span>) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> (t == <span style="color: #800000;">"</span><span style="color: #800000;">..</span><span style="color: #800000;">"</span> &amp;&amp; !<span style="color: #000000;">v.empty()) v.pop_back();
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (t != <span style="color: #800000;">"</span><span style="color: #800000;">..</span><span style="color: #800000;">"</span><span style="color: #000000;">) v.push_back(t);
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">string</span> s : v) res += <span style="color: #800000;">"</span><span style="color: #800000;">/</span><span style="color: #800000;">"</span> +<span style="color: #000000;"> s;
        </span><span style="color: #0000ff;">return</span> res.empty() ? <span style="color: #800000;">"</span><span style="color: #800000;">/</span><span style="color: #800000;">"</span><span style="color: #000000;"> : res;
    }
};</span></pre>
</div>
<p> </p>
<p>Java 解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> String simplifyPath(String path) {
        Stack</span>&lt;String&gt; s = <span style="color: #0000ff;">new</span> Stack&lt;&gt;<span style="color: #000000;">();
        String[] p </span>= path.split("/"<span style="color: #000000;">);
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (String t : p) {
            </span><span style="color: #0000ff;">if</span> (!s.isEmpty() &amp;&amp; t.equals(".."<span style="color: #000000;">)) {
                s.pop();
            } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (!t.equals(".") &amp;&amp; !t.equals("") &amp;&amp; !t.equals(".."<span style="color: #000000;">)) {
                s.push(t);
            }
        }
        List</span>&lt;String&gt; list = <span style="color: #0000ff;">new</span><span style="color: #000000;"> ArrayList(s);
        </span><span style="color: #0000ff;">return</span> "/" + String.join("/"<span style="color: #000000;">, list);
    }
}</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/8678/c-10-lines-solution" target="_blank">https://discuss.leetcode.com/topic/8678/c-10-lines-solution</a></p>
<p><a href="https://discuss.leetcode.com/topic/7675/java-10-lines-solution-with-stack" target="_blank">https://discuss.leetcode.com/topic/7675/java-10-lines-solution-with-stack</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-03-18 14:39</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4347125" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4347125);return false;">收藏</a></div>
</div>None<div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4346413.html" id="cb_post_title_url">[LeetCode] Sqrt(x) 求平方根</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Implement <code>int sqrt(int x)</code>.</p>
<p>Compute and return the square root of <em>x</em>.</p>
<p> </p>
<p>这道题要求我们求平方根，我们能想到的方法就是算一个候选值的平方，然后和x比较大小，为了缩短查找时间，我们采用二分搜索法来找平方根，这里属于博主之前总结的<a class="entrylistItemTitle" href="http://www.cnblogs.com/grandyang/p/6854825.html" id="CategoryEntryList1_EntryStoryList_ctl00_Entries_TitleUrl_1">LeetCode Binary Search Summary 二分搜索法小结</a>中的第三类的变形，找最后一个不大于目标值的数，代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> mySqrt(<span style="color: #0000ff;">int</span><span style="color: #000000;"> x) {
        </span><span style="color: #0000ff;">if</span> (x &lt;= <span style="color: #800080;">1</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;"> x;
        </span><span style="color: #0000ff;">int</span> left = <span style="color: #800080;">0</span>, right =<span style="color: #000000;"> x;
        </span><span style="color: #0000ff;">while</span> (left &lt;<span style="color: #000000;"> right) {
            </span><span style="color: #0000ff;">int</span> mid = left + (right - left) / <span style="color: #800080;">2</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> (x / mid &gt;= mid) left = mid + <span style="color: #800080;">1</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">else</span> right =<span style="color: #000000;"> mid;
        }
        </span><span style="color: #0000ff;">return</span> right - <span style="color: #800080;">1</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>这道题还有另一种解法，是利用<a href="http://zh.wikipedia.org/wiki/%E7%89%9B%E9%A1%BF%E6%B3%95" target="_blank">牛顿迭代法</a>，记得高数中好像讲到过这个方法，是用逼近法求方程根的神器，在这里也可以借用一下，可参见网友<a href="http://www.cnblogs.com/AnnieKim/archive/2013/04/18/3028607.html" target="_blank">Annie Kim's Blog的博客</a>，因为要求x<sup>2</sup> = n的解，令f(x)=x<sup>2</sup>-n，相当于求解f(x)=0的解，可以求出递推式如下：</p>
<p>x<sub>i+1</sub>=x<sub>i</sub> - (x<sub>i<sup>2 </sup></sub>- n) / (2x<sub>i</sub>) = x<sub>i</sub> - x<sub>i</sub> / 2 + n / (2x<sub>i</sub>) = x<sub>i</sub> / 2 + n / 2x<sub>i</sub> = (x<sub>i</sub> + n/x<sub>i</sub>) / 2</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> mySqrt(<span style="color: #0000ff;">int</span><span style="color: #000000;"> x) {
        </span><span style="color: #0000ff;">if</span> (x == <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">double</span> res = <span style="color: #800080;">1</span>, pre = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (abs(res - pre) &gt; 1e-<span style="color: #800080;">6</span><span style="color: #000000;">) {
            pre </span>=<span style="color: #000000;"> res;
            res </span>= (res + x / res) / <span style="color: #800080;">2</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">int</span><span style="color: #000000;">(res);
    }
};</span></pre>
</div>
<p> </p>
<p>也是牛顿迭代法，写法更加简洁一些，注意为了防止越界，声明为长整型，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> mySqrt(<span style="color: #0000ff;">int</span><span style="color: #000000;"> x) {
        </span><span style="color: #0000ff;">long</span> res =<span style="color: #000000;"> x;
        </span><span style="color: #0000ff;">while</span> (res * res &gt;<span style="color: #000000;"> x) {
            res </span>= (res + x / res) / <span style="color: #800080;">2</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4383775.html" target="_blank">Pow(x, n)</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/5619296.html">Valid Perfect Square</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-03-18 10:10</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4346413" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4346413);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4350381.html" id="cb_post_title_url">[LeetCode] Text Justification 文本左右对齐</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given an array of words and a length <em>L</em>, format the text such that each line has exactly <em>L</em> characters and is fully (left and right) justified.</p>
<p>You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces <code>' '</code> when necessary so that each line has exactly <em>L</em>characters.</p>
<p>Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.</p>
<p>For the last line of text, it should be left justified and no extra space is inserted between words.</p>
<p>For example,<br/>words: <code>["This", "is", "an", "example", "of", "text", "justification."]</code><br/>L: <code>16</code>.</p>
<p>Return the formatted lines as:</p>
<pre>[
   "This    is    an",
   "example  of text",
   "justification.  "
]
</pre>
<p> </p>
<p>Note: Each word is guaranteed not to exceed <em>L</em> in length.</p>
<div class="spoilers">Corner Cases:
<p> </p>
<ul>
<li>A line other than the last line might contain only one word. What should you do in this case?<br/>In this case, that line should be left-justified.</li>
</ul>
</div>
<p> </p>
<p>我将这道题翻译为文本的左右对齐是因为这道题像极了word软件里面的文本左右对齐功能，这道题我前前后后折腾了快四个小时终于通过了OJ，完成了之后想着去网上搜搜看有没有更简单的方法，搜了一圈发现都差不多，都挺复杂的，于是乎就按自己的思路来说吧，由于返回的结果是多行的，所以我们在处理的时候也要一行一行的来处理，首先要做的就是确定每一行能放下的单词数，这个不难，就是比较n个单词的长度和加上n - 1个空格的长度跟给定的长度L来比较即可，找到了一行能放下的单词个数，然后计算出这一行存在的空格的个数，是用给定的长度L减去这一行所有单词的长度和。得到了空格的个数之后，就要在每个单词后面插入这些空格，这里有两种情况，比如某一行有两个单词"to" 和 "a"，给定长度L为6，如果这行不是最后一行，那么应该输出"to   a"，如果是最后一行，则应该输出 "to a  "，所以这里需要分情况讨论，最后一行的处理方法和其他行之间略有不同。最后一个难点就是，如果一行有三个单词，这时候中间有两个空，如果空格数不是2的倍数，那么左边的空间里要比右边的空间里多加入一个空格，那么我们只需要用总的空格数除以空间个数，能除尽最好，说明能平均分配，除不尽的话就多加个空格放在左边的空间里，以此类推，具体实现过程还是看代码吧：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; fullJustify(vector&lt;<span style="color: #0000ff;">string</span>&gt; &amp;words, <span style="color: #0000ff;">int</span><span style="color: #000000;"> L) {
        vector</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (i &lt;<span style="color: #000000;"> words.size()) {
            </span><span style="color: #0000ff;">int</span> j = i, len = <span style="color: #800080;">0</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">while</span> (j &lt; words.size() &amp;&amp; len + words[j].size() + j - i &lt;=<span style="color: #000000;"> L) {
                len </span>+= words[j++<span style="color: #000000;">].size();
            }
            </span><span style="color: #0000ff;">string</span> <span style="color: #0000ff;">out</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">int</span> space = L -<span style="color: #000000;"> len;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> k = i; k &lt; j; ++<span style="color: #000000;">k) {
                </span><span style="color: #0000ff;">out</span> +=<span style="color: #000000;"> words[k];
                </span><span style="color: #0000ff;">if</span> (space &gt; <span style="color: #800080;">0</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> tmp;
                    </span><span style="color: #0000ff;">if</span> (j ==<span style="color: #000000;"> words.size()) { 
                        </span><span style="color: #0000ff;">if</span> (j - k == <span style="color: #800080;">1</span>) tmp =<span style="color: #000000;"> space;
                        </span><span style="color: #0000ff;">else</span> tmp = <span style="color: #800080;">1</span><span style="color: #000000;">;
                    } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                        </span><span style="color: #0000ff;">if</span> (j - k - <span style="color: #800080;">1</span> &gt; <span style="color: #800080;">0</span><span style="color: #000000;">) {
                            </span><span style="color: #0000ff;">if</span> (space % (j - k - <span style="color: #800080;">1</span>) == <span style="color: #800080;">0</span>) tmp = space / (j - k - <span style="color: #800080;">1</span><span style="color: #000000;">);
                            </span><span style="color: #0000ff;">else</span> tmp = space / (j - k - <span style="color: #800080;">1</span>) + <span style="color: #800080;">1</span><span style="color: #000000;">;
                        } </span><span style="color: #0000ff;">else</span> tmp =<span style="color: #000000;"> space;
                    }
                    </span><span style="color: #0000ff;">out</span>.append(tmp, <span style="color: #800000;">'</span> <span style="color: #800000;">'</span><span style="color: #000000;">);
                    space </span>-=<span style="color: #000000;"> tmp;
                }
            }
            res.push_back(</span><span style="color: #0000ff;">out</span><span style="color: #000000;">);
            i </span>=<span style="color: #000000;"> j;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-03-19 14:39</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4350381" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4350381);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4084971.html" id="cb_post_title_url">[LeetCode] Add Binary 二进制数相加</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p>Given two binary strings, return their sum (also a binary string).</p>
<p>For example,<br/>a = <code>"11"</code><br/>b = <code>"1"</code><br/>Return <code>"100"</code>.</p>
<p> </p>
<p>二进制数相加，并且保存在string中，要注意的是如何将string和int之间互相转换，并且每位相加时，会有进位的可能，会影响之后相加的结果。而且两个输入string的长度也可能会不同。这时我们需要新建一个string，它的长度是两条输入string中的较大的那个，并且把较短的那个输入string通过在开头加字符‘0’来补的较大的那个长度。这时候我们逐个从两个string的末尾开始取出字符，然后转为数字，想加，如果大于等于2，则标记进位标志carry，并且给新string加入一个字符‘0’。代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> addBinary(<span style="color: #0000ff;">string</span> a, <span style="color: #0000ff;">string</span><span style="color: #000000;"> b) {
        </span><span style="color: #0000ff;">string</span><span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">int</span> na =<span style="color: #000000;"> a.size();
        </span><span style="color: #0000ff;">int</span> nb =<span style="color: #000000;"> b.size();
        </span><span style="color: #0000ff;">int</span> n =<span style="color: #000000;"> max(na, nb);
        </span><span style="color: #0000ff;">bool</span> carry = <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (na &gt;<span style="color: #000000;"> nb) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; na - nb; ++i) b.insert(b.begin(), <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span><span style="color: #000000;">);
        }
        </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (na &lt;<span style="color: #000000;"> nb) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; nb - na; ++i) a.insert(a.begin(), <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span><span style="color: #000000;">);
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = n - <span style="color: #800080;">1</span>; i &gt;= <span style="color: #800080;">0</span>; --<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">int</span> tmp = <span style="color: #800080;">0</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> (carry) tmp = (a[i] - <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span>) + (b[i] - <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span>) + <span style="color: #800080;">1</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">else</span> tmp = (a[i] - <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span>) + (b[i] - <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span><span style="color: #000000;">);
            </span><span style="color: #0000ff;">if</span> (tmp == <span style="color: #800080;">0</span><span style="color: #000000;">) {
                res.insert(res.begin(), </span><span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span><span style="color: #000000;">);
                carry </span>= <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            }
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (tmp == <span style="color: #800080;">1</span><span style="color: #000000;">) {
                res.insert(res.begin(), </span><span style="color: #800000;">'</span><span style="color: #800000;">1</span><span style="color: #800000;">'</span><span style="color: #000000;">);
                carry </span>= <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            }
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (tmp == <span style="color: #800080;">2</span><span style="color: #000000;">) {
                res.insert(res.begin(), </span><span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span><span style="color: #000000;">);
                carry </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
            }
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (tmp == <span style="color: #800080;">3</span><span style="color: #000000;">) {
                res.insert(res.begin(), </span><span style="color: #800000;">'</span><span style="color: #800000;">1</span><span style="color: #800000;">'</span><span style="color: #000000;">);
                carry </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
            }
        }
        </span><span style="color: #0000ff;">if</span> (carry) res.insert(res.begin(), <span style="color: #800000;">'</span><span style="color: #800000;">1</span><span style="color: #800000;">'</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种写法又巧妙又简洁，用了两个指针分别指向a和b的末尾，然后每次取出一个字符，转为数字，若无法取出字符则按0处理，然后定义进位carry，初始化为0，将三者加起来，对2取余即为当前位的数字，对2取商即为当前进位的值，记得最后还要判断下carry，如果为1的话，要在结果最前面加上一个1，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> addBinary(<span style="color: #0000ff;">string</span> a, <span style="color: #0000ff;">string</span><span style="color: #000000;"> b) {
        </span><span style="color: #0000ff;">string</span> res = <span style="color: #800000;">""</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> m = a.size() - <span style="color: #800080;">1</span>, n = b.size() - <span style="color: #800080;">1</span>, carry = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (m &gt;= <span style="color: #800080;">0</span> || n &gt;= <span style="color: #800080;">0</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">int</span> p = m &gt;= <span style="color: #800080;">0</span> ? a[m--] - <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span> : <span style="color: #800080;">0</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">int</span> q = n &gt;= <span style="color: #800080;">0</span> ? b[n--] - <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span> : <span style="color: #800080;">0</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">int</span> sum = p + q +<span style="color: #000000;"> carry;
            res </span>= to_string(sum % <span style="color: #800080;">2</span>) +<span style="color: #000000;"> res;
            carry </span>= sum / <span style="color: #800080;">2</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> carry == <span style="color: #800080;">1</span> ? <span style="color: #800000;">"</span><span style="color: #800000;">1</span><span style="color: #800000;">"</span> +<span style="color: #000000;"> res : res;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/8981/short-code-by-c" target="_blank">https://discuss.leetcode.com/topic/8981/short-code-by-c</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2014-11-09 12:59</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4084971" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4084971);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4079357.html" id="cb_post_title_url">[LeetCode] Plus One 加一运算</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p>Given a non-negative number represented as an array of digits, plus one to the number.</p>
<p>The digits are stored such that the most significant digit is at the head of the list.</p>
<p> </p>
<p>将一个数字的每个位上的数字分别存到一个一维向量中，最高位在最开头，我们需要给这个数字加一，即在末尾数字加一，如果末尾数字是9，那么则会有进位问题，而如果前面位上的数字仍为9，则需要继续向前进位。具体算法如下：首先判断最后一位是否为9，若不是，直接加一返回，若是，则该位赋0，再继续查前一位，同样的方法，知道查完第一位。如果第一位原本为9，加一后会产生新的一位，那么最后要做的是，查运算完的第一位是否为0，如果是，则在最前头加一个1。代码如下：</p>
<p> </p>
<p>C++ 解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; plusOne(vector&lt;<span style="color: #0000ff;">int</span>&gt; &amp;<span style="color: #000000;">digits) {
        </span><span style="color: #0000ff;">int</span> n =<span style="color: #000000;"> digits.size();
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = n - <span style="color: #800080;">1</span>; i &gt;= <span style="color: #800080;">0</span>; --<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (digits[i] == <span style="color: #800080;">9</span>) digits[i] = <span style="color: #800080;">0</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                digits[i] </span>+= <span style="color: #800080;">1</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> digits;
            }
        }
        </span><span style="color: #0000ff;">if</span> (digits.front() == <span style="color: #800080;">0</span>) digits.insert(digits.begin(), <span style="color: #800080;">1</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> digits;
    }
};</span></pre>
</div>
<p> </p>
<p>Java 解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span>[] plusOne(<span style="color: #0000ff;">int</span><span style="color: #000000;">[] digits) {
        </span><span style="color: #0000ff;">int</span> n =<span style="color: #000000;"> digits.length;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = digits.length - 1; i &gt;= 0; --<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (digits[i] &lt; 9<span style="color: #000000;">) {
                </span>++<span style="color: #000000;">digits[i];
                </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> digits;
            }
            digits[i] </span>= 0<span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">int</span>[] res = <span style="color: #0000ff;">new</span> <span style="color: #0000ff;">int</span>[n + 1<span style="color: #000000;">];
        res[</span>0] = 1<span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
}</span></pre>
</div>
<p> </p>
<p>我们也可以使用跟之前那道<a href="http://www.cnblogs.com/grandyang/p/4084971.html" target="_blank">Add Binary</a>类似的做法，我们将carry初始化为1，然后相当于digits加了一个0，处理方法跟之前那道题一样，参见代码如下：</p>
<p> </p>
<p>C++ 解法二 ：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; plusOne(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> digits) {
        </span><span style="color: #0000ff;">if</span> (digits.empty()) <span style="color: #0000ff;">return</span><span style="color: #000000;"> digits;
        </span><span style="color: #0000ff;">int</span> carry = <span style="color: #800080;">1</span>, n =<span style="color: #000000;"> digits.size();
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = n - <span style="color: #800080;">1</span>; i &gt;= <span style="color: #800080;">0</span>; --<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (carry == <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;"> digits;
            </span><span style="color: #0000ff;">int</span> sum = digits[i] +<span style="color: #000000;"> carry;
            digits[i] </span>= sum % <span style="color: #800080;">10</span><span style="color: #000000;">;
            carry </span>= sum / <span style="color: #800080;">10</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">if</span> (carry == <span style="color: #800080;">1</span>) digits.insert(digits.begin(), <span style="color: #800080;">1</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> digits;
    }
};</span></pre>
</div>
<p> </p>
<p>Java 解法二 ：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span>[] plusOne(<span style="color: #0000ff;">int</span><span style="color: #000000;">[] digits) {
        </span><span style="color: #0000ff;">if</span> (digits.length == 0) <span style="color: #0000ff;">return</span><span style="color: #000000;"> digits;
        </span><span style="color: #0000ff;">int</span> carry = 1, n =<span style="color: #000000;"> digits.length;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = digits.length - 1; i &gt;= 0; --<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (carry == 0) <span style="color: #0000ff;">return</span><span style="color: #000000;"> digits;
            </span><span style="color: #0000ff;">int</span> sum = digits[i] +<span style="color: #000000;"> carry;
            digits[i] </span>= sum % 10<span style="color: #000000;">;
            carry </span>= sum / 10<span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">int</span>[] res = <span style="color: #0000ff;">new</span> <span style="color: #0000ff;">int</span>[n + 1<span style="color: #000000;">];
        res[</span>0] = 1<span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span> carry == 0 ?<span style="color: #000000;"> digits : res;
    }
}</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4084971.html" target="_blank">Add Binary</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/24288/my-simple-java-solution" target="_blank">https://discuss.leetcode.com/topic/24288/my-simple-java-solution</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2014-11-06 17:01</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4079357" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4079357);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4084408.html" id="cb_post_title_url">[LeetCode] Valid Number 验证数字</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p>Validate if a given string is numeric.</p>
<p>Some examples:<br/><code>"0"</code> =&gt; <code>true</code><br/><code>" 0.1 "</code> =&gt; <code>true</code><br/><code>"abc"</code> =&gt; <code>false</code><br/><code>"1 a"</code> =&gt; <code>false</code><br/><code>"2e10"</code> =&gt; <code>true</code></p>
<p>Note: It is intended for the problem statement to be ambiguous. You should gather all requirements up front before implementing one.</p>
<p> </p>
<p>这道验证数字的题比想象中的要复杂的多，有很多情况需要考虑，而OJ上给这道题的分类居然是Easy，Why? 而10.9% 的全场最低的Accept Rate正说明这道题的难度，网上有很多解法，有利用有限自动机Finite Automata Machine的程序写的简洁优雅 (<a href="http://blog.csdn.net/kenden23/article/details/18696083" target="_blank">http://blog.csdn.net/kenden23/article/details/18696083</a>), 还有利用正则表达式，更是写的丧心病狂的简洁 (<a href="http://blog.csdn.net/fightforyourdream/article/details/12900751" target="_blank">http://blog.csdn.net/fightforyourdream/article/details/12900751</a>)。而我主要还是用最一般的写法，参考了网上另一篇博文 (<a href="http://yucoding.blogspot.com/2013/05/leetcode-question-118-valid-number.html" target="_blank">http://yucoding.blogspot.com/2013/05/leetcode-question-118-valid-number.html</a>)，处理各种情况。</p>
<p> </p>
<p>首先，从题目中给的一些例子可以分析出来，我们所需要关注的除了数字以外的特殊字符有空格 ‘ ’， 小数点 '.', 自然数 'e/E', 还要加上正负号 '+/-"， 除了这些字符需要考虑意外，出现了任何其他的字符，可以马上判定不是数字。下面我们来一一分析这些出现了也可能是数字的特殊字符：</p>
<p>1. 空格 ‘ ’： 空格分为两种情况需要考虑，一种是出现在开头和末尾的空格，一种是出现在中间的字符。出现在开头和末尾的空格不影响数字，而一旦中间出现了空格，则立马不是数字。解决方法：预处理时去掉字符的首位空格，中间再检测到空格，则判定不是数字。</p>
<p>2. 小数点 '.'：小数点需要分的情况较多，首先的是小数点只能出现一次，但是小数点可以出现在任何位置，开头(".3"), 中间("1.e2"), 以及结尾("1." ), 而且需要注意的是，小数点不能出现在自然数 'e/E' 之后，如 "1e.1" false, "1e1.1" false。还有，当小数点位于末尾时，前面必须是数字，如 "1."  true，" -." false。解决方法：开头中间结尾三个位置分开讨论情况。</p>
<p>3. 自然数 'e/E'：自然数的前后必须有数字，即自然数不能出现在开头和结尾，如 "e" false,  ".e1" false, "3.e" false, "3.e1" true。而且小数点只能出现在自然数之前，还有就是自然数前面不能是符号，如 "+e1" false, "1+e" false. 解决方法：开头中间结尾三个位置分开讨论情况。</p>
<p>4. 正负号 '+/-"，正负号可以再开头出现，可以再自然数e之后出现，但不能是最后一个字符，后面得有数字，如  "+1.e+5" true。解决方法：开头中间结尾三个位置分开讨论情况。</p>
<p> </p>
<p>下面我们开始正式分开头中间结尾三个位置来讨论情况：</p>
<p>1. 在讨论三个位置之前做预处理，去掉字符串首尾的空格，可以采用两个指针分别指向开头和结尾，遇到空格则跳过，分别指向开头结尾非空格的字符。</p>
<p>2. 对首字符处理，首字符只能为数字或者正负号 '+/-"，我们需要定义三个flag在标示我们是否之前检测到过小数点，自然数和正负号。首字符如为数字或正负号，则标记对应的flag，若不是，直接返回false。</p>
<p>3. 对中间字符的处理，中间字符会出现五种情况，数字，小数点，自然数，正负号和其他字符。</p>
<p>若是数字，标记flag并通过。</p>
<p>若是自然数，则必须是第一次出现自然数，并且前一个字符不能是正负号，而且之前一定要出现过数字，才能标记flag通过。</p>
<p>若是正负号，则之前的字符必须是自然数e，才能标记flag通过。</p>
<p>若是小数点，则必须是第一次出现小数点并且自然数没有出现过，才能标记flag通过。</p>
<p>若是其他，返回false。</p>
<p>4. 对尾字符处理，最后一个字符只能是数字或小数点，其他字符都返回false。</p>
<p>若是数字，返回true。</p>
<p>若是小数点，则必须是第一次出现小数点并且自然数没有出现过，还有前面必须是数字，才能返回true。</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> isNumber(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        </span><span style="color: #0000ff;">int</span> len =<span style="color: #000000;"> s.size();
        </span><span style="color: #0000ff;">int</span> left = <span style="color: #800080;">0</span>, right = len - <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">bool</span> eExisted = <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">bool</span> dotExisted = <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">bool</span> digitExisited = <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> Delete spaces in the front and end of string</span>
        <span style="color: #0000ff;">while</span> (s[left] == <span style="color: #800000;">'</span> <span style="color: #800000;">'</span>) ++<span style="color: #000000;">left;
        </span><span style="color: #0000ff;">while</span> (s[right] == <span style="color: #800000;">'</span> <span style="color: #800000;">'</span>) --<span style="color: #000000;">right;
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> If only have one char and not digit, return false</span>
        <span style="color: #0000ff;">if</span> (left &gt;= right &amp;&amp; (s[left] &lt; <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span> || s[left] &gt; <span style="color: #800000;">'</span><span style="color: #800000;">9</span><span style="color: #800000;">'</span>)) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        </span><span style="color: #008000;">//</span><span style="color: #008000;">Process the first char</span>
        <span style="color: #0000ff;">if</span> (s[left] == <span style="color: #800000;">'</span><span style="color: #800000;">.</span><span style="color: #800000;">'</span>) dotExisted = <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (s[left] &gt;= <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span> &amp;&amp; s[left] &lt;= <span style="color: #800000;">'</span><span style="color: #800000;">9</span><span style="color: #800000;">'</span>) digitExisited = <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (s[left] != <span style="color: #800000;">'</span><span style="color: #800000;">+</span><span style="color: #800000;">'</span> &amp;&amp; s[left] != <span style="color: #800000;">'</span><span style="color: #800000;">-</span><span style="color: #800000;">'</span>) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> Process the middle chars</span>
        <span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = left + <span style="color: #800080;">1</span>; i &lt;= right - <span style="color: #800080;">1</span>; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (s[i] &gt;= <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span> &amp;&amp; s[i] &lt;= <span style="color: #800000;">'</span><span style="color: #800000;">9</span><span style="color: #800000;">'</span>) digitExisited = <span style="color: #0000ff;">true</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (s[i] == <span style="color: #800000;">'</span><span style="color: #800000;">e</span><span style="color: #800000;">'</span> || s[i] == <span style="color: #800000;">'</span><span style="color: #800000;">E</span><span style="color: #800000;">'</span>) { <span style="color: #008000;">//</span><span style="color: #008000;"> e/E cannot follow +/-, must follow a digit</span>
                <span style="color: #0000ff;">if</span> (!eExisted &amp;&amp; s[i - <span style="color: #800080;">1</span>] != <span style="color: #800000;">'</span><span style="color: #800000;">+</span><span style="color: #800000;">'</span> &amp;&amp; s[i - <span style="color: #800080;">1</span>] != <span style="color: #800000;">'</span><span style="color: #800000;">-</span><span style="color: #800000;">'</span> &amp;&amp; digitExisited) eExisted = <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (s[i] == <span style="color: #800000;">'</span><span style="color: #800000;">+</span><span style="color: #800000;">'</span> || s[i] == <span style="color: #800000;">'</span><span style="color: #800000;">-</span><span style="color: #800000;">'</span>) { <span style="color: #008000;">//</span><span style="color: #008000;"> +/- can only follow e/E</span>
                <span style="color: #0000ff;">if</span> (s[i - <span style="color: #800080;">1</span>] != <span style="color: #800000;">'</span><span style="color: #800000;">e</span><span style="color: #800000;">'</span> &amp;&amp; s[i - <span style="color: #800080;">1</span>] != <span style="color: #800000;">'</span><span style="color: #800000;">E</span><span style="color: #800000;">'</span>) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;                
            } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (s[i] == <span style="color: #800000;">'</span><span style="color: #800000;">.</span><span style="color: #800000;">'</span>) { <span style="color: #008000;">//</span><span style="color: #008000;"> dot can only occur once and cannot occur after e/E</span>
                <span style="color: #0000ff;">if</span> (!dotExisted &amp;&amp; !eExisted) dotExisted = <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        }
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> Process the last char, it can only be digit or dot, when is dot, there should be no dot and e/E before and must follow a digit</span>
        <span style="color: #0000ff;">if</span> (s[right] &gt;= <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span> &amp;&amp; s[right] &lt;= <span style="color: #800000;">'</span><span style="color: #800000;">9</span><span style="color: #800000;">'</span>) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (s[right] == <span style="color: #800000;">'</span><span style="color: #800000;">.</span><span style="color: #800000;">'</span> &amp;&amp; !dotExisted &amp;&amp; !eExisted &amp;&amp; digitExisited) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p><span style="line-height: 1.5;"> </span></p>
<p>上面的写法略为复杂，我们尝试着来优化一下，根据上面的分析，所有的字符可以分为六大类，空格，符号，数字，小数点，自然底数和其他字符，我们需要五个标志变量，num, dot, exp, sign分别表示数字，小数点，自然底数和符号是否出现，numAfterE表示自然底数后面是否有数字，那么我们分别来看各种情况：</p>
<p><span style="line-height: 1.5;">- 空格： 我们需要排除的情况是，当前位置是空格而后面一位不为空格，但是之前有数字，小数点，自然底数或者符号出现时返回false。</span></p>
<p><span style="line-height: 1.5;">- 符号：符号前面如果有字符的话必须是空格或者是自然底数，标记sign为true。</span></p>
<p><span style="line-height: 1.5;">- 数字：标记num和numAfterE为true。</span></p>
<p><span style="line-height: 1.5;">- 小数点：如果之前出现过小数点或者自然底数，返回false，否则标记dot为true。</span></p>
<p><span style="line-height: 1.5;">- 自然底数：如果之前出现过自然底数或者之前从未出现过数字，返回false，否则标记exp为true，numAfterE为false。</span></p>
<p><span style="line-height: 1.5;">- 其他字符：返回false。</span></p>
<p>最后返回num &amp;&amp; numAfterE即可。</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> isNumber(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        </span><span style="color: #0000ff;">bool</span> num = <span style="color: #0000ff;">false</span>, numAfterE = <span style="color: #0000ff;">true</span>, dot = <span style="color: #0000ff;">false</span>, exp = <span style="color: #0000ff;">false</span>, sign = <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> n =<span style="color: #000000;"> s.size();
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (s[i] == <span style="color: #800000;">'</span> <span style="color: #800000;">'</span><span style="color: #000000;">) {
                </span><span style="color: #0000ff;">if</span> (i &lt; n - <span style="color: #800080;">1</span> &amp;&amp; s[i + <span style="color: #800080;">1</span>] != <span style="color: #800000;">'</span> <span style="color: #800000;">'</span> &amp;&amp; (num || dot || exp || sign)) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (s[i] == <span style="color: #800000;">'</span><span style="color: #800000;">+</span><span style="color: #800000;">'</span> || s[i] == <span style="color: #800000;">'</span><span style="color: #800000;">-</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                </span><span style="color: #0000ff;">if</span> (i &gt; <span style="color: #800080;">0</span> &amp;&amp; s[i - <span style="color: #800080;">1</span>] != <span style="color: #800000;">'</span><span style="color: #800000;">e</span><span style="color: #800000;">'</span> &amp;&amp; s[i - <span style="color: #800080;">1</span>] != <span style="color: #800000;">'</span> <span style="color: #800000;">'</span>) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                sign </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
            } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (s[i] &gt;= <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span> &amp;&amp; s[i] &lt;= <span style="color: #800000;">'</span><span style="color: #800000;">9</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                num </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                numAfterE </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
            } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (s[i] == <span style="color: #800000;">'</span><span style="color: #800000;">.</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                </span><span style="color: #0000ff;">if</span> (dot || exp) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                dot </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
            } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (s[i] == <span style="color: #800000;">'</span><span style="color: #800000;">e</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                </span><span style="color: #0000ff;">if</span> (exp || !num) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                exp </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                numAfterE </span>= <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> num &amp;&amp;<span style="color: #000000;"> numAfterE;
    }
};</span></pre>
</div>
<p> </p>
<p>这道题给了例子不够用，下面这些例子都是我在调试的过程中出现过的例子，用来参考：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">string</span> s1 = <span style="color: #800000;">"</span><span style="color: #800000;">0</span><span style="color: #800000;">"</span>; <span style="color: #008000;">//</span><span style="color: #008000;"> True</span>
<span style="color: #0000ff;">string</span> s2 = <span style="color: #800000;">"</span><span style="color: #800000;"> 0.1 </span><span style="color: #800000;">"</span>; <span style="color: #008000;">//</span><span style="color: #008000;"> True</span>
<span style="color: #0000ff;">string</span> s3 = <span style="color: #800000;">"</span><span style="color: #800000;">abc</span><span style="color: #800000;">"</span>; <span style="color: #008000;">//</span><span style="color: #008000;"> False</span>
<span style="color: #0000ff;">string</span> s4 = <span style="color: #800000;">"</span><span style="color: #800000;">1 a</span><span style="color: #800000;">"</span>; <span style="color: #008000;">//</span><span style="color: #008000;"> False</span>
<span style="color: #0000ff;">string</span> s5 = <span style="color: #800000;">"</span><span style="color: #800000;">2e10</span><span style="color: #800000;">"</span>; <span style="color: #008000;">//</span><span style="color: #008000;"> True</span>

<span style="color: #0000ff;">string</span> s6 = <span style="color: #800000;">"</span><span style="color: #800000;">-e10</span><span style="color: #800000;">"</span>; <span style="color: #008000;">//</span><span style="color: #008000;"> False</span>
<span style="color: #0000ff;">string</span> s7 = <span style="color: #800000;">"</span><span style="color: #800000;"> 2e-9 </span><span style="color: #800000;">"</span>; <span style="color: #008000;">//</span><span style="color: #008000;"> True</span>
<span style="color: #0000ff;">string</span> s8 = <span style="color: #800000;">"</span><span style="color: #800000;">+e1</span><span style="color: #800000;">"</span>; <span style="color: #008000;">//</span><span style="color: #008000;"> False</span>
<span style="color: #0000ff;">string</span> s9 = <span style="color: #800000;">"</span><span style="color: #800000;">1+e</span><span style="color: #800000;">"</span>; <span style="color: #008000;">//</span><span style="color: #008000;"> False</span>
<span style="color: #0000ff;">string</span> s10 = <span style="color: #800000;">"</span> <span style="color: #800000;">"</span>; <span style="color: #008000;">//</span><span style="color: #008000;"> False</span>

<span style="color: #0000ff;">string</span> s11 = <span style="color: #800000;">"</span><span style="color: #800000;">e9</span><span style="color: #800000;">"</span>; <span style="color: #008000;">//</span><span style="color: #008000;"> False</span>
<span style="color: #0000ff;">string</span> s12 = <span style="color: #800000;">"</span><span style="color: #800000;">4e+</span><span style="color: #800000;">"</span>; <span style="color: #008000;">//</span><span style="color: #008000;"> False</span>
<span style="color: #0000ff;">string</span> s13 = <span style="color: #800000;">"</span><span style="color: #800000;"> -.</span><span style="color: #800000;">"</span>; <span style="color: #008000;">//</span><span style="color: #008000;"> False</span>
<span style="color: #0000ff;">string</span> s14 = <span style="color: #800000;">"</span><span style="color: #800000;">+.8</span><span style="color: #800000;">"</span>; <span style="color: #008000;">//</span><span style="color: #008000;"> True</span>
<span style="color: #0000ff;">string</span> s15 = <span style="color: #800000;">"</span><span style="color: #800000;"> 005047e+6</span><span style="color: #800000;">"</span>; <span style="color: #008000;">//</span><span style="color: #008000;"> True</span>

<span style="color: #0000ff;">string</span> s16 = <span style="color: #800000;">"</span><span style="color: #800000;">.e1</span><span style="color: #800000;">"</span>; <span style="color: #008000;">//</span><span style="color: #008000;"> False</span>
<span style="color: #0000ff;">string</span> s17 = <span style="color: #800000;">"</span><span style="color: #800000;">3.e</span><span style="color: #800000;">"</span>; <span style="color: #008000;">//</span><span style="color: #008000;"> False</span>
<span style="color: #0000ff;">string</span> s18 = <span style="color: #800000;">"</span><span style="color: #800000;">3.e1</span><span style="color: #800000;">"</span>; <span style="color: #008000;">//</span><span style="color: #008000;"> True</span>
<span style="color: #0000ff;">string</span> s19 = <span style="color: #800000;">"</span><span style="color: #800000;">+1.e+5</span><span style="color: #800000;">"</span>; <span style="color: #008000;">//</span><span style="color: #008000;"> True</span>
<span style="color: #0000ff;">string</span> s20 = <span style="color: #800000;">"</span><span style="color: #800000;"> -54.53061</span><span style="color: #800000;">"</span>; <span style="color: #008000;">//</span><span style="color: #008000;"> True</span>

<span style="color: #0000ff;">string</span> s21 = <span style="color: #800000;">"</span><span style="color: #800000;">. 1</span><span style="color: #800000;">"</span>; <span style="color: #008000;">//</span><span style="color: #008000;"> False</span></pre>
</div>
<p> </p>
<p>感想：这道题实在是太烦了，情况太多了，这再不是Hard，天理难容呀~</p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/9490/clear-java-solution-with-ifs" target="_blank">https://discuss.leetcode.com/topic/9490/clear-java-solution-with-ifs</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p>
<p> </p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2014-11-09 08:22</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4084408" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4084408);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4353255.html" id="cb_post_title_url">[LeetCode] Minimum Path Sum 最小路径和</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a <em>m</em> x <em>n</em> grid filled with non-negative numbers, find a path from top left to bottom right which <em>minimizes</em> the sum of all numbers along its path.</p>
<p>Note: You can only move either down or right at any point in time.</p>
<p> </p>
<p>这道题跟之前那道<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4233035.html" id="cb_post_title_url"> Dungeon Game 地牢游戏</a> 没有什么太大的区别，都需要用动态规划Dynamic Programming来做，这应该算是DP问题中比较简单的一类，我们维护一个二维的dp数组，其中dp[i][j]表示当前位置的最小路径和，递推式也容易写出来 dp[i][j] = grid[i][j] + min(dp[i - 1][j], 反正难度不算大，代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> minPathSum(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt; &gt; &amp;<span style="color: #000000;">grid) {
        </span><span style="color: #0000ff;">int</span> m = grid.size(), n = grid[<span style="color: #800080;">0</span><span style="color: #000000;">].size();
        </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> dp[m][n];
        dp[</span><span style="color: #800080;">0</span>][<span style="color: #800080;">0</span>] = grid[<span style="color: #800080;">0</span>][<span style="color: #800080;">0</span><span style="color: #000000;">];
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt; m; ++i) dp[i][<span style="color: #800080;">0</span>] = grid[i][<span style="color: #800080;">0</span>] + dp[i - <span style="color: #800080;">1</span>][<span style="color: #800080;">0</span><span style="color: #000000;">];
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt; n; ++i) dp[<span style="color: #800080;">0</span>][i] = grid[<span style="color: #800080;">0</span>][i] + dp[<span style="color: #800080;">0</span>][i - <span style="color: #800080;">1</span><span style="color: #000000;">];
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt; m; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">1</span>; j &lt; n; ++<span style="color: #000000;">j) {
                dp[i][j] </span>= grid[i][j] + min(dp[i - <span style="color: #800080;">1</span>][j], dp[i][j - <span style="color: #800080;">1</span><span style="color: #000000;">]);
            }
        }
        </span><span style="color: #0000ff;">return</span> dp[m - <span style="color: #800080;">1</span>][n - <span style="color: #800080;">1</span><span style="color: #000000;">];
    }
};</span></pre>
</div>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-03-20 11:50</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4353255" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4353255);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4353680.html" id="cb_post_title_url">[LeetCode] Unique Paths II 不同的路径之二</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Follow up for "Unique Paths":</p>
<p>Now consider if some obstacles are added to the grids. How many unique paths would there be?</p>
<p>An obstacle and empty space is marked as <code>1</code> and <code>0</code> respectively in the grid.</p>
<p>For example,</p>
<p>There is one obstacle in the middle of a 3x3 grid as illustrated below.</p>
<pre>[
  [0,0,0],
  [0,1,0],
  [0,0,0]
]
</pre>
<p>The total number of unique paths is <code>2</code>.</p>
<p>Note: <em>m</em> and <em>n</em> will be at most 100.</p>
<p> </p>
<p>这道题是之前那道<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4353555.html" id="homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0"> Unique Paths 不同的路径</a> 的延伸，在路径中加了一些障碍物，还是用动态规划Dynamic Programming来解，不同的是当遇到为1的点，将该位置的dp数组中的值清零，其余和之前那道题并没有什么区别，代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> uniquePathsWithObstacles(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> obstacleGrid) {
        </span><span style="color: #0000ff;">if</span> (obstacleGrid.empty() || obstacleGrid[<span style="color: #800080;">0</span>].empty() || obstacleGrid[<span style="color: #800080;">0</span>][<span style="color: #800080;">0</span>] == <span style="color: #800080;">1</span>) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt; &gt; dp(obstacleGrid.size(), vector&lt;<span style="color: #0000ff;">int</span>&gt;(obstacleGrid[<span style="color: #800080;">0</span>].size(), <span style="color: #800080;">0</span><span style="color: #000000;">));
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; obstacleGrid.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; obstacleGrid[i].size(); ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> (obstacleGrid[i][j] == <span style="color: #800080;">1</span>) dp[i][j] = <span style="color: #800080;">0</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (i == <span style="color: #800080;">0</span> &amp;&amp; j == <span style="color: #800080;">0</span>) dp[i][j] = <span style="color: #800080;">1</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (i == <span style="color: #800080;">0</span> &amp;&amp; j &gt; <span style="color: #800080;">0</span>) dp[i][j] = dp[i][j - <span style="color: #800080;">1</span><span style="color: #000000;">];
                </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (i &gt; <span style="color: #800080;">0</span> &amp;&amp; j == <span style="color: #800080;">0</span>) dp[i][j] = dp[i - <span style="color: #800080;">1</span><span style="color: #000000;">][j];
                </span><span style="color: #0000ff;">else</span> dp[i][j] = dp[i - <span style="color: #800080;">1</span>][j] + dp[i][j - <span style="color: #800080;">1</span><span style="color: #000000;">];
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> dp.back().back();
    }
};</span></pre>
</div>
<p> </p>
<p>或者我们也可以使用一维dp数组来解，省一些空间，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> DP</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> uniquePathsWithObstacles(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt; &gt; &amp;<span style="color: #000000;">obstacleGrid) {
        </span><span style="color: #0000ff;">if</span> (obstacleGrid.empty() || obstacleGrid[<span style="color: #800080;">0</span>].empty()) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> m = obstacleGrid.size(), n = obstacleGrid[<span style="color: #800080;">0</span><span style="color: #000000;">].size();
        </span><span style="color: #0000ff;">if</span> (obstacleGrid[<span style="color: #800080;">0</span>][<span style="color: #800080;">0</span>] == <span style="color: #800080;">1</span>) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; dp(n, <span style="color: #800080;">0</span><span style="color: #000000;">);
        dp[</span><span style="color: #800080;">0</span>] = <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; m; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; n; ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> (obstacleGrid[i][j] == <span style="color: #800080;">1</span>) dp[j] = <span style="color: #800080;">0</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (j &gt; <span style="color: #800080;">0</span>) dp[j] += dp[j - <span style="color: #800080;">1</span><span style="color: #000000;">];
            }
        }
        </span><span style="color: #0000ff;">return</span> dp[n - <span style="color: #800080;">1</span><span style="color: #000000;">];
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4353555.html" target="_blank">Unique Paths</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-03-20 15:13</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4353680" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4353680);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4353555.html" id="cb_post_title_url">[LeetCode] Unique Paths 不同的路径</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>A robot is located at the top-left corner of a <em>m</em> x <em>n</em> grid (marked 'Start' in the diagram below).</p>
<p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).</p>
<p>How many possible unique paths are there?</p>
<p><img alt="" src="http://leetcode.com/wp-content/uploads/2014/12/robot_maze.png"/></p>
<p>Above is a 3 x 7 grid. How many possible unique paths are there?</p>
<p>Note: <em>m</em> and <em>n</em> will be at most 100.</p>
<p> </p>
<p>这道题让求所有不同的路径的个数，一开始还真把我难住了，因为之前好像没有遇到过这类的问题，所以感觉好像有种无从下手的感觉。在网上找攻略之后才恍然大悟，原来这跟之前那道<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4079165.html" id="cb_post_title_url"> Climbing Stairs 爬梯子问题</a> 很类似，那道题是说可以每次能爬一格或两格，问到达顶部的所有不同爬法的个数。而这道题是每次可以向下走或者向右走，求到达最右下角的所有不同走法的个数。那么跟爬梯子问题一样，我们需要用动态规划Dynamic Programming来解，我们可以维护一个二维数组dp，其中dp[i][j]表示到当前位置不同的走法的个数，然后可以得到递推式为: dp[i][j] = dp[i - 1][j] + dp[i][j - 1]，这里为了节省空间，我们使用一维数组dp，一行一行的刷新也可以，代码如下：</p>
<p>解法一</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> DP</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> uniquePaths(<span style="color: #0000ff;">int</span> m, <span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; dp(n, <span style="color: #800080;">1</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt; m; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">1</span>; j &lt; n; ++<span style="color: #000000;">j) {
                dp[j] </span>+= dp[j - <span style="color: #800080;">1</span><span style="color: #000000;">]; 
            }
        }
        </span><span style="color: #0000ff;">return</span> dp[n - <span style="color: #800080;">1</span><span style="color: #000000;">];
    }
};</span></pre>
</div>
<p> </p>
<p>这道题其实还有另一种很数学的解法，参见网友<a href="http://blog.csdn.net/linhuanmars/article/details/22126357" target="_blank">Code Ganker的博客</a>，实际相当于机器人总共走了m + n - 2步，其中m - 1步向下走，n - 1步向右走，那么总共不同的方法个数就相当于在步数里面m - 1和n - 1中较小的那个数的取法，实际上是一道组合数的问题，写出代码如下:</p>
<p> </p>
<p>解法二</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> uniquePaths(<span style="color: #0000ff;">int</span> m, <span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        </span><span style="color: #0000ff;">double</span> num = <span style="color: #800080;">1</span>, denom = <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> small = m &gt; n ?<span style="color: #000000;"> n : m;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt;= small - <span style="color: #800080;">1</span>; ++<span style="color: #000000;">i) {
            num </span>*= m + n - <span style="color: #800080;">1</span> -<span style="color: #000000;"> i;
            denom </span>*=<span style="color: #000000;"> i;
        }
        </span><span style="color: #0000ff;">return</span> (<span style="color: #0000ff;">int</span>)(num /<span style="color: #000000;"> denom);
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4353680.html" target="_blank">Unique Paths II</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-03-20 14:30</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4353555" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4353555);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4355505.html" id="cb_post_title_url">[LeetCode] Rotate List  旋转链表</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a list, rotate the list to the right by <em>k</em> places, where <em>k</em> is non-negative.</p>
<p>For example:<br/>Given <code>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</code> and <em>k</em> = <code>2</code>,<br/>return <code>4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</code>.</p>
<p> </p>
<p>这道旋转链表的题和之前那道<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4298711.html" id="cb_post_title_url"> Rotate Array 旋转数组</a> 很类似，但是比那道要难一些，因为链表的值不能通过下表来访问，只能一个一个的走，我刚开始拿到这题首先想到的就是用快慢指针来解，快指针先走k步，然后两个指针一起走，当快指针走到末尾时，慢指针的下一个位置是新的顺序的头结点，这样就可以旋转链表了，自信满满的写完程序，放到OJ上跑，以为能一次通过，结果跪在了各种特殊情况，首先一个就是当原链表为空时，直接返回NULL，还有就是当k大于链表长度和k远远大于链表长度时该如何处理，我们需要首先遍历一遍原链表得到链表长度n，然后k对n取余，这样k肯定小于n，就可以用上面的算法了，代码如下:</p>
<p> 解法一</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    ListNode </span>*rotateRight(ListNode *head, <span style="color: #0000ff;">int</span><span style="color: #000000;"> k) {
        </span><span style="color: #0000ff;">if</span> (!head) <span style="color: #0000ff;">return</span><span style="color: #000000;"> NULL;
        </span><span style="color: #0000ff;">int</span> n = <span style="color: #800080;">0</span><span style="color: #000000;">;
        ListNode </span>*cur =<span style="color: #000000;"> head;
        </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> (cur) {
            </span>++<span style="color: #000000;">n;
            cur </span>= cur-&gt;<span style="color: #000000;">next;
        }
        k </span>%=<span style="color: #000000;"> n;
        ListNode </span>*fast = head, *slow =<span style="color: #000000;"> head;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; k; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (fast) fast = fast-&gt;<span style="color: #000000;">next;
        }
        </span><span style="color: #0000ff;">if</span> (!fast) <span style="color: #0000ff;">return</span><span style="color: #000000;"> head;
        </span><span style="color: #0000ff;">while</span> (fast-&gt;<span style="color: #000000;">next) {
            fast </span>= fast-&gt;<span style="color: #000000;">next;
            slow </span>= slow-&gt;<span style="color: #000000;">next;
        }
        fast</span>-&gt;next =<span style="color: #000000;"> head;
        fast </span>= slow-&gt;<span style="color: #000000;">next;
        slow</span>-&gt;next =<span style="color: #000000;"> NULL;
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> fast;
    }
};</span></pre>
</div>
<p> <br/>这道题还有一种解法，跟上面的方法类似，但是不用快慢指针，一个指针就够了，原理是先遍历整个链表获得链表长度n，然后此时把链表头和尾链接起来，在往后走n - k % n个节点就到达新链表的头结点前一个点，这时断开链表即可，代码如下:</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    ListNode </span>*rotateRight(ListNode *head, <span style="color: #0000ff;">int</span><span style="color: #000000;"> k) {
        </span><span style="color: #0000ff;">if</span> (!head) <span style="color: #0000ff;">return</span><span style="color: #000000;"> NULL;
        </span><span style="color: #0000ff;">int</span> n = <span style="color: #800080;">1</span><span style="color: #000000;">;
        ListNode </span>*cur =<span style="color: #000000;"> head;
        </span><span style="color: #0000ff;">while</span> (cur-&gt;<span style="color: #000000;">next) {
            </span>++<span style="color: #000000;">n;
            cur </span>= cur-&gt;<span style="color: #000000;">next;
        }
        cur</span>-&gt;next =<span style="color: #000000;"> head;
        </span><span style="color: #0000ff;">int</span> m = n - k %<span style="color: #000000;"> n;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; m; ++<span style="color: #000000;">i) {
            cur </span>= cur-&gt;<span style="color: #000000;">next;
        }
        ListNode </span>*newhead = cur-&gt;<span style="color: #000000;">next;
        cur</span>-&gt;next =<span style="color: #000000;"> NULL;
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> newhead;
    }
};</span></pre>
</div>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-03-21 13:49</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4355505" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4355505);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4358678.html" id="cb_post_title_url">[LeetCode] Permutation Sequence 序列排序</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>The set <code>[1,2,3,...,<em>n</em>]</code> contains a total of <em>n</em>! unique permutations.</p>
<p>By listing and labeling all of the permutations in order, we get the following sequence for <em>n</em> = 3:</p>
<ol>
<li><code>"123"</code></li>
<li><code>"132"</code></li>
<li><code>"213"</code></li>
<li><code>"231"</code></li>
<li><code>"312"</code></li>
<li><code>"321"</code></li>
</ol>
<p>Given <em>n</em> and <em>k</em>, return the <em>k</em>th permutation sequence.</p>
<p>Note:</p>
<ul>
<li>Given <em>n</em> will be between 1 and 9 inclusive.</li>
<li>Given <em>k</em> will be between 1 and <em>n</em>! inclusive.</li>
</ul>
<p>Example 1:</p>
<pre>Input: n = 3, k = 3
Output: "213"
</pre>
<p>Example 2:</p>
<pre>Input: n = 4, k = 9
Output: "2314"</pre>
<p> </p>
<p>这道题是让求出n个数字的第k个排列组合，由于其特殊性，我们不用将所有的排列组合的情况都求出来，然后返回其第k个，我们可以只求出第k个排列组合即可，那么难点就在于如何知道数字的排列顺序，可参见网友<a href="http://bangbingsyb.blogspot.com/2014/11/leetcode-permutation-sequence.html" target="_blank">喜刷刷的博客</a>，首先我们要知道当n = 3时，其排列组合共有3! = 6种，当n = 4时，其排列组合共有4! = 24种，我们就以n = 4, k = 17的情况来分析，所有排列组合情况如下：</p>
<p><span style="color: #ff0000;">1</span><span style="color: #008000;">2</span>34<br/><span style="color: #ff0000;">1</span><span style="color: #008000;">2</span>43<br/><span style="color: #ff0000;">1</span><span style="color: #0000ff;">3</span>24<br/><span style="color: #ff0000;">1</span><span style="color: #0000ff;">3</span>42<br/><span style="color: #ff0000;">1</span><span style="color: #ffcc00;">4</span>23<br/><span style="color: #ff0000;">1</span><span style="color: #ffcc00;">4</span>32<br/><span style="color: #008000;">2</span><span style="color: #ff0000;">1</span>34<br/><span style="color: #008000;">2</span><span style="color: #ff0000;">1</span>43<br/><span style="color: #008000;">2</span><span style="color: #0000ff;">3</span>14  <br/><span style="color: #008000;">2</span><span style="color: #0000ff;">3</span>41<br/><span style="color: #008000;">2</span><span style="color: #ffcc00;">4</span>13<br/><span style="color: #008000;">2</span><span style="color: #ffcc00;">4</span>31<br/><span style="color: #0000ff;">3</span><span style="color: #ff0000;">1</span>24<br/><span style="color: #0000ff;">3</span><span style="color: #ff0000;">1</span>42<br/><span style="color: #0000ff;">3</span><span style="color: #008000;">2</span>14<br/><span style="color: #0000ff;">3</span><span style="color: #008000;">2</span>41<br/><span style="color: #0000ff;">3</span><span style="color: #ffcc00;">4</span>12	&lt;---  k = 17<br/><span style="color: #0000ff;">3</span><span style="color: #ffcc00;">4</span>21<br/><span style="color: #ffcc00;">4</span><span style="color: #ff0000;">1</span>23<br/><span style="color: #ffcc00;">4</span><span style="color: #ff0000;">1</span>32<br/><span style="color: #ffcc00;">4</span><span style="color: #008000;">2</span>13<br/><span style="color: #ffcc00;">4</span><span style="color: #008000;">2</span>31<br/><span style="color: #ffcc00;">4</span><span style="color: #0000ff;">3</span>12<br/><span style="color: #ffcc00;">4</span><span style="color: #0000ff;">3</span>21</p>
<p>我们可以发现，每一位上1,2,3,4分别都出现了6次，当最高位上的数字确定了，第二高位每个数字都出现了2次，当第二高位也确定了，第三高位上的数字都只出现了1次，当第三高位确定了，那么第四高位上的数字也只能出现一次，下面我们来看k = 17这种情况的每位数字如何确定，由于k = 17是转化为数组下标为16：</p>
<p>最高位可取1,2,3,4中的一个，每个数字出现3！= 6次，所以k = 16的第一位数字的下标为16 / 6 = 2，在 "1234" 中即3被取出。这里我们的k是要求的坐标为k的全排列序列，我们定义 k' 为当最高位确定后，要求的全排序列在新范围中的位置，同理，k'' 为当第二高为确定后，所要求的全排列序列在新范围中的位置，以此类推，下面来具体看看：</p>
<p>第二位此时从1,2,4中取一个，k = 16，则此时的 k' = 16 % (3!) = 4，如下所示，而剩下的每个数字出现2！= 2次，所以第二数字的下标为4 / 2 = 2，在 "124" 中即4被取出。</p>
<p><span style="color: #0000ff;">3</span><span style="color: #ff0000;">1</span>24<br/><span style="color: #0000ff;">3</span><span style="color: #ff0000;">1</span>42<br/><span style="color: #0000ff;">3</span><span style="color: #008000;">2</span>14<br/><span style="color: #0000ff;">3</span><span style="color: #008000;">2</span>41<br/><span style="color: #0000ff;">3</span><span style="color: #ff9900;">4</span>12	&lt;--- k' = 4<br/><span style="color: #0000ff;">3</span><span style="color: #ff9900;">4</span>21</p>
<p>第三位此时从1,2中去一个，k' = 4，则此时的k'' = 4 % (2!) = 0，如下所示，而剩下的每个数字出现1！= 1次，所以第三个数字的下标为 0 / 1 = 0，在 "12" 中即1被取出。</p>
<p><span style="color: #0000ff;">3</span><span style="color: #ff9900;">4</span>12 &lt;--- k'' = 0<br/><span style="color: #0000ff;">3</span><span style="color: #ff9900;">4</span>21</p>
<p>第四位是从2中取一个，k'' = 0，则此时的k''' = 0 % (1!) = 0，如下所示，而剩下的每个数字出现0！= 1次，所以第四个数字的下标为0 / 1= 0，在 "2" 中即2被取出。</p>
<p><span style="color: #0000ff;">3</span><span style="color: #ff9900;">4</span>12 &lt;--- k''' = 0</p>
<p>那么我们就可以找出规律了<br/>a1 = k / (n - 1)!<br/>k1 = k</p>
<p>a2 = k1 / (n - 2)!<br/>k2 = k1 % (n - 2)!<br/>...</p>
<p>an-1 = kn-2 / 1!<br/>kn-1 = kn-2 % 1!</p>
<p>an = kn-1 / 0!<br/>kn = kn-1 % 0! </p>
<p> </p>
<p>代码如下：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> getPermutation(<span style="color: #0000ff;">int</span> n, <span style="color: #0000ff;">int</span><span style="color: #000000;"> k) {
        </span><span style="color: #0000ff;">string</span><span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">string</span> num = <span style="color: #800000;">"</span><span style="color: #800000;">123456789</span><span style="color: #800000;">"</span><span style="color: #000000;">;
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; f(n, <span style="color: #800080;">1</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt; n; ++i) f[i] = f[i - <span style="color: #800080;">1</span>] *<span style="color: #000000;"> i;
        </span>--<span style="color: #000000;">k;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = n; i &gt;= <span style="color: #800080;">1</span>; --<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">int</span> j = k / f[i - <span style="color: #800080;">1</span><span style="color: #000000;">];
            k </span>%= f[i - <span style="color: #800080;">1</span><span style="color: #000000;">];
            res.push_back(num[j]);
            num.erase(j, </span><span style="color: #800080;">1</span><span style="color: #000000;">);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4428207.html" target="_blank">Next Permutation</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4358848.html" target="_blank">Permutations</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-03-23 01:44</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4358678" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4358678);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4362813.html" id="cb_post_title_url">[LeetCode] Spiral Matrix II 螺旋矩阵之二</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="content__1c40">
<div>
<p>Given a positive integer <em>n</em>, generate a square matrix filled with elements from 1 to <em>n</em>2 in spiral order.</p>
<p>Example:</p>
<pre>Input: 3
Output:
[
 [ 1, 2, 3 ],
 [ 8, 9, 4 ],
 [ 7, 6, 5 ]
]
</pre>
</div>
</div>
<div class="header__2cgQ"> </div>
<p>此题跟之前那道<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4362675.html" id="homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0"> Spiral Matrix</a> 本质上没什么区别，就相当于个类似逆运算的过程，这道题是要按螺旋的顺序来填数，由于给定矩形是个正方形，我们计算环数时用n / 2来计算，若n为奇数时，此时最中间的那个点没有被算在环数里，所以最后需要单独赋值，还是下标转换问题是难点，参考之前<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4362675.html" id="homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0"> Spiral Matrix</a> 的讲解来转换下标吧，代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt; &gt; generateMatrix(<span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt; &gt; res(n, vector&lt;<span style="color: #0000ff;">int</span>&gt;(n, <span style="color: #800080;">0</span><span style="color: #000000;">));
        </span><span style="color: #0000ff;">int</span> val = <span style="color: #800080;">1</span>, p =<span style="color: #000000;"> n;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n / <span style="color: #800080;">2</span>; ++i, p -= <span style="color: #800080;">2</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> col = i; col &lt; i + p; ++<span style="color: #000000;">col)
                res[i][col] </span>= val++<span style="color: #000000;">;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> row = i + <span style="color: #800080;">1</span>; row &lt; i + p; ++<span style="color: #000000;">row)
                res[row][i </span>+ p - <span style="color: #800080;">1</span>] = val++<span style="color: #000000;">;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> col = i + p - <span style="color: #800080;">2</span>; col &gt;= i; --<span style="color: #000000;">col)
                res[i </span>+ p - <span style="color: #800080;">1</span>][col] = val++<span style="color: #000000;">;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> row = i + p - <span style="color: #800080;">2</span>; row &gt; i; --<span style="color: #000000;">row)    
                res[row][i] </span>= val++<span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">if</span> (n % <span style="color: #800080;">2</span> != <span style="color: #800080;">0</span>) res[n / <span style="color: #800080;">2</span>][n / <span style="color: #800080;">2</span>] =<span style="color: #000000;"> val;
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>当然我们也可以使用下面这种简化了坐标转换的方法，博主个人还是比较推崇下面这种解法，不容易出错，而且好理解，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; generateMatrix(<span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; res(n, vector&lt;<span style="color: #0000ff;">int</span>&gt;(n, <span style="color: #800080;">0</span><span style="color: #000000;">));
        </span><span style="color: #0000ff;">int</span> up = <span style="color: #800080;">0</span>, down = n - <span style="color: #800080;">1</span>, left = <span style="color: #800080;">0</span>, right = n - <span style="color: #800080;">1</span>, val = <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (<span style="color: #0000ff;">true</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = left; j &lt;= right; ++j) res[up][j] = val++<span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> (++up &gt; down) <span style="color: #0000ff;">break</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = up; i &lt;= down; ++i) res[i][right] = val++<span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> (--right &lt; left) <span style="color: #0000ff;">break</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = right; j &gt;= left; --j) res[down][j] = val++<span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> (--down &lt; up) <span style="color: #0000ff;">break</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = down; i &gt;= up; --i) res[i][left] = val++<span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> (++left &gt; right) <span style="color: #0000ff;">break</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4362675.html" target="_blank">Spiral Matrix</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-03-24 14:54</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4362813" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4362813);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4086298.html" id="cb_post_title_url">[LeetCode] Length of Last Word 求末尾单词的长度</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a string <em>s</em> consists of upper/lower-case alphabets and empty space characters <code>' '</code>, return the length of last word in the string.</p>
<p>If the last word does not exist, return 0.</p>
<p>Note: A word is defined as a character sequence consists of non-space characters only.</p>
<p>For example, <br/>Given <em>s</em> = <code>"Hello World"</code>,<br/>return <code>5</code>.</p>
<p> </p>
<p>这道题难度不是很大。先对输入字符串做预处理，去掉开头和结尾的空格，然后用一个计数器来累计非空格的字符串的长度，遇到空格则将计数器清零。代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> lengthOfLastWord(<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span> *<span style="color: #000000;">s) {
        </span><span style="color: #0000ff;">int</span> len =<span style="color: #000000;"> strlen(s);
        </span><span style="color: #0000ff;">int</span> left = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> right = len - <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> count = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (s[left] == <span style="color: #800000;">'</span> <span style="color: #800000;">'</span>) ++<span style="color: #000000;">left;
        </span><span style="color: #0000ff;">while</span> (s[right] == <span style="color: #800000;">'</span> <span style="color: #800000;">'</span>) --<span style="color: #000000;">right;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = left; i &lt;= right; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (s[i] == <span style="color: #800000;">'</span> <span style="color: #800000;">'</span>) count = <span style="color: #800080;">0</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">else</span> ++<span style="color: #000000;">count;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> count;
    }
};</span></pre>
</div>
<p> </p>
<p>昨晚睡觉前又想到了一种解法，其实不用上面那么复杂的，我们关心的主要是非空格的字符，那么我们实际上在遍历字符串的时候，如果遇到非空格的字符，我们只需要判断其前面一个位置的字符是否为空格，如果是的话，那么当前肯定是一个新词的开始，将计数器重置为1，如果不是的话，说明正在统计一个词的长度，计数器自增1即可。但是需要注意的是，当i=0的时候，无法访问前一个字符，所以这种情况要特别判断一下，归为计数器自增1那类。参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> lengthOfLastWord(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; s.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (s[i] != <span style="color: #800000;">'</span> <span style="color: #800000;">'</span><span style="color: #000000;">) {
                </span><span style="color: #0000ff;">if</span> (i != <span style="color: #800080;">0</span> &amp;&amp; s[i - <span style="color: #800080;">1</span>] == <span style="color: #800000;">'</span> <span style="color: #800000;">'</span>) res = <span style="color: #800080;">1</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">else</span> ++<span style="color: #000000;">res;
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种方法是第一种解法的优化版本，由于我们只关于最后一个单词的长度，所以开头有多少个空格起始我们并不在意，我们从字符串末尾开始，先将末尾的空格都去掉，然后开始找非空格的字符的长度即可，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> lengthOfLastWord(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        </span><span style="color: #0000ff;">int</span> right = s.size() - <span style="color: #800080;">1</span>, res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (right &gt;= <span style="color: #800080;">0</span> &amp;&amp; s[right] == <span style="color: #800000;">'</span> <span style="color: #800000;">'</span>) --<span style="color: #000000;">right;
        </span><span style="color: #0000ff;">while</span> (right &gt;= <span style="color: #800080;">0</span> &amp;&amp; s[right] != <span style="color: #800000;">'</span> <span style="color: #800000;">'</span><span style="color: #000000;"> ) {
            </span>--<span style="color: #000000;">right; 
            </span>++<span style="color: #000000;">res;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>这道题用Java来做可以一行搞定，请参见<a href="https://discuss.leetcode.com/topic/6055/a-single-line-of-code-in-java" target="_blank">这个帖子</a>.</p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/17312/7-lines-4ms-c-solution" target="_blank">https://discuss.leetcode.com/topic/17312/7-lines-4ms-c-solution</a></p>
<p><a href="https://discuss.leetcode.com/topic/6055/a-single-line-of-code-in-java" target="_blank">https://discuss.leetcode.com/topic/6055/a-single-line-of-code-in-java</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2014-11-10 03:42</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4086298" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4086298);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4367569.html" id="cb_post_title_url">[LeetCode] Insert Interval 插入区间</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a set of <em>non-overlapping</em> intervals, insert a new interval into the intervals (merge if necessary).</p>
<p>You may assume that the intervals were initially sorted according to their start times.</p>
<p> <strong>Example 1:</strong><br/>
Given intervals <code>[1,3],[6,9]</code>, insert and merge <code>[2,5]</code> in as <code>[1,5],[6,9]</code>.
</p>
<p>
<strong>Example 2:</strong><br/>
Given <code>[1,2],[3,5],[6,7],[8,10],[12,16]</code>, insert and merge <code>[4,9]</code> in as <code>[1,2],[3,10],[12,16]</code>.
</p>
<p>
This is because the new interval <code>[4,9]</code> overlaps with <code>[3,5],[6,7],[8,10]</code>.
</p>
<p> </p>
<p>这道题让我们在一系列非重叠的区间中插入一个新的区间，可能还需要和原有的区间合并，那么我们需要对给区间集一个一个的遍历比较，那么会有两种情况，重叠或是不重叠，不重叠的情况最好，直接将新区间插入到对应的位置即可，重叠的情况比较复杂，有时候会有多个重叠，我们需要更新新区间的范围以便包含所有重叠，之后将新区间加入结果res，最后将后面的区间再加入结果res即可。具体思路是，我们用一个变量cur来遍历区间，如果当前cur区间的结束位置小于要插入的区间的起始位置的话，说明没有重叠，则将cur区间加入结果res中，然后cur自增1。直到有cur越界或有重叠while循环退出，然后再用一个while循环处理所有重叠的区间，每次用取两个区间起始位置的较小值，和结束位置的较大值来更新要插入的区间，然后cur自增1。直到cur越界或者没有重叠时while循环退出。之后将更新好的新区间加入结果res，然后将cur之后的区间再加入结果res中即可，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;Interval&gt; insert(vector&lt;Interval&gt;&amp;<span style="color: #000000;"> intervals, Interval newInterval) {
        vector</span>&lt;Interval&gt;<span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">int</span> n = intervals.size(), cur = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (cur &lt; n &amp;&amp; intervals[cur].end &lt;<span style="color: #000000;"> newInterval.start) {
            res.push_back(intervals[cur</span>++<span style="color: #000000;">]);
        }
        </span><span style="color: #0000ff;">while</span> (cur &lt; n &amp;&amp; intervals[cur].start &lt;=<span style="color: #000000;"> newInterval.end) {
            newInterval.start </span>=<span style="color: #000000;"> min(newInterval.start, intervals[cur].start);
            newInterval.end </span>=<span style="color: #000000;"> max(newInterval.end, intervals[cur].end);
            </span>++<span style="color: #000000;">cur;
        }
        res.push_back(newInterval);
        </span><span style="color: #0000ff;">while</span> (cur &lt;<span style="color: #000000;"> n) {
            res.push_back(intervals[cur</span>++<span style="color: #000000;">]);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种方法的思路跟上面的解法很像，只不过没有用while循环，而是使用的是for循环，但是思路上没有太大的区别，变量cur还是用来记录新区间该插入的位置，稍有不同的地方在于在for循环中已经将新区间后面不重叠的区间也加进去了，for循环结束后就只需要插入新区间即可，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;Interval&gt; insert(vector&lt;Interval&gt;&amp;<span style="color: #000000;"> intervals, Interval newInterval) {
        vector</span>&lt;Interval&gt;<span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">int</span> n = intervals.size(), cur = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (intervals[i].end &lt;<span style="color: #000000;"> newInterval.start) {
                res.push_back(intervals[i]);
                </span>++<span style="color: #000000;">cur;
            } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (intervals[i].start &gt;<span style="color: #000000;"> newInterval.end) {
                res.push_back(intervals[i]);
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                newInterval.start </span>=<span style="color: #000000;"> min(newInterval.start, intervals[i].start);
                newInterval.end </span>=<span style="color: #000000;"> max(newInterval.end, intervals[i].end);
            }
        }
        res.insert(res.begin() </span>+<span style="color: #000000;"> cur, newInterval);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种解法就是把上面解法的for循环改为了while循环，其他的都没有变，代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;Interval&gt; insert(vector&lt;Interval&gt;&amp; <span style="color: #000000;">intervals, Interval newInterval) {
        vector</span>&lt;Interval&gt;<span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">int</span> n = intervals.size(), cur = <span style="color: #800080;">0</span>, i = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (i &lt;<span style="color: #000000;"> n) {
            </span><span style="color: #0000ff;">if</span> (intervals[i].end &lt;<span style="color: #000000;"> newInterval.start) {
                res.push_back(intervals[i]);
                </span>++<span style="color: #000000;">cur;
            } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (intervals[i].start &gt;<span style="color: #000000;"> newInterval.end) {
                res.push_back(intervals[i]);
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                newInterval.start </span>=<span style="color: #000000;"> min(newInterval.start, intervals[i].start);
                newInterval.end </span>=<span style="color: #000000;"> max(newInterval.end, intervals[i].end);
            }
            </span>++<span style="color: #000000;">i;
        }
        res.insert(res.begin() </span>+<span style="color: #000000;"> cur, newInterval);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>如果学过Design Pattern的，对Iterator Pattern比较熟悉的也可应用Iterator来求解，本质还是一样的，只是写法略有不同，代码如下：</p>
<p> </p>
<p>解法四：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;Interval&gt; insert(vector&lt;Interval&gt;&amp; <span style="color: #000000;">intervals, Interval newInterval) {
        vector</span>&lt;Interval&gt;<span style="color: #000000;"> res;
        vector</span>&lt;Interval&gt;::iterator it =<span style="color: #000000;"> intervals.begin();
        </span><span style="color: #0000ff;">int</span> cur = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (it !=<span style="color: #000000;"> intervals.end()) {
            </span><span style="color: #0000ff;">if</span> (it-&gt;end &lt;<span style="color: #000000;"> newInterval.start) {
                res.push_back(</span>*<span style="color: #000000;">it);
                </span>++<span style="color: #000000;">cur;
            } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (it-&gt;start &gt;<span style="color: #000000;"> newInterval.end) {
                res.push_back(</span>*<span style="color: #000000;">it);
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                newInterval.start </span>= min(newInterval.start, it-&gt;<span style="color: #000000;">start);
                newInterval.end </span>= max(newInterval.end, it-&gt;<span style="color: #000000;">end);
            }
            </span>++<span style="color: #000000;">it;
        }
        res.insert(res.begin() </span>+<span style="color: #000000;"> cur, newInterval);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/8586531.html">Range Module</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4370601.html" target="_blank">Merge Intervals</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-03-26 00:59</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4367569" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4367569);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4370601.html" id="cb_post_title_url">[LeetCode] Merge Intervals 合并区间</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a collection of intervals, merge all overlapping intervals.</p>
<p> For example,<br/>
Given <code>[1,3],[2,6],[8,10],[15,18]</code>,<br/>
return <code>[1,6],[8,10],[15,18]</code>.
</p>
<p> </p>
<p>这道和之前那道 <a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4367569.html" id="homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0">Insert Interval</a> 很类似，这次题目要求我们合并区间，之前那题明确了输入区间集是有序的，而这题没有，所以我们首先要做的就是给区间集排序，由于我们要排序的是个结构体，所以我们要定义自己的comparator，才能用sort来排序，我们以start的值从小到大来排序，排完序我们就可以开始合并了，首先把第一个区间存入结果中，然后从第二个开始遍历区间集，如果结果中最后一个区间和遍历的当前区间无重叠，直接将当前区间存入结果中，如果有重叠，将结果中最后一个区间的end值更新为结果中最后一个区间的end和当前end值之中的较大值，然后继续遍历区间集，以此类推可以得到最终结果，代码如下：</p>
<p> </p>
<p>解法一:</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;Interval&gt; merge(vector&lt;Interval&gt;&amp;<span style="color: #000000;"> intervals) {
        </span><span style="color: #0000ff;">if</span> (intervals.empty()) <span style="color: #0000ff;">return</span><span style="color: #000000;"> {};
        sort(intervals.begin(), intervals.end(), [](Interval </span>&amp;a, Interval &amp;b) {<span style="color: #0000ff;">return</span> a.start &lt;<span style="color: #000000;"> b.start;});
        vector</span>&lt;Interval&gt; res{intervals[<span style="color: #800080;">0</span><span style="color: #000000;">]};
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt; intervals.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (res.back().end &lt;<span style="color: #000000;"> intervals[i].start) {
                res.push_back(intervals[i]);
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                res.back().end </span>=<span style="color: #000000;"> max(res.back().end, intervals[i].end);
            }
        }   
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种解法将起始位置和结束位置分别存到了两个不同的数组starts和ends中，然后分别进行排序，之后用两个指针i和j，初始化时分别指向starts和ends数组的首位置，然后如果i指向starts数组中的最后一个位置，或者当starts数组上i+1位置上的数字大于ends数组的i位置上的数时，此时说明区间已经不连续了，我们来看题目中的例子，排序后的starts和ends为：</p>
<p>starts:    1    <span style="color: #ff0000;">2</span>    8    15</p>
<p>ends:     <span style="color: #0000ff;">3</span>    <span style="color: #000000;">6</span>    10    18</p>
<p>红色为i的位置，蓝色为j的位置，那么此时starts[i+1]为8，ends[i]为6，8大于6，所以此时不连续了，将区间[starts[j], ends[i]]，即 [1, 6] 加入结果res中，然后j赋值为i+1继续循环，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;Interval&gt; merge(vector&lt;Interval&gt;&amp;<span style="color: #000000;"> intervals) {
        </span><span style="color: #0000ff;">int</span> n =<span style="color: #000000;"> intervals.size();
        vector</span>&lt;Interval&gt;<span style="color: #000000;"> res;
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> starts, ends;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            starts.push_back(intervals[i].start);
            ends.push_back(intervals[i].end);
        }
        sort(starts.begin(), starts.end());
        sort(ends.begin(), ends.end());
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>, j = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (i == n - <span style="color: #800080;">1</span> || starts[i + <span style="color: #800080;">1</span>] &gt;<span style="color: #000000;"> ends[i]) {
                res.push_back(Interval(starts[j], ends[i]));
                j </span>= i + <span style="color: #800080;">1</span><span style="color: #000000;">;
            }
        } 
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>这道题还有另一种解法，这个解法直接调用了之前那道题<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4367569.html" id="homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0"> Insert Interval </a><span class="postTitle2">的函数，由于插入的过程中也有合并的操作，所以我们可以建立一个空的集合，然后把区间集的每一个区间当做一个新的区间插入结果中，也可以得到合并后的结果，那道题中的四种解法都可以在这里使用，但是没必要都列出来，这里只选了那道题中的解法二放到这里，代码如下：</span></p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;Interval&gt; merge(vector&lt;Interval&gt;&amp;<span style="color: #000000;"> intervals) {
        vector</span>&lt;Interval&gt;<span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; intervals.size(); ++<span style="color: #000000;">i) {
            res </span>=<span style="color: #000000;"> insert(res, intervals[i]);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    vector</span>&lt;Interval&gt; insert(vector&lt;Interval&gt;&amp;<span style="color: #000000;"> intervals, Interval newInterval) {
        vector</span>&lt;Interval&gt;<span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">int</span> n = intervals.size(), cur = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (intervals[i].end &lt;<span style="color: #000000;"> newInterval.start) {
                res.push_back(intervals[i]);
                </span>++<span style="color: #000000;">cur;
            } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (intervals[i].start &gt;<span style="color: #000000;"> newInterval.end) {
                res.push_back(intervals[i]);
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                newInterval.start </span>=<span style="color: #000000;"> min(newInterval.start, intervals[i].start);
                newInterval.end </span>=<span style="color: #000000;"> max(newInterval.end, intervals[i].end);
            }
        }
        res.insert(res.begin() </span>+<span style="color: #000000;"> cur, newInterval);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/8552586.html">Employee Free Time</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4367569.html" target="_blank">Insert Interval</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-03-27 02:53</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4370601" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4370601);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4371526.html" id="cb_post_title_url">[LeetCode] Jump Game 跳跃游戏</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="question-description">
<p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p>
<p>Each element in the array represents your maximum jump length at that position.</p>
<p>Determine if you are able to reach the last index.</p>
<p>Example 1:</p>
<pre>Input: [2,3,1,1,4]
Output: true
Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.
</pre>
<p>Example 2:</p>
<pre>Input: [3,2,1,0,4]
Output: false
Explanation: You will always arrive at index 3 no matter what. Its maximum
             jump length is 0, which makes it impossible to reach the last index.</pre>
</div>
<p> </p>
<p>这道题说的是有一个非负整数的数组，每个数字表示在当前位置的基础上最多可以走的步数，求判断能不能到达最后一个位置，开始我以为是必须刚好到达最后一个位置，超过了不算，其实是理解题意有误，因为每个位置上的数字表示的是最多可以走的步数而不是像玩大富翁一样摇骰子摇出几一定要走几步。那么我们可以用动态规划Dynamic Programming来解，我们维护一个一位数组dp，其中dp[i]表示达到i位置时剩余的步数，那么难点就是推导状态转移方程啦。我们想啊，到达当前位置的剩余步数跟什么有关呢，其实是跟上一个位置的剩余步数和上一个位置的跳力有关，这里的跳力就是原数组中每个位置的数字，因为其代表了以当前位置为起点能到达的最远位置。所以当前位置的剩余步数（dp值）和当前位置的跳力中的较大那个数决定了当前能到的最远距离，而下一个位置的剩余步数（dp值）就等于当前的这个较大值减去1，因为需要花一个跳力到达下一个位置，所以我们就有状态转移方程了：dp[i] = max(dp[i - 1], nums[i - 1]) - 1，如果当某一个时刻dp数组的值为负了，说明无法抵达当前位置，则直接返回false，最后我们判断dp数组最后一位是否为非负数即可知道是否能抵达该位置，代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> canJump(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; dp(nums.size(), <span style="color: #800080;">0</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt; nums.size(); ++<span style="color: #000000;">i) {
            dp[i] </span>= max(dp[i - <span style="color: #800080;">1</span>], nums[i - <span style="color: #800080;">1</span>]) - <span style="color: #800080;">1</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> (dp[i] &lt; <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> dp.back() &gt;= <span style="color: #800080;">0</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>其实这题最好的解法不是DP，而是贪婪算法Greedy Algorithm，因为我们并不是很关心每一个位置上的剩余步数，我们只希望知道能否到达末尾，也就是说我们只对最远能到达的位置感兴趣，所以我们维护一个变量reach，表示最远能到达的位置，初始化为0。遍历数组中每一个数字，如果当前坐标大于reach或者reach已经抵达最后一个位置则跳出循环，否则就更新reach的值为其和i + nums[i]中的较大值，其中i + nums[i]表示当前位置能到达的最大位置，代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> canJump(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        </span><span style="color: #0000ff;">int</span> n = nums.size(), reach = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (i &gt; reach || reach &gt;= n - <span style="color: #800080;">1</span>) <span style="color: #0000ff;">break</span><span style="color: #000000;">;
            reach </span>= max(reach, i +<span style="color: #000000;"> nums[i]);
        }
        </span><span style="color: #0000ff;">return</span> reach &gt;= n - <span style="color: #800080;">1</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4373533.html" target="_blank">Jump Game II</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-03-27 13:17</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4371526" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4371526);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4362675.html" id="cb_post_title_url">[LeetCode] Spiral Matrix 螺旋矩阵</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a matrix of <em>m</em> x <em>n</em> elements (<em>m</em> rows, <em>n</em>columns), return all elements of the matrix in spiral order.</p>
<p>Example 1:</p>
<pre>Input:
[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]
Output: [1,2,3,6,9,8,7,4,5]
</pre>
<p>Example 2:</p>
<pre>Input:
[
  [1, 2, 3, 4],
  [5, 6, 7, 8],
  [9,10,11,12]
]
Output: [1,2,3,4,8,12,11,10,9,5,6,7]</pre>
<p> </p>
<p>这道题让我们将一个矩阵按照螺旋顺序打印出来，我们只能一条边一条边的打印，首先我们要从给定的mxn的矩阵中算出按螺旋顺序有几个环，注意最终间的环可以是一个数字，也可以是一行或者一列。环数的计算公式是 min(m, n) / 2，知道了环数，我们可以对每个环的边按顺序打印，比如对于题目中给的那个例子，个边生成的顺序是(用颜色标记了数字) Red -&gt; Green -&gt; Blue -&gt; Yellow -&gt; Black </p>
<p><span style="color: #ff0000;">1　2　3</span></p>
<p><span style="color: #ff9900;">4</span>　5　<span style="color: #008000;">6</span></p>
<p><span style="color: #0000ff;">7　8</span>　<span style="color: #008000;">9</span></p>
<p> </p>
<p>我们定义p，q为当前环的高度和宽度，当p或者q为1时，表示最后一个环只有一行或者一列，可以跳出循环。此题的难点在于下标的转换，如何正确的转换下标是解此题的关键，我们可以对照着上面的3x3的例子来完成下标的填写，代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; spiralOrder(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt; &gt; &amp;<span style="color: #000000;">matrix) {
        </span><span style="color: #0000ff;">if</span> (matrix.empty() || matrix[<span style="color: #800080;">0</span>].empty()) <span style="color: #0000ff;">return</span><span style="color: #000000;"> {};
        </span><span style="color: #0000ff;">int</span> m = matrix.size(), n = matrix[<span style="color: #800080;">0</span><span style="color: #000000;">].size();
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">int</span> c = m &gt; n ? (n + <span style="color: #800080;">1</span>) / <span style="color: #800080;">2</span> : (m + <span style="color: #800080;">1</span>) / <span style="color: #800080;">2</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> p = m, q =<span style="color: #000000;"> n;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; c; ++i, p -= <span style="color: #800080;">2</span>, q -= <span style="color: #800080;">2</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> col = i; col &lt; i + q; ++<span style="color: #000000;">col) 
                res.push_back(matrix[i][col]);
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> row = i + <span style="color: #800080;">1</span>; row &lt; i + p; ++<span style="color: #000000;">row)
                res.push_back(matrix[row][i </span>+ q - <span style="color: #800080;">1</span><span style="color: #000000;">]);
            </span><span style="color: #0000ff;">if</span> (p == <span style="color: #800080;">1</span> || q == <span style="color: #800080;">1</span>) <span style="color: #0000ff;">break</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> col = i + q - <span style="color: #800080;">2</span>; col &gt;= i; --<span style="color: #000000;">col)
                res.push_back(matrix[i </span>+ p - <span style="color: #800080;">1</span><span style="color: #000000;">][col]);
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> row = i + p - <span style="color: #800080;">2</span>; row &gt; i; --<span style="color: #000000;">row) 
                res.push_back(matrix[row][i]);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>如果觉得上面解法中的下标的转换比较难弄的话，我们可以使用下面这种坐标稍稍简洁一些的方法。对于这种螺旋遍历的方法，重要的是要确定上下左右四条边的位置，那么初始化的时候，上边up就是0，下边down就是m-1，左边left是0，右边right是n-1。然后我们进行while循环，先遍历上边，将所有元素加入结果res，然后上边下移一位，如果此时上边大于下边，说明此时已经遍历完成了，直接break。同理对于下边，左边，右边，依次进行相对应的操作，这样就会使得坐标很有规律，并且不易出错，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; spiralOrder(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> matrix) {
        </span><span style="color: #0000ff;">if</span> (matrix.empty() || matrix[<span style="color: #800080;">0</span>].empty()) <span style="color: #0000ff;">return</span><span style="color: #000000;"> {};
        </span><span style="color: #0000ff;">int</span> m = matrix.size(), n = matrix[<span style="color: #800080;">0</span><span style="color: #000000;">].size();
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">int</span> up = <span style="color: #800080;">0</span>, down = m - <span style="color: #800080;">1</span>, left = <span style="color: #800080;">0</span>, right = n - <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (<span style="color: #0000ff;">true</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = left; j &lt;= right; ++<span style="color: #000000;">j) res.push_back(matrix[up][j]);
            </span><span style="color: #0000ff;">if</span> (++up &gt; down) <span style="color: #0000ff;">break</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = up; i &lt;= down; ++<span style="color: #000000;">i) res.push_back(matrix[i][right]);
            </span><span style="color: #0000ff;">if</span> (--right &lt; left) <span style="color: #0000ff;">break</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = right; j &gt;= left; --<span style="color: #000000;">j) res.push_back(matrix[down][j]);
            </span><span style="color: #0000ff;">if</span> (--down &lt; up) <span style="color: #0000ff;">break</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = down; i &gt;= up; --<span style="color: #000000;">i) res.push_back(matrix[i][left]);
            </span><span style="color: #0000ff;">if</span> (++left &gt; right) <span style="color: #0000ff;">break</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4362813.html" target="_blank">Spiral Matrix II</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-03-24 14:22</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4362675" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4362675);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4377150.html" id="cb_post_title_url">[LeetCode] Maximum Subarray 最大子数组</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Find the contiguous subarray within an array (containing at least one number) which has the largest sum.</p>
<p>For example, given the array <code>[−2,1,−3,4,−1,2,1,−5,4]</code>,<br/>the contiguous subarray <code>[4,−1,2,1]</code> has the largest sum = <code>6</code>.</p>
<div class="spoilers">More practice:
<p>If you have figured out the O(<em>n</em>) solution, try coding another solution using the divide and conquer approach, which is more subtle.</p>
</div>
<p> </p>
<p>这道题让我们求最大子数组之和，并且要我们用两种方法来解，分别是O(n)的解法，还有用分治法Divide and Conquer Approach，这个解法的时间复杂度是O(nlgn)，那我们就先来看O(n)的解法，定义两个变量res和curSum，其中res保存最终要返回的结果，即最大的子数组之和，curSum初始值为0，每遍历一个数字num，比较curSum + num和num中的较大值存入curSum，然后再把res和curSum中的较大值存入res，以此类推直到遍历完整个数组，可得到最大子数组的值存在res中，代码如下：</p>
<p> </p>
<p>C++ 解法一:</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> maxSubArray(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        </span><span style="color: #0000ff;">int</span> res = INT_MIN, curSum = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span><span style="color: #000000;"> num : nums) {
            curSum </span>= max(curSum +<span style="color: #000000;"> num, num);
            res </span>=<span style="color: #000000;"> max(res, curSum);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>Java 解法一:</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span> maxSubArray(<span style="color: #0000ff;">int</span><span style="color: #000000;">[] nums) {
        </span><span style="color: #0000ff;">int</span> res = Integer.MIN_VALUE, curSum = 0<span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span><span style="color: #000000;"> num : nums) {
            curSum </span>= Math.max(curSum +<span style="color: #000000;"> num, num);
            res </span>=<span style="color: #000000;"> Math.max(res, curSum);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
}</span></pre>
</div>
<p> </p>
<p>题目还要求我们用分治法Divide and Conquer Approach来解，这个分治法的思想就类似于二分搜索法，我们需要把数组一分为二，分别找出左边和右边的最大子数组之和，然后还要从中间开始向左右分别扫描，求出的最大值分别和左右两边得出的最大值相比较取最大的那一个，代码如下：</p>
<p> </p>
<p>C++ 解法二:</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> maxSubArray(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        </span><span style="color: #0000ff;">if</span> (nums.empty()) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span> helper(nums, <span style="color: #800080;">0</span>, (<span style="color: #0000ff;">int</span>)nums.size() - <span style="color: #800080;">1</span><span style="color: #000000;">);
    }
    </span><span style="color: #0000ff;">int</span> helper(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; nums, <span style="color: #0000ff;">int</span> left, <span style="color: #0000ff;">int</span><span style="color: #000000;"> right) {
        </span><span style="color: #0000ff;">if</span> (left &gt;= right) <span style="color: #0000ff;">return</span><span style="color: #000000;"> nums[left];
        </span><span style="color: #0000ff;">int</span> mid = left + (right - left) / <span style="color: #800080;">2</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> lmax = helper(nums, left, mid - <span style="color: #800080;">1</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">int</span> rmax = helper(nums, mid + <span style="color: #800080;">1</span><span style="color: #000000;">, right);
        </span><span style="color: #0000ff;">int</span> mmax = nums[mid], t =<span style="color: #000000;"> mmax;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = mid - <span style="color: #800080;">1</span>; i &gt;= left; --<span style="color: #000000;">i) {
            t </span>+=<span style="color: #000000;"> nums[i];
            mmax </span>=<span style="color: #000000;"> max(mmax, t);
        }
        t </span>=<span style="color: #000000;"> mmax;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = mid + <span style="color: #800080;">1</span>; i &lt;= right; ++<span style="color: #000000;">i) {
            t </span>+=<span style="color: #000000;"> nums[i];
            mmax </span>=<span style="color: #000000;"> max(mmax, t);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> max(mmax, max(lmax, rmax));
    }
};</span></pre>
</div>
<p> </p>
<p>Java 解法二:</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span> maxSubArray(<span style="color: #0000ff;">int</span><span style="color: #000000;">[] nums) {
        </span><span style="color: #0000ff;">if</span> (nums.length == 0) <span style="color: #0000ff;">return</span> 0<span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span> helper(nums, 0, nums.length - 1<span style="color: #000000;">);
    }
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span> helper(<span style="color: #0000ff;">int</span>[] nums, <span style="color: #0000ff;">int</span> left, <span style="color: #0000ff;">int</span><span style="color: #000000;"> right) {
        </span><span style="color: #0000ff;">if</span> (left &gt;= right) <span style="color: #0000ff;">return</span><span style="color: #000000;"> nums[left];
        </span><span style="color: #0000ff;">int</span> mid = left + (right - left) / 2<span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> lmax = helper(nums, left, mid - 1<span style="color: #000000;">);
        </span><span style="color: #0000ff;">int</span> rmax = helper(nums, mid + 1<span style="color: #000000;">, right);
        </span><span style="color: #0000ff;">int</span> mmax = nums[mid], t =<span style="color: #000000;"> mmax;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = mid - 1; i &gt;= left; --<span style="color: #000000;">i) {
            t </span>+=<span style="color: #000000;"> nums[i];
            mmax </span>=<span style="color: #000000;"> Math.max(mmax, t);
        }
        t </span>=<span style="color: #000000;"> mmax;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = mid + 1; i &lt;= right; ++<span style="color: #000000;">i) {
            t </span>+=<span style="color: #000000;"> nums[i];
            mmax </span>=<span style="color: #000000;"> Math.max(mmax, t);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> Math.max(mmax, Math.max(lmax, rmax));
    }
}</span></pre>
</div>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-03-30 09:20</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4377150" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4377150);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4380706.html" id="cb_post_title_url">[LeetCode] N-Queens II N皇后问题之二</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Follow up for N-Queens problem.</p>
<p>Now, instead outputting board configurations, return the total number of distinct solutions.</p>
<p><img alt="" src="http://www.leetcode.com/wp-content/uploads/2012/03/8-queens.png"/></p>
<p> </p>
<p>这道题是之前那道<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4377782.html" id="homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0"> N-Queens N皇后问题</a> 的延伸，说是延伸其实我觉得两者顺序应该颠倒一样，上一道题比这道题还要稍稍复杂一些，两者本质上没有啥区别，都是要用回溯法Backtracking来解，如果理解了之前那道题的思路，此题只要做很小的改动即可，不再需要求出具体的皇后的摆法，只需要每次生成一种解法时，计数器加一即可，代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> totalNQueens(<span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; pos(n, -<span style="color: #800080;">1</span><span style="color: #000000;">);
        totalNQueensDFS(pos, </span><span style="color: #800080;">0</span><span style="color: #000000;">, res);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">void</span> totalNQueensDFS(vector&lt;<span style="color: #0000ff;">int</span>&gt; &amp;pos, <span style="color: #0000ff;">int</span> row, <span style="color: #0000ff;">int</span> &amp;<span style="color: #000000;">res) {
        </span><span style="color: #0000ff;">int</span> n =<span style="color: #000000;"> pos.size();
        </span><span style="color: #0000ff;">if</span> (row == n) ++<span style="color: #000000;">res;
        </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> col = <span style="color: #800080;">0</span>; col &lt; n; ++<span style="color: #000000;">col) {
                </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (isValid(pos, row, col)) {
                    pos[row] </span>=<span style="color: #000000;"> col;
                    totalNQueensDFS(pos, row </span>+ <span style="color: #800080;">1</span><span style="color: #000000;">, res);
                    pos[row] </span>= -<span style="color: #800080;">1</span><span style="color: #000000;">;
                }
            }
        }
    }
    </span><span style="color: #0000ff;">bool</span> isValid(vector&lt;<span style="color: #0000ff;">int</span>&gt; &amp;pos, <span style="color: #0000ff;">int</span> row, <span style="color: #0000ff;">int</span><span style="color: #000000;"> col) {
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; row; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (col == pos[i] || abs(row - i) == abs(col -<span style="color: #000000;"> pos[i])) {
                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            }
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-03-31 13:54</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4380706" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4380706);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4377782.html" id="cb_post_title_url">[LeetCode] N-Queens N皇后问题</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>The <em>n</em>-queens puzzle is the problem of placing <em>n</em> queens on an <em>n</em>×<em>n</em> chessboard such that no two queens attack each other.</p>
<p><img alt="" src="http://www.leetcode.com/wp-content/uploads/2012/03/8-queens.png"/></p>
<p>Given an integer <em>n</em>, return all distinct solutions to the <em>n</em>-queens puzzle.</p>
<p>Each solution contains a distinct board configuration of the <em>n</em>-queens' placement, where <code>'Q'</code> and <code>'.'</code> both indicate a queen and an empty space respectively.</p>
<p>For example,<br/>There exist two distinct solutions to the 4-queens puzzle:</p>
<pre>[
 [".Q..",  // Solution 1
  "...Q",
  "Q...",
  "..Q."],

 ["..Q.",  // Solution 2
  "Q...",
  "...Q",
  ".Q.."]
]</pre>
<p> </p>
<p>经典的N皇后问题，基本所有的算法书中都会包含的问题，经典解法为回溯递归，一层一层的向下扫描，需要用到一个pos数组，其中pos[i]表示第i行皇后的位置，初始化为-1，然后从第0开始递归，每一行都一次遍历各列，判断如果在该位置放置皇后会不会有冲突，以此类推，当到最后一行的皇后放好后，一种解法就生成了，将其存入结果res中，然后再还会继续完成搜索所有的情况，代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;vector&lt;<span style="color: #0000ff;">string</span>&gt; &gt; solveNQueens(<span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">string</span>&gt; &gt;<span style="color: #000000;"> res;
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; pos(n, -<span style="color: #800080;">1</span><span style="color: #000000;">);
        solveNQueensDFS(pos, </span><span style="color: #800080;">0</span><span style="color: #000000;">, res);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">void</span> solveNQueensDFS(vector&lt;<span style="color: #0000ff;">int</span>&gt; &amp;pos, <span style="color: #0000ff;">int</span> row, vector&lt;vector&lt;<span style="color: #0000ff;">string</span>&gt; &gt; &amp;<span style="color: #000000;">res) {
        </span><span style="color: #0000ff;">int</span> n =<span style="color: #000000;"> pos.size();
        </span><span style="color: #0000ff;">if</span> (row ==<span style="color: #000000;"> n) {
            vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; <span style="color: #0000ff;">out</span>(n, <span style="color: #0000ff;">string</span>(n, <span style="color: #800000;">'</span><span style="color: #800000;">.</span><span style="color: #800000;">'</span><span style="color: #000000;">));
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
                </span><span style="color: #0000ff;">out</span>[i][pos[i]] = <span style="color: #800000;">'</span><span style="color: #800000;">Q</span><span style="color: #800000;">'</span><span style="color: #000000;">;
            }
            res.push_back(</span><span style="color: #0000ff;">out</span><span style="color: #000000;">);
        } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> col = <span style="color: #800080;">0</span>; col &lt; n; ++<span style="color: #000000;">col) {
                </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (isValid(pos, row ,col)) {
                    pos[row] </span>=<span style="color: #000000;"> col;
                    solveNQueensDFS(pos, row </span>+ <span style="color: #800080;">1</span><span style="color: #000000;">, res);
                    pos[row] </span>= -<span style="color: #800080;">1</span><span style="color: #000000;">;
                }
            }
        }
    }
    </span><span style="color: #0000ff;">bool</span> isValid(vector&lt;<span style="color: #0000ff;">int</span>&gt; &amp;pos, <span style="color: #0000ff;">int</span> row, <span style="color: #0000ff;">int</span><span style="color: #000000;"> col) {
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; row; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (col == pos[i] || abs(row - i) == abs(col -<span style="color: #000000;"> pos[i])) {
                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            }
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>此题还有非递归的解法，请参见网友<a href="http://www.cnblogs.com/TenosDoIt/p/3801621.html" target="_blank">JustDoIt的博客</a>。</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-03-30 13:18</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4377782" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4377782);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4383775.html" id="cb_post_title_url">[LeetCode] Pow(x, n) 求x的n次方</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Implement pow(<em>x</em>, <em>n</em>).</p>
<p> </p>
<p>这道题让我们求x的n次方，如果我们只是简单的用个for循环让x乘以自己n次的话，未免也把LeetCode上的题想的太简单了，一句话形容图样图森破啊。OJ因超时无法通过，所以我们需要优化我们的算法，使其在更有效的算出结果来。我们可以用递归来折半计算，每次把n缩小一半，这样n最终会缩小到0，任何数的0次方都为1，这时候我们再往回乘，如果此时n是偶数，直接把上次递归得到的值算个平方返回即可，如果是奇数，则还需要乘上个x的值。还有一点需要引起我们的注意的是n有可能为负数，对于n是负数的情况，我们可以先用其绝对值计算出一个结果再取其倒数即可，代码如下：</p>
<p> </p>
<p>解法一:</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">double</span> myPow(<span style="color: #0000ff;">double</span> x, <span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        </span><span style="color: #0000ff;">if</span> (n &lt; <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span> <span style="color: #800080;">1</span> / power(x, -<span style="color: #000000;">n);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> power(x, n);
    }
    </span><span style="color: #0000ff;">double</span> power(<span style="color: #0000ff;">double</span> x, <span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        </span><span style="color: #0000ff;">if</span> (n == <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span> <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">double</span> half = power(x, n / <span style="color: #800080;">2</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">if</span> (n % <span style="color: #800080;">2</span> == <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span> half *<span style="color: #000000;"> half;
        </span><span style="color: #0000ff;">return</span> x * half *<span style="color: #000000;"> half;
    }
};</span></pre>
</div>
<p><span style="line-height: 1.5;"> </span></p>
<p>还有一种写法可以只用一个函数即可，在每次递归中处理n的正负，然后做相应的变换即可，代码如下：</p>
<p> </p>
<p>解法二:</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">double</span> myPow(<span style="color: #0000ff;">double</span> x, <span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        </span><span style="color: #0000ff;">if</span> (n == <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span> <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">double</span> half = myPow(x, n / <span style="color: #800080;">2</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">if</span> (n % <span style="color: #800080;">2</span> == <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span> half *<span style="color: #000000;"> half;
        </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (n &gt; <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span> half * half *<span style="color: #000000;"> x;
        </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">return</span> half * half /<span style="color: #000000;"> x;
    }
};</span></pre>
</div>
<p> </p>
<p>这道题还有迭代的解法，我们让i初始化为n，然后看i是否是2的倍数，是的话x乘以自己，否则res乘以x，i每次循环缩小一半，直到为0停止循环。最后看n的正负，如果为负，返回其倒数，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">double</span> myPow(<span style="color: #0000ff;">double</span> x, <span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        </span><span style="color: #0000ff;">double</span> res = <span style="color: #800080;">1.0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = n; i != <span style="color: #800080;">0</span>; i /= <span style="color: #800080;">2</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">if</span> (i % <span style="color: #800080;">2</span> != <span style="color: #800080;">0</span>) res *=<span style="color: #000000;"> x;
            x </span>*=<span style="color: #000000;"> x;
        }
        </span><span style="color: #0000ff;">return</span> n &lt; <span style="color: #800080;">0</span> ? <span style="color: #800080;">1</span> /<span style="color: #000000;"> res : res;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/2836/o-logn-solution-in-java" target="_blank">https://discuss.leetcode.com/topic/2836/o-logn-solution-in-java</a></p>
<p><a href="https://discuss.leetcode.com/topic/4165/simple-iterative-lg-n-solution/3" target="_blank">https://discuss.leetcode.com/topic/4165/simple-iterative-lg-n-solution/3</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-04-01 14:34</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4383775" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4383775);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4385822.html" id="cb_post_title_url">[LeetCode] Group Anagrams 群组错位词</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given an array of strings, group anagrams together.</p>
<p>For example, given: <code>["eat", "tea", "tan", "ate", "nat", "bat"]</code>, <br/>Return:</p>
<pre>[
  ["ate", "eat","tea"],
  ["nat","tan"],
  ["bat"]
]</pre>
<p> </p>
<p>Note: All inputs will be in lower-case.</p>
<p> </p>
<p>这道题让我们群组给定字符串集中所有的错位词，所谓的错位词就是两个字符串中字母出现的次数都一样，只是位置不同，比如abc，bac, cba等它们就互为错位词，那么我们如何判断两者是否是错位词呢，我们发现如果把错位词的字符顺序重新排列，那么会得到相同的结果，所以重新排序是判断是否互为错位词的方法，由于错位词重新排序后都会得到相同的字符串，我们以此作为key，将所有错位词都保存到字符串数组中，建立key和字符串数组之间的映射，最后再存入结果res中即可，擦巾代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;vector&lt;<span style="color: #0000ff;">string</span>&gt;&gt; groupAnagrams(vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp;<span style="color: #000000;"> strs) {
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">string</span>&gt;&gt;<span style="color: #000000;"> res;
        unordered_map</span>&lt;<span style="color: #0000ff;">string</span>, vector&lt;<span style="color: #0000ff;">string</span>&gt;&gt;<span style="color: #000000;"> m;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">string</span><span style="color: #000000;"> str : strs) {
            </span><span style="color: #0000ff;">string</span> t =<span style="color: #000000;"> str;
            sort(t.begin(), t.end());
            m[t].push_back(str);
        }
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto a : m) {
            res.push_back(a.second);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种解法没有用到排序，提高了运算效率，我们用一个大小为26的int数组来统计每个单词中字符出现的次数，然后将int数组转为一个唯一的字符串，跟字符串数组进行映射，这样我们就不用给字符串排序了，代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;vector&lt;<span style="color: #0000ff;">string</span>&gt;&gt; groupAnagrams(vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp;<span style="color: #000000;"> strs) {
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">string</span>&gt;&gt;<span style="color: #000000;"> res;
        unordered_map</span>&lt;<span style="color: #0000ff;">string</span>, vector&lt;<span style="color: #0000ff;">string</span>&gt;&gt;<span style="color: #000000;"> m;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">string</span><span style="color: #000000;"> str : strs) {
            vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; cnt(<span style="color: #800080;">26</span>, <span style="color: #800080;">0</span><span style="color: #000000;">);
            </span><span style="color: #0000ff;">string</span> t = <span style="color: #800000;">""</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span> c : str) ++cnt[c - <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span><span style="color: #000000;">];
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> d : cnt) t += to_string(d) + <span style="color: #800000;">"</span><span style="color: #800000;">/</span><span style="color: #800000;">"</span><span style="color: #000000;">;
            m[t].push_back(str);
        }
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto a : m) {
            res.push_back(a.second);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/24494/share-my-short-java-solution" target="_blank">https://discuss.leetcode.com/topic/24494/share-my-short-java-solution</a></p>
<p><a href="https://discuss.leetcode.com/topic/21038/10-lines-76ms-easy-c-solution-updated-function-signature/2" target="_blank">https://discuss.leetcode.com/topic/21038/10-lines-76ms-easy-c-solution-updated-function-signature/2</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-04-02 06:14</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4385822" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4385822);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4389572.html" id="cb_post_title_url">[LeetCode] Rotate Image 旋转图像</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>You are given an <em>n</em> x <em>n</em> 2D matrix representing an image.</p>
<p>Rotate the image by 90 degrees (clockwise).</p>
<p>Follow up:<br/>Could you do this in-place?</p>
<p> </p>
<p>在计算机图像处理里，旋转图片是很常见的，由于图片的本质是二维数组，所以也就变成了对数组的操作处理，翻转的本质就是某个位置上数移动到另一个位置上，比如用一个简单的例子来分析：</p>
<p>1  2  3　　　 　　 7  4  1　</p>
<p>4  5  6　　--&gt;　　 8  5  2　　</p>
<p>7  8  9 　　　 　　9  6  3</p>
<p>对于90度的翻转有很多方法，一步或多步都可以解，我们先来看一种直接的方法，对于当前位置，计算旋转后的新位置，然后再计算下一个新位置，第四个位置又变成当前位置了，所以这个方法每次循环换四个数字，如下所示：</p>
<p>1  2  3                 <span style="color: #ff0000;">7</span>  2  <span style="color: #ff0000;">1                  </span>7  <span style="color: #ff0000;">4</span>  1</p>
<p>4  5  6      --&gt;      4  5  6　　 --&gt;  　 <span style="color: #ff0000;">8</span>  5  <span style="color: #ff0000;">2</span>　　</p>
<p>7  8  9                 <span style="color: #ff0000;">9</span>  8  <span style="color: #ff0000;">3</span>　　　　　 9  <span style="color: #ff0000;">6</span>  3</p>
<p>解法一</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">void</span> rotate(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt; &gt; &amp;<span style="color: #000000;">matrix) {
        </span><span style="color: #0000ff;">int</span> n =<span style="color: #000000;"> matrix.size();
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n / <span style="color: #800080;">2</span>; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = i; j &lt; n - <span style="color: #800080;">1</span> - i; ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">int</span> tmp =<span style="color: #000000;"> matrix[i][j];
                matrix[i][j] </span>= matrix[n - <span style="color: #800080;">1</span> -<span style="color: #000000;"> j][i];
                matrix[n </span>- <span style="color: #800080;">1</span> - j][i] = matrix[n - <span style="color: #800080;">1</span> - i][n - <span style="color: #800080;">1</span> -<span style="color: #000000;"> j];
                matrix[n </span>- <span style="color: #800080;">1</span> - i][n - <span style="color: #800080;">1</span> - j] = matrix[j][n - <span style="color: #800080;">1</span> -<span style="color: #000000;"> i];
                matrix[j][n </span>- <span style="color: #800080;">1</span> - i] =<span style="color: #000000;"> tmp;
            }
        }
    }
};</span></pre>
</div>
<p> </p>
<p>还有一种解法，首先以从对角线为轴翻转，然后再以x轴中线上下翻转即可得到结果，如下图所示(其中蓝色数字表示翻转轴)：</p>
<p>1  2  3　　　 　　 <span style="color: #ff0000;">9</span>  <span style="color: #ff0000;">6</span>  <span style="color: #0000ff;">3</span>　　　　　  <span style="color: #ff0000;">7  4  1</span></p>
<p>4  5  6　　--&gt;　　 <span style="color: #ff0000;">8</span>  <span style="color: #0000ff;">5</span>  <span style="color: #ff0000;">2</span>　　 --&gt;   　<span style="color: #0000ff;"> 8  5  2</span>　　</p>
<p>7  8  9 　　　 　　<span style="color: #0000ff;">7</span>  <span style="color: #ff0000;">4</span>  <span style="color: #ff0000;">1</span>　　　　　 <span style="color: #ff0000;"> 9  6  3</span></p>
<p>解法二</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">void</span> rotate(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt; &gt; &amp;<span style="color: #000000;">matrix) {
        </span><span style="color: #0000ff;">int</span> n =<span style="color: #000000;"> matrix.size();
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n - <span style="color: #800080;">1</span>; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; n - i; ++<span style="color: #000000;">j) {
                swap(matrix[i][j], matrix[n </span>- <span style="color: #800080;">1</span>- j][n - <span style="color: #800080;">1</span> -<span style="color: #000000;"> i]);
            }
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n / <span style="color: #800080;">2</span>; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; n; ++<span style="color: #000000;">j) {
                swap(matrix[i][j], matrix[n </span>- <span style="color: #800080;">1</span> -<span style="color: #000000;"> i][j]);
            }
        }
    }
};</span></pre>
</div>
<p> </p>
<p>最后再来看一种方法，这种方法首先对原数组取其转置矩阵，然后把每行的数字翻转可得到结果，如下所示(其中蓝色数字表示翻转轴)：</p>
<p>1  2  3　　　 　　 <span style="color: #0000ff;">1</span>  <span style="color: #ff0000;">4</span>  <span style="color: #ff0000;">7</span>　　　　　  <span style="color: #ff0000;">7</span>  <span style="color: #0000ff;">4</span>  <span style="color: #ff0000;">1</span></p>
<p>4  5  6　　--&gt;　　 <span style="color: #ff0000;">2</span>  <span style="color: #0000ff;">5</span>  <span style="color: #ff0000;">8</span>　　 --&gt;  　  <span style="color: #ff0000;">8</span>  <span style="color: #0000ff;">5</span>  <span style="color: #ff0000;">2</span>　　</p>
<p>7  8  9 　　　 　　<span style="color: #ff0000;">3</span>  <span style="color: #ff0000;">6</span>  <span style="color: #0000ff;">9</span>　　　　      <span style="color: #ff0000;">9</span>  <span style="color: #0000ff;">6</span>  <span style="color: #ff0000;">3</span></p>
<p>解法三</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">void</span> rotate(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt; &gt; &amp;<span style="color: #000000;">matrix) {
        </span><span style="color: #0000ff;">int</span> n =<span style="color: #000000;"> matrix.size();
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = i + <span style="color: #800080;">1</span>; j &lt; n; ++<span style="color: #000000;">j) {
                swap(matrix[i][j], matrix[j][i]);
            }
            reverse(matrix[i].begin(), matrix[i].end());
        }
    }
};</span></pre>
</div>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-04-03 11:33</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4389572" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4389572);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4359825.html" id="cb_post_title_url">[LeetCode] Permutations II 全排列之二</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a collection of numbers that might contain duplicates, return all possible unique permutations.</p>
<p>For example,<br/><code>[1,1,2]</code> have the following unique permutations:<br/><code>[1,1,2]</code>, <code>[1,2,1]</code>, and <code>[2,1,1]</code>.</p>
<p> </p>
<p>这道题是之前那道<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4358848.html" id="homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0"> Permutations 全排列</a>的延伸，由于输入数组有可能出现重复数字，如果按照之前的算法运算，会有重复排列产生，我们要避免重复的产生，在递归函数中要判断前面一个数和当前的数是否相等，如果相等，前面的数必须已经使用了，即对应的visited中的值为1，当前的数字才能使用，否则需要跳过，这样就不会产生重复排列了，代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt; &gt; permuteUnique(vector&lt;<span style="color: #0000ff;">int</span>&gt; &amp;<span style="color: #000000;">num) {
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt; &gt;<span style="color: #000000;"> res;
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; <span style="color: #0000ff;">out</span><span style="color: #000000;">;
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; visited(num.size(), <span style="color: #800080;">0</span><span style="color: #000000;">);
        sort(num.begin(), num.end());
        permuteUniqueDFS(num, </span><span style="color: #800080;">0</span>, visited, <span style="color: #0000ff;">out</span><span style="color: #000000;">, res);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">void</span> permuteUniqueDFS(vector&lt;<span style="color: #0000ff;">int</span>&gt; &amp;num, <span style="color: #0000ff;">int</span> level, vector&lt;<span style="color: #0000ff;">int</span>&gt; &amp;visited, vector&lt;<span style="color: #0000ff;">int</span>&gt; &amp;<span style="color: #0000ff;">out</span>, vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt; &gt; &amp;<span style="color: #000000;">res) {
        </span><span style="color: #0000ff;">if</span> (level &gt;= num.size()) res.push_back(<span style="color: #0000ff;">out</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; num.size(); ++<span style="color: #000000;">i) {
                </span><span style="color: #0000ff;">if</span> (visited[i] == <span style="color: #800080;">0</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">if</span> (i &gt; <span style="color: #800080;">0</span> &amp;&amp; num[i] == num[i - <span style="color: #800080;">1</span>] &amp;&amp; visited[i - <span style="color: #800080;">1</span>] == <span style="color: #800080;">0</span>) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                    visited[i] </span>= <span style="color: #800080;">1</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">out</span><span style="color: #000000;">.push_back(num[i]);
                    permuteUniqueDFS(num, level </span>+ <span style="color: #800080;">1</span>, visited, <span style="color: #0000ff;">out</span><span style="color: #000000;">, res);
                    </span><span style="color: #0000ff;">out</span><span style="color: #000000;">.pop_back();
                    visited[i] </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
                }
            }
        }
    }
};</span></pre>
</div>
<p> </p>
<p>还有一种比较简便的方法，在<a href="http://www.cnblogs.com/grandyang/p/4358848.html" target="_blank">Permutations</a>的基础上稍加修改，我们用set来保存结果，利用其不会有重复项的特点，然后我们再递归函数中的swap的地方，判断如果i和start不相同，但是nums[i]和nums[start]相同的情况下跳过，继续下一个循环，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; permuteUnique(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        </span><span style="color: #0000ff;">set</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;<span style="color: #000000;"> res;
        permute(nums, </span><span style="color: #800080;">0</span><span style="color: #000000;">, res);
        </span><span style="color: #0000ff;">return</span> vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;<span style="color: #000000;"> (res.begin(), res.end());
    }
    </span><span style="color: #0000ff;">void</span> permute(vector&lt;<span style="color: #0000ff;">int</span>&gt; &amp;nums, <span style="color: #0000ff;">int</span> start, <span style="color: #0000ff;">set</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; &amp;<span style="color: #000000;">res) {
        </span><span style="color: #0000ff;">if</span> (start &gt;=<span style="color: #000000;"> nums.size()) res.insert(nums);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = start; i &lt; nums.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (i != start &amp;&amp; nums[i] == nums[start]) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
            swap(nums[i], nums[start]);
            permute(nums, start </span>+ <span style="color: #800080;">1</span><span style="color: #000000;">, res);
            swap(nums[i], nums[start]);
        }
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4358848.html" target="_blank">Permutations</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4428207.html" target="_blank">Next Permutation</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-03-23 14:57</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4359825" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4359825);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4358848.html" id="cb_post_title_url">[LeetCode] Permutations 全排列</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a collection of numbers, return all possible permutations.</p>
<p>For example,<br/><code>[1,2,3]</code> have the following permutations:<br/><code>[1,2,3]</code>, <code>[1,3,2]</code>, <code>[2,1,3]</code>, <code>[2,3,1]</code>, <code>[3,1,2]</code>, and <code>[3,2,1]</code>.</p>
<p> </p>
<p>这道题是求全排列问题，给的输入数组没有重复项，这跟之前的那道<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4332522.html" id="cb_post_title_url"> Combinations 组合项</a> 和类似，解法基本相同，但是不同点在于那道不同的数字顺序只算一种，是一道典型的组合题，而此题是求全排列问题，还是用递归DFS来求解。这里我们需要用到一个visited数组来标记某个数字是否访问过，然后在DFS递归函数从的循环应从头开始，而不是从level开始，这是和<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4332522.html" id="cb_post_title_url"> Combinations 组合项</a> 不同的地方，其余思路大体相同，代码如下：</p>
<p>解法一</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt; &gt; permute(vector&lt;<span style="color: #0000ff;">int</span>&gt; &amp;<span style="color: #000000;">num) {
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt; &gt;<span style="color: #000000;"> res;
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; <span style="color: #0000ff;">out</span><span style="color: #000000;">;
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; visited(num.size(), <span style="color: #800080;">0</span><span style="color: #000000;">);
        permuteDFS(num, </span><span style="color: #800080;">0</span>, visited, <span style="color: #0000ff;">out</span><span style="color: #000000;">, res);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">void</span> permuteDFS(vector&lt;<span style="color: #0000ff;">int</span>&gt; &amp;num, <span style="color: #0000ff;">int</span> level, vector&lt;<span style="color: #0000ff;">int</span>&gt; &amp;visited, vector&lt;<span style="color: #0000ff;">int</span>&gt; &amp;<span style="color: #0000ff;">out</span>, vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt; &gt; &amp;<span style="color: #000000;">res) {
        </span><span style="color: #0000ff;">if</span> (level == num.size()) res.push_back(<span style="color: #0000ff;">out</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; num.size(); ++<span style="color: #000000;">i) {
                </span><span style="color: #0000ff;">if</span> (visited[i] == <span style="color: #800080;">0</span><span style="color: #000000;">) {
                    visited[i] </span>= <span style="color: #800080;">1</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">out</span><span style="color: #000000;">.push_back(num[i]);
                    permuteDFS(num, level </span>+ <span style="color: #800080;">1</span>, visited, <span style="color: #0000ff;">out</span><span style="color: #000000;">, res);
                    </span><span style="color: #0000ff;">out</span><span style="color: #000000;">.pop_back();
                    visited[i] </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
                }
            }
        }
    }
};</span></pre>
</div>
<p> </p>
<p>还有一种递归的写法，更简单一些，这里是每次交换num里面的两个数字，经过递归可以生成所有的排列情况，代码如下：</p>
<p>解法二</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt; &gt; permute(vector&lt;<span style="color: #0000ff;">int</span>&gt; &amp;<span style="color: #000000;">num) {
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt; &gt;<span style="color: #000000;"> res;
        permuteDFS(num, </span><span style="color: #800080;">0</span><span style="color: #000000;">, res);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">void</span> permuteDFS(vector&lt;<span style="color: #0000ff;">int</span>&gt; &amp;num, <span style="color: #0000ff;">int</span> start, vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt; &gt; &amp;<span style="color: #000000;">res) {
        </span><span style="color: #0000ff;">if</span> (start &gt;=<span style="color: #000000;"> num.size()) res.push_back(num);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = start; i &lt; num.size(); ++<span style="color: #000000;">i) {
            swap(num[start], num[i]);
            permuteDFS(num, start </span>+ <span style="color: #800080;">1</span><span style="color: #000000;">, res);
            swap(num[start], num[i]);
        }
    }
};</span></pre>
</div>
<p> </p>
<p>最后再来看一种方法，这种方法是CareerCup书上的方法，也挺不错的，这道题是思想是这样的：</p>
<p>当n=1时，数组中只有一个数a<sub>1</sub>，其全排列只有一种，即为a<sub>1</sub></p>
<p>当n=2时，数组中此时有a<sub>1</sub>a<sub>2</sub>，其全排列有两种，a<sub>1</sub>a<sub>2</sub>和a<sub>2</sub>a<sub>1</sub>，那么此时我们考虑和上面那种情况的关系，我们发现，其实就是在a<sub>1</sub>的前后两个位置分别加入了a<sub>2</sub></p>
<p>当n=3时，数组中有a<sub>1</sub>a<sub>2</sub>a<sub>3</sub>，此时全排列有六种，分别为a<sub>1</sub>a<sub>2</sub>a<sub>3</sub>, a<sub>1</sub>a<sub>3</sub>a<sub>2</sub>, a<sub>2</sub>a<sub>1</sub>a<sub>3</sub>, a<sub>2</sub>a<sub>3</sub>a<sub>1</sub>, a<sub>3</sub>a<sub>1</sub>a<sub>2</sub>, 和 a<sub>3</sub>a<sub>2</sub>a<sub>1</sub>。那么根据上面的结论，实际上是在a<sub>1</sub>a<sub>2</sub>和a<sub>2</sub>a<sub>1</sub>的基础上在不同的位置上加入a<sub>3</sub>而得到的。</p>
<p>_ a<sub>1 </sub>_ a<sub>2 </sub>_ : a<sub>3</sub>a<sub>1</sub>a<sub>2</sub>, a<sub>1</sub>a<sub>3</sub>a<sub>2</sub>, a<sub>1</sub>a<sub>2</sub>a<sub>3</sub></p>
<p>_ a<sub>2 </sub>_ a<sub>1 </sub>_ : a<sub>3</sub>a<sub>2</sub>a<sub>1</sub>, a<sub>2</sub>a<sub>3</sub>a<sub>1</sub>, a<sub>2</sub>a<sub>1</sub>a<sub>3</sub></p>
<p> </p>
<p>解法三:</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt; &gt; permute(vector&lt;<span style="color: #0000ff;">int</span>&gt; &amp;<span style="color: #000000;">num) {
        </span><span style="color: #0000ff;">if</span> (num.empty()) <span style="color: #0000ff;">return</span> vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt; &gt;(<span style="color: #800080;">1</span>, vector&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;">());
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt; &gt;<span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">int</span> first = num[<span style="color: #800080;">0</span><span style="color: #000000;">];
        num.erase(num.begin());
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt; &gt; words =<span style="color: #000000;"> permute(num);
        </span><span style="color: #0000ff;">for</span> (auto &amp;<span style="color: #000000;">a : words) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt;= a.size(); ++<span style="color: #000000;">i) {
                a.insert(a.begin() </span>+<span style="color: #000000;"> i, first);
                res.push_back(a);
                a.erase(a.begin() </span>+<span style="color: #000000;"> i);
            }
        }   
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4428207.html" target="_blank">Next Permutation</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4359825.html" target="_blank">Permutations II</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-03-23 08:29</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4358848" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4358848);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4373533.html" id="cb_post_title_url">[LeetCode] Jump Game II 跳跃游戏之二</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p>
<p>Each element in the array represents your maximum jump length at that position.</p>
<p>Your goal is to reach the last index in the minimum number of jumps.</p>
<p> For example:<br/>
Given array A = <code>[2,3,1,1,4]</code>
</p>
<p>
The minimum number of jumps to reach the last index is <code>2</code>. (Jump <code>1</code> step from index 0 to 1, then <code>3</code> steps to the last index.)
</p>
<p> </p>
<p>这题是之前那道<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4371526.html" id="homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0">Jump Game 跳跃游戏</a> 的延伸，那题是问能不能到达最后一个数字，而此题只让我们求到达最后一个位置的最少跳跃数，貌似是默认一定能到达最后位置的? 此题的核心方法是利用贪婪算法Greedy的思想来解，想想为什么呢？ 为了较快的跳到末尾，我们想知道每一步能跳的范围，这里贪婪并不是要在能跳的范围中选跳力最远的那个位置，因为这样选下来不一定是最优解，这么一说感觉又有点不像贪婪算法了。我们这里贪的是一个能到达的最远范围，我们遍历当前跳跃能到的所有位置，然后根据该位置上的跳力来预测下一步能跳到的最远距离，贪出一个最远的范围，一旦当这个范围到达末尾时，当前所用的步数一定是最小步数。我们需要两个变量cur和pre分别来保存当前的能到达的最远位置和之前能到达的最远位置，只要cur未达到最后一个位置则循环继续，pre先赋值为cur的值，表示上一次循环后能到达的最远位置，如果当前位置i小于等于pre，说明还是在上一跳能到达的范围内，我们根据当前位置加跳力来更新cur，更新cur的方法是比较当前的cur和i + A[i]之中的较大值，如果题目中未说明是否能到达末尾，我们还可以判断此时pre和cur是否相等，如果相等说明cur没有更新，即无法到达末尾位置，返回-1，代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> jump(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, n = nums.size(), i = <span style="color: #800080;">0</span>, cur = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (cur &lt; n - <span style="color: #800080;">1</span><span style="color: #000000;">) {
            </span>++<span style="color: #000000;">res;
            </span><span style="color: #0000ff;">int</span> pre =<span style="color: #000000;"> cur;
            </span><span style="color: #0000ff;">for</span> (; i &lt;= pre; ++<span style="color: #000000;">i) {
                cur </span>= max(cur, i +<span style="color: #000000;"> nums[i]);
            }
            </span><span style="color: #0000ff;">if</span> (pre == cur) <span style="color: #0000ff;">return</span> -<span style="color: #800080;">1</span>; <span style="color: #008000;">//</span><span style="color: #008000;"> May not need this</span>
<span style="color: #000000;">        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>还有一种写法，跟上面那解法略有不同，但是本质的思想还是一样的，关于此解法的详细分析可参见网友<a href="http://www.cnblogs.com/lichen782/p/leetcode_Jump_Game_II.html" target="_blank">实验室小纸贴校外版的博客</a>，这里cur是当前能到达的最远位置，last是上一步能到达的最远位置，我们遍历数组，首先用i + nums[i]更新cur，这个在上面解法中讲过了，然后判断如果当前位置到达了last，即上一步能到达的最远位置，说明需要再跳一次了，我们将last赋值为cur，并且步数res自增1，这里我们小优化一下，判断如果cur到达末尾了，直接break掉即可，代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> jump(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, n = nums.size(), last = <span style="color: #800080;">0</span>, cur = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n - <span style="color: #800080;">1</span>; ++<span style="color: #000000;">i) {
            cur </span>= max(cur, i +<span style="color: #000000;"> nums[i]);
            </span><span style="color: #0000ff;">if</span> (i ==<span style="color: #000000;"> last) {
                last </span>=<span style="color: #000000;"> cur;
                </span>++<span style="color: #000000;">res;
                </span><span style="color: #0000ff;">if</span> (cur &gt;= n - <span style="color: #800080;">1</span>) <span style="color: #0000ff;">break</span><span style="color: #000000;">;
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4371526.html" target="_blank">Jump Game</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-03-28 03:31</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4373533" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4373533);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4401196.html" id="cb_post_title_url">[LeetCode] Wildcard Matching 外卡匹配</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Implement wildcard pattern matching with support for <code>'?'</code> and <code>'*'</code>.</p>
<pre>'?' Matches any single character.
'*' Matches any sequence of characters (including the empty sequence).

The matching should cover the <strong>entire</strong> input string (not partial).

The function prototype should be:
bool isMatch(const char *s, const char *p)

Some examples:
isMatch("aa","a") → false
isMatch("aa","aa") → true
isMatch("aaa","aa") → false
isMatch("aa", "*") → true
isMatch("aa", "a*") → true
isMatch("ab", "?*") → true
isMatch("aab", "c*a*b") → false
</pre>
<p>这道题通配符匹配问题还是小有难度的，这道里用了贪婪算法Greedy Alogrithm来解，由于有特殊字符*和？，其中？能代替任何字符，*能代替任何字符串，那么我们需要定义几个额外的指针，其中scur和pcur分别指向当前遍历到的字符，再定义pstar指向p中最后一个*的位置，sstar指向此时对应的s的位置，具体算法如下：</p>
<p>- 定义scur, pcur, sstar, pstar</p>
<p>- 如果*scur存在</p>
<p>  - 如果*scur等于*pcur或者*pcur为 '?'，则scur和pcur都自增1</p>
<p>  - 如果*pcur为'*'，则pstar指向pcur位置，pcur自增1，且sstar指向scur</p>
<p>  - 如果pstar存在，则pcur指向pstar的下一个位置，scur指向sstar自增1后的位置</p>
<p>- 如果pcur为'*'，则pcur自增1</p>
<p>- 若*pcur存在，返回False，若不存在，返回True</p>
<p> </p>
<p>C 解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">bool</span> isMatch(<span style="color: #0000ff;">char</span> *s, <span style="color: #0000ff;">char</span> *<span style="color: #000000;">p) {
    </span><span style="color: #0000ff;">char</span> *scur = s, *pcur = p, *sstar = NULL, *pstar =<span style="color: #000000;"> NULL;
    </span><span style="color: #0000ff;">while</span> (*<span style="color: #000000;">scur) {
        </span><span style="color: #0000ff;">if</span> (*scur == *pcur || *pcur == <span style="color: #800000;">'</span><span style="color: #800000;">?</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
            </span>++<span style="color: #000000;">scur;
            </span>++<span style="color: #000000;">pcur;
        } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (*pcur == <span style="color: #800000;">'</span><span style="color: #800000;">*</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
            pstar </span>= pcur++<span style="color: #000000;">;
            sstar </span>=<span style="color: #000000;"> scur;
        } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span><span style="color: #000000;"> (pstar) {
            pcur </span>= pstar + <span style="color: #800080;">1</span><span style="color: #000000;">;
            scur </span>= ++<span style="color: #000000;">sstar;
        } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
    } 
    </span><span style="color: #0000ff;">while</span> (*pcur == <span style="color: #800000;">'</span><span style="color: #800000;">*</span><span style="color: #800000;">'</span>) ++<span style="color: #000000;">pcur;
    </span><span style="color: #0000ff;">return</span> !*<span style="color: #000000;">pcur;
}</span></pre>
</div>
<p> </p>
<p>这道题也能用动态规划Dynamic Programming来解，写法跟之前那道题<a href="http://www.cnblogs.com/grandyang/p/4461713.html" target="_blank">Regular Expression Matching</a>很像，但是还是不一样。外卡匹配和正则匹配最大的区别就是在星号的使用规则上，对于正则匹配来说，星号不能单独存在，前面必须要有一个字符，而星号存在的意义就是表明前面这个字符的个数可以是任意个，包括0个，那么就是说即使前面这个字符并没有在s中出现过也无所谓，只要后面的能匹配上就可以了。而外卡匹配就不是这样的，外卡匹配中的星号跟前面的字符没有半毛钱关系，如果前面的字符没有匹配上，那么直接返回false了，根本不用管星号。而星号存在的作用是可以表示任意的字符串，当然只是当匹配字符串缺少一些字符的时候起作用，当匹配字符串包含目标字符串没有的字符时，将无法成功匹配。</p>
<p> </p>
<p>C++ 解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> isMatch(<span style="color: #0000ff;">string</span> s, <span style="color: #0000ff;">string</span><span style="color: #000000;"> p) {
        </span><span style="color: #0000ff;">int</span> m = s.size(), n =<span style="color: #000000;"> p.size();
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">bool</span>&gt;&gt; dp(m + <span style="color: #800080;">1</span>, vector&lt;<span style="color: #0000ff;">bool</span>&gt;(n + <span style="color: #800080;">1</span>, <span style="color: #0000ff;">false</span><span style="color: #000000;">));
        dp[</span><span style="color: #800080;">0</span>][<span style="color: #800080;">0</span>] = <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt;= n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (p[i - <span style="color: #800080;">1</span>] == <span style="color: #800000;">'</span><span style="color: #800000;">*</span><span style="color: #800000;">'</span>) dp[<span style="color: #800080;">0</span>][i] = dp[<span style="color: #800080;">0</span>][i - <span style="color: #800080;">1</span><span style="color: #000000;">];
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt;= m; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">1</span>; j &lt;= n; ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> (p[j - <span style="color: #800080;">1</span>] == <span style="color: #800000;">'</span><span style="color: #800000;">*</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                    dp[i][j] </span>= dp[i - <span style="color: #800080;">1</span>][j] || dp[i][j - <span style="color: #800080;">1</span><span style="color: #000000;">];
                } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    dp[i][j] </span>= (s[i - <span style="color: #800080;">1</span>] == p[j - <span style="color: #800080;">1</span>] || p[j - <span style="color: #800080;">1</span>] == <span style="color: #800000;">'</span><span style="color: #800000;">?</span><span style="color: #800000;">'</span>) &amp;&amp; dp[i - <span style="color: #800080;">1</span>][j - <span style="color: #800080;">1</span><span style="color: #000000;">];
                }
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> dp[m][n];
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4461713.html" target="_blank">Regular Expression Matching</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/3040/linear-runtime-and-constant-space-solution" target="_blank">https://discuss.leetcode.com/topic/3040/linear-runtime-and-constant-space-solution</a></p>
<p><a href="https://discuss.leetcode.com/topic/40118/clear-c-dp-solution-similar-to-the-last-matching-problem" target="_blank">https://discuss.leetcode.com/topic/40118/clear-c-dp-solution-similar-to-the-last-matching-problem</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-04-08 01:39</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4401196" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4401196);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4395356.html" id="cb_post_title_url">[LeetCode] Multiply Strings 字符串相乘</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given two numbers represented as strings, return multiplication of the numbers as a string.</p>
<p>Note: The numbers can be arbitrarily large and are non-negative.</p>
<p> </p>
<p>这道题让我们求两个字符串数字的相乘，输入的两个数和返回的数都是以字符串格式储存的，这样做的原因可能是这样可以计算超大数相乘，可以不受int或long的数值范围的约束，那么我们该如何来计算乘法呢，我们小时候都学过多位数的乘法过程，都是每位相乘然后错位相加，那么这里就是用到这种方法，参见网友<a href="http://www.cnblogs.com/TenosDoIt/p/3735309.html" target="_blank">JustDoIt的博客</a>，把错位相加后的结果保存到一个一维数组中，然后分别每位上算进位，最后每个数字都变成一位，然后要做的是去除掉首位0，最后把每位上的数字按顺序保存到结果中即可，代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> multiply(<span style="color: #0000ff;">string</span> num1, <span style="color: #0000ff;">string</span><span style="color: #000000;"> num2) {
        </span><span style="color: #0000ff;">string</span><span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">int</span> n1 = num1.size(), n2 =<span style="color: #000000;"> num2.size();
        </span><span style="color: #0000ff;">int</span> k = n1 + n2 - <span style="color: #800080;">2</span>, carry = <span style="color: #800080;">0</span><span style="color: #000000;">;
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; v(n1 + n2, <span style="color: #800080;">0</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n1; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; n2; ++<span style="color: #000000;">j) {
                v[k </span>- i - j] += (num1[i] - <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span>) * (num2[j] - <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span><span style="color: #000000;">);
            }
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n1 + n2; ++<span style="color: #000000;">i) {
            v[i] </span>+=<span style="color: #000000;"> carry;
            carry </span>= v[i] / <span style="color: #800080;">10</span><span style="color: #000000;">;
            v[i] </span>%= <span style="color: #800080;">10</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">int</span> i = n1 + n2 - <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (v[i] == <span style="color: #800080;">0</span>) --<span style="color: #000000;">i;
        </span><span style="color: #0000ff;">if</span> (i &lt; <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span> <span style="color: #800000;">"</span><span style="color: #800000;">0</span><span style="color: #800000;">"</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (i &gt;= <span style="color: #800080;">0</span>) res.push_back(v[i--] + <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-04-06 06:53</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4395356" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4395356);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4402392.html" id="cb_post_title_url">[LeetCode] Trapping Rain Water 收集雨水</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given <em>n</em> non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.</p>
<p>For example, <br/>Given <code>[0,1,0,2,1,0,1,3,2,1,2,1]</code>, return <code>6</code>.</p>
<p><img alt="" src="http://www.leetcode.com/wp-content/uploads/2012/08/rainwatertrap.png"/></p>
<p>The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image!</p>
<p> </p>
<p>这道收集雨水的题跟之前的那道 <a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4322653.html" id="cb_post_title_url">Largest Rectangle in Histogram 直方图中最大的矩形</a> 有些类似，但是又不太一样，我们先来看一种方法，这种方法是基于动态规划Dynamic Programming的，我们维护一个一维的dp数组，这个DP算法需要遍历两遍数组，第一遍遍历dp[i]中存入i位置左边的最大值，然后开始第二遍遍历数组，第二次遍历时找右边最大值，然后和左边最大值比较取其中的较小值，然后跟当前值A[i]相比，如果大于当前值，则将差值存入结果，代码如下：</p>
<p> </p>
<p>C++ 解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> trap(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> height) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, mx = <span style="color: #800080;">0</span>, n =<span style="color: #000000;"> height.size();
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; dp(n, <span style="color: #800080;">0</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            dp[i] </span>=<span style="color: #000000;"> mx;
            mx </span>=<span style="color: #000000;"> max(mx, height[i]);
        }
        mx </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = n - <span style="color: #800080;">1</span>; i &gt;= <span style="color: #800080;">0</span>; --<span style="color: #000000;">i) {
            dp[i] </span>=<span style="color: #000000;"> min(dp[i], mx);
            mx </span>=<span style="color: #000000;"> max(mx, height[i]);
            </span><span style="color: #0000ff;">if</span> (dp[i] &gt; height[i]) res += dp[i] -<span style="color: #000000;"> height[i];
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>Java 解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span> trap(<span style="color: #0000ff;">int</span><span style="color: #000000;">[] height) {
        </span><span style="color: #0000ff;">int</span> res = 0, mx = 0, n =<span style="color: #000000;"> height.length;
        </span><span style="color: #0000ff;">int</span>[] dp = <span style="color: #0000ff;">new</span> <span style="color: #0000ff;">int</span><span style="color: #000000;">[n];
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = 0; i &lt; n; ++<span style="color: #000000;">i) {
            dp[i] </span>=<span style="color: #000000;"> mx;
            mx </span>=<span style="color: #000000;"> Math.max(mx, height[i]);
        }
        mx </span>= 0<span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = n - 1; i &gt;= 0; --<span style="color: #000000;">i) {
            dp[i] </span>=<span style="color: #000000;"> Math.min(dp[i], mx);
            mx </span>=<span style="color: #000000;"> Math.max(mx, height[i]);
            </span><span style="color: #0000ff;">if</span> (dp[i] - height[i] &gt; 0) res += dp[i] -<span style="color: #000000;"> height[i];
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
}</span></pre>
</div>
<p> </p>
<p>最后我们来看一种只需要遍历一次即可的解法，这个算法需要left和right两个指针分别指向数组的首尾位置，从两边向中间扫描，在当前两指针确定的范围内，先比较两头找出较小值，如果较小值是left指向的值，则从左向右扫描，如果较小值是right指向的值，则从右向左扫描，若遇到的值比当较小值小，则将差值存入结果，如遇到的值大，则重新确定新的窗口范围，以此类推直至left和right指针重合，具体参见代码如下：</p>
<p> </p>
<p>C++ 解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> trap(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> height) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, l = <span style="color: #800080;">0</span>, r = height.size() - <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (l &lt;<span style="color: #000000;"> r) {
            </span><span style="color: #0000ff;">int</span> mn =<span style="color: #000000;"> min(height[l], height[r]);
            </span><span style="color: #0000ff;">if</span> (mn ==<span style="color: #000000;"> height[l]) {
                </span>++<span style="color: #000000;">l;
                </span><span style="color: #0000ff;">while</span> (l &lt; r &amp;&amp; height[l] &lt;<span style="color: #000000;"> mn) {
                    res </span>+= mn - height[l++<span style="color: #000000;">];
                }
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                </span>--<span style="color: #000000;">r;
                </span><span style="color: #0000ff;">while</span> (l &lt; r &amp;&amp; height[r] &lt;<span style="color: #000000;"> mn) {
                    res </span>+= mn - height[r--<span style="color: #000000;">];
                }
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>Java 解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span> trap(<span style="color: #0000ff;">int</span><span style="color: #000000;">[] height) {
        </span><span style="color: #0000ff;">int</span> res = 0, l = 0, r = height.length - 1<span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (l &lt;<span style="color: #000000;"> r) {
            </span><span style="color: #0000ff;">int</span> mn =<span style="color: #000000;"> Math.min(height[l], height[r]);
            </span><span style="color: #0000ff;">if</span> (height[l] ==<span style="color: #000000;"> mn) {
                </span>++<span style="color: #000000;">l;
                </span><span style="color: #0000ff;">while</span> (l &lt; r &amp;&amp; height[l] &lt;<span style="color: #000000;"> mn) {
                    res </span>+= mn - height[l++<span style="color: #000000;">];
                }
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                </span>--<span style="color: #000000;">r;
                </span><span style="color: #0000ff;">while</span> (l &lt; r &amp;&amp; height[r] &lt;<span style="color: #000000;"> mn) {
                    res </span>+= mn - height[r--<span style="color: #000000;">];
                }
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
}</span></pre>
</div>
<p> </p>
<p>我们可以对上面的解法进行进一步优化，使其更加简介：</p>
<p> </p>
<p>C++ 解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> trap(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> height) {
        </span><span style="color: #0000ff;">int</span> l = <span style="color: #800080;">0</span>, r = height.size() - <span style="color: #800080;">1</span>, level = <span style="color: #800080;">0</span>, res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (l &lt;<span style="color: #000000;"> r) {
            </span><span style="color: #0000ff;">int</span> lower = height[(height[l] &lt; height[r]) ? l++ : r--<span style="color: #000000;">];
            level </span>=<span style="color: #000000;"> max(level, lower);
            res </span>+= level -<span style="color: #000000;"> lower;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>Java 解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span> trap(<span style="color: #0000ff;">int</span><span style="color: #000000;">[] height) {
        </span><span style="color: #0000ff;">int</span> l = 0, r = height.length - 1, level = 0, res = 0<span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (l &lt;<span style="color: #000000;"> r) {
            </span><span style="color: #0000ff;">int</span> lower = height[(height[l] &lt; height[r]) ? l++ : r--<span style="color: #000000;">];
            level </span>=<span style="color: #000000;"> Math.max(level, lower);
            res </span>+= level -<span style="color: #000000;"> lower;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
}</span></pre>
</div>
<p> </p>
<p>下面这种解法是用stack来做的，博主一开始都没有注意到这道题的tag还有stack，所以以后在总结的时候还是要多多留意一下标签啊。其实用stack的方法博主感觉更容易理解，我们的做法是，遍历高度，如果此时栈为空，或者当前高度小于等于栈顶高度，则把当前高度的坐标压入栈，注意我们不直接把高度压入栈，而是把坐标压入栈，这样方便我们在后来算水平距离。当我们遇到比栈顶高度大的时候，就说明有可能会有坑存在，可以装雨水。此时我们栈里至少有一个高度，如果只有一个的话，那么不能形成坑，我们直接跳过，如果多余一个的话，那么此时把栈顶元素取出来当作坑，新的栈顶元素就是左边界，当前高度是右边界，只要取二者较小的，减去坑的高度，长度就是右边界坐标减去左边界坐标再减1，二者相乘就是盛水量啦，参见代码如下：</p>
<p> </p>
<p>C++ 解法四：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> trap(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> height) {
        stack</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> st;
        </span><span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>, res = <span style="color: #800080;">0</span>, n =<span style="color: #000000;"> height.size();
        </span><span style="color: #0000ff;">while</span> (i &lt;<span style="color: #000000;"> n) {
            </span><span style="color: #0000ff;">if</span> (st.empty() || height[i] &lt;=<span style="color: #000000;"> height[st.top()]) {
                st.push(i</span>++<span style="color: #000000;">);
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                </span><span style="color: #0000ff;">int</span> t =<span style="color: #000000;"> st.top(); st.pop();
                </span><span style="color: #0000ff;">if</span> (st.empty()) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                res </span>+= (min(height[i], height[st.top()]) - height[t]) * (i - st.top() - <span style="color: #800080;">1</span><span style="color: #000000;">);
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>Java 解法四：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span> trap(<span style="color: #0000ff;">int</span><span style="color: #000000;">[] height) {
        Stack</span>&lt;Integer&gt; s = <span style="color: #0000ff;">new</span> Stack&lt;Integer&gt;<span style="color: #000000;">();
        </span><span style="color: #0000ff;">int</span> i = 0, n = height.length, res = 0<span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (i &lt;<span style="color: #000000;"> n) {
            </span><span style="color: #0000ff;">if</span> (s.isEmpty() || height[i] &lt;=<span style="color: #000000;"> height[s.peek()]) {
                s.push(i</span>++<span style="color: #000000;">);
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                </span><span style="color: #0000ff;">int</span> t =<span style="color: #000000;"> s.pop();
                </span><span style="color: #0000ff;">if</span> (s.isEmpty()) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                res </span>+= (Math.min(height[i], height[s.peek()]) - height[t]) * (i - s.peek() - 1<span style="color: #000000;">);
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
}</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/5928987.html">Trapping Rain Water II</a> </p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/18731/7-lines-c-c/2" target="_blank">https://discuss.leetcode.com/topic/18731/7-lines-c-c/2</a></p>
<p><a href="https://discuss.leetcode.com/topic/5125/sharing-my-simple-c-code-o-n-time-o-1-space" target="_blank">https://discuss.leetcode.com/topic/5125/sharing-my-simple-c-code-o-n-time-o-1-space</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-04-08 14:46</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4402392" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4402392);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4395963.html" id="cb_post_title_url">[LeetCode] First Missing Positive 首个缺失的正数</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="question-description">
<div>
<p>Given an unsorted integer array, find the smallest missing positive integer.</p>
<p>Example 1:</p>
<pre>Input: [1,2,0]
Output: 3
</pre>
<p>Example 2:</p>
<pre>Input: [3,4,-1,1]
Output: 2
</pre>
<p>Example 3:</p>
<pre>Input: [7,8,9,11,12]
Output: 1
</pre>
<p>Note:</p>
<p>Your algorithm should run in <em>O</em>(<em>n</em>) time and uses constant extra space.</p>
<p> </p>
</div>
</div>
<p>这道题让我们找缺失的首个正数，由于限定了O(n)的时间，所以一般的排序方法都不能用，最开始我没有看到还限制了空间复杂度，所以想到了用HashSet来解，这个思路很简单，第一遍遍历数组把所有的数都存入HashSet中，并且找出数组的最大值，下次循环从1开始递增找数字，哪个数字找不到就返回哪个数字，如果一直找到了最大的数字，则返回最大值+1，代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> NOT constant space</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> firstMissingPositive(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        </span><span style="color: #0000ff;">int</span> mx = <span style="color: #800080;">0</span><span style="color: #000000;">;
        unordered_set</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> s;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span><span style="color: #000000;"> num : nums) {
            </span><span style="color: #0000ff;">if</span> (num &lt;= <span style="color: #800080;">0</span>) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
            s.insert(num);
            mx </span>=<span style="color: #000000;"> max(mx, num);
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt;= mx; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (!s.count(i)) <span style="color: #0000ff;">return</span><span style="color: #000000;"> i;
        }
        </span><span style="color: #0000ff;">return</span> mx + <span style="color: #800080;">1</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>但是上面的解法不是O(1)的空间复杂度，所以我们需要另想一种解法，既然不能建立新的数组，那么我们只能覆盖原有数组，我们的思路是把1放在数组第一个位置nums[0]，2放在第二个位置nums[1]，即需要把nums[i]放在nums[nums[i] - 1]上，那么我们遍历整个数组，如果nums[i] != i + 1, 而nums[i]为整数且不大于n，另外nums[i]不等于nums[nums[i] - 1]的话，我们将两者位置调换，如果不满足上述条件直接跳过，最后我们再遍历一遍数组，如果对应位置上的数不正确则返回正确的数，代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> firstMissingPositive(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        </span><span style="color: #0000ff;">int</span> n =<span style="color: #000000;"> nums.size();
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">while</span> (nums[i] &gt; <span style="color: #800080;">0</span> &amp;&amp; nums[i] &lt;= n &amp;&amp; nums[nums[i] - <span style="color: #800080;">1</span>] !=<span style="color: #000000;"> nums[i]) {
                swap(nums[i], nums[nums[i] </span>- <span style="color: #800080;">1</span><span style="color: #000000;">]);
            }
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (nums[i] != i + <span style="color: #800080;">1</span>) <span style="color: #0000ff;">return</span> i + <span style="color: #800080;">1</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> n + <span style="color: #800080;">1</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4756677.html" target="_blank">Missing Number</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4843654.html" target="_blank">Find the Duplicate Number</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/6222149.html">Find All Numbers Disappeared in an Array</a></p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/8716597.html" id="homepage1_HomePageDays_DaysList_ctl11_DayList_TitleUrl_0">Couples Holding Hands</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-04-06 14:59</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4395963" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4395963);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4419386.html" id="cb_post_title_url">[LeetCode] Combination Sum II 组合之和之二</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a collection of candidate numbers (<em>C</em>) and a target number (<em>T</em>), find all unique combinations in <em>C</em> where the candidate numbers sums to <em>T</em>.</p>
<p>Each number in <em>C</em> may only be used once in the combination.</p>
<p>Note:</p>
<ul>
<li>All numbers (including target) will be positive integers.</li>
<li>Elements in a combination (<em>a</em>1, <em>a</em>2, … , <em>a</em>k) must be in non-descending order. (ie, <em>a</em>1 ≤ <em>a</em>2 ≤ … ≤ <em>a</em>k).</li>
<li>The solution set must not contain duplicate combinations.</li>
</ul>
<p> </p>
<p>For example, given candidate set <code>10,1,2,7,6,1,5</code> and target <code>8</code>, <br/>A solution set is: <br/><code>[1, 7]</code> <br/><code>[1, 2, 5]</code> <br/><code>[2, 6]</code> <br/><code>[1, 1, 6]</code> </p>
<p> </p>
<p>这道题跟之前那道<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4419259.html" id="homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0"> Combination Sum 组合之和</a> 本质没有区别，只需要改动一点点即可，之前那道题给定数组中的数字可以重复使用，而这道题不能重复使用，只需要在之前的基础上修改两个地方即可，首先在递归的for循环里加上if (i &gt; start &amp;&amp; num[i] == num[i - 1]) continue; 这样可以防止res中出现重复项，然后就在递归调用combinationSum2DFS里面的参数换成i+1，这样就不会重复使用数组中的数字了，代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt; &gt; combinationSum2(vector&lt;<span style="color: #0000ff;">int</span>&gt; &amp;num, <span style="color: #0000ff;">int</span><span style="color: #000000;"> target) {
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt; &gt;<span style="color: #000000;"> res;
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; <span style="color: #0000ff;">out</span><span style="color: #000000;">;
        sort(num.begin(), num.end());
        combinationSum2DFS(num, target, </span><span style="color: #800080;">0</span>, <span style="color: #0000ff;">out</span><span style="color: #000000;">, res);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">void</span> combinationSum2DFS(vector&lt;<span style="color: #0000ff;">int</span>&gt; &amp;num, <span style="color: #0000ff;">int</span> target, <span style="color: #0000ff;">int</span> start, vector&lt;<span style="color: #0000ff;">int</span>&gt; &amp;<span style="color: #0000ff;">out</span>, vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt; &gt; &amp;<span style="color: #000000;">res) {
        </span><span style="color: #0000ff;">if</span> (target &lt; <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (target == <span style="color: #800080;">0</span>) res.push_back(<span style="color: #0000ff;">out</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = start; i &lt; num.size(); ++<span style="color: #000000;">i) {
                </span><span style="color: #0000ff;">if</span> (i &gt; start &amp;&amp; num[i] == num[i - <span style="color: #800080;">1</span>]) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">out</span><span style="color: #000000;">.push_back(num[i]);
                combinationSum2DFS(num, target </span>- num[i], i + <span style="color: #800080;">1</span>, <span style="color: #0000ff;">out</span><span style="color: #000000;">, res);
                </span><span style="color: #0000ff;">out</span><span style="color: #000000;">.pop_back();
            }
        }
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a class="link-post-title" href="http://www.cnblogs.com/grandyang/p/4537983.html" id="link_post_title">Combination Sum III</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4419259.html" target="_blank">Combination Sum</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-04-12 13:19</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4419386" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4419386);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4419259.html" id="cb_post_title_url">[LeetCode] Combination Sum 组合之和</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="content__1c40">
<div>
<p>Given a set of candidate numbers (<code>candidates</code>) (without duplicates) and a target number (<code>target</code>), find all unique combinations in <code>candidates</code> where the candidate numbers sums to <code>target</code>.</p>
<p>The same repeated number may be chosen from <code>candidates</code> unlimited number of times.</p>
<p>Note:</p>
<ul>
<li>All numbers (including <code>target</code>) will be positive integers.</li>
<li>The solution set must not contain duplicate combinations.</li>
</ul>
<p>Example 1:</p>
<pre>Input: candidates = <code>[2,3,6,7], </code>target = <code>7</code>,
A solution set is:
[
  [7],
  [2,2,3]
]
</pre>
<p>Example 2:</p>
<pre>Input: candidates = [2,3,5]<code>, </code>target = 8,
A solution set is:
[
  [2,2,2,2],
  [2,3,3],
  [3,5]
]
</pre>
</div>
</div>
<div class="header__2cgQ">  </div>
<p>像这种结果要求返回所有符合要求解的题十有八九都是要利用到递归，而且解题的思路都大同小异，相类似的题目有<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4042156.html" id="cb_post_title_url"> Path Sum II</a>，<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4310964.html" id="cb_post_title_url">Subsets II</a>，<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4358848.html" id="cb_post_title_url">Permutations</a>，<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4359825.html" id="cb_post_title_url">Permutations II</a>，<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4332522.html" id="cb_post_title_url">Combinations</a> 等等，如果仔细研究这些题目发现都是一个套路，都是需要另写一个递归函数，这里我们新加入三个变量，start记录当前的递归到的下标，out为一个解，res保存所有已经得到的解，每次调用新的递归函数时，此时的target要减去当前数组的的数，具体看代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; combinationSum(vector&lt;<span style="color: #0000ff;">int</span>&gt; &amp;candidates, <span style="color: #0000ff;">int</span><span style="color: #000000;"> target) {
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;<span style="color: #000000;"> res;
        sort(candidates.begin(), candidates.end());
        combinationSumDFS(candidates, target, </span><span style="color: #800080;">0</span><span style="color: #000000;">, {}, res);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">void</span> combinationSumDFS(vector&lt;<span style="color: #0000ff;">int</span>&gt; &amp;candidates, <span style="color: #0000ff;">int</span> target, <span style="color: #0000ff;">int</span> start, vector&lt;<span style="color: #0000ff;">int</span>&gt; <span style="color: #0000ff;">out</span>, vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; &amp;<span style="color: #000000;">res) {
        </span><span style="color: #0000ff;">if</span> (target &lt; <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (target == <span style="color: #800080;">0</span>) {res.push_back(<span style="color: #0000ff;">out</span>); <span style="color: #0000ff;">return</span><span style="color: #000000;">;}
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = start; i &lt; candidates.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">out</span><span style="color: #000000;">.push_back(candidates[i]);
            combinationSumDFS(candidates, target </span>- candidates[i], i, <span style="color: #0000ff;">out</span><span style="color: #000000;">, res);
            </span><span style="color: #0000ff;">out</span><span style="color: #000000;">.pop_back();
        }
    }
};</span></pre>
</div>
<p> </p>
<p>我们也可以不使用额外的函数，就在一个函数中完成递归，还是要先给数组排序，然后遍历，如果当前数字大于target，说明肯定无法组成target，由于排过序，之后的也无法组成target，直接break掉。如果当前数字正好等于target，那么当前单个数字就是一个解，组成一个数组然后放到结果res中。然后我们将当前位置之后的数组取出来，调用递归函数，注意此时的target要减去当前的数字，然后我们遍历递归结果返回的二维数组，将当前数字加到每一个数组最前面，然后再将每个数组加入结果res即可，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; combinationSum(vector&lt;<span style="color: #0000ff;">int</span>&gt; &amp;candidates, <span style="color: #0000ff;">int</span><span style="color: #000000;"> target) {
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;<span style="color: #000000;"> res;
        sort(candidates.begin(), candidates.end());
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; candidates.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (candidates[i] &gt; target) <span style="color: #0000ff;">break</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (candidates[i] == target) {res.push_back({candidates[i]}); <span style="color: #0000ff;">continue</span><span style="color: #000000;">;}
            vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; vec = vector&lt;<span style="color: #0000ff;">int</span>&gt;(candidates.begin() +<span style="color: #000000;"> i, candidates.end());
            vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; tmp = combinationSum(vec, target -<span style="color: #000000;"> candidates[i]);
            </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto a : tmp) {
                a.insert(a.begin(), candidates[i]);
                res.push_back(a);
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>我们也可以用迭代的解法来做，建立一个三维数组dp，这里dp[i]表示目标数为i的所有解法集合。这里的i就从1遍历到target即可，对于每个i，我们都新建一个二维数组cur，然后遍历candidates数组，如果遍历到的数字大于i，说明当前及之后的数字都无法组成i，直接break掉。否则如果相等，那么把当前数字自己组成一个数组，并且加到cur中。否则就遍历dp[i - candidates[j] - 1] 中的所有数组，如果当前数字大于数组的首元素，则跳过，因为我们的结果要求是要有序的。否则就将当前数字加入数组的开头，并且将数组放入cur之中即可，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; combinationSum(vector&lt;<span style="color: #0000ff;">int</span>&gt; &amp;candidates, <span style="color: #0000ff;">int</span><span style="color: #000000;"> target) {
        vector</span>&lt;vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&gt;<span style="color: #000000;"> dp;
        sort(candidates.begin(), candidates.end());
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt;= target; ++<span style="color: #000000;">i) {
            vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;<span style="color: #000000;"> cur;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; candidates.size(); ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> (candidates[j] &gt; i) <span style="color: #0000ff;">break</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (candidates[j] == i) {cur.push_back({candidates[j]}); <span style="color: #0000ff;">continue</span><span style="color: #000000;">;}
                </span><span style="color: #0000ff;">for</span> (auto a : dp[i - candidates[j] - <span style="color: #800080;">1</span><span style="color: #000000;">]) {
                    </span><span style="color: #0000ff;">if</span> (candidates[j] &gt; a[<span style="color: #800080;">0</span>]) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                    a.insert(a.begin(), candidates[j]);
                    cur.push_back(a);
                }
            }
            dp.push_back(cur);
        }
        </span><span style="color: #0000ff;">return</span> dp[target - <span style="color: #800080;">1</span><span style="color: #000000;">];
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a class="link-post-title" href="http://www.cnblogs.com/grandyang/p/4537983.html" id="link_post_title">Combination Sum III</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4419386.html" target="_blank">Combination Sum II</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/5705750.html">Combination Sum IV</a> </p>
<p><a href="http://www.cnblogs.com/grandyang/p/4332522.html" target="_blank">Combinations</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/5332722.html" target="_blank">Factor Combinations</a> </p>
<p><a href="http://www.cnblogs.com/grandyang/p/4452220.html" target="_blank">Letter Combinations of a Phone Number</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-04-12 12:03</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4419259" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4419259);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4086299.html" id="cb_post_title_url">[LeetCode] Count and Say 计数和读法</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>The count-and-say sequence is the sequence of integers beginning as follows:<br/><code>1, 11, 21, 1211, 111221, ...</code></p>
<p><code>1</code> is read off as <code>"one 1"</code> or <code>11</code>.<br/><code>11</code> is read off as <code>"two 1s"</code> or <code>21</code>.<br/><code>21</code> is read off as <code>"one 2</code>, then <code>one 1"</code> or <code>1211</code>.</p>
<p>Given an integer <em>n</em>, generate the <em>n</em>th sequence.</p>
<p>Note: The sequence of integers will be represented as a string.</p>
<p> </p>
<p>这道计数和读法问题还是第一次遇到，看似挺复杂，其实仔细一看，算法很简单，就是对于前一个数，找出相同元素的个数，把个数和该元素存到新的string里。代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> countAndSay(<span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        </span><span style="color: #0000ff;">if</span> (n &lt;= <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span> <span style="color: #800000;">""</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">string</span> res = <span style="color: #800000;">"</span><span style="color: #800000;">1</span><span style="color: #800000;">"</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (--<span style="color: #000000;">n) {
            </span><span style="color: #0000ff;">string</span> cur = <span style="color: #800000;">""</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; res.size(); ++<span style="color: #000000;">i) {
                </span><span style="color: #0000ff;">int</span> cnt = <span style="color: #800080;">1</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">while</span> (i + <span style="color: #800080;">1</span> &lt; res.size() &amp;&amp; res[i] == res[i + <span style="color: #800080;">1</span><span style="color: #000000;">]) {
                    </span>++<span style="color: #000000;">cnt;
                    </span>++<span style="color: #000000;">i;
                }
                cur </span>+= to_string(cnt) +<span style="color: #000000;"> res[i];
            }
            res </span>=<span style="color: #000000;"> cur;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>博主出于好奇打印出了前12个数字，发现一个很有意思的现象，不管打印到后面多少位，出现的数字只是由1,2和3组成，网上也有人发现了并分析了原因 (<a href="http://www.cnblogs.com/TenosDoIt/p/3776356.html" target="_blank">http://www.cnblogs.com/TenosDoIt/p/3776356.html</a>)，前十二个数字如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #800080;">1</span>
<span style="color: #800080;">1</span> <span style="color: #800080;">1</span>
<span style="color: #800080;">2</span> <span style="color: #800080;">1</span>
<span style="color: #800080;">1</span> <span style="color: #800080;">2</span> <span style="color: #800080;">1</span> <span style="color: #800080;">1</span>
<span style="color: #800080;">1</span> <span style="color: #800080;">1</span> <span style="color: #800080;">1</span> <span style="color: #800080;">2</span> <span style="color: #800080;">2</span> <span style="color: #800080;">1</span>
<span style="color: #800080;">3</span> <span style="color: #800080;">1</span> <span style="color: #800080;">2</span> <span style="color: #800080;">2</span> <span style="color: #800080;">1</span> <span style="color: #800080;">1</span>
<span style="color: #800080;">1</span> <span style="color: #800080;">3</span> <span style="color: #800080;">1</span> <span style="color: #800080;">1</span> <span style="color: #800080;">2</span> <span style="color: #800080;">2</span> <span style="color: #800080;">2</span> <span style="color: #800080;">1</span>
<span style="color: #800080;">1</span> <span style="color: #800080;">1</span> <span style="color: #800080;">1</span> <span style="color: #800080;">3</span> <span style="color: #800080;">2</span> <span style="color: #800080;">1</span> <span style="color: #800080;">3</span> <span style="color: #800080;">2</span> <span style="color: #800080;">1</span> <span style="color: #800080;">1</span>
<span style="color: #800080;">3</span> <span style="color: #800080;">1</span> <span style="color: #800080;">1</span> <span style="color: #800080;">3</span> <span style="color: #800080;">1</span> <span style="color: #800080;">2</span> <span style="color: #800080;">1</span> <span style="color: #800080;">1</span> <span style="color: #800080;">1</span> <span style="color: #800080;">3</span> <span style="color: #800080;">1</span> <span style="color: #800080;">2</span> <span style="color: #800080;">2</span> <span style="color: #800080;">1</span>
<span style="color: #800080;">1</span> <span style="color: #800080;">3</span> <span style="color: #800080;">2</span> <span style="color: #800080;">1</span> <span style="color: #800080;">1</span> <span style="color: #800080;">3</span> <span style="color: #800080;">1</span> <span style="color: #800080;">1</span> <span style="color: #800080;">1</span> <span style="color: #800080;">2</span> <span style="color: #800080;">3</span> <span style="color: #800080;">1</span> <span style="color: #800080;">1</span> <span style="color: #800080;">3</span> <span style="color: #800080;">1</span> <span style="color: #800080;">1</span> <span style="color: #800080;">2</span> <span style="color: #800080;">2</span> <span style="color: #800080;">1</span> <span style="color: #800080;">1</span>
<span style="color: #800080;">1</span> <span style="color: #800080;">1</span> <span style="color: #800080;">1</span> <span style="color: #800080;">3</span> <span style="color: #800080;">1</span> <span style="color: #800080;">2</span> <span style="color: #800080;">2</span> <span style="color: #800080;">1</span> <span style="color: #800080;">1</span> <span style="color: #800080;">3</span> <span style="color: #800080;">3</span> <span style="color: #800080;">1</span> <span style="color: #800080;">1</span> <span style="color: #800080;">2</span> <span style="color: #800080;">1</span> <span style="color: #800080;">3</span> <span style="color: #800080;">2</span> <span style="color: #800080;">1</span> <span style="color: #800080;">1</span> <span style="color: #800080;">3</span> <span style="color: #800080;">2</span> <span style="color: #800080;">1</span> <span style="color: #800080;">2</span> <span style="color: #800080;">2</span> <span style="color: #800080;">2</span> <span style="color: #800080;">1</span>
<span style="color: #800080;">3</span> <span style="color: #800080;">1</span> <span style="color: #800080;">1</span> <span style="color: #800080;">3</span> <span style="color: #800080;">1</span> <span style="color: #800080;">1</span> <span style="color: #800080;">2</span> <span style="color: #800080;">2</span> <span style="color: #800080;">2</span> <span style="color: #800080;">1</span> <span style="color: #800080;">2</span> <span style="color: #800080;">3</span> <span style="color: #800080;">2</span> <span style="color: #800080;">1</span> <span style="color: #800080;">1</span> <span style="color: #800080;">2</span> <span style="color: #800080;">1</span> <span style="color: #800080;">1</span> <span style="color: #800080;">1</span> <span style="color: #800080;">3</span> <span style="color: #800080;">1</span> <span style="color: #800080;">2</span> <span style="color: #800080;">2</span> <span style="color: #800080;">1</span> <span style="color: #800080;">1</span> <span style="color: #800080;">3</span> <span style="color: #800080;">1</span> <span style="color: #800080;">2</span> <span style="color: #800080;">1</span> <span style="color: #800080;">1</span> <span style="color: #800080;">3</span> <span style="color: #800080;">2</span> <span style="color: #800080;">1</span> <span style="color: #800080;">1</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/20195/c-solution-easy-understand">https://discuss.leetcode.com/topic/20195/c-solution-easy-understand</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2014-11-10 05:10</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4086299" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4086299);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4421852.html" id="cb_post_title_url">[LeetCode] Sudoku Solver 求解数独</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Write a program to solve a Sudoku puzzle by filling the empty cells.</p>
<p>Empty cells are indicated by the character <code>'.'</code>.</p>
<p>You may assume that there will be only one unique solution.</p>
<p><img alt="" src="http://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png"/></p>
<p>A sudoku puzzle...</p>
<p> </p>
<p><img alt="" src="http://upload.wikimedia.org/wikipedia/commons/thumb/3/31/Sudoku-by-L2G-20050714_solution.svg/250px-Sudoku-by-L2G-20050714_solution.svg.png"/></p>
<p>...and its solution numbers marked in red.</p>
<p> </p>
<p>这道求解数独的题是在之前那道<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4421217.html" id="homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0"> Valid Sudoku 验证数独</a>的基础上的延伸，之前那道题让我们验证给定的数组是否为数独数组，这道让我们求解数独数组，跟此题类似的有<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4042156.html" id="cb_post_title_url"> </a><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4358848.html" id="cb_post_title_url">Permutations 全排列</a>，<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4359825.html" id="cb_post_title_url"></a><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4332522.html" id="cb_post_title_url">Combinations 组合项</a>，<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4377782.html" id="homepage1_HomePageDays_DaysList_ctl10_DayList_TitleUrl_0"> N-Queens N皇后问题</a>等等，其中尤其是跟<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4377782.html" id="homepage1_HomePageDays_DaysList_ctl10_DayList_TitleUrl_0"> N-Queens N皇后问题</a>的解题思路及其相似，对于每个需要填数字的格子带入1到9，每代入一个数字都判定其是否合法，如果合法就继续下一次递归，结束时把数字设回'.'，判断新加入的数字是否合法时，只需要判定当前数字是否合法，不需要判定这个数组是否为数独数组，因为之前加进的数字都是合法的，这样可以使程序更加高效一些，具体实现如代码所示：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">void</span> solveSudoku(vector&lt;vector&lt;<span style="color: #0000ff;">char</span>&gt; &gt; &amp;<span style="color: #000000;">board) {
        </span><span style="color: #0000ff;">if</span> (board.empty() || board.size() != <span style="color: #800080;">9</span> || board[<span style="color: #800080;">0</span>].size() != <span style="color: #800080;">9</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
        solveSudokuDFS(board, </span><span style="color: #800080;">0</span>, <span style="color: #800080;">0</span><span style="color: #000000;">);
    }
    </span><span style="color: #0000ff;">bool</span> solveSudokuDFS(vector&lt;vector&lt;<span style="color: #0000ff;">char</span>&gt; &gt; &amp;board, <span style="color: #0000ff;">int</span> i, <span style="color: #0000ff;">int</span><span style="color: #000000;"> j) {
        </span><span style="color: #0000ff;">if</span> (i == <span style="color: #800080;">9</span>) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (j &gt;= <span style="color: #800080;">9</span>) <span style="color: #0000ff;">return</span> solveSudokuDFS(board, i + <span style="color: #800080;">1</span>, <span style="color: #800080;">0</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">if</span> (board[i][j] == <span style="color: #800000;">'</span><span style="color: #800000;">.</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> k = <span style="color: #800080;">1</span>; k &lt;= <span style="color: #800080;">9</span>; ++<span style="color: #000000;">k) {
                board[i][j] </span>= (<span style="color: #0000ff;">char</span>)(k + <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span><span style="color: #000000;">);
                </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (isValid(board, i , j)) {
                    </span><span style="color: #0000ff;">if</span> (solveSudokuDFS(board, i, j + <span style="color: #800080;">1</span>)) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                }
                board[i][j] </span>= <span style="color: #800000;">'</span><span style="color: #800000;">.</span><span style="color: #800000;">'</span><span style="color: #000000;">;
            }
        } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            </span><span style="color: #0000ff;">return</span> solveSudokuDFS(board, i, j + <span style="color: #800080;">1</span><span style="color: #000000;">);
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
    }
    </span><span style="color: #0000ff;">bool</span> isValid(vector&lt;vector&lt;<span style="color: #0000ff;">char</span>&gt; &gt; &amp;board, <span style="color: #0000ff;">int</span> i, <span style="color: #0000ff;">int</span><span style="color: #000000;"> j) {
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> col = <span style="color: #800080;">0</span>; col &lt; <span style="color: #800080;">9</span>; ++<span style="color: #000000;">col) {
            </span><span style="color: #0000ff;">if</span> (col != j &amp;&amp; board[i][j] == board[i][col]) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> row = <span style="color: #800080;">0</span>; row &lt; <span style="color: #800080;">9</span>; ++<span style="color: #000000;">row) {
            </span><span style="color: #0000ff;">if</span> (row != i &amp;&amp; board[i][j] == board[row][j]) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> row = i / <span style="color: #800080;">3</span> * <span style="color: #800080;">3</span>; row &lt; i / <span style="color: #800080;">3</span> * <span style="color: #800080;">3</span> + <span style="color: #800080;">3</span>; ++<span style="color: #000000;">row) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> col = j / <span style="color: #800080;">3</span> * <span style="color: #800080;">3</span>; col &lt; j / <span style="color: #800080;">3</span> * <span style="color: #800080;">3</span> + <span style="color: #800080;">3</span>; ++<span style="color: #000000;">col) {
                </span><span style="color: #0000ff;">if</span> ((row != i || col != j) &amp;&amp; board[i][j] == board[row][col]) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            }
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-04-13 12:22</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4421852" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4421852);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4421217.html" id="cb_post_title_url">[LeetCode] Valid Sudoku 验证数独</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Determine if a Sudoku is valid, according to: <a href="http://sudoku.com.au/TheRules.aspx">Sudoku Puzzles - The Rules</a>.</p>
<p>The Sudoku board could be partially filled, where empty cells are filled with the character <code>'.'</code>.</p>
<p><img alt="" src="http://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png"/></p>
<p>A partially filled sudoku which is valid.</p>
<p> </p>
<p>Note:<br/>A valid Sudoku board (partially filled) is not necessarily solvable. Only the filled cells need to be validated.</p>
<p> </p>
<p>这道题让我们验证一个方阵是否为<a href="http://zh.wikipedia.org/wiki/%E6%95%B8%E7%8D%A8" target="_blank">数独矩阵</a>，判断标准是看各行各列是否有重复数字，以及每个小的3x3的小方阵里面是否有重复数字，如果都无重复，则当前矩阵是数独矩阵，但不代表待数独矩阵有解，只是单纯的判断当前未填完的矩阵是否是数独矩阵。那么根据数独矩阵的定义，我们在遍历每个数字的时候，就看看包含当前位置的行和列以及3x3小方阵中是否已经出现该数字，那么我们需要三个标志矩阵，分别记录各行，各列，各小方阵是否出现某个数字，其中行和列标志下标很好对应，就是小方阵的下标需要稍稍转换一下，具体代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> isValidSudoku(vector&lt;vector&lt;<span style="color: #0000ff;">char</span>&gt; &gt; &amp;<span style="color: #000000;">board) {
        </span><span style="color: #0000ff;">if</span> (board.empty() || board[<span style="color: #800080;">0</span>].empty()) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> m = board.size(), n = board[<span style="color: #800080;">0</span><span style="color: #000000;">].size();
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">bool</span>&gt; &gt; rowFlag(m, vector&lt;<span style="color: #0000ff;">bool</span>&gt;(n, <span style="color: #0000ff;">false</span><span style="color: #000000;">));
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">bool</span>&gt; &gt; colFlag(m, vector&lt;<span style="color: #0000ff;">bool</span>&gt;(n, <span style="color: #0000ff;">false</span><span style="color: #000000;">));
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">bool</span>&gt; &gt; cellFlag(m, vector&lt;<span style="color: #0000ff;">bool</span>&gt;(n, <span style="color: #0000ff;">false</span><span style="color: #000000;">));
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; m; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; n; ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> (board[i][j] &gt;= <span style="color: #800000;">'</span><span style="color: #800000;">1</span><span style="color: #800000;">'</span> &amp;&amp; board[i][j] &lt;= <span style="color: #800000;">'</span><span style="color: #800000;">9</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">int</span> c = board[i][j] - <span style="color: #800000;">'</span><span style="color: #800000;">1</span><span style="color: #800000;">'</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">if</span> (rowFlag[i][c] || colFlag[c][j] || cellFlag[<span style="color: #800080;">3</span> * (i / <span style="color: #800080;">3</span>) + j / <span style="color: #800080;">3</span>][c]) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                    rowFlag[i][c] </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                    colFlag[c][j] </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                    cellFlag[</span><span style="color: #800080;">3</span> * (i / <span style="color: #800080;">3</span>) + j / <span style="color: #800080;">3</span>][c] = <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                }
            }
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-04-13 07:05</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4421217" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4421217);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4408638.html" id="cb_post_title_url">[LeetCode] Search Insert Position 搜索插入位置</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p>
<p>You may assume no duplicates in the array.</p>
<p>Here are few examples.<br/><code>[1,3,5,6]</code>, 5 → 2<br/><code>[1,3,5,6]</code>, 2 → 1<br/><code>[1,3,5,6]</code>, 7 → 4<br/><code>[1,3,5,6]</code>, 0 → 0</p>
<p> </p>
<p>这道题基本没有什么难度，实在不理解为啥还是Medium难度的，完完全全的应该是Easy啊，三行代码搞定的题，只需要遍历一遍原数组，若当前数字大于或等于目标值，则返回当前坐标，如果遍历结束了，说明目标值比数组中任何一个数都要大，则返回数组长度n即可，代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> searchInsert(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; nums, <span style="color: #0000ff;">int</span><span style="color: #000000;"> target) {
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; nums.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (nums[i] &gt;= target) <span style="color: #0000ff;">return</span><span style="color: #000000;"> i;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> nums.size();
    }
};</span></pre>
</div>
<p> </p>
<p>当然，我们还可以用二分搜索法来优化我们的时间复杂度，而且个人认为这种方法应该是面试官们想要考察的算法吧，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> searchInsert(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; nums, <span style="color: #0000ff;">int</span><span style="color: #000000;"> target) {
        </span><span style="color: #0000ff;">if</span> (nums.back() &lt; target) <span style="color: #0000ff;">return</span><span style="color: #000000;"> nums.size();
        </span><span style="color: #0000ff;">int</span> left = <span style="color: #800080;">0</span>, right = nums.size() - <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (left &lt;<span style="color: #000000;"> right) {
            </span><span style="color: #0000ff;">int</span> mid = left + (right - left) / <span style="color: #800080;">2</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> (nums[mid] == target) <span style="color: #0000ff;">return</span><span style="color: #000000;"> mid;
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (nums[mid] &lt; target) left = mid + <span style="color: #800080;">1</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">else</span> right =<span style="color: #000000;"> mid;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> right;
    }
};</span></pre>
</div>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-04-09 08:31</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4408638" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4408638);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4409379.html" id="cb_post_title_url">[LeetCode] Search for a Range 搜索一个范围</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a sorted array of integers, find the starting and ending position of a given target value.</p>
<p>Your algorithm's runtime complexity must be in the order of <em>O</em>(log <em>n</em>).</p>
<p>If the target is not found in the array, return <code>[-1, -1]</code>.</p>
<p>For example,<br/>Given <code>[5, 7, 7, 8, 8, 10]</code> and target value 8,<br/>return <code>[3, 4]</code>.</p>
<p> </p>
<p>这道题让我们在一个有序整数数组中寻找相同目标值的起始和结束位置，而且限定了时间复杂度为O(logn)，这是典型的二分查找法的时间复杂度，所以这道题我们也需要用此方法，我们的思路是首先对原数组使用二分查找法，找出其中一个目标值的位置，然后向两边搜索找出起始和结束的位置，代码如下：</p>
<p> </p>
<p>解法一:</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; searchRange(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; nums, <span style="color: #0000ff;">int</span><span style="color: #000000;"> target) {
        </span><span style="color: #0000ff;">int</span> idx = search(nums, <span style="color: #800080;">0</span>, nums.size() - <span style="color: #800080;">1</span><span style="color: #000000;">, target);
        </span><span style="color: #0000ff;">if</span> (idx == -<span style="color: #800080;">1</span>) <span style="color: #0000ff;">return</span> {-<span style="color: #800080;">1</span>, -<span style="color: #800080;">1</span><span style="color: #000000;">};
        </span><span style="color: #0000ff;">int</span> left = idx, right =<span style="color: #000000;"> idx;
        </span><span style="color: #0000ff;">while</span> (left &gt; <span style="color: #800080;">0</span> &amp;&amp; nums[left - <span style="color: #800080;">1</span>] == nums[idx]) --<span style="color: #000000;">left;
        </span><span style="color: #0000ff;">while</span> (right &lt; nums.size() - <span style="color: #800080;">1</span> &amp;&amp; nums[right + <span style="color: #800080;">1</span>] == nums[idx]) ++<span style="color: #000000;">right;
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> {left, right};
    }
    </span><span style="color: #0000ff;">int</span> search(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; nums, <span style="color: #0000ff;">int</span> left, <span style="color: #0000ff;">int</span> right, <span style="color: #0000ff;">int</span><span style="color: #000000;"> target) {
        </span><span style="color: #0000ff;">if</span> (left &gt; right) <span style="color: #0000ff;">return</span> -<span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> mid = left + (right - left) / <span style="color: #800080;">2</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (nums[mid] == target) <span style="color: #0000ff;">return</span><span style="color: #000000;"> mid;
        </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (nums[mid] &lt; target) <span style="color: #0000ff;">return</span> search(nums, mid + <span style="color: #800080;">1</span><span style="color: #000000;">, right, target);
        </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">return</span> search(nums, left, mid - <span style="color: #800080;">1</span><span style="color: #000000;">, target);
    }
};</span></pre>
</div>
<p> </p>
<p>可能有些人会觉得上面的算法不是严格意义上的O(logn)的算法，因为在最坏的情况下会变成O(n)，比如当数组里的数全是目标值的话，从中间向两边找边界就会一直遍历完整个数组，那么我们下面来看一种真正意义上的O(logn)的算法，使用两次二分查找法，第一次找到左边界，第二次调用找到右边界即可，具体代码如下：</p>
<p> </p>
<p>解法二:</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; searchRange(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; nums, <span style="color: #0000ff;">int</span><span style="color: #000000;"> target) {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; res(<span style="color: #800080;">2</span>, -<span style="color: #800080;">1</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">int</span> left = <span style="color: #800080;">0</span>, right = nums.size() - <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (left &lt;<span style="color: #000000;"> right) {
            </span><span style="color: #0000ff;">int</span> mid = left + (right - left) / <span style="color: #800080;">2</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> (nums[mid] &lt; target) left = mid + <span style="color: #800080;">1</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">else</span> right =<span style="color: #000000;"> mid;
        }
        </span><span style="color: #0000ff;">if</span> (nums[right] != target) <span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
        res[</span><span style="color: #800080;">0</span>] =<span style="color: #000000;"> right;
        right </span>=<span style="color: #000000;"> nums.size();
        </span><span style="color: #0000ff;">while</span> (left &lt;<span style="color: #000000;"> right) {
            </span><span style="color: #0000ff;">int</span> mid = left + (right - left) / <span style="color: #800080;">2</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> (nums[mid] &lt;= target) left = mid + <span style="color: #800080;">1</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">else</span> right=<span style="color: #000000;"> mid;
        }
        res[</span><span style="color: #800080;">1</span>] = left - <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/19437/the-standard-and-clean-c-binary-search-implementation" target="_blank">https://discuss.leetcode.com/topic/19437/the-standard-and-clean-c-binary-search-implementation</a></p>
<p><a href="https://discuss.leetcode.com/topic/5891/clean-iterative-solution-with-two-binary-searches-with-explanation/2" target="_blank">https://discuss.leetcode.com/topic/5891/clean-iterative-solution-with-two-binary-searches-with-explanation/2</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-04-09 13:01</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4409379" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4409379);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4325648.html" id="cb_post_title_url">[LeetCode] Search in Rotated Sorted Array 在旋转有序数组中搜索</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Suppose a sorted array is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e., <code>0 1 2 4 5 6 7</code> might become <code>4 5 6 7 0 1 2</code>).</p>
<p>You are given a target value to search. If found in the array return its index, otherwise return -1.</p>
<p>You may assume no duplicate exists in the array.</p>
<p> </p>
<p>这道题让在旋转数组中搜索一个给定值，若存在返回坐标，若不存在返回-1。我们还是考虑二分搜索法，但是这道题的难点在于我们不知道原数组在哪旋转了，我们还是用题目中给的例子来分析，对于数组[0 1 2 4 5 6 7] 共有下列七种旋转方法：</p>
<p>0　　1　　2　　 <span style="color: #ff0000;"><strong>4　　5　　6　　7</strong></span></p>
<p>7　　0　　1　　 <span style="color: #ff0000;"><strong>2　　4　　5　　6</strong></span></p>
<p>6　　7　　0　　 <span style="color: #ff0000;"><strong>1　　2　　4　　5</strong></span></p>
<p>5　　6　　7　　 <span style="color: #ff0000;"><strong>0　　1　　2　　4</strong></span></p>
<p><span style="color: #ff0000;"><strong>4　　5　　6　　7</strong></span>　　0　　1　　2</p>
<p><span style="color: #ff0000;"><strong>2　　4　　5　　6</strong></span>　　7　　0　　1</p>
<p><span style="color: #ff0000;"><strong>1　　2　　4　　5</strong></span>　　6　　7　　0</p>
<p>二分搜索法的关键在于获得了中间数后，判断下面要搜索左半段还是右半段，我们观察上面红色的数字都是升序的，由此我们可以观察出规律，如果中间的数小于最右边的数，则右半段是有序的，若中间数大于最右边数，则左半段是有序的，我们只要在有序的半段里用首尾两个数组来判断目标值是否在这一区域内，这样就可以确定保留哪半边了，代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> search(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; nums, <span style="color: #0000ff;">int</span><span style="color: #000000;"> target) {
        </span><span style="color: #0000ff;">int</span> left = <span style="color: #800080;">0</span>, right = nums.size() - <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (left &lt;=<span style="color: #000000;"> right) {
            </span><span style="color: #0000ff;">int</span> mid = left + (right - left) / <span style="color: #800080;">2</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> (nums[mid] == target) <span style="color: #0000ff;">return</span><span style="color: #000000;"> mid;
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (nums[mid] &lt;<span style="color: #000000;"> nums[right]) {
                </span><span style="color: #0000ff;">if</span> (nums[mid] &lt; target &amp;&amp; nums[right] &gt;= target) left = mid + <span style="color: #800080;">1</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">else</span> right = mid - <span style="color: #800080;">1</span><span style="color: #000000;">;
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                </span><span style="color: #0000ff;">if</span> (nums[left] &lt;= target &amp;&amp; nums[mid] &gt; target) right = mid - <span style="color: #800080;">1</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">else</span> left = mid + <span style="color: #800080;">1</span><span style="color: #000000;">;
            }
        }
        </span><span style="color: #0000ff;">return</span> -<span style="color: #800080;">1</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4325840.html" target="_blank">Search in Rotated Sorted Array II</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4032934.html" target="_blank">Find Minimum in Rotated Sorted Array</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-03-10 12:34</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4325648" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4325648);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4424731.html" id="cb_post_title_url">[LeetCode] Longest Valid Parentheses 最长有效括号</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a string containing just the characters <code>'('</code> and <code>')'</code>, find the length of the longest valid (well-formed) parentheses substring.</p>
<p>For <code>"(()"</code>, the longest valid parentheses substring is <code>"()"</code>, which has length = 2.</p>
<p>Another example is <code>")()())"</code>, where the longest valid parentheses substring is <code>"()()"</code>, which has length = 4.</p>
<p> </p>
<p>这道求最长有效括号比之前那道<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4424587.html" id="homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0"> Valid Parentheses 验证括号</a>难度要大一些，这里我们还是借助栈来求解，需要定义个start变量来记录合法括号串的起始位置，我们遍历字符串，如果遇到左括号，则将当前下标压入栈，如果遇到右括号，如果当前栈为空，则将下一个坐标位置记录到start，如果栈不为空，则将栈顶元素取出，此时若栈为空，则更新结果和i - start + 1中的较大值，否则更新结果和i - 栈顶元素中的较大值，代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> longestValidParentheses(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, start = <span style="color: #800080;">0</span><span style="color: #000000;">;
        stack</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> m;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; s.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (s[i] == <span style="color: #800000;">'</span><span style="color: #800000;">(</span><span style="color: #800000;">'</span><span style="color: #000000;">) m.push(i);
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (s[i] == <span style="color: #800000;">'</span><span style="color: #800000;">)</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                </span><span style="color: #0000ff;">if</span> (m.empty()) start = i + <span style="color: #800080;">1</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    m.pop();
                    res </span>= m.empty() ? max(res, i - start + <span style="color: #800080;">1</span>) : max(res, i -<span style="color: #000000;"> m.top());
                }
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>还有一种利用动态规划Dynamic Programming的解法，可参见网友<a href="http://bangbingsyb.blogspot.com/2014/11/leetcode-longest-valid-parentheses.html" target="_blank">喜刷刷的博客</a>。</p>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4944875.html">Remove Invalid Parentheses 移除非法括号</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4682458.html">Different Ways to Add Parentheses</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4444160.html" target="_blank">Generate Parentheses</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4424587.html" target="_blank">Valid Parentheses</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-04-14 14:02</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4424731" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4424731);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4428207.html" id="cb_post_title_url">[LeetCode] Next Permutation 下一个排列</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.</p>
<p>If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).</p>
<p>The replacement must be in-place, do not allocate extra memory.</p>
<p>Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.<br/><code>1,2,3</code> → <code>1,3,2</code><br/><code>3,2,1</code> → <code>1,2,3</code><br/><code>1,1,5</code> → <code>1,5,1</code></p>
<p> </p>
<p>这道题让我们求下一个排列顺序，有题目中给的例子可以看出来，如果给定数组是降序，则说明是全排列的最后一种情况，则下一个排列就是最初始情况，可以参见之前的博客<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4042156.html" id="cb_post_title_url"> </a><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4358848.html" id="cb_post_title_url">Permutations 全排列</a>。我们再来看下面一个例子，有如下的一个数组</p>
<p>1　　2　　7　　4　　3　　1</p>
<p>下一个排列为：</p>
<p>1　　3　　1　　2　　4　　7</p>
<p>那么是如何得到的呢，我们通过观察原数组可以发现，如果从末尾往前看，数字逐渐变大，到了2时才减小的，然后我们再从后往前找第一个比2大的数字，是3，那么我们交换2和3，再把此时3后面的所有数字转置一下即可，步骤如下：</p>
<p>1　　<span style="color: #ff0000;">2</span>　　7　　4　　3　　1</p>
<p>1　　<span style="color: #ff0000;">2</span>　　7　　4　　<span style="color: #ff0000;">3</span>　　1</p>
<p>1　　<span style="color: #ff0000;">3</span>　　7　　4　　<span style="color: #ff0000;">2</span>　　1</p>
<p>1　　3　　<span style="color: #ff0000;">1　　2　　4　　7</span></p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">void</span> nextPermutation(vector&lt;<span style="color: #0000ff;">int</span>&gt; &amp;<span style="color: #000000;">num) {
        </span><span style="color: #0000ff;">int</span> i, j, n =<span style="color: #000000;"> num.size();
        </span><span style="color: #0000ff;">for</span> (i = n - <span style="color: #800080;">2</span>; i &gt;= <span style="color: #800080;">0</span>; --<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (num[i + <span style="color: #800080;">1</span>] &gt;<span style="color: #000000;"> num[i]) {
                </span><span style="color: #0000ff;">for</span> (j = n - <span style="color: #800080;">1</span>; j &gt; i; --<span style="color: #000000;">j) {
                    </span><span style="color: #0000ff;">if</span> (num[j] &gt; num[i]) <span style="color: #0000ff;">break</span><span style="color: #000000;">;
                }
                swap(num[i], num[j]);
                reverse(num.begin() </span>+ i + <span style="color: #800080;">1</span><span style="color: #000000;">, num.end());
                </span><span style="color: #0000ff;">return</span><span style="color: #000000;">;
            }
        }
        reverse(num.begin(), num.end());
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种写法更简洁一些，但是整体思路和上面的解法没有什么区别，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">void</span> nextPermutation(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {</span><span style="color: #0000ff;">int</span> n = nums.size(), i = n - <span style="color: #800080;">2</span>, j = n - <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (i &gt;= <span style="color: #800080;">0</span> &amp;&amp; nums[i] &gt;= nums[i + <span style="color: #800080;">1</span>]) --<span style="color: #000000;">i;
        </span><span style="color: #0000ff;">if</span> (i &gt;= <span style="color: #800080;">0</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">while</span> (nums[j] &lt;= nums[i]) --<span style="color: #000000;">j;
            swap(nums[i], nums[j]);
        }
        reverse(nums.begin() </span>+ i + <span style="color: #800080;">1</span><span style="color: #000000;">, nums.end());
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4359825.html" target="_blank">Permutations II</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4358848.html" target="_blank">Permutations</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/30212/easiest-java-solution" target="_blank">https://discuss.leetcode.com/topic/30212/easiest-java-solution</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-04-15 12:53</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4428207" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4428207);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4521224.html" id="cb_post_title_url">[LeetCode] Substring with Concatenation of All Words 串联所有单词的子串</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>You are given a string, <strong>s</strong>, and a list of words, <strong>words</strong>, that are all of the same length. Find all starting indices of substring(s) in <strong>s</strong> that is a concatenation of each word in <strong>words</strong> exactly once and without any intervening characters.</p>
<p> For example, given:<br/>
<strong>s</strong>: <code>"barfoothefoobarman"</code><br/>
<strong>words</strong>: <code>["foo", "bar"]</code>
</p>
<p>
You should return the indices: <code>[0,9]</code>.<br/>
(order does not matter).
</p>
<p> </p>
<p>这道题让我们求串联所有单词的子串，就是说给定一个长字符串，再给定几个长度相同的单词，让我们找出串联给定所有单词的子串的起始位置，还是蛮有难度的一道题。这道题我们需要用到两个哈希表，第一个哈希表先把所有的单词存进去，然后从开头开始一个个遍历，停止条件为当剩余字符个数小于单词集里所有字符的长度。这时候我们需要定义第二个哈希表，然后每次找出给定单词长度的子串，看其是否在第一个哈希表里，如果没有，则break，如果有，则加入第二个哈希表，但相同的词只能出现一次，如果多了，也break。如果正好匹配完给定单词集里所有的单词，则把i存入结果中，具体参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; findSubstring(<span style="color: #0000ff;">string</span> s, vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp;<span style="color: #000000;"> words) {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">if</span> (s.empty() || words.empty()) <span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">int</span> n = words.size(), m = words[<span style="color: #800080;">0</span><span style="color: #000000;">].size();
        unordered_map</span>&lt;<span style="color: #0000ff;">string</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> m1;
        </span><span style="color: #0000ff;">for</span> (auto &amp;a : words) ++<span style="color: #000000;">m1[a];
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt;= (<span style="color: #0000ff;">int</span>)s.size() - n * m; ++<span style="color: #000000;">i) {
            unordered_map</span>&lt;<span style="color: #0000ff;">string</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> m2;
            </span><span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span><span style="color: #000000;">; 
            </span><span style="color: #0000ff;">for</span> (j = <span style="color: #800080;">0</span>; j &lt; n; ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">string</span> t = s.substr(i + j *<span style="color: #000000;"> m, m);
                </span><span style="color: #0000ff;">if</span> (m1.find(t) == m1.end()) <span style="color: #0000ff;">break</span><span style="color: #000000;">;
                </span>++<span style="color: #000000;">m2[t];
                </span><span style="color: #0000ff;">if</span> (m2[t] &gt; m1[t]) <span style="color: #0000ff;">break</span><span style="color: #000000;">;
            }
            </span><span style="color: #0000ff;">if</span> (j ==<span style="color: #000000;"> n) res.push_back(i);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>这道题还有一种O(n)时间复杂度的解法，设计思路非常巧妙，但是感觉很难想出来，博主目测还未到达这种水平。这种方法不再是一个字符一个字符的遍历，而是一个词一个词的遍历，比如根据题目中的例子，字符串s的长度n为18，words数组中有两个单词(cnt=2)，每个单词的长度len均为3，那么遍历的顺序为0，3，6，8，12，15，然后偏移一个字符1，4，7，9，13，16，然后再偏移一个字符2，5，8，10，14，17，这样就可以把所有情况都遍历到，我们还是先用一个哈希表m1来记录words里的所有词，然后我们从0开始遍历，用left来记录左边界的位置，count表示当前已经匹配的单词的个数。然后我们一个单词一个单词的遍历，如果当前遍历的到的单词t在m1中存在，那么我们将其加入另一个哈希表m2中，如果在m2中个数小于等于m1中的个数，那么我们count自增1，如果大于了，那么需要做一些处理，比如下面这种情况, s = barfoofoo, words = {bar, foo, abc}, 我们给words中新加了一个abc，目的是为了遍历到barfoo不会停止，那么当遍历到第二foo的时候, m2[foo]=2, 而此时m1[foo]=1，这是后已经不连续了，所以我们要移动左边界left的位置，我们先把第一个词t1=bar取出来，然后将m2[t1]自减1，如果此时m2[t1]&lt;m1[t1]了，说明一个匹配没了，那么对应的count也要自减1，然后左边界加上个len，这样就可以了。如果某个时刻count和cnt相等了，说明我们成功匹配了一个位置，那么将当前左边界left存入结果res中，此时去掉最左边的一个词，同时count自减1，左边界右移len，继续匹配。如果我们匹配到一个不在m1中的词，那么说明跟前面已经断开了，我们重置m2，count为0，左边界left移到j+len，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; findSubstring(<span style="color: #0000ff;">string</span> s, vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp;<span style="color: #000000;"> words) {
        </span><span style="color: #0000ff;">if</span> (s.empty() || words.empty()) <span style="color: #0000ff;">return</span><span style="color: #000000;"> {};
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">int</span> n = s.size(), cnt = words.size(), len = words[<span style="color: #800080;">0</span><span style="color: #000000;">].size();
        unordered_map</span>&lt;<span style="color: #0000ff;">string</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> m1;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">string</span> w : words) ++<span style="color: #000000;">m1[w];
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; len; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">int</span> left = i, count = <span style="color: #800080;">0</span><span style="color: #000000;">;
            unordered_map</span>&lt;<span style="color: #0000ff;">string</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> m2;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = i; j &lt;= n - len; j +=<span style="color: #000000;"> len) {
                </span><span style="color: #0000ff;">string</span> t =<span style="color: #000000;"> s.substr(j, len);
                </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (m1.count(t)) {
                    </span>++<span style="color: #000000;">m2[t];
                    </span><span style="color: #0000ff;">if</span> (m2[t] &lt;=<span style="color: #000000;"> m1[t]) {
                        </span>++<span style="color: #000000;">count;
                    } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                        </span><span style="color: #0000ff;">while</span> (m2[t] &gt;<span style="color: #000000;"> m1[t]) {
                            </span><span style="color: #0000ff;">string</span> t1 =<span style="color: #000000;"> s.substr(left, len);
                            </span>--<span style="color: #000000;">m2[t1];
                            </span><span style="color: #0000ff;">if</span> (m2[t1] &lt; m1[t1]) --<span style="color: #000000;">count;
                            left </span>+=<span style="color: #000000;"> len;
                        }
                    }
                    </span><span style="color: #0000ff;">if</span> (count ==<span style="color: #000000;"> cnt) {
                        res.push_back(left);
                        </span>--<span style="color: #000000;">m2[s.substr(left, len)];
                        </span>--<span style="color: #000000;">count;
                        left </span>+=<span style="color: #000000;"> len;
                    }
                } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    m2.clear();
                    count </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
                    left </span>= j +<span style="color: #000000;"> len;
                }
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="http://yucoding.blogspot.com/2013/09/leetcode-question-106-substring-with.html" target="_blank">http://yucoding.blogspot.com/2013/09/leetcode-question-106-substring-with.html</a></p>
<p><a href="https://discuss.leetcode.com/topic/6617/an-o-n-solution-with-detailed-explanation/2" target="_blank">https://discuss.leetcode.com/topic/6617/an-o-n-solution-with-detailed-explanation/2</a></p>
<p><a href="http://blog.unieagle.net/2012/10/28/leetcode%E9%A2%98%E7%9B%AE%EF%BC%9Asubstring-with-concatenation-of-all-words/" target="_blank">http://blog.unieagle.net/2012/10/28/leetcode%E9%A2%98%E7%9B%AE%EF%BC%9Asubstring-with-concatenation-of-all-words/</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-05-22 00:07</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4521224" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4521224);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4431949.html" id="cb_post_title_url">[LeetCode] Divide Two Integers 两数相除</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Divide two integers without using multiplication, division and mod operator.</p>
<p>If it is overflow, return MAX_INT.</p>
<p> </p>
<p>这道题让我们求两数相除，而且规定我们不能用乘法，除法和取余操作，那么我们还可以用另一神器位操作Bit Operation，思路是，如果被除数大于或等于除数，则进行如下循环，定义变量t等于除数，定义计数p，当t的两倍小于等于被除数时，进行如下循环，t扩大一倍，p扩大一倍，然后更新res和m。这道题的OJ给的一些test case非常的讨厌，因为输入的都是int型，比如被除数是-2147483648，在int范围内，当除数是-1时，结果就超出了int范围，需要返回INT_MAX，所以对于这种情况我们就在开始用if判定，将其和除数为0的情况放一起判定，返回INT_MAX。然后我们还要根据被除数和除数的正负来确定返回值的正负，这里我们采用长整型long来完成所有的计算，最后返回值乘以符号即可，代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> divide(<span style="color: #0000ff;">int</span> dividend, <span style="color: #0000ff;">int</span><span style="color: #000000;"> divisor) {
        </span><span style="color: #0000ff;">if</span> (divisor == <span style="color: #800080;">0</span> || (dividend == INT_MIN &amp;&amp; divisor == -<span style="color: #800080;">1</span>)) <span style="color: #0000ff;">return</span><span style="color: #000000;"> INT_MAX;
        </span><span style="color: #0000ff;">long</span> <span style="color: #0000ff;">long</span> m = abs((<span style="color: #0000ff;">long</span> <span style="color: #0000ff;">long</span>)dividend), n = abs((<span style="color: #0000ff;">long</span> <span style="color: #0000ff;">long</span>)divisor), res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> sign = ((dividend &lt; <span style="color: #800080;">0</span>) ^ (divisor &lt; <span style="color: #800080;">0</span>)) ? -<span style="color: #800080;">1</span> : <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (n == <span style="color: #800080;">1</span>) <span style="color: #0000ff;">return</span> sign == <span style="color: #800080;">1</span> ? m : -<span style="color: #000000;">m;
        </span><span style="color: #0000ff;">while</span> (m &gt;=<span style="color: #000000;"> n) {
            </span><span style="color: #0000ff;">long</span> <span style="color: #0000ff;">long</span> t = n, p = <span style="color: #800080;">1</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">while</span> (m &gt;= (t &lt;&lt; <span style="color: #800080;">1</span><span style="color: #000000;">)) {
                t </span>&lt;&lt;= <span style="color: #800080;">1</span><span style="color: #000000;">;
                p </span>&lt;&lt;= <span style="color: #800080;">1</span><span style="color: #000000;">;
            }
            res </span>+=<span style="color: #000000;"> p;
            m </span>-=<span style="color: #000000;"> t;
        }
        </span><span style="color: #0000ff;">return</span> sign == <span style="color: #800080;">1</span> ? res : -<span style="color: #000000;">res;
    }
};</span></pre>
</div>
<p> </p>
<p>我们可以使上面的解法变得更加简洁：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> divide(<span style="color: #0000ff;">int</span> dividend, <span style="color: #0000ff;">int</span><span style="color: #000000;"> divisor) {
        </span><span style="color: #0000ff;">long</span> <span style="color: #0000ff;">long</span> m = abs((<span style="color: #0000ff;">long</span> <span style="color: #0000ff;">long</span>)dividend), n = abs((<span style="color: #0000ff;">long</span> <span style="color: #0000ff;">long</span>)divisor), res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (m &lt; n) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;    
        </span><span style="color: #0000ff;">while</span> (m &gt;=<span style="color: #000000;"> n) {
            </span><span style="color: #0000ff;">long</span> <span style="color: #0000ff;">long</span> t = n, p = <span style="color: #800080;">1</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">while</span> (m &gt; (t &lt;&lt; <span style="color: #800080;">1</span><span style="color: #000000;">)) {
                t </span>&lt;&lt;= <span style="color: #800080;">1</span><span style="color: #000000;">;
                p </span>&lt;&lt;= <span style="color: #800080;">1</span><span style="color: #000000;">;
            }
            res </span>+=<span style="color: #000000;"> p;
            m </span>-=<span style="color: #000000;"> t;
        }
        </span><span style="color: #0000ff;">if</span> ((dividend &lt; <span style="color: #800080;">0</span>) ^ (divisor &lt; <span style="color: #800080;">0</span>)) res = -<span style="color: #000000;">res;
        </span><span style="color: #0000ff;">return</span> res &gt; INT_MAX ?<span style="color: #000000;"> INT_MAX : res;
    }
};</span></pre>
</div>
<p> </p>
<p>我们也可以通过递归的方法来解，思路都一样：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> divide(<span style="color: #0000ff;">int</span> dividend, <span style="color: #0000ff;">int</span><span style="color: #000000;"> divisor) {
        </span><span style="color: #0000ff;">long</span> <span style="color: #0000ff;">long</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">long</span> <span style="color: #0000ff;">long</span> m = abs((<span style="color: #0000ff;">long</span> <span style="color: #0000ff;">long</span>)dividend), n = abs((<span style="color: #0000ff;">long</span> <span style="color: #0000ff;">long</span><span style="color: #000000;">)divisor);
        </span><span style="color: #0000ff;">if</span> (m &lt; n) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">long</span> <span style="color: #0000ff;">long</span> t = n, p = <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (m &gt; (t &lt;&lt; <span style="color: #800080;">1</span><span style="color: #000000;">)) {
            t </span>&lt;&lt;= <span style="color: #800080;">1</span><span style="color: #000000;">;
            p </span>&lt;&lt;= <span style="color: #800080;">1</span><span style="color: #000000;">;
        }
        res </span>+= p + divide(m -<span style="color: #000000;"> t, n);
        </span><span style="color: #0000ff;">if</span> ((dividend &lt; <span style="color: #800080;">0</span>) ^ (divisor &lt; <span style="color: #800080;">0</span>)) res = -<span style="color: #000000;">res;
        </span><span style="color: #0000ff;">return</span> res &gt; INT_MAX ?<span style="color: #000000;"> INT_MAX : res;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/38191/summary-of-3-c-solutions" target="_blank">https://discuss.leetcode.com/topic/38191/summary-of-3-c-solutions</a></p>
<p><a href="https://discuss.leetcode.com/topic/3421/simple-o-log-n-2-c-solution" target="_blank">https://discuss.leetcode.com/topic/3421/simple-o-log-n-2-c-solution</a></p>
<p><a href="https://discuss.leetcode.com/topic/15568/detailed-explained-8ms-c-solution/2" target="_blank">https://discuss.leetcode.com/topic/15568/detailed-explained-8ms-c-solution/2</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-04-16 14:04</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4431949" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4431949);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4606696.html" id="cb_post_title_url">[LeetCode] Implement strStr() 实现strStr()函数</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Implement strStr().</p>
<p>Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.</p>
<p> <strong><span style="color: red;">Update (2014-11-02):</span></strong><br/>
The signature of the function had been updated to return the <em>index</em> instead of the pointer. If you still see your function signature returns a <code>char *</code> or <code>String</code>, please click the reload button <span class="glyphicon glyphicon-refresh"> to reset your code definition.
</span></p>
<p> </p>
<p>这道题让我们在一个字符串中找另一个字符串第一次出现的位置，那我们首先要做一些判断，如果子字符串为空，则返回0，如果子字符串长度大于母字符串长度，则返回-1。然后我们开始遍历母字符串，我们并不需要遍历整个母字符串，而是遍历到剩下的长度和子字符串相等的位置即可，这样可以提高运算效率。然后对于每一个字符，我们都遍历一遍子字符串，一个一个字符的对应比较，如果对应位置有不等的，则跳出循环，如果一直都没有跳出循环，则说明子字符串出现了，则返回起始位置即可，代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> strStr(<span style="color: #0000ff;">string</span> haystack, <span style="color: #0000ff;">string</span><span style="color: #000000;"> needle) {
        </span><span style="color: #0000ff;">if</span> (needle.empty()) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> m = haystack.size(), n =<span style="color: #000000;"> needle.size();
        </span><span style="color: #0000ff;">if</span> (m &lt; n) <span style="color: #0000ff;">return</span> -<span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt;= m - n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">for</span> (j = <span style="color: #800080;">0</span>; j &lt; n; ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> (haystack[i + j] != needle[j]) <span style="color: #0000ff;">break</span><span style="color: #000000;">;
            }
            </span><span style="color: #0000ff;">if</span> (j == n) <span style="color: #0000ff;">return</span><span style="color: #000000;"> i;
        }
        </span><span style="color: #0000ff;">return</span> -<span style="color: #800080;">1</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p><span style="line-height: 1.5;"> </span></p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-06-29 08:51</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4606696" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4606696);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4606700.html" id="cb_post_title_url">[LeetCode] Remove Element 移除元素</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given an array and a value, remove all instances of that value in place and return the new length.</p>
<p>The order of elements can be changed. It doesn't matter what you leave beyond the new length.</p>
<p> </p>
<p>这道题让我们移除一个数组中和给定值相同的数字，并返回新的数组的长度。是一道比较容易的题，我们只需要一个变量用来计数，然后遍历原数组，如果当前的值和给定值不同，我们就把当前值覆盖计数变量的位置，并将计数变量加1。代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> removeElement(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; nums, <span style="color: #0000ff;">int</span><span style="color: #000000;"> val) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; nums.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (nums[i] != val) nums[res++] =<span style="color: #000000;"> nums[i];
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-06-29 08:54</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4606700" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4606700);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4329128.html" id="cb_post_title_url">[LeetCode] Remove Duplicates from Sorted Array 有序数组中去除重复项</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a sorted array, remove the duplicates in place such that each element appear only <em>once</em> and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this in place with constant memory.</p>
<p>For example,<br/>Given input array A = <code>[1,1,2]</code>,</p>
<p>Your function should return length = <code>2</code>, and A is now <code>[1,2]</code>.</p>
<p> </p>
<p>这道题要我们从有序数组中去除重复项，和之前那道<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4066453.html" id="cb_post_title_url"> Remove Duplicates from Sorted List 移除有序链表中的重复项</a> 的题很类似，但是要简单一些，因为毕竟数组的值可以通过下标直接访问，而链表不行。那么这道题的解题思路是，我们使用快慢指针来记录遍历的坐标，最开始时两个指针都指向第一个数字，如果两个指针指的数字相同，则快指针向前走一步，如果不同，则两个指针都向前走一步，这样当快指针走完整个数组后，慢指针当前的坐标加1就是数组中不同数字的个数，代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> removeDuplicates(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        </span><span style="color: #0000ff;">if</span> (nums.empty()) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> pre = <span style="color: #800080;">0</span>, cur = <span style="color: #800080;">0</span>, n =<span style="color: #000000;"> nums.size();
        </span><span style="color: #0000ff;">while</span> (cur &lt;<span style="color: #000000;"> n) {
            </span><span style="color: #0000ff;">if</span> (nums[pre] == nums[cur]) ++<span style="color: #000000;">cur;
            </span><span style="color: #0000ff;">else</span> nums[++pre] = nums[cur++<span style="color: #000000;">];
        }
        </span><span style="color: #0000ff;">return</span> pre + <span style="color: #800080;">1</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>我们也可以用for循环来写，这里的j就是上面解法中的pre，i就是cur，所以本质上都是一样的，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> removeDuplicates(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        </span><span style="color: #0000ff;">if</span> (nums.empty()) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>, n =<span style="color: #000000;"> nums.size();
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (nums[i] != nums[j]) nums[++j] =<span style="color: #000000;"> nums[i];
        }
        </span><span style="color: #0000ff;">return</span> j + <span style="color: #800080;">1</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4066453.html" target="_blank">Remove Duplicates from Sorted List</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4069003.html" target="_blank">Remove Duplicates from Sorted List II</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4329295.html" target="_blank">Remove Duplicates from Sorted Array II</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4606700.html" target="_blank">Remove Element</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-03-11 10:22</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4329128" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4329128);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4441324.html" id="cb_post_title_url">[LeetCode] Reverse Nodes in k-Group 每k个一组翻转链表</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a linked list, reverse the nodes of a linked list <em>k</em> at a time and return its modified list.</p>
<p><em>k</em> is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of <em>k</em> then left-out nodes in the end should remain as it is.</p>
<p>Example:</p>
<p>Given this linked list: <code>1-&gt;2-&gt;3-&gt;4-&gt;5</code></p>
<p>For <em>k</em> = 2, you should return: <code>2-&gt;1-&gt;4-&gt;3-&gt;5</code></p>
<p>For <em>k</em> = 3, you should return: <code>3-&gt;2-&gt;1-&gt;4-&gt;5</code></p>
<p>Note:</p>
<ul>
<li>Only constant extra memory is allowed.</li>
<li>You may not alter the values in the list's nodes, only nodes itself may be changed.</li>
</ul>
<p> </p>
<p>这道题让我们以每k个为一组来翻转链表，实际上是把原链表分成若干小段，然后分别对其进行翻转，那么肯定总共需要两个函数，一个是用来分段的，一个是用来翻转的，我们就以题目中给的例子来看，对于给定链表1-&gt;2-&gt;3-&gt;4-&gt;5，一般在处理链表问题时，我们大多时候都会在开头再加一个dummy node，因为翻转链表时头结点可能会变化，为了记录当前最新的头结点的位置而引入的dummy node，那么我们加入dummy node后的链表变为-1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;5，如果k为3的话，我们的目标是将1,2,3翻转一下，那么我们需要一些指针，pre和next分别指向要翻转的链表的前后的位置，然后翻转后pre的位置更新到如下新的位置：</p>
<p> </p>
<div class="cnblogs_code">
<pre>-<span style="color: #800080;">1</span>-&gt;<span style="color: #800080;">1</span>-&gt;<span style="color: #800080;">2</span>-&gt;<span style="color: #800080;">3</span>-&gt;<span style="color: #800080;">4</span>-&gt;<span style="color: #800080;">5</span>
 |           |<span style="color: #000000;">
pre         next

</span>-<span style="color: #800080;">1</span>-&gt;<span style="color: #800080;">3</span>-&gt;<span style="color: #800080;">2</span>-&gt;<span style="color: #800080;">1</span>-&gt;<span style="color: #800080;">4</span>-&gt;<span style="color: #800080;">5</span>
          |  |<span style="color: #000000;">
         pre next</span></pre>
</div>
<p> </p>
<p>以此类推，只要next走过k个节点，就可以调用翻转函数来进行局部翻转了，代码如下所示：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    ListNode </span>*reverseKGroup(ListNode *head, <span style="color: #0000ff;">int</span><span style="color: #000000;"> k) {
        </span><span style="color: #0000ff;">if</span> (!head || k == <span style="color: #800080;">1</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;"> head;
        ListNode </span>*dummy = <span style="color: #0000ff;">new</span> ListNode(-<span style="color: #800080;">1</span><span style="color: #000000;">);
        ListNode </span>*pre = dummy, *cur =<span style="color: #000000;"> head;
        dummy</span>-&gt;next =<span style="color: #000000;"> head;
        </span><span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> (cur) {
            </span>++<span style="color: #000000;">i;
            </span><span style="color: #0000ff;">if</span> (i % k == <span style="color: #800080;">0</span><span style="color: #000000;">) {
                pre </span>= reverseOneGroup(pre, cur-&gt;<span style="color: #000000;">next);
                cur </span>= pre-&gt;<span style="color: #000000;">next;
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                cur </span>= cur-&gt;<span style="color: #000000;">next;
            }
        }
        </span><span style="color: #0000ff;">return</span> dummy-&gt;<span style="color: #000000;">next;
    }
    ListNode </span>*reverseOneGroup(ListNode *pre, ListNode *<span style="color: #000000;">next) {
        ListNode </span>*last = pre-&gt;<span style="color: #000000;">next;
        ListNode </span>*cur = last-&gt;<span style="color: #000000;">next;
        </span><span style="color: #0000ff;">while</span>(cur !=<span style="color: #000000;"> next) {
            last</span>-&gt;next = cur-&gt;<span style="color: #000000;">next;
            cur</span>-&gt;next = pre-&gt;<span style="color: #000000;">next;
            pre</span>-&gt;next =<span style="color: #000000;"> cur;
            cur </span>= last-&gt;<span style="color: #000000;">next;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> last;
    }
};</span></pre>
</div>
<p> </p>
<p>我们也可以在一个函数中完成，我们首先遍历整个链表，统计出链表的长度，然后如果长度大于等于k，我们开始交换节点，当k=2时，每段我们只需要交换一次，当k=3时，每段需要交换2此，所以i从1开始循环，注意交换一段后更新pre指针，然后num自减k，直到num&lt;k时循环结束，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    ListNode</span>* reverseKGroup(ListNode* head, <span style="color: #0000ff;">int</span><span style="color: #000000;"> k) {
        ListNode </span>*dummy = <span style="color: #0000ff;">new</span> ListNode(-<span style="color: #800080;">1</span>), *pre = dummy, *cur =<span style="color: #000000;"> pre;
        dummy</span>-&gt;next =<span style="color: #000000;"> head;
        </span><span style="color: #0000ff;">int</span> num = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (cur = cur-&gt;next) ++<span style="color: #000000;">num;
        </span><span style="color: #0000ff;">while</span> (num &gt;=<span style="color: #000000;"> k) {
            cur </span>= pre-&gt;<span style="color: #000000;">next;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt; k; ++<span style="color: #000000;">i) {
                ListNode </span>*t = cur-&gt;<span style="color: #000000;">next;
                cur</span>-&gt;next = t-&gt;<span style="color: #000000;">next;
                t</span>-&gt;next = pre-&gt;<span style="color: #000000;">next;
                pre</span>-&gt;next =<span style="color: #000000;"> t;
            }
            pre </span>=<span style="color: #000000;"> cur;
            num </span>-=<span style="color: #000000;"> k;
        }
        </span><span style="color: #0000ff;">return</span> dummy-&gt;<span style="color: #000000;">next;
    }
};</span></pre>
</div>
<p> </p>
<p>我们也可以使用递归来做，我们用head记录每段的开始位置，cur记录结束位置的下一个节点，然后我们调用reverse函数来将这段翻转，然后得到一个new_head，原来的head就变成了末尾，这时候后面接上递归调用下一段得到的新节点，返回new_head即可，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    ListNode</span>* reverseKGroup(ListNode* head, <span style="color: #0000ff;">int</span><span style="color: #000000;"> k) {
        ListNode </span>*cur =<span style="color: #000000;"> head;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; k; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (!cur) <span style="color: #0000ff;">return</span><span style="color: #000000;"> head;
            cur </span>= cur-&gt;<span style="color: #000000;">next;
        }
        ListNode </span>*new_head =<span style="color: #000000;"> reverse(head, cur);
        head</span>-&gt;next =<span style="color: #000000;"> reverseKGroup(cur, k);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> new_head;
    }
    ListNode</span>* reverse(ListNode* head, ListNode*<span style="color: #000000;"> tail) {
        ListNode </span>*pre =<span style="color: #000000;"> tail;
        </span><span style="color: #0000ff;">while</span> (head !=<span style="color: #000000;"> tail) {
            ListNode </span>*t = head-&gt;<span style="color: #000000;">next;
            head</span>-&gt;next =<span style="color: #000000;"> pre;
            pre </span>=<span style="color: #000000;"> head;
            head </span>=<span style="color: #000000;"> t;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> pre;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4441680.html" target="_blank">Swap Nodes in Pairs</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-04-20 13:24</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4441324" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4441324);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4441680.html" id="cb_post_title_url">[LeetCode] Swap Nodes in Pairs 成对交换节点</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="question-description">
<div>
<p>Given a linked list, swap every two adjacent nodes and return its head.</p>
<p>Example:</p>
<pre>Given <code>1-&gt;2-&gt;3-&gt;4</code>, you should return the list as <code>2-&gt;1-&gt;4-&gt;3</code>.</pre>
<p>Note:</p>
<ul>
<li>Your algorithm should use only constant extra space.</li>
<li>You may not modify the values in the list's nodes, only nodes itself may be changed.</li>
</ul>
</div>
</div>
<p> </p>
<p>这道题不算难，是基本的链表操作题，我们可以分别用递归和迭代来实现。对于迭代实现，还是需要建立dummy节点，注意在连接节点的时候，最好画个图，以免把自己搞晕了，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    ListNode</span>* swapPairs(ListNode*<span style="color: #000000;"> head) {
        ListNode </span>*dummy = <span style="color: #0000ff;">new</span> ListNode(-<span style="color: #800080;">1</span>), *pre =<span style="color: #000000;"> dummy;
        dummy</span>-&gt;next =<span style="color: #000000;"> head;
        </span><span style="color: #0000ff;">while</span> (pre-&gt;next &amp;&amp; pre-&gt;next-&gt;<span style="color: #000000;">next) {
            ListNode </span>*t = pre-&gt;next-&gt;<span style="color: #000000;">next;
            pre</span>-&gt;next-&gt;next = t-&gt;<span style="color: #000000;">next;
            t</span>-&gt;next = pre-&gt;<span style="color: #000000;">next;
            pre</span>-&gt;next =<span style="color: #000000;"> t;
            pre </span>= t-&gt;<span style="color: #000000;">next;
        }
        </span><span style="color: #0000ff;">return</span> dummy-&gt;<span style="color: #000000;">next;
    }
};</span></pre>
</div>
<p> </p>
<p>递归的写法就更简洁了，实际上利用了回溯的思想，递归遍历到链表末尾，然后先交换末尾两个，然后依次往前交换：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    ListNode</span>* swapPairs(ListNode*<span style="color: #000000;"> head) {
        </span><span style="color: #0000ff;">if</span> (!head || !head-&gt;next) <span style="color: #0000ff;">return</span><span style="color: #000000;"> head;
        ListNode </span>*t = head-&gt;<span style="color: #000000;">next;
        head</span>-&gt;next = swapPairs(head-&gt;next-&gt;<span style="color: #000000;">next);
        t</span>-&gt;next =<span style="color: #000000;"> head;
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> t;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4441324.html" target="_blank">Reverse Nodes in k-Group</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-04-20 15:20</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4441680" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4441680);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4606710.html" id="cb_post_title_url">[LeetCode] Merge k Sorted Lists 合并k个有序链表</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Merge <em>k</em> sorted linked lists and return it as one sorted list. Analyze and describe its complexity.</p>
<p> </p>
<p>这道题让我们合并k个有序链表，之前我们做过一道<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4086297.html" id="cb_post_title_url">Merge Two Sorted Lists 混合插入有序链表</a>，是混合插入两个有序链表。这道题增加了难度，变成合并k个有序链表了，但是不管合并几个，基本还是要两两合并。那么我们首先考虑的方法是能不能利用之前那道题的解法来解答此题。答案是肯定的，但是需要修改，怎么修改呢，最先想到的就是两两合并，就是前两个先合并，合并好了再跟第三个，然后第四个直到第k个。这样的思路是对的，但是效率不高，没法通过OJ，所以我们只能换一种思路，这里就需要用到分治法 <span class="st">Divide and Conquer Approach。简单来说就是不停的对半划分，比如k个链表先划分为合并两个k/2个链表的任务，再不停的往下划分，直到划分成只有一个或两个链表的任务，开始合并。举个例子来说比如合并6个链表，那么按照分治法，我们首先分别合并1和4,2和5,3和6。这样下一次只需合并3个链表，我们再合并1和3，最后和2合并就可以了。参见代码如下：</span></p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    ListNode </span>*mergeKLists(vector&lt;ListNode *&gt; &amp;<span style="color: #000000;">lists) {
        </span><span style="color: #0000ff;">if</span> (lists.size() == <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;"> NULL;
        </span><span style="color: #0000ff;">int</span> n =<span style="color: #000000;"> lists.size();
        </span><span style="color: #0000ff;">while</span> (n &gt; <span style="color: #800080;">1</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">int</span> k = (n + <span style="color: #800080;">1</span>) / <span style="color: #800080;">2</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n / <span style="color: #800080;">2</span>; ++<span style="color: #000000;">i) {
                lists[i] </span>= mergeTwoLists(lists[i], lists[i +<span style="color: #000000;"> k]);
            }
            n </span>=<span style="color: #000000;"> k;
        }
        </span><span style="color: #0000ff;">return</span> lists[<span style="color: #800080;">0</span><span style="color: #000000;">];
    }
    
    ListNode </span>*mergeTwoLists(ListNode *l1, ListNode *<span style="color: #000000;">l2) {
        ListNode </span>*head = <span style="color: #0000ff;">new</span> ListNode(-<span style="color: #800080;">1</span><span style="color: #000000;">);
        ListNode </span>*cur =<span style="color: #000000;"> head;
        </span><span style="color: #0000ff;">while</span> (l1 &amp;&amp;<span style="color: #000000;"> l2) {
            </span><span style="color: #0000ff;">if</span> (l1-&gt;val &lt; l2-&gt;<span style="color: #000000;">val) {
                cur</span>-&gt;next =<span style="color: #000000;"> l1;
                l1 </span>= l1-&gt;<span style="color: #000000;">next;
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                cur</span>-&gt;next =<span style="color: #000000;"> l2;
                l2 </span>= l2-&gt;<span style="color: #000000;">next;
            }
            cur </span>= cur-&gt;<span style="color: #000000;">next;
        }
        </span><span style="color: #0000ff;">if</span> (l1) cur-&gt;next =<span style="color: #000000;"> l1;
        </span><span style="color: #0000ff;">if</span> (l2) cur-&gt;next =<span style="color: #000000;"> l2;
        </span><span style="color: #0000ff;">return</span> head-&gt;<span style="color: #000000;">next;
    }
};</span></pre>
</div>
<p> </p>
<p>我们再来看另一种解法，这种解法利用了<a href="https://zh.wikipedia.org/wiki/%E6%9C%80%E5%A4%A7%E2%80%94%E6%9C%80%E5%B0%8F%E5%A0%86" target="_blank">最小堆</a>这种数据结构，我们首先把k个链表的首元素都加入最小堆中，它们会自动排好序。然后我们每次取出最小的那个元素加入我们最终结果的链表中，然后把取出元素的下一个元素再加入堆中，下次仍从堆中取出最小的元素做相同的操作，以此类推，直到堆中没有元素了，此时k个链表也合并为了一个链表，返回首节点即可，代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">struct</span><span style="color: #000000;"> cmp {
    </span><span style="color: #0000ff;">bool</span> <span style="color: #0000ff;">operator</span> () (ListNode *a, ListNode *<span style="color: #000000;">b) {
        </span><span style="color: #0000ff;">return</span> a-&gt;val &gt; b-&gt;<span style="color: #000000;">val;
    }
};
 
</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {  
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:  
    ListNode </span>*mergeKLists(vector&lt;ListNode *&gt; &amp;<span style="color: #000000;">lists) {  </span>
        priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, cmp&gt;<span style="color: #000000;"> q;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; lists.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (lists[i]) q.push(lists[i]);
        }
        ListNode </span>*head = NULL, *pre = NULL, *tmp =<span style="color: #000000;"> NULL;
        </span><span style="color: #0000ff;">while</span> (!<span style="color: #000000;">q.empty()) {
            tmp </span>=<span style="color: #000000;"> q.top();
            q.pop();
            </span><span style="color: #0000ff;">if</span> (!pre) head =<span style="color: #000000;"> tmp;
            </span><span style="color: #0000ff;">else</span> pre-&gt;next =<span style="color: #000000;"> tmp;
            pre </span>=<span style="color: #000000;"> tmp;
            </span><span style="color: #0000ff;">if</span> (tmp-&gt;next) q.push(tmp-&gt;<span style="color: #000000;">next);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> head;
    }  
};  </span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="http://www.cnblogs.com/TenosDoIt/p/3673188.html" target="_blank">http://www.cnblogs.com/TenosDoIt/p/3673188.html</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-06-29 08:59</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4606710" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4606710);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4444160.html" id="cb_post_title_url">[LeetCode] Generate Parentheses 生成括号</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given <em>n</em> pairs of parentheses, write a function to generate all combinations of well-formed parentheses.</p>
<p>For example, given <em>n</em> = 3, a solution set is:</p>
<p><code>"((()))", "(()())", "(())()", "()(())", "()()()"</code></p>
<p> </p>
<p>在LeetCode中有关括号的题共有三道，除了这一道的另外两道是<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4424587.html" id="homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0"> Valid Parentheses 验证括号</a>和<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4424731.html" id="cb_post_title_url"> Longest Valid Parentheses 最长有效括号</a>，这道题给定一个数字n，让生成共有n个括号的所有正确的形式，对于这种列出所有结果的题首先还是考虑用递归Recursion来解，由于字符串只有左括号和右括号两种字符，而且最终结果必定是左括号3个，右括号3个，所以我们定义两个变量left和right分别表示剩余左右括号的个数，如果在某次递归时，左括号的个数大于右括号的个数，说明此时生成的字符串中右括号的个数大于左括号的个数，即会出现')('这样的非法串，所以这种情况直接返回，不继续处理。如果left和right都为0，则说明此时生成的字符串已有3个左括号和3个右括号，且字符串合法，则存入结果中后返回。如果以上两种情况都不满足，若此时left大于0，则调用递归函数，注意参数的更新，若right大于0，则调用递归函数，同样要更新参数。代码如下：</p>
<p> </p>
<p>C++ 解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; generateParenthesis(<span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        vector</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> res;
        generateParenthesisDFS(n, n, </span><span style="color: #800000;">""</span><span style="color: #000000;">, res);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">void</span> generateParenthesisDFS(<span style="color: #0000ff;">int</span> left, <span style="color: #0000ff;">int</span> right, <span style="color: #0000ff;">string</span> <span style="color: #0000ff;">out</span>, vector&lt;<span style="color: #0000ff;">string</span>&gt; &amp;<span style="color: #000000;">res) {
        </span><span style="color: #0000ff;">if</span> (left &gt; right) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (left == <span style="color: #800080;">0</span> &amp;&amp; right == <span style="color: #800080;">0</span>) res.push_back(<span style="color: #0000ff;">out</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            </span><span style="color: #0000ff;">if</span> (left &gt; <span style="color: #800080;">0</span>) generateParenthesisDFS(left - <span style="color: #800080;">1</span>, right, <span style="color: #0000ff;">out</span> + <span style="color: #800000;">'</span><span style="color: #800000;">(</span><span style="color: #800000;">'</span><span style="color: #000000;">, res);
            </span><span style="color: #0000ff;">if</span> (right &gt; <span style="color: #800080;">0</span>) generateParenthesisDFS(left, right - <span style="color: #800080;">1</span>, <span style="color: #0000ff;">out</span> + <span style="color: #800000;">'</span><span style="color: #800000;">)</span><span style="color: #800000;">'</span><span style="color: #000000;">, res);
        }
    }
};</span></pre>
</div>
<p> </p>
<p>Java 解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
    </span><span style="color: #0000ff;">public</span> List&lt;String&gt; generateParenthesis(<span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        List</span>&lt;String&gt; res = <span style="color: #0000ff;">new</span> ArrayList&lt;String&gt;<span style="color: #000000;">();
        helper(n, n, </span>""<span style="color: #000000;">, res);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">void</span> helper(<span style="color: #0000ff;">int</span> left, <span style="color: #0000ff;">int</span> right, String out, List&lt;String&gt;<span style="color: #000000;"> res) {
        </span><span style="color: #0000ff;">if</span> (left &lt; 0 || right &lt; 0 || left &gt; right) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (left == 0 &amp;&amp; right == 0<span style="color: #000000;">) {
            res.add(out);
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;">;
        }
        helper(left </span>- 1, right, out + "("<span style="color: #000000;">, res);
        helper(left, right </span>- 1, out + ")"<span style="color: #000000;">, res);
    }
}</span></pre>
</div>
<p> </p>
<p>再来看那一种方法，这种方法是CareerCup书上给的方法，感觉也是满巧妙的一种方法，这种方法的思想是找左括号，每找到一个左括号，就在其后面加一个完整的括号，最后再在开头加一个()，就形成了所有的情况，需要注意的是，有时候会出现重复的情况，所以我们用set数据结构，好处是如果遇到重复项，不会加入到结果中，最后我们再把set转为vector即可，参见代码如下：：</p>
<p>n＝1:    ()</p>
<p>n=2:    (())    ()()</p>
<p>n=3:    (()())    ((()))    ()(())    (())()    ()()()   </p>
<p> </p>
<p>C++ 解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; generateParenthesis(<span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        </span><span style="color: #0000ff;">set</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> t;
        </span><span style="color: #0000ff;">if</span> (n == <span style="color: #800080;">0</span>) t.insert(<span style="color: #800000;">""</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; pre = generateParenthesis(n - <span style="color: #800080;">1</span><span style="color: #000000;">);
            </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto a : pre) {
                </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; a.size(); ++<span style="color: #000000;">i) {
                    </span><span style="color: #0000ff;">if</span> (a[i] == <span style="color: #800000;">'</span><span style="color: #800000;">(</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                        a.insert(a.begin() </span>+ i + <span style="color: #800080;">1</span>, <span style="color: #800000;">'</span><span style="color: #800000;">(</span><span style="color: #800000;">'</span><span style="color: #000000;">);
                        a.insert(a.begin() </span>+ i + <span style="color: #800080;">2</span>, <span style="color: #800000;">'</span><span style="color: #800000;">)</span><span style="color: #800000;">'</span><span style="color: #000000;">);
                        t.insert(a);
                        a.erase(a.begin() </span>+ i + <span style="color: #800080;">1</span>, a.begin() + i + <span style="color: #800080;">3</span><span style="color: #000000;">);
                    }
                }
                t.insert(</span><span style="color: #800000;">"</span><span style="color: #800000;">()</span><span style="color: #800000;">"</span> +<span style="color: #000000;"> a);
            }
        }
        </span><span style="color: #0000ff;">return</span> vector&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;">(t.begin(), t.end());
    }
};</span></pre>
</div>
<p>  </p>
<p>Java 解法二:</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
    </span><span style="color: #0000ff;">public</span> List&lt;String&gt; generateParenthesis(<span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        Set</span>&lt;String&gt; res = <span style="color: #0000ff;">new</span> HashSet&lt;String&gt;<span style="color: #000000;">();
        </span><span style="color: #0000ff;">if</span> (n == 0<span style="color: #000000;">) {
            res.add(</span>""<span style="color: #000000;">);
        } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            List</span>&lt;String&gt; pre = generateParenthesis(n - 1<span style="color: #000000;">);
            </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (String str : pre) {
                </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = 0; i &lt; str.length(); ++<span style="color: #000000;">i) {
                    </span><span style="color: #0000ff;">if</span> (str.charAt(i) == '('<span style="color: #000000;">) {
                        str </span>= str.substring(0, i + 1) + "()" + str.substring(i + 1<span style="color: #000000;">, str.length());
                        res.add(str);
                        str </span>= str.substring(0, i + 1) +  str.substring(i + 3<span style="color: #000000;">, str.length());
                    }
                }
                res.add(</span>"()" +<span style="color: #000000;"> str);
            }
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> ArrayList(res);
    }
}</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4944875.html">Remove Invalid Parentheses</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4682458.html">Different Ways to Add Parentheses</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4424731.html" target="_blank">Longest Valid Parentheses</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4424587.html" target="_blank">Valid Parentheses</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/4485/concise-recursive-c-solution" target="_blank">https://discuss.leetcode.com/topic/4485/concise-recursive-c-solution</a></p>
<p><a href="https://discuss.leetcode.com/topic/30026/2ms-ac-java-solution-using-recursive-call/2" target="_blank">https://discuss.leetcode.com/topic/30026/2ms-ac-java-solution-using-recursive-call/2</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-04-21 13:47</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4444160" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4444160);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4086297.html" id="cb_post_title_url">[LeetCode] Merge Two Sorted Lists 混合插入有序链表</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p>
<p> </p>
<p>这道混合插入有序链表和我之前那篇混合插入有序数组非常的相似<a href="http://www.cnblogs.com/grandyang/p/4059650.html" target="_blank">Merge Sorted Array</a>，仅仅是数据结构由数组换成了链表而已，代码写起来反而更简洁。具体思想就是新建一个链表，然后比较两个链表中的元素值，把较小的那个链到新链表中，由于两个输入链表的长度可能不同，所以最终会有一个链表先完成插入所有元素，则直接另一个未完成的链表直接链入新链表的末尾。代码如下：</p>
<p> </p>
<p>C++ 解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    ListNode</span>* mergeTwoLists(ListNode* l1, ListNode*<span style="color: #000000;"> l2) {
        ListNode </span>*dummy = <span style="color: #0000ff;">new</span> ListNode(-<span style="color: #800080;">1</span>), *cur =<span style="color: #000000;"> dummy;
        </span><span style="color: #0000ff;">while</span> (l1 &amp;&amp;<span style="color: #000000;"> l2) {
            </span><span style="color: #0000ff;">if</span> (l1-&gt;val &lt; l2-&gt;<span style="color: #000000;">val) {
                cur</span>-&gt;next =<span style="color: #000000;"> l1;
                l1 </span>= l1-&gt;<span style="color: #000000;">next;
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                cur</span>-&gt;next =<span style="color: #000000;"> l2;
                l2 </span>= l2-&gt;<span style="color: #000000;">next;
            }
            cur </span>= cur-&gt;<span style="color: #000000;">next;
        }
        cur</span>-&gt;next = l1 ?<span style="color: #000000;"> l1 : l2;
        </span><span style="color: #0000ff;">return</span> dummy-&gt;<span style="color: #000000;">next;
    }
};</span></pre>
</div>
<p> </p>
<p>Java 解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode dummy </span>= <span style="color: #0000ff;">new</span> ListNode(-1), cur =<span style="color: #000000;"> dummy;
        </span><span style="color: #0000ff;">while</span> (l1 != <span style="color: #0000ff;">null</span> &amp;&amp; l2 != <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">if</span> (l1.val &lt;<span style="color: #000000;"> l2.val) {
                cur.next </span>=<span style="color: #000000;"> l1;
                l1 </span>=<span style="color: #000000;"> l1.next;
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                cur.next </span>=<span style="color: #000000;"> l2;
                l2 </span>=<span style="color: #000000;"> l2.next;
            }
            cur </span>=<span style="color: #000000;"> cur.next;
        }
        cur.next </span>= (l1 != <span style="color: #0000ff;">null</span>) ?<span style="color: #000000;"> l1 : l2;
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> dummy.next;
    }
}</span></pre>
</div>
<p> </p>
<p>下面我们来看递归的写法，当某个链表为空了，就返回另一个。然后核心还是比较当前两个节点值大小，如果l1的小，那么对于l1的下一个节点和l2调用递归函数，将返回值赋值给l1.next，然后返回l1；否则就对于l2的下一个节点和l1调用递归函数，将返回值赋值给l2.next，然后返回l2，参见代码如下：</p>
<p> </p>
<p>C++ 解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    ListNode</span>* mergeTwoLists(ListNode* l1, ListNode*<span style="color: #000000;"> l2) {
        </span><span style="color: #0000ff;">if</span> (!l1) <span style="color: #0000ff;">return</span><span style="color: #000000;"> l2;
        </span><span style="color: #0000ff;">if</span> (!l2) <span style="color: #0000ff;">return</span><span style="color: #000000;"> l1;
        </span><span style="color: #0000ff;">if</span> (l1-&gt;val &lt; l2-&gt;<span style="color: #000000;">val) {
            l1</span>-&gt;next = mergeTwoLists(l1-&gt;<span style="color: #000000;">next, l2);
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> l1;
        } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            l2</span>-&gt;next = mergeTwoLists(l1, l2-&gt;<span style="color: #000000;">next);
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> l2;
        }
    }
};</span></pre>
</div>
<p> </p>
<p>Java 解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        </span><span style="color: #0000ff;">if</span> (l1 == <span style="color: #0000ff;">null</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;"> l2;
        </span><span style="color: #0000ff;">if</span> (l2 == <span style="color: #0000ff;">null</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;"> l1;
        </span><span style="color: #0000ff;">if</span> (l1.val &lt;<span style="color: #000000;"> l2.val) {
            l1.next </span>=<span style="color: #000000;"> mergeTwoLists(l1.next, l2);
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> l1;
        } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            l2.next </span>=<span style="color: #000000;"> mergeTwoLists(l1, l2.next);
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> l2;
        }
    }
}</span></pre>
</div>
<p> </p>
<p>下面这种递归的写法去掉了if从句，看起来更加简洁一些，但是思路并没有什么不同：</p>
<p> </p>
<p>C++ 解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    ListNode</span>* mergeTwoLists(ListNode* l1, ListNode*<span style="color: #000000;"> l2) {
        </span><span style="color: #0000ff;">if</span> (!l1) <span style="color: #0000ff;">return</span><span style="color: #000000;"> l2;
        </span><span style="color: #0000ff;">if</span> (!l2) <span style="color: #0000ff;">return</span><span style="color: #000000;"> l1;
        ListNode </span>*head = l1-&gt;val &lt; l2-&gt;val ?<span style="color: #000000;"> l1 : l2;
        ListNode </span>*nonhead = l1-&gt;val &lt; l2-&gt;val ?<span style="color: #000000;"> l2 : l1;
        head</span>-&gt;next = mergeTwoLists(head-&gt;<span style="color: #000000;">next, nonhead);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> head;
    }
};</span></pre>
</div>
<p> </p>
<p>Java 解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        </span><span style="color: #0000ff;">if</span> (l1 == <span style="color: #0000ff;">null</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;"> l2;
        </span><span style="color: #0000ff;">if</span> (l2 == <span style="color: #0000ff;">null</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;"> l1;
        ListNode head </span>= (l1.val &lt; l2.val) ?<span style="color: #000000;"> l1 : l2;
        ListNode nonhead </span>= (l1.val &lt; l2.val) ?<span style="color: #000000;"> l2 : l1;
        head.next </span>=<span style="color: #000000;"> mergeTwoLists(head.next, nonhead);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> head;
    }
}</span></pre>
</div>
<p> </p>
<p> 我们还可以三行搞定，简直丧心病狂有木有！</p>
<p> </p>
<p>C++ 解法四：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    ListNode</span>* mergeTwoLists(ListNode* l1, ListNode*<span style="color: #000000;"> l2) {
        </span><span style="color: #0000ff;">if</span> (!l1 || (l2 &amp;&amp; l1-&gt;val &gt; l2-&gt;<span style="color: #000000;">val)) swap(l1, l2);
        </span><span style="color: #0000ff;">if</span> (l1) l1-&gt;next = mergeTwoLists(l1-&gt;<span style="color: #000000;">next, l2);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> l1;
    }
};</span></pre>
</div>
<p> </p>
<p>Java 解法四：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        </span><span style="color: #0000ff;">if</span> (l1 == <span style="color: #0000ff;">null</span> || (l2 != <span style="color: #0000ff;">null</span> &amp;&amp; l1.val &gt;<span style="color: #000000;"> l2.val)) {
            ListNode t </span>= l1; l1 = l2; l2 =<span style="color: #000000;"> t;
        }
        </span><span style="color: #0000ff;">if</span> (l1 != <span style="color: #0000ff;">null</span>) l1.next =<span style="color: #000000;"> mergeTwoLists(l1.next, l2);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> l1;
    }
}</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4059650.html" target="_blank">Merge Sorted Array</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/2513/a-recursive-solution" target="_blank">https://discuss.leetcode.com/topic/2513/a-recursive-solution</a></p>
<p><a href="https://discuss.leetcode.com/topic/18709/3-lines-c-12ms-and-c-4ms/2" target="_blank">https://discuss.leetcode.com/topic/18709/3-lines-c-12ms-and-c-4ms/2</a></p>
<p><a href="https://discuss.leetcode.com/topic/32953/java-recursive-solution-in-6-lines" target="_blank">https://discuss.leetcode.com/topic/32953/java-recursive-solution-in-6-lines</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2014-11-10 03:22</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4086297" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4086297);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4424587.html" id="cb_post_title_url">[LeetCode] Valid Parentheses 验证括号</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a string containing just the characters <code>'('</code>, <code>')'</code>, <code>'{'</code>, <code>'}'</code>, <code>'['</code> and <code>']'</code>, determine if the input string is valid.</p>
<p>The brackets must close in the correct order, <code>"()"</code> and <code>"()[]{}"</code> are all valid but <code>"(]"</code> and <code>"([)]"</code> are not.</p>
<p> </p>
<p><span style="color: #000000;">这道题让我们验证输入的字符串是否为括号字符串，包括大括号，中括号和小括号。这里我们需要用一个栈，我们开始遍历输入字符串，如果当前字符为左半边括号时，则将其压入栈中，如果遇到右半边括号时，若此时栈为空，则直接返回false，如不为空，则取出栈顶元素，若为对应的左半边括号，则继续循环，反之返回false，代码如下：</span></p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> isValid(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        stack</span>&lt;<span style="color: #0000ff;">char</span>&gt;<span style="color: #000000;"> parentheses;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; s.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (s[i] == <span style="color: #800000;">'</span><span style="color: #800000;">(</span><span style="color: #800000;">'</span> || s[i] == <span style="color: #800000;">'</span><span style="color: #800000;">[</span><span style="color: #800000;">'</span> || s[i] == <span style="color: #800000;">'</span><span style="color: #800000;">{</span><span style="color: #800000;">'</span><span style="color: #000000;">) parentheses.push(s[i]);
            </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                </span><span style="color: #0000ff;">if</span> (parentheses.empty()) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">if</span> (s[i] == <span style="color: #800000;">'</span><span style="color: #800000;">)</span><span style="color: #800000;">'</span> &amp;&amp; parentheses.top() != <span style="color: #800000;">'</span><span style="color: #800000;">(</span><span style="color: #800000;">'</span>) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">if</span> (s[i] == <span style="color: #800000;">'</span><span style="color: #800000;">]</span><span style="color: #800000;">'</span> &amp;&amp; parentheses.top() != <span style="color: #800000;">'</span><span style="color: #800000;">[</span><span style="color: #800000;">'</span>) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">if</span> (s[i] == <span style="color: #800000;">'</span><span style="color: #800000;">}</span><span style="color: #800000;">'</span> &amp;&amp; parentheses.top() != <span style="color: #800000;">'</span><span style="color: #800000;">{</span><span style="color: #800000;">'</span>) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                parentheses.pop();
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> parentheses.empty();
    }
}; </span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4944875.html">Remove Invalid Parentheses 移除非法括号</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4682458.html">Different Ways to Add Parentheses</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4424731.html" target="_blank">Longest Valid Parentheses</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4444160.html" target="_blank">Generate Parentheses</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/27768/short-easy-to-follow-8ms-java-solution" target="_blank">https://discuss.leetcode.com/topic/27768/short-easy-to-follow-8ms-java-solution</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-04-14 12:53</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4424587" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4424587);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4606920.html" id="cb_post_title_url">[LeetCode] Remove Nth Node From End of List 移除链表倒数第N个节点</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a linked list, remove the <em>n</em><sup>th</sup> node from the end of list and return its head.</p>
<p>For example,</p>
<pre>   Given linked list: <strong>1-&gt;2-&gt;3-&gt;4-&gt;5</strong>, and <strong><em>n</em> = 2</strong>.

   After removing the second node from the end, the linked list becomes <strong>1-&gt;2-&gt;3-&gt;5</strong>.
</pre>
<p> <strong>Note:</strong><br/>
Given <em>n</em> will always be valid.<br/>
Try to do this in one pass.
</p>
<p> </p>
<p>这道题让我们移除链表倒数第N个节点，限定n一定是有效的，即n不会大于链表中的元素总数。还有题目要求我们一次遍历解决问题，那么就得想些比较巧妙的方法了。比如我们首先要考虑的时，如何找到倒数第N个节点，由于只允许一次遍历，所以我们不能用一次完整的遍历来统计链表中元素的个数，而是遍历到对应位置就应该移除了。那么我们需要用两个指针来帮助我们解题，pre和cur指针。首先cur指针先向前走N步，如果此时cur指向空，说明N为链表的长度，则需要移除的为首元素，那么此时我们返回head-&gt;next即可，如果cur存在，我们再继续往下走，此时pre指针也跟着走，直到cur为最后一个元素时停止，此时pre指向要移除元素的前一个元素，我们再修改指针跳过需要移除的元素即可。代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    ListNode</span>* removeNthFromEnd(ListNode* head, <span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        </span><span style="color: #0000ff;">if</span> (!head-&gt;next) <span style="color: #0000ff;">return</span><span style="color: #000000;"> NULL;
        ListNode </span>*pre = head, *cur =<span style="color: #000000;"> head;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++i) cur = cur-&gt;<span style="color: #000000;">next;
        </span><span style="color: #0000ff;">if</span> (!cur) <span style="color: #0000ff;">return</span> head-&gt;<span style="color: #000000;">next;
        </span><span style="color: #0000ff;">while</span> (cur-&gt;<span style="color: #000000;">next) {
            cur </span>= cur-&gt;<span style="color: #000000;">next;
            pre </span>= pre-&gt;<span style="color: #000000;">next;
        }
        pre</span>-&gt;next = pre-&gt;next-&gt;<span style="color: #000000;">next;
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> head;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-06-29 10:28</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4606920" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4606920);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4515925.html" id="cb_post_title_url">[LeetCode] 4Sum 四数之和</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given an array <em>S</em> of <em>n</em> integers, are there elements <em>a</em>, <em>b</em>, <em>c</em>, and <em>d</em> in <em>S</em> such that <em>a</em> + <em>b</em> + <em>c</em> + <em>d</em> = target? Find all unique quadruplets in the array which gives the sum of target.</p>
<p><strong>Note:</strong><br/>
</p>
<ul>
<li>Elements in a quadruplet (<em>a</em>,<em>b</em>,<em>c</em>,<em>d</em>) must be in non-descending order. (ie, <em>a</em> ≤ <em>b</em> ≤ <em>c</em> ≤ <em>d</em>)</li>
<li>The solution set must not contain duplicate quadruplets.</li>
</ul>
<pre>    For example, given array S = {1 0 -1 0 -2 2}, and target = 0.

    A solution set is:
    (-1,  0, 0, 1)
    (-2, -1, 1, 2)
    (-2,  0, 0, 2)
</pre>
<p> </p>
<p>LeetCode中关于数字之和还有其他几道，分别是<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4130379.html" id="cb_post_title_url">Two Sum 两数之和</a>，<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4481576.html" id="cb_post_title_url">3Sum 三数之和</a>，<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4510984.html" id="homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0">3Sum Closest 最近三数之和</a>，虽然难度在递增，但是整体的套路都是一样的，在这里为了避免重复项，我们使用了STL中的set，其特点是不能有重复，如果新加入的数在set中原本就存在的话，插入操作就会失败，这样能很好的避免的重复项的存在。此题的O(n^3)解法的思路跟<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4481576.html" id="cb_post_title_url">3Sum 三数之和</a>基本没啥区别，就是多加了一层for循环，其他的都一样，代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; fourSum(vector&lt;<span style="color: #0000ff;">int</span>&gt; &amp;nums, <span style="color: #0000ff;">int</span><span style="color: #000000;"> target) {
        </span><span style="color: #0000ff;">set</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;<span style="color: #000000;"> res;
        sort(nums.begin(), nums.end());
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; <span style="color: #0000ff;">int</span>(nums.size() - <span style="color: #800080;">3</span>); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = i + <span style="color: #800080;">1</span>; j &lt; <span style="color: #0000ff;">int</span>(nums.size() - <span style="color: #800080;">2</span>); ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> (j &gt; i + <span style="color: #800080;">1</span> &amp;&amp; nums[j] == nums[j - <span style="color: #800080;">1</span>]) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">int</span> left = j + <span style="color: #800080;">1</span>, right = nums.size() - <span style="color: #800080;">1</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">while</span> (left &lt;<span style="color: #000000;"> right) {
                    </span><span style="color: #0000ff;">int</span> sum = nums[i] + nums[j] + nums[left] +<span style="color: #000000;"> nums[right];
                    </span><span style="color: #0000ff;">if</span> (sum ==<span style="color: #000000;"> target) {
                        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; <span style="color: #0000ff;">out</span><span style="color: #000000;">{nums[i], nums[j], nums[left], nums[right]};
                        res.insert(</span><span style="color: #0000ff;">out</span><span style="color: #000000;">);
                        </span>++left; --<span style="color: #000000;">right;
                    } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (sum &lt; target) ++<span style="color: #000000;">left;
                    </span><span style="color: #0000ff;">else</span> --<span style="color: #000000;">right;
                }
            }
        }
        </span><span style="color: #0000ff;">return</span> vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;<span style="color: #000000;">(res.begin(), res.end());
    }
};</span></pre>
</div>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-05-19 23:28</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4515925" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4515925);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4452220.html" id="cb_post_title_url">[LeetCode] Letter Combinations of a Phone Number 电话号码的字母组合</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a digit string, return all possible letter combinations that the number could represent.</p>
<p>A mapping of digit to letters (just like on the telephone buttons) is given below.</p>
<p><img alt="" src="http://upload.wikimedia.org/wikipedia/commons/thumb/7/73/Telephone-keypad2.svg/200px-Telephone-keypad2.svg.png"/></p>
<pre><strong>Input:</strong>Digit string "23"
<strong>Output:</strong> ["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].
</pre>
<p> <strong>Note:</strong><br/>
Although the above answer is in lexicographical order, your answer could be in any order you want.
</p>
<p> </p>
<p>这道题让我们求电话号码的字母组合，即数字2到9中每个数字可以代表若干个字母，然后给一串数字，求出所有可能的组合，相类似的题目有<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4042156.html" id="cb_post_title_url">Path Sum II</a>，<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4310964.html" id="cb_post_title_url">Subsets II</a>，<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4358848.html" id="cb_post_title_url">Permutations</a>，<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4359825.html" id="cb_post_title_url">Permutations II</a>，<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4332522.html" id="cb_post_title_url">Combinations</a>，<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4419259.html" id="homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0">Combination Sum</a> 和<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4419386.html" id="cb_post_title_url">Combination Sum II</a> 等等。我们用递归Recursion来解，我们需要建立一个字典，用来保存每个数字所代表的字符串，然后我们还需要一个变量level，记录当前生成的字符串的字符个数，实现套路和上述那些题十分类似。在递归函数中我们首先判断level，如果跟digits中数字的个数相等了，我们将当前的组合加入结果res中，然后返回。否则我们通过digits中的数字到dict中取出字符串，然后遍历这个取出的字符串，将每个字符都加到当前的组合后面，并调用递归函数即可，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; letterCombinations(<span style="color: #0000ff;">string</span><span style="color: #000000;"> digits) {
        </span><span style="color: #0000ff;">if</span> (digits.empty()) <span style="color: #0000ff;">return</span><span style="color: #000000;"> {};
        vector</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">string</span> dict[] = {<span style="color: #800000;">""</span>, <span style="color: #800000;">""</span>, <span style="color: #800000;">"</span><span style="color: #800000;">abc</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">def</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">ghi</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">jkl</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">mno</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">pqrs</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">tuv</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">wxyz</span><span style="color: #800000;">"</span><span style="color: #000000;">};
        letterCombinationsDFS(digits, dict, </span><span style="color: #800080;">0</span>, <span style="color: #800000;">""</span><span style="color: #000000;">, res);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">void</span> letterCombinationsDFS(<span style="color: #0000ff;">string</span> digits, <span style="color: #0000ff;">string</span> dict[], <span style="color: #0000ff;">int</span> level, <span style="color: #0000ff;">string</span> <span style="color: #0000ff;">out</span>, vector&lt;<span style="color: #0000ff;">string</span>&gt; &amp;<span style="color: #000000;">res) {
        </span><span style="color: #0000ff;">if</span> (level == digits.size()) {res.push_back(<span style="color: #0000ff;">out</span>); <span style="color: #0000ff;">return</span><span style="color: #000000;">;}
        </span><span style="color: #0000ff;">string</span> str = dict[digits[level] - <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span><span style="color: #000000;">];
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; str.size(); ++<span style="color: #000000;">i) {
            letterCombinationsDFS(digits, dict, level </span>+ <span style="color: #800080;">1</span>, <span style="color: #0000ff;">out</span> + <span style="color: #0000ff;">string</span>(<span style="color: #800080;">1</span><span style="color: #000000;">, str[i]), res);
        }
    }
};</span></pre>
</div>
<p> </p>
<p>这道题我们也可以用迭代Iterative来解，在遍历digits中所有的数字时，我们先建立一个临时的字符串数组t，然后跟上面解法的操作一样，通过数字到dict中取出字符串str，然后遍历取出字符串中的所有字符，再遍历当前结果res中的每一个字符串，将字符加到后面，并加入到临时字符串数组t中。取出的字符串str遍历完成后，将临时字符串数组赋值给结果res，具体实现参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; letterCombinations(<span style="color: #0000ff;">string</span><span style="color: #000000;"> digits) {
        </span><span style="color: #0000ff;">if</span> (digits.empty()) <span style="color: #0000ff;">return</span><span style="color: #000000;"> {};
        vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; res{<span style="color: #800000;">""</span><span style="color: #000000;">};
        </span><span style="color: #0000ff;">string</span> dict[] = {<span style="color: #800000;">""</span>, <span style="color: #800000;">""</span>, <span style="color: #800000;">"</span><span style="color: #800000;">abc</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">def</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">ghi</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">jkl</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">mno</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">pqrs</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">tuv</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">wxyz</span><span style="color: #800000;">"</span><span style="color: #000000;">};
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; digits.size(); ++<span style="color: #000000;">i) {
            vector</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> t;
            </span><span style="color: #0000ff;">string</span> str = dict[digits[i] - <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span><span style="color: #000000;">];
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; str.size(); ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">string</span> s : res) t.push_back(s +<span style="color: #000000;"> str[j]);
            }
            res </span>=<span style="color: #000000;"> t;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4444160.html" target="_blank">Generate Parentheses</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4419259.html" target="_blank">Combination Sum</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/5896454.html">Binary Watch</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-04-24 00:06</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4452220" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4452220);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4510984.html" id="cb_post_title_url">[LeetCode] 3Sum Closest 最近三数之和</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given an array <em>S</em> of <em>n</em> integers, find three integers in <em>S</em> such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution.</p>
<pre>    For example, given array S = {-1 2 1 -4}, and target = 1.

    The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).</pre>
<p> </p>
<p>这道题让我们求最接近给定值的三数之和，是在之前那道<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4481576.html" id="cb_post_title_url"> 3Sum 三数之和</a>的基础上又增加了些许难度，那么这道题让我们返回这个最接近于给定值的值，即我们要保证当前三数和跟给定值之间的差的绝对值最小，所以我们需要定义一个变量diff用来记录差的绝对值，然后我们还是要先将数组排个序，然后开始遍历数组，思路跟那道三数之和很相似，都是先确定一个数，然后用两个指针left和right来滑动寻找另外两个数，每确定两个数，我们求出此三数之和，然后算和给定值的差的绝对值存在newDiff中，然后和diff比较并更新diff和结果closest即可，代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> threeSumClosest(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; nums, <span style="color: #0000ff;">int</span><span style="color: #000000;"> target) {
        </span><span style="color: #0000ff;">int</span> closest = nums[<span style="color: #800080;">0</span>] + nums[<span style="color: #800080;">1</span>] + nums[<span style="color: #800080;">2</span><span style="color: #000000;">];
        </span><span style="color: #0000ff;">int</span> diff = abs(closest -<span style="color: #000000;"> target);
        sort(nums.begin(), nums.end());
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; nums.size() - <span style="color: #800080;">2</span>; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">int</span> left = i + <span style="color: #800080;">1</span>, right = nums.size() - <span style="color: #800080;">1</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">while</span> (left &lt;<span style="color: #000000;"> right) {
                </span><span style="color: #0000ff;">int</span> sum = nums[i] + nums[left] +<span style="color: #000000;"> nums[right];
                </span><span style="color: #0000ff;">int</span> newDiff = abs(sum -<span style="color: #000000;"> target);
                </span><span style="color: #0000ff;">if</span> (diff &gt;<span style="color: #000000;"> newDiff) {
                    diff </span>=<span style="color: #000000;"> newDiff;
                    closest </span>=<span style="color: #000000;"> sum;
                }
                </span><span style="color: #0000ff;">if</span> (sum &lt; target) ++<span style="color: #000000;">left;
                </span><span style="color: #0000ff;">else</span> --<span style="color: #000000;">right;
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> closest;
    }
};</span></pre>
</div>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-05-18 02:24</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4510984" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4510984);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4481576.html" id="cb_post_title_url">[LeetCode] 3Sum 三数之和</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given an array <em>S</em> of <em>n</em> integers, are there elements <em>a</em>, <em>b</em>, <em>c</em> in <em>S</em> such that <em>a</em> + <em>b</em> + <em>c</em> = 0? Find all unique triplets in the array which gives the sum of zero.</p>
<p>Note:</p>
<ul>
<li>Elements in a triplet (<em>a</em>,<em>b</em>,<em>c</em>) must be in non-descending order. (ie, <em>a</em> ≤ <em>b</em> ≤ <em>c</em>)</li>
<li>The solution set must not contain duplicate triplets.</li>
</ul>
<p> </p>
<pre>    For example, given array S = {-1 0 1 2 -1 -4},

    A solution set is:
    (-1, 0, 1)
    (-1, -1, 2)</pre>
<p> </p>
<p>这道题让我们求三数之和，比之前那道<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4130379.html" id="cb_post_title_url">Two Sum</a>要复杂一些，博主考虑过先fix一个数，然后另外两个数使用<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4130379.html" id="cb_post_title_url">Two Sum</a>那种HashMap的解法，但是会有重复结果出现，就算使用set来去除重复也不行，会TLE，看来此题并不是考我们<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4130379.html" id="cb_post_title_url">Two Sum</a>的解法。那么我们来分析一下这道题的特点，要我们找出三个数且和为0，那么除了三个数全是0的情况之外，肯定会有负数和正数，我们还是要先fix一个数，然后去找另外两个数，我们只要找到两个数且和为第一个fix数的相反数就行了，既然另外两个数不能使用<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4130379.html" id="cb_post_title_url">Two Sum</a>的那种解法来找，如果能更有效的定位呢？我们肯定不希望遍历所有两个数的组合吧，所以如果数组是有序的，那么我们就可以用双指针以线性时间复杂度来遍历所有满足题意的两个数组合。</p>
<p>我们对原数组进行排序，然后开始遍历排序后的数组，这里注意不是遍历到最后一个停止，而是到倒数第三个就可以了。这里我们可以先做个剪枝优化，就是当遍历到正数的时候就break，为啥呢，因为我们的数组现在是有序的了，如果第一个要fix的数就是正数了，那么后面的数字就都是正数，就永远不会出现和为0的情况了。然后我们还要加上重复就跳过的处理，处理方法是从第二个数开始，如果和前面的数字相等，就跳过，因为我们不想把相同的数字fix两次。对于遍历到的数，用0减去这个fix的数得到一个target，然后只需要再之后找到两个数之和等于target即可。我们用两个指针分别指向fix数字之后开始的数组首尾两个数，如果两个数和正好为target，则将这两个数和fix的数一起存入结果中。然后就是跳过重复数字的步骤了，两个指针都需要检测重复数字。如果两数之和小于target，则我们将左边那个指针i右移一位，使得指向的数字增大一些。同理，如果两数之和大于target，则我们将右边那个指针j左移一位，使得指向的数字减小一些，代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; threeSum(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;<span style="color: #000000;"> res;
        sort(nums.begin(), nums.end());
        </span><span style="color: #0000ff;">if</span> (nums.empty() || nums.back() &lt; <span style="color: #800080;">0</span> || nums.front() &gt; <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;"> {};
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> k = <span style="color: #800080;">0</span>; k &lt; nums.size(); ++<span style="color: #000000;">k) {
            </span><span style="color: #0000ff;">if</span> (nums[k] &gt; <span style="color: #800080;">0</span>) <span style="color: #0000ff;">break</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> (k &gt; <span style="color: #800080;">0</span> &amp;&amp; nums[k] == nums[k - <span style="color: #800080;">1</span>]) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">int</span> target = <span style="color: #800080;">0</span> -<span style="color: #000000;"> nums[k];
            </span><span style="color: #0000ff;">int</span> i = k + <span style="color: #800080;">1</span>, j = nums.size() - <span style="color: #800080;">1</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">while</span> (i &lt;<span style="color: #000000;"> j) {
                </span><span style="color: #0000ff;">if</span> (nums[i] + nums[j] ==<span style="color: #000000;"> target) {
                    res.push_back({nums[k], nums[i], nums[j]});
                    </span><span style="color: #0000ff;">while</span> (i &lt; j &amp;&amp; nums[i] == nums[i + <span style="color: #800080;">1</span>]) ++<span style="color: #000000;">i;
                    </span><span style="color: #0000ff;">while</span> (i &lt; j &amp;&amp; nums[j] == nums[j - <span style="color: #800080;">1</span>]) --<span style="color: #000000;">j;
                    </span>++i; --<span style="color: #000000;">j;
                } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (nums[i] + nums[j] &lt; target) ++<span style="color: #000000;">i;
                </span><span style="color: #0000ff;">else</span> --<span style="color: #000000;">j;
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>或者我们也可以利用set的不能包含重复项的特点来防止重复项的产生，那么我们就不需要检测数字是否被fix过两次，不过个人觉得还是前面那种解法更好一些，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; threeSum(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        </span><span style="color: #0000ff;">set</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;<span style="color: #000000;"> res;
        sort(nums.begin(), nums.end());
        </span><span style="color: #0000ff;">if</span> (nums.empty() || nums.back() &lt; <span style="color: #800080;">0</span> || nums.front() &gt; <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;"> {};
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> k = <span style="color: #800080;">0</span>; k &lt; nums.size(); ++<span style="color: #000000;">k) {
            </span><span style="color: #0000ff;">if</span> (nums[k] &gt; <span style="color: #800080;">0</span>) <span style="color: #0000ff;">break</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">int</span> target = <span style="color: #800080;">0</span> -<span style="color: #000000;"> nums[k];
            </span><span style="color: #0000ff;">int</span> i = k + <span style="color: #800080;">1</span>, j = nums.size() - <span style="color: #800080;">1</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">while</span> (i &lt;<span style="color: #000000;"> j) {
                </span><span style="color: #0000ff;">if</span> (nums[i] + nums[j] ==<span style="color: #000000;"> target) {
                    res.insert({nums[k], nums[i], nums[j]});
                    </span><span style="color: #0000ff;">while</span> (i &lt; j &amp;&amp; nums[i] == nums[i + <span style="color: #800080;">1</span>]) ++<span style="color: #000000;">i;
                    </span><span style="color: #0000ff;">while</span> (i &lt; j &amp;&amp; nums[j] == nums[j - <span style="color: #800080;">1</span>]) --<span style="color: #000000;">j;
                    </span>++i; --<span style="color: #000000;">j;
                } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (nums[i] + nums[j] &lt; target) ++<span style="color: #000000;">i;
                </span><span style="color: #0000ff;">else</span> --<span style="color: #000000;">j;
            }
        }
        </span><span style="color: #0000ff;">return</span> vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;<span style="color: #000000;">(res.begin(), res.end());
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4130379.html" target="_blank">Two Sum</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/5235086.html" target="_blank">3Sum Smaller</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4510984.html" target="_blank">3Sum Closest</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4515925.html" target="_blank">4Sum</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="http://www.lifeincode.net/programming/leetcode-two-sum-3-sum-3-sum-closest-and-4-sum-java/" target="_blank">http://www.lifeincode.net/programming/leetcode-two-sum-3-sum-3-sum-closest-and-4-sum-java/</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-05-06 13:01</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4481576" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4481576);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4606926.html" id="cb_post_title_url">[LeetCode] Longest Common Prefix 最长共同前缀</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Write a function to find the longest common prefix string amongst an array of strings.</p>
<p>If there is no common prefix, return an empty string <code>""</code>.</p>
<p>Example 1:</p>
<pre>Input: ["flower","flow","flight"]
Output: "fl"
</pre>
<p>Example 2:</p>
<pre>Input: ["dog","racecar","car"]
Output: ""
Explanation: There is no common prefix among the input strings.
</pre>
<p>Note:</p>
<p>All given inputs are in lowercase letters <code>a-z</code>.</p>
<p> </p>
<p>这道题让我们求一系列字符串的共同前缀，没有什么特别的技巧，无脑查找即可，我们定义两个变量i和j，其中i是遍历搜索字符串中的字符，j是遍历字符串集中的每个字符串。这里将单词上下排好，则相当于一个各行长度有可能不相等的二维数组，我们遍历顺序和一般的横向逐行遍历不同，而是采用纵向逐列遍历，在遍历的过程中，如果某一行没有了，说明其为最短的单词，因为共同前缀的长度不能长于最短单词，所以此时返回已经找出的共同前缀。我们每次取出第一个字符串的某一个位置的单词，然后遍历其他所有字符串的对应位置看是否相等，如果有不满足的直接返回res，如果都相同，则将当前字符存入结果，继续检查下一个位置的字符，参见代码如下：</p>
<p> </p>
<p>C++ 解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> longestCommonPrefix(vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp;<span style="color: #000000;"> strs) {
        </span><span style="color: #0000ff;">if</span> (strs.empty()) <span style="color: #0000ff;">return</span> <span style="color: #800000;">""</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">string</span> res = <span style="color: #800000;">""</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; strs[<span style="color: #800080;">0</span>].size(); ++<span style="color: #000000;">j) {
            </span><span style="color: #0000ff;">char</span> c = strs[<span style="color: #800080;">0</span><span style="color: #000000;">][j];
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt; strs.size(); ++<span style="color: #000000;">i) {
                </span><span style="color: #0000ff;">if</span> (j &gt;= strs[i].size() || strs[i][j] !=<span style="color: #000000;"> c) {
                    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
                }
            }
            res.push_back(c);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>Java 解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> String longestCommonPrefix(String[] strs) {
        </span><span style="color: #0000ff;">if</span> (strs == <span style="color: #0000ff;">null</span> || strs.length == 0) <span style="color: #0000ff;">return</span> ""<span style="color: #000000;">;
        String res </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> String();
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = 0; j &lt; strs[0].length(); ++<span style="color: #000000;">j) {
            </span><span style="color: #0000ff;">char</span> c = strs[0<span style="color: #000000;">].charAt(j);
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = 1; i &lt; strs.length; ++<span style="color: #000000;">i) {
                </span><span style="color: #0000ff;">if</span> (j &gt;= strs[i].length() || strs[i].charAt(j) !=<span style="color: #000000;"> c) {
                    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
                }
            }
            res </span>+=<span style="color: #000000;"> Character.toString(c);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
}</span></pre>
</div>
<p> </p>
<p>我们可以对上面的方法进行适当精简，如果我们发现当前某个字符和下一行对应位置的字符不相等，说明不会再有更长的共同前缀了，我们直接通过用substr的方法直接取出共同前缀的子字符串。如果遍历结束前没有返回结果的话，说明第一个单词就是公共前缀，返回为结果即可。代码如下：</p>
<p> </p>
<p>C++ 解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> longestCommonPrefix(vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp;<span style="color: #000000;"> strs) {
        </span><span style="color: #0000ff;">if</span> (strs.empty()) <span style="color: #0000ff;">return</span> <span style="color: #800000;">""</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; strs[<span style="color: #800080;">0</span>].size(); ++<span style="color: #000000;">j) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; strs.size() - <span style="color: #800080;">1</span>; ++<span style="color: #000000;">i) {
                </span><span style="color: #0000ff;">if</span> (j &gt;= strs[i].size() || j &gt;= strs[i + <span style="color: #800080;">1</span>].size() || strs[i][j] != strs[i + <span style="color: #800080;">1</span><span style="color: #000000;">][j]) {
                    </span><span style="color: #0000ff;">return</span> strs[i].substr(<span style="color: #800080;">0</span><span style="color: #000000;">, j);
                }
            }
        }
        </span><span style="color: #0000ff;">return</span> strs[<span style="color: #800080;">0</span><span style="color: #000000;">];
    }
};</span></pre>
</div>
<p> </p>
<p>Java 解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> String longestCommonPrefix(String[] strs) {
        </span><span style="color: #0000ff;">if</span> (strs == <span style="color: #0000ff;">null</span> || strs.length == 0) <span style="color: #0000ff;">return</span> ""<span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = 0; j &lt; strs[0].length(); ++<span style="color: #000000;">j) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = 0; i &lt; strs.length - 1; ++<span style="color: #000000;">i) {
                </span><span style="color: #0000ff;">if</span> (j &gt;= strs[i].length() || j &gt;= strs[i + 1].length() || strs[i].charAt(j) != strs[i + 1<span style="color: #000000;">].charAt(j)) {
                    </span><span style="color: #0000ff;">return</span> strs[i].substring(0<span style="color: #000000;">, j);   
                }
            }
        }
        </span><span style="color: #0000ff;">return</span> strs[0<span style="color: #000000;">];
    }
}</span></pre>
</div>
<p> </p>
<p>我们再来看一种解法，这种方法给输入字符串数组排了个序，想想这样做有什么好处？既然是按字母顺序排序的话，那么有共同字母多的两个字符串会被排到一起，而跟大家相同的字母越少的字符串会被挤到首尾两端，那么如果有共同前缀的话，一定会出现在首尾两端的字符串中，所以我们只需要找首尾字母串的共同前缀即可。比如例子1排序后为 ["flight", "flow", "flower"]，例子2排序后为 ["cat", "dog", "racecar"]，虽然例子2没有共同前缀，但也可以认为共同前缀是空串，且出现在首尾两端的字符串中。由于是按字母顺序排的，而不是按长度，所以首尾字母的长度关系不知道，为了防止溢出错误，我们只遍历而这种较短的那个的长度，找出共同前缀返回即可，参见代码如下：</p>
<p> </p>
<p>C++ 解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> longestCommonPrefix(vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp;<span style="color: #000000;"> strs) {
        </span><span style="color: #0000ff;">if</span> (strs.empty()) <span style="color: #0000ff;">return</span> <span style="color: #800000;">""</span><span style="color: #000000;">;
        sort(strs.begin(), strs.end());
        </span><span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>, len = min(strs[<span style="color: #800080;">0</span><span style="color: #000000;">].size(), strs.back().size());
        </span><span style="color: #0000ff;">while</span> (i &lt; len &amp;&amp; strs[<span style="color: #800080;">0</span>][i] == strs.back()[i]) ++<span style="color: #000000;">i;
        </span><span style="color: #0000ff;">return</span> strs[<span style="color: #800080;">0</span>].substr(<span style="color: #800080;">0</span><span style="color: #000000;">, i);
    }
};</span></pre>
</div>
<p> </p>
<p>Java 解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> String longestCommonPrefix(String[] strs) {
        </span><span style="color: #0000ff;">if</span> (strs == <span style="color: #0000ff;">null</span> || strs.length == <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span> <span style="color: #800000;">""</span><span style="color: #000000;">;
        Arrays.sort(strs);
        </span><span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>, len = Math.min(strs[<span style="color: #800080;">0</span>].length(), strs[strs.length - <span style="color: #800080;">1</span><span style="color: #000000;">].length());
        </span><span style="color: #0000ff;">while</span> (i &lt; len &amp;&amp; strs[<span style="color: #800080;">0</span>].charAt(i) == strs[strs.length - <span style="color: #800080;">1</span>].charAt(i)) i++<span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span> strs[<span style="color: #800080;">0</span>].substring(<span style="color: #800080;">0</span><span style="color: #000000;">, i);
    }
}</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-06-29 10:30</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4606926" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4606926);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4120857.html" id="cb_post_title_url">[LeetCode] Roman to Integer 罗马数字转化成整数</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a roman numeral, convert it to an integer.</p>
<p>Input is guaranteed to be within the range from 1 to 3999.</p>
<p> </p>
<p><strong><a href="http://zh.wikipedia.org/wiki/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97" target="_blank">罗马数</a></strong>转化成数字问题，我们需要对于<strong><a href="http://baike.baidu.com/view/42061.htm?fr=aladdin" target="_blank">罗马数字</a></strong>很熟悉才能完成转换。以下截自百度百科：</p>
<div class="para"><a href="http://baike.baidu.com/view/2245.htm" target="_blank"><strong>罗马</strong></a><strong>数字是最早的数字表示方式，比阿拉伯数字早2000多年，起源于罗马。</strong></div>
<div class="para">如今我们最常见的罗马数字就是钟表的表盘符号：<strong>Ⅰ，Ⅱ，Ⅲ，Ⅳ（IIII），Ⅴ，Ⅵ，Ⅶ，Ⅷ，Ⅸ，Ⅹ，Ⅺ，Ⅻ……</strong></div>
<div class="para">对应阿拉伯数字（就是现在国际通用的数字），就是1，2，3，4，5，6，7，8，9，10，11，12。（注：<strong>阿拉伯数字</strong>其实是古代<a href="http://baike.baidu.com/view/2174.htm" target="_blank">印度</a>人发明的，后来由阿拉伯人传入<a href="http://baike.baidu.com/view/3622.htm" target="_blank">欧洲</a>，被欧洲人误称为阿拉伯数字。）</div>
<div class="para"> </div>
<div class="para"> </div>
<div class="para">
<table class="table-view log-set-param">
<tbody>
<tr>
<td align="left" valign="top" width="65">
<div class="para">基本字符</div>
</td>
<td align="left" valign="top" width="65">
<div class="para">I</div>
</td>
<td align="left" valign="top" width="65">
<div class="para">V</div>
</td>
<td align="left" valign="top" width="65">
<div class="para">X</div>
</td>
<td align="left" valign="top" width="65">
<div class="para">L</div>
</td>
<td align="left" valign="top" width="65">
<div class="para">C</div>
</td>
<td align="left" valign="top" width="65">
<div class="para">D</div>
</td>
<td align="left" valign="top" width="65">
<div class="para">M</div>
</td>
</tr>
<tr>
<td align="left" valign="top" width="65">
<div class="para">相应的阿拉伯数字表示为</div>
</td>
<td align="left" valign="top" width="65">
<div class="para">1</div>
</td>
<td align="left" valign="top" width="65">
<div class="para">5</div>
</td>
<td align="left" valign="top" width="65">
<div class="para">10</div>
</td>
<td align="left" valign="top" width="65">
<div class="para">50</div>
</td>
<td align="left" valign="top" width="65">
<div class="para">100</div>
</td>
<td align="left" valign="top" width="65">
<div class="para">500</div>
</td>
<td align="left" valign="top" width="65">
<div class="para">1000</div>
</td>
</tr>
</tbody>
</table>
<div class="para"> </div>
<div class="para">1、相同的数字连写，所表示的数等于这些数字相加得到的数，如：Ⅲ = 3；</div>
<div class="para">2、小的数字在大的数字的右边，所表示的数等于这些数字相加得到的数， 如：Ⅷ = 8；Ⅻ = 12；</div>
<div class="para">3、小的数字，（限于Ⅰ、X 和C）在大的数字的左边，所表示的数等于大数减小数得到的数，如：Ⅳ= 4；Ⅸ= 9；</div>
<div class="para">4、正常使用时，连写的数字重复不得超过三次。（表盘上的四点钟“IIII”例外）</div>
<div class="para">5、在一个数的上面画一条横线，表示这个数扩大1000倍。</div>
<div class="para"> </div>
<div class="para">
<div class="para"><strong>有几条须注意掌握：</strong></div>
<div class="para">1、基本数字Ⅰ、X 、C 中的任何一个，自身连用构成数目，或者放在大数的右边连用构成数目，都不能超过三个；放在大数的左边只能用一个。</div>
<div class="para">2、不能把基本数字V 、L 、D 中的任何一个作为小数放在大数的左边采用相减的方法构成数目；放在大数的右边采用相加的方式构成数目，只能使用一个。</div>
<div class="para">3、V 和X 左边的小数字只能用Ⅰ。</div>
<div class="para">4、L 和C 左边的小数字只能用X。</div>
<div class="para">5、D 和M 左边的小数字只能用C。</div>
<div class="para"> </div>
<div class="para">而这道题好就好在没有让我们来验证输入字符串是不是罗马数字，这样省掉不少功夫。我们需要用到map数据结构，来将罗马数字的字母转化为对应的整数值，因为输入的一定是罗马数字，那么我们只要考虑两种情况即可：</div>
<div class="para">第一，如果当前数字是最后一个数字，或者之后的数字比它小的话，则加上当前数字</div>
<div class="para">第二，其他情况则减去这个数字</div>
<div class="para"> </div>
<div class="para">代码如下：</div>
<div class="para"> </div>
<div class="para">解法一：</div>
<div class="para">
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> romanToInt(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        unordered_map</span>&lt;<span style="color: #0000ff;">char</span>, <span style="color: #0000ff;">int</span>&gt; m{{<span style="color: #800000;">'</span><span style="color: #800000;">I</span><span style="color: #800000;">'</span>, <span style="color: #800080;">1</span>}, {<span style="color: #800000;">'</span><span style="color: #800000;">V</span><span style="color: #800000;">'</span>, <span style="color: #800080;">5</span>}, {<span style="color: #800000;">'</span><span style="color: #800000;">X</span><span style="color: #800000;">'</span>, <span style="color: #800080;">10</span>}, {<span style="color: #800000;">'</span><span style="color: #800000;">L</span><span style="color: #800000;">'</span>, <span style="color: #800080;">50</span>}, {<span style="color: #800000;">'</span><span style="color: #800000;">C</span><span style="color: #800000;">'</span>, <span style="color: #800080;">100</span>}, {<span style="color: #800000;">'</span><span style="color: #800000;">D</span><span style="color: #800000;">'</span>, <span style="color: #800080;">500</span>}, {<span style="color: #800000;">'</span><span style="color: #800000;">M</span><span style="color: #800000;">'</span>, <span style="color: #800080;">1000</span><span style="color: #000000;">}};
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; s.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">int</span> val =<span style="color: #000000;"> m[s[i]];
            </span><span style="color: #0000ff;">if</span> (i == s.size() - <span style="color: #800080;">1</span> || m[s[i+<span style="color: #800080;">1</span>]] &lt;= m[s[i]]) res +=<span style="color: #000000;"> val;
            </span><span style="color: #0000ff;">else</span> res -=<span style="color: #000000;"> val;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>我们也可以每次跟前面的数字比较，如果小于等于前面的数字，我们先加上当前的数字，如果大于的前面的数字，我们加上当前的数字减去二倍前面的数字，这样可以把在上一个循环多加数减掉，参见代码如下:</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> romanToInt(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        unordered_map</span>&lt;<span style="color: #0000ff;">char</span>, <span style="color: #0000ff;">int</span>&gt; m{{<span style="color: #800000;">'</span><span style="color: #800000;">I</span><span style="color: #800000;">'</span>, <span style="color: #800080;">1</span>}, {<span style="color: #800000;">'</span><span style="color: #800000;">V</span><span style="color: #800000;">'</span>, <span style="color: #800080;">5</span>}, {<span style="color: #800000;">'</span><span style="color: #800000;">X</span><span style="color: #800000;">'</span>, <span style="color: #800080;">10</span>}, {<span style="color: #800000;">'</span><span style="color: #800000;">L</span><span style="color: #800000;">'</span>, <span style="color: #800080;">50</span>}, {<span style="color: #800000;">'</span><span style="color: #800000;">C</span><span style="color: #800000;">'</span>, <span style="color: #800080;">100</span>}, {<span style="color: #800000;">'</span><span style="color: #800000;">D</span><span style="color: #800000;">'</span>, <span style="color: #800080;">500</span>}, {<span style="color: #800000;">'</span><span style="color: #800000;">M</span><span style="color: #800000;">'</span>, <span style="color: #800080;">1000</span><span style="color: #000000;">}};
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; s.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (i == <span style="color: #800080;">0</span> || m[s[i]] &lt;= m[s[i - <span style="color: #800080;">1</span>]]) res +=<span style="color: #000000;"> m[s[i]];
            </span><span style="color: #0000ff;">else</span> res += m[s[i]] - <span style="color: #800080;">2</span> * m[s[i - <span style="color: #800080;">1</span><span style="color: #000000;">]];
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4123374.html" target="_blank">Integer to Roman</a></p>
<p><span style="line-height: 1.5;"> </span></p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/15224/simple-56ms-c-solution" target="_blank">https://discuss.leetcode.com/topic/15224/simple-56ms-c-solution</a></p>
<p> </p>
</div>
<div class="para">
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p>
</div>
</div>
</div></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2014-11-25 13:56</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4120857" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4120857);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4123374.html" id="cb_post_title_url">[LeetCode] Integer to Roman 整数转化成罗马数字</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given an integer, convert it to a roman numeral.</p>
<p>Input is guaranteed to be within the range from 1 to 3999.</p>
<p> </p>
<p>之前那篇文章写的是罗马数字转化成整数(<a href="http://www.cnblogs.com/grandyang/p/4120857.html" target="_blank">http://www.cnblogs.com/grandyang/p/4120857.html</a>)， 这次变成了整数转化成罗马数字，基本算法还是一样。由于题目中限定了输入数字的范围(1 - 3999), 使得题目变得简单了不少。</p>
<table class="table-view log-set-param">
<tbody>
<tr>
<td align="left" valign="top" width="65">
<div class="para">基本字符</div>
</td>
<td align="left" valign="top" width="65">
<div class="para">I</div>
</td>
<td align="left" valign="top" width="65">
<div class="para">V</div>
</td>
<td align="left" valign="top" width="65">
<div class="para">X</div>
</td>
<td align="left" valign="top" width="65">
<div class="para">L</div>
</td>
<td align="left" valign="top" width="65">
<div class="para">C</div>
</td>
<td align="left" valign="top" width="65">
<div class="para">D</div>
</td>
<td align="left" valign="top" width="65">
<div class="para">M</div>
</td>
</tr>
<tr>
<td align="left" valign="top" width="65">
<div class="para">相应的阿拉伯数字表示为</div>
</td>
<td align="left" valign="top" width="65">
<div class="para">1</div>
</td>
<td align="left" valign="top" width="65">
<div class="para">5</div>
</td>
<td align="left" valign="top" width="65">
<div class="para">10</div>
</td>
<td align="left" valign="top" width="65">
<div class="para">50</div>
</td>
<td align="left" valign="top" width="65">
<div class="para">100</div>
</td>
<td align="left" valign="top" width="65">
<div class="para">500</div>
</td>
<td align="left" valign="top" width="65">
<div class="para">1000</div>
<p> </p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>例如整数 1437 的罗马数字为 MCDXXXVII， 我们不难发现，千位，百位，十位和个位上的数分别用罗马数字表示了。 1000 - M, 400 - CD, 30 - XXX, 7 - VII。所以我们要做的就是用取商法分别提取各个位上的数字，然后分别表示出来：</p>
<p>100 - C</p>
<p>200 - CC</p>
<p>300 - CCC</p>
<p>400 - CD</p>
<p>500 - D</p>
<p>600 - DC</p>
<p>700 - DCC</p>
<p>800 - DCCC</p>
<p>900 - CM</p>
<p>我们可以分为四类，100到300一类，400一类，500到800一类，900最后一类。每一位上的情况都是类似的，代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> intToRoman(<span style="color: #0000ff;">int</span><span style="color: #000000;"> num) {
        </span><span style="color: #0000ff;">string</span> res = <span style="color: #800000;">""</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">char</span> roman[] = {<span style="color: #800000;">'</span><span style="color: #800000;">M</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">D</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">C</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">L</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">X</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">V</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">I</span><span style="color: #800000;">'</span><span style="color: #000000;">};
        </span><span style="color: #0000ff;">int</span> value[] = {<span style="color: #800080;">1000</span>, <span style="color: #800080;">500</span>, <span style="color: #800080;">100</span>, <span style="color: #800080;">50</span>, <span style="color: #800080;">10</span>, <span style="color: #800080;">5</span>, <span style="color: #800080;">1</span><span style="color: #000000;">};
        
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> n = <span style="color: #800080;">0</span>; n &lt; <span style="color: #800080;">7</span>; n += <span style="color: #800080;">2</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">int</span> x = num /<span style="color: #000000;"> value[n];
            </span><span style="color: #0000ff;">if</span> (x &lt; <span style="color: #800080;">4</span><span style="color: #000000;">) {
                </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt;= x; ++i) res +=<span style="color: #000000;"> roman[n];
            } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (x == <span style="color: #800080;">4</span>) res = res + roman[n] + roman[n - <span style="color: #800080;">1</span><span style="color: #000000;">];
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (x &gt; <span style="color: #800080;">4</span> &amp;&amp; x &lt; <span style="color: #800080;">9</span><span style="color: #000000;">) {
                res </span>+= roman[n - <span style="color: #800080;">1</span><span style="color: #000000;">];
                </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">6</span>; i &lt;= x; ++i) res +=<span style="color: #000000;"> roman[n];
            }
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (x == <span style="color: #800080;">9</span>) res = res + roman[n] + roman[n - <span style="color: #800080;">2</span><span style="color: #000000;">];
            num </span>%=<span style="color: #000000;"> value[n];            
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>本题由于限制了输入数字范围这一特殊性，故而还有一种利用贪婪算法的解法，建立一个数表，每次通过查表找出当前最大的数，减去再继续查表。参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> intToRoman(<span style="color: #0000ff;">int</span><span style="color: #000000;"> num) {
        </span><span style="color: #0000ff;">string</span> res = <span style="color: #800000;">""</span><span style="color: #000000;">;
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; val{<span style="color: #800080;">1000</span>, <span style="color: #800080;">900</span>, <span style="color: #800080;">500</span>, <span style="color: #800080;">400</span>, <span style="color: #800080;">100</span>, <span style="color: #800080;">90</span>, <span style="color: #800080;">50</span>, <span style="color: #800080;">40</span>, <span style="color: #800080;">10</span>, <span style="color: #800080;">9</span>, <span style="color: #800080;">5</span>, <span style="color: #800080;">4</span>, <span style="color: #800080;">1</span><span style="color: #000000;">};
        vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; str{<span style="color: #800000;">"</span><span style="color: #800000;">M</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">CM</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">D</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">CD</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">C</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">XC</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">L</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">XL</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">X</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">IX</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">V</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">IV</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">I</span><span style="color: #800000;">"</span><span style="color: #000000;">};
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; val.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">while</span> (num &gt;=<span style="color: #000000;"> val[i]) {
                num </span>-=<span style="color: #000000;"> val[i];
                res </span>+=<span style="color: #000000;"> str[i];
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种方法个人感觉属于比较投机取巧的方法，把所有的情况都列了出来，然后直接按位查表，O(1)的时间复杂度啊，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> intToRoman(<span style="color: #0000ff;">int</span><span style="color: #000000;"> num) {
        </span><span style="color: #0000ff;">string</span> res = <span style="color: #800000;">""</span><span style="color: #000000;">;
        vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; v1{<span style="color: #800000;">""</span>, <span style="color: #800000;">"</span><span style="color: #800000;">M</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">MM</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">MMM</span><span style="color: #800000;">"</span><span style="color: #000000;">};
        vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; v2{<span style="color: #800000;">""</span>, <span style="color: #800000;">"</span><span style="color: #800000;">C</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">CC</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">CCC</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">CD</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">D</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">DC</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">DCC</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">DCCC</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">CM</span><span style="color: #800000;">"</span><span style="color: #000000;">};
        vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; v3{<span style="color: #800000;">""</span>, <span style="color: #800000;">"</span><span style="color: #800000;">X</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">XX</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">XXX</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">XL</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">L</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">LX</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">LXX</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">LXXX</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">XC</span><span style="color: #800000;">"</span><span style="color: #000000;">};
        vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; v4{<span style="color: #800000;">""</span>, <span style="color: #800000;">"</span><span style="color: #800000;">I</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">II</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">III</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">IV</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">V</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">VI</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">VII</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">VIII</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">IX</span><span style="color: #800000;">"</span><span style="color: #000000;">};
        </span><span style="color: #0000ff;">return</span> v1[num / <span style="color: #800080;">1000</span>] + v2[(num % <span style="color: #800080;">1000</span>) / <span style="color: #800080;">100</span>] + v3[(num % <span style="color: #800080;">100</span>) / <span style="color: #800080;">10</span>] + v4[num % <span style="color: #800080;">10</span><span style="color: #000000;">];
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4120857.html" target="_blank">Roman to Integer</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/12384/simple-solution" target="_blank">https://discuss.leetcode.com/topic/12384/simple-solution</a></p>
<p><a href="https://discuss.leetcode.com/topic/20510/my-java-solution-easy-to-understand" target="_blank">https://discuss.leetcode.com/topic/20510/my-java-solution-easy-to-understand</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2014-11-26 15:26</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4123374" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4123374);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4455109.html" id="cb_post_title_url">[LeetCode] Container With Most Water 装最多水的容器</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given <em>n</em> non-negative integers <em>a<sub>1</sub></em>, <em>a<sub>2</sub></em>, ..., <em>a<sub>n</sub></em>, where each represents a point at coordinate (<em>i</em>, <em>a<sub>i</sub></em>). <em>n</em> vertical lines are drawn such that the two endpoints of line <em>i</em> is at (<em>i</em>, <em>a<sub>i</sub></em>) and (<em>i</em>, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p>
<p>Note: You may not slant the container.</p>
<p> </p>
<p>这道求装最多水的容器的题和那道<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4402392.html" id="cb_post_title_url"> Trapping Rain Water 收集雨水 </a>很类似，但又有些不同，那道题让求整个能收集雨水的量，这道只是让求最大的一个的装水量，而且还有一点不同的是，那道题容器边缘不能算在里面，而这道题却可以算，相比较来说还是这道题容易一些，我们需要定义i和j两个指针分别指向数组的左右两端，然后两个指针向中间搜索，每移动一次算一个值和结果比较取较大的，容器装水量的算法是找出左右两个边缘中较小的那个乘以两边缘的距离，代码如下：</p>
<p> </p>
<p>C++ 解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> maxArea(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> height) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, i = <span style="color: #800080;">0</span>, j = height.size() - <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (i &lt;<span style="color: #000000;"> j) {
            res </span>= max(res, min(height[i], height[j]) * (j -<span style="color: #000000;"> i));
            height[i] </span>&lt; height[j] ? ++i : --<span style="color: #000000;">j;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>Java 解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span> maxArea(<span style="color: #0000ff;">int</span><span style="color: #000000;">[] height) {
        </span><span style="color: #0000ff;">int</span> res = 0, i = 0, j = height.length - 1<span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (i &lt;<span style="color: #000000;"> j) {
            res </span>= Math.max(res, Math.min(height[i], height[j]) * (j -<span style="color: #000000;"> i));
            </span><span style="color: #0000ff;">if</span> (height[i] &lt; height[j]) ++<span style="color: #000000;">i;
            </span><span style="color: #0000ff;">else</span> --<span style="color: #000000;">j;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
}</span></pre>
</div>
<p> </p>
<p>这里需要注意的是，由于Java中的三元运算符A?B:C必须须要有返回值，所以只能用if..else..来替换，不知道Java对于三元运算符这么严格的限制的原因是什么。</p>
<p>下面这种方法是对上面的方法进行了小幅度的优化，对于相同的高度们直接移动i和j就行了，不再进行计算容量了，参见代码如下：</p>
<p> </p>
<p>C++ 解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> maxArea(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> height) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, i = <span style="color: #800080;">0</span>, j = height.size() - <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (i &lt;<span style="color: #000000;"> j) {
            </span><span style="color: #0000ff;">int</span> h =<span style="color: #000000;"> min(height[i], height[j]);
            res </span>= max(res, h * (j -<span style="color: #000000;"> i));
            </span><span style="color: #0000ff;">while</span> (i &lt; j &amp;&amp; h == height[i]) ++<span style="color: #000000;">i;
            </span><span style="color: #0000ff;">while</span> (i &lt; j &amp;&amp; h == height[j]) --<span style="color: #000000;">j;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>Java 解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span> maxArea(<span style="color: #0000ff;">int</span><span style="color: #000000;">[] height) {
        </span><span style="color: #0000ff;">int</span> res = 0, i = 0, j = height.length - 1<span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (i &lt;<span style="color: #000000;"> j) {
            </span><span style="color: #0000ff;">int</span> h =<span style="color: #000000;"> Math.min(height[i], height[j]);
            res </span>= Math.max(res, h * (j -<span style="color: #000000;"> i));
            </span><span style="color: #0000ff;">while</span> (i &lt; j &amp;&amp; h == height[i]) ++<span style="color: #000000;">i;
            </span><span style="color: #0000ff;">while</span> (i &lt; j &amp;&amp; h == height[j]) --<span style="color: #000000;">j;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
}</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/16754/simple-and-fast-c-c-with-explanation" target="_blank">https://discuss.leetcode.com/topic/16754/simple-and-fast-c-c-with-explanation</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-04-25 00:28</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4455109" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4455109);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4461713.html" id="cb_post_title_url">[LeetCode] Regular Expression Matching 正则表达式匹配</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Implement regular expression matching with support for <code>'.'</code> and <code>'*'</code>.</p>
<pre>'.' Matches any single character.
'*' Matches zero or more of the preceding element.

The matching should cover the entire input string (not partial).

The function prototype should be:
bool isMatch(const char *s, const char *p)

Some examples:
isMatch("aa","a") → false
isMatch("aa","aa") → true
isMatch("aaa","aa") → false
isMatch("aa", "a*") → true
isMatch("aa", ".*") → true
isMatch("ab", ".*") → true
isMatch("aab", "c*a*b") → true</pre>
<p> </p>
<p>这道求正则表达式匹配的题和那道<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4401196.html" id="cb_post_title_url"> Wildcard Matching 通配符匹配</a>的题很类似，不同点在于*的意义不同，在之前那道题中，*表示可以代替任意个数的字符，而这道题中的*表示之前那个字符可以有0个，1个或是多个，就是说，字符串a*b，可以表示b或是aaab，即a的个数任意，这道题的难度要相对之前那一道大一些，分的情况的要复杂一些，需要用递归Recursion来解，大概思路如下：</p>
<p>- 若p为空，若s也为空，返回true，反之返回false</p>
<p>- 若p的长度为1，若s长度也为1，且相同或是p为'.'则返回true，反之返回false</p>
<p>- 若p的第二个字符不为*，若此时s为空返回false，否则判断首字符是否匹配，且从各自的第二个字符开始调用递归函数匹配</p>
<p>- 若p的第二个字符为*，若s不为空且字符匹配，调用递归函数匹配s和去掉前两个字符的p，若匹配返回true，否则s去掉首字母</p>
<p>- 返回调用递归函数匹配s和去掉前两个字符的p的结果</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> isMatch(<span style="color: #0000ff;">string</span> s, <span style="color: #0000ff;">string</span><span style="color: #000000;"> p) {
        </span><span style="color: #0000ff;">if</span> (p.empty()) <span style="color: #0000ff;">return</span><span style="color: #000000;"> s.empty();
        </span><span style="color: #0000ff;">if</span> (p.size() == <span style="color: #800080;">1</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">return</span> (s.size() == <span style="color: #800080;">1</span> &amp;&amp; (s[<span style="color: #800080;">0</span>] == p[<span style="color: #800080;">0</span>] || p[<span style="color: #800080;">0</span>] == <span style="color: #800000;">'</span><span style="color: #800000;">.</span><span style="color: #800000;">'</span><span style="color: #000000;">));
        }
        </span><span style="color: #0000ff;">if</span> (p[<span style="color: #800080;">1</span>] != <span style="color: #800000;">'</span><span style="color: #800000;">*</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">if</span> (s.empty()) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">return</span> (s[<span style="color: #800080;">0</span>] == p[<span style="color: #800080;">0</span>] || p[<span style="color: #800080;">0</span>] == <span style="color: #800000;">'</span><span style="color: #800000;">.</span><span style="color: #800000;">'</span>) &amp;&amp; isMatch(s.substr(<span style="color: #800080;">1</span>), p.substr(<span style="color: #800080;">1</span><span style="color: #000000;">));
        }
        </span><span style="color: #0000ff;">while</span> (!s.empty() &amp;&amp; (s[<span style="color: #800080;">0</span>] == p[<span style="color: #800080;">0</span>] || p[<span style="color: #800080;">0</span>] == <span style="color: #800000;">'</span><span style="color: #800000;">.</span><span style="color: #800000;">'</span><span style="color: #000000;">)) {
            </span><span style="color: #0000ff;">if</span> (isMatch(s, p.substr(<span style="color: #800080;">2</span>))) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
            s </span>= s.substr(<span style="color: #800080;">1</span><span style="color: #000000;">);
        }
        </span><span style="color: #0000ff;">return</span> isMatch(s, p.substr(<span style="color: #800080;">2</span><span style="color: #000000;">));
    }
};</span></pre>
</div>
<p> </p>
<p>上面的方法可以写的更加简洁一些，但是整个思路还是一样的，我们先来判断p是否为空，若为空则根据s的为空的情况返回结果。当p的第二个字符为*号时，由于*号前面的字符的个数可以任意，可以为0，那么我们先用递归来调用为0的情况，就是直接把这两个字符去掉再比较，或者当s不为空，且第一个字符和p的第一个字符相同时，我们再对去掉首字符的s和p调用递归，注意p不能去掉首字符，因为*号前面的字符可以有无限个；如果第二个字符不为*号，那么我们就老老实实的比较第一个字符，然后对后面的字符串调用递归，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> isMatch(<span style="color: #0000ff;">string</span> s, <span style="color: #0000ff;">string</span><span style="color: #000000;"> p) {
        </span><span style="color: #0000ff;">if</span> (p.empty()) <span style="color: #0000ff;">return</span><span style="color: #000000;"> s.empty();
        </span><span style="color: #0000ff;">if</span> (p.size() &gt; <span style="color: #800080;">1</span> &amp;&amp; p[<span style="color: #800080;">1</span>] == <span style="color: #800000;">'</span><span style="color: #800000;">*</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">return</span> isMatch(s, p.substr(<span style="color: #800080;">2</span>)) || (!s.empty() &amp;&amp; (s[<span style="color: #800080;">0</span>] == p[<span style="color: #800080;">0</span>] || p[<span style="color: #800080;">0</span>] == <span style="color: #800000;">'</span><span style="color: #800000;">.</span><span style="color: #800000;">'</span>) &amp;&amp; isMatch(s.substr(<span style="color: #800080;">1</span><span style="color: #000000;">), p));
        } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            </span><span style="color: #0000ff;">return</span> !s.empty() &amp;&amp; (s[<span style="color: #800080;">0</span>] == p[<span style="color: #800080;">0</span>] || p[<span style="color: #800080;">0</span>] == <span style="color: #800000;">'</span><span style="color: #800000;">.</span><span style="color: #800000;">'</span>) &amp;&amp; isMatch(s.substr(<span style="color: #800080;">1</span>), p.substr(<span style="color: #800080;">1</span><span style="color: #000000;">));
        }
    }
};</span></pre>
</div>
<p> </p>
<p>我们也可以用DP来解，定义一个二维的DP数组，其中dp[i][j]表示s[0,i)和p[0,j)是否match，然后有下面三种情况(下面部分摘自<a href="https://discuss.leetcode.com/topic/17852/9-lines-16ms-c-dp-solutions-with-explanations" target="_blank">这个帖子</a>)：</p>
<p>1.  P[i][j] = P[i - 1][j - 1], if p[j - 1] != '*' &amp;&amp; (s[i - 1] == p[j - 1] || p[j - 1] == '.');<br/>2.  P[i][j] = P[i][j - 2], if p[j - 1] == '*' and the pattern repeats for 0 times;<br/>3.  P[i][j] = P[i - 1][j] &amp;&amp; (s[i - 1] == p[j - 2] || p[j - 2] == '.'), if p[j - 1] == '*' and the pattern repeats for at least 1 times.</p>
<p><br/>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> isMatch(<span style="color: #0000ff;">string</span> s, <span style="color: #0000ff;">string</span><span style="color: #000000;"> p) {
        </span><span style="color: #0000ff;">int</span> m = s.size(), n =<span style="color: #000000;"> p.size();
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">bool</span>&gt;&gt; dp(m + <span style="color: #800080;">1</span>, vector&lt;<span style="color: #0000ff;">bool</span>&gt;(n + <span style="color: #800080;">1</span>, <span style="color: #0000ff;">false</span><span style="color: #000000;">));
        dp[</span><span style="color: #800080;">0</span>][<span style="color: #800080;">0</span>] = <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt;= m; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">1</span>; j &lt;= n; ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> (j &gt; <span style="color: #800080;">1</span> &amp;&amp; p[j - <span style="color: #800080;">1</span>] == <span style="color: #800000;">'</span><span style="color: #800000;">*</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                    dp[i][j] </span>= dp[i][j - <span style="color: #800080;">2</span>] || (i &gt; <span style="color: #800080;">0</span> &amp;&amp; (s[i - <span style="color: #800080;">1</span>] == p[j - <span style="color: #800080;">2</span>] || p[j - <span style="color: #800080;">2</span>] == <span style="color: #800000;">'</span><span style="color: #800000;">.</span><span style="color: #800000;">'</span>) &amp;&amp; dp[i - <span style="color: #800080;">1</span><span style="color: #000000;">][j]);
                } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    dp[i][j] </span>= i &gt; <span style="color: #800080;">0</span> &amp;&amp; dp[i - <span style="color: #800080;">1</span>][j - <span style="color: #800080;">1</span>] &amp;&amp; (s[i - <span style="color: #800080;">1</span>] == p[j - <span style="color: #800080;">1</span>] || p[j - <span style="color: #800080;">1</span>] == <span style="color: #800000;">'</span><span style="color: #800000;">.</span><span style="color: #800000;">'</span><span style="color: #000000;">);
                }
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> dp[m][n];
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4401196.html" target="_blank">Wildcard Matching</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/17852/9-lines-16ms-c-dp-solutions-with-explanations" target="_blank">https://discuss.leetcode.com/topic/17852/9-lines-16ms-c-dp-solutions-with-explanations</a></p>
<p><a href="https://discuss.leetcode.com/topic/6183/my-concise-recursive-and-dp-solutions-with-full-explanation-in-c" target="_blank">https://discuss.leetcode.com/topic/6183/my-concise-recursive-and-dp-solutions-with-full-explanation-in-c</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-04-27 23:05</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4461713" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4461713);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4125510.html" id="cb_post_title_url">[LeetCode] Palindrome Number 验证回文数字</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.</p>
<p>Example 1:</p>
<pre>Input: 121
Output: true
</pre>
<p>Example 2:</p>
<pre>Input: -121
Output: false
Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.
</pre>
<p>Example 3:</p>
<pre>Input: 10
Output: false
Explanation: Reads 01 from right to left. Therefore it is not a palindrome.
</pre>
<p>Follow up:</p>
<p>Coud you solve it without converting the integer to a string?</p>
<div class="spoilers" style="display: block;">
<p> </p>
<p>这道验证回文数字的题如果将数字转为字符串，就变成了验证回文字符串的题，没啥难度了，我们就直接来做follow up吧，不能转为字符串，而是直接对整数进行操作，我们可以利用取整和取余来获得我们想要的数字，比如 1221 这个数字，如果 计算 1221 / 1000， 则可得首位1， 如果 1221 % 10， 则可得到末尾1，进行比较，然后把中间的22取出继续比较。代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> isPalindrome(<span style="color: #0000ff;">int</span><span style="color: #000000;"> x) {
        </span><span style="color: #0000ff;">if</span> (x &lt; <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> div = <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (x / div &gt;= <span style="color: #800080;">10</span>) div *= <span style="color: #800080;">10</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (x &gt; <span style="color: #800080;">0</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">int</span> left = x /<span style="color: #000000;"> div;
            </span><span style="color: #0000ff;">int</span> right = x % <span style="color: #800080;">10</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> (left != right) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            x </span>= (x % div) / <span style="color: #800080;">10</span><span style="color: #000000;">;
            div </span>/= <span style="color: #800080;">100</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>我们再来看一种很巧妙的解法，还是首先判断x是否为负数，这里我们可以用一个小trick，因为我们知道整数的最高位不能是0，所以回文数的最低位也不能为0，数字0除外，所以如果发现某个正数的末尾是0了，也直接返回false即可。好，下面来看具体解法，要验证回文数，那么就需要看前后半段是否对称，如果把后半段翻转一下，就看和前半段是否相等就行了。所以我们的做法就是取出后半段数字，进行翻转，具体做法是，每次通过对10取余，取出最低位的数字，然后加到取出数的末尾，就是将revertNum乘以10，再加上这个余数，这样我们的翻转也就同时完成了，每取一个最低位数字，x都要自除以10。这样当revertNum大于等于x的时候循环停止。由于回文数的位数可奇可偶，如果是偶数的话，那么revertNum就应该和x相等了；如果是奇数的话，那么最中间的数字就在revertNum的最低位上了，我们除以10以后应该和x是相等的，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> isPalindrome(<span style="color: #0000ff;">int</span><span style="color: #000000;"> x) {
        </span><span style="color: #0000ff;">if</span> (x &lt; <span style="color: #800080;">0</span> || (x % <span style="color: #800080;">10</span> == <span style="color: #800080;">0</span> &amp;&amp; x != <span style="color: #800080;">0</span>)) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> revertNum = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (x &gt;<span style="color: #000000;"> revertNum) {
            revertNum </span>= revertNum * <span style="color: #800080;">10</span> + x % <span style="color: #800080;">10</span><span style="color: #000000;">;
            x </span>/= <span style="color: #800080;">10</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> x == revertNum || x == revertNum / <span style="color: #800080;">10</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种解法由网友zeeng提供，如果是palindrome，反转后仍是原数字，就不可能溢出，只要溢出一定不是palindrome返回false就行。可以参考<a href="http://www.cnblogs.com/grandyang/p/4125588.html" target="_blank">Reverse Integer</a>这题, 直接调用Reverse()。</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> isPalindrome(<span style="color: #0000ff;">int</span><span style="color: #000000;"> x) {
        </span><span style="color: #0000ff;">if</span> (x &lt; <span style="color: #800080;">0</span> || (x % <span style="color: #800080;">10</span> == <span style="color: #800080;">0</span> &amp;&amp; x != <span style="color: #800080;">0</span>)) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span> reverse(x) ==<span style="color: #000000;"> x;
    }
    </span><span style="color: #0000ff;">int</span> reverse(<span style="color: #0000ff;">int</span><span style="color: #000000;"> x) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (x != <span style="color: #800080;">0</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">if</span> (res &gt; INT_MAX / <span style="color: #800080;">10</span>) <span style="color: #0000ff;">return</span> -<span style="color: #800080;">1</span><span style="color: #000000;">;
            res </span>= res * <span style="color: #800080;">10</span> + x % <span style="color: #800080;">10</span><span style="color: #000000;">;
            x </span>/= <span style="color: #800080;">10</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4635425.html">Palindrome Linked List</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4125588.html" target="_blank">Reverse Integer</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p>
</div></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2014-11-27 02:28</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4125510" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4125510);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4125537.html" id="cb_post_title_url">[LeetCode] String to Integer (atoi) 字符串转为整数</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Implement atoi to convert a string to an integer.</p>
<p>Hint: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases.</p>
<p>Notes: It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front.</p>
<p><span style="color: red;">Update (2015-02-10):</span><br/>The signature of the <code>C++</code> function had been updated. If you still see your function signature accepts a <code>const char *</code> argument, please click the reload button <span class="glyphicon glyphicon-refresh"> to reset your code definition.</span></p>
<div class="spoilers">Requirements for atoi:
<p>The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.</p>
<p>The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.</p>
<p>If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.</p>
<p>If no valid conversion could be performed, a zero value is returned. If the correct value is out of the range of representable values, INT_MAX (2147483647) or INT_MIN (-2147483648) is returned.</p>
</div>
<div class="spoilers" style="display: block;">
<p> </p>
<p>字符串转为整数是很常用的一个函数，由于输入的是字符串，所以需要考虑的情况有很多种。我之前有一篇文章是关于验证一个字符串是否为数字的，参见 <a href="http://www.cnblogs.com/grandyang/p/4084408.html" target="_blank">http://www.cnblogs.com/grandyang/p/4084408.html </a>。在那篇文章中，详细的讨论了各种情况，包括符号，自然数，小数点的出现位置，判断他们是否是数字。个人以为这道题也应该有这么多种情况。但是这题只需要考虑数字和符号的情况：</p>
<p>1. 若字符串开头是空格，则跳过所有空格，到第一个非空格字符，如果没有，则返回0.</p>
<p>2. 若第一个非空格字符是符号+/-，则标记sign的真假，这道题还有个局限性，那就是在c++里面，+-1和-+1都是认可的，都是-1，而在此题里，则会返回0.</p>
<p>3. 若下一个字符不是数字，则返回0. 完全不考虑小数点和自然数的情况，不过这样也好，起码省事了不少。</p>
<p>4. 如果下一个字符是数字，则转为整形存下来，若接下来再有非数字出现，则返回目前的结果。</p>
<p>5. 还需要考虑边界问题，如果超过了整形数的范围，则用边界值替代当前值。</p>
<p> </p>
<p>C++ 解法：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> myAtoi(<span style="color: #0000ff;">string</span><span style="color: #000000;"> str) {
        </span><span style="color: #0000ff;">if</span> (str.empty()) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> sign = <span style="color: #800080;">1</span>, <span style="color: #0000ff;">base</span> = <span style="color: #800080;">0</span>, i = <span style="color: #800080;">0</span>, n =<span style="color: #000000;"> str.size();
        </span><span style="color: #0000ff;">while</span> (i &lt; n &amp;&amp; str[i] == <span style="color: #800000;">'</span> <span style="color: #800000;">'</span>) ++<span style="color: #000000;">i;
        </span><span style="color: #0000ff;">if</span> (str[i] == <span style="color: #800000;">'</span><span style="color: #800000;">+</span><span style="color: #800000;">'</span> || str[i] == <span style="color: #800000;">'</span><span style="color: #800000;">-</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
            sign </span>= (str[i++] == <span style="color: #800000;">'</span><span style="color: #800000;">+</span><span style="color: #800000;">'</span>) ? <span style="color: #800080;">1</span> : -<span style="color: #800080;">1</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">while</span> (i &lt; n &amp;&amp; str[i] &gt;= <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span> &amp;&amp; str[i] &lt;= <span style="color: #800000;">'</span><span style="color: #800000;">9</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">base</span> &gt; INT_MAX / <span style="color: #800080;">10</span> || (<span style="color: #0000ff;">base</span> == INT_MAX / <span style="color: #800080;">10</span> &amp;&amp; str[i] - <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span> &gt; <span style="color: #800080;">7</span><span style="color: #000000;">)) {
                </span><span style="color: #0000ff;">return</span> (sign == <span style="color: #800080;">1</span>) ?<span style="color: #000000;"> INT_MAX : INT_MIN;
            }
            </span><span style="color: #0000ff;">base</span> = <span style="color: #800080;">10</span> * <span style="color: #0000ff;">base</span> + (str[i++] - <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span><span style="color: #000000;">);
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">base</span> *<span style="color: #000000;"> sign;
    }
};</span></pre>
</div>
<p> </p>
<p>Java 解法：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> myAtoi(String str) {
        </span><span style="color: #0000ff;">if</span> (str.isEmpty()) <span style="color: #0000ff;">return</span> 0<span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> sign = 1, base = 0, i = 0, n =<span style="color: #000000;"> str.length();
        </span><span style="color: #0000ff;">while</span> (i &lt; n &amp;&amp; str.charAt(i) == ' ') ++<span style="color: #000000;">i;
        </span><span style="color: #0000ff;">if</span> (str.charAt(i) == '+' || str.charAt(i) == '-'<span style="color: #000000;">) {
            sign </span>= (str.charAt(i++) == '+') ? 1 : -1<span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">while</span> (i &lt; n &amp;&amp; str.charAt(i) &gt;= '0' &amp;&amp; str.charAt(i) &lt;= '9'<span style="color: #000000;">) {
            </span><span style="color: #0000ff;">if</span> (base &gt; Integer.MAX_VALUE / 10 || (base == Integer.MAX_VALUE / 10 &amp;&amp; str.charAt(i) - '0' &gt; 7<span style="color: #000000;">)) {
                </span><span style="color: #0000ff;">return</span> (sign == 1) ?<span style="color: #000000;"> Integer.MAX_VALUE : Integer.MIN_VALUE;
            }
            base </span>= 10 * base + (str.charAt(i++) - '0'<span style="color: #000000;">);
        }
        </span><span style="color: #0000ff;">return</span> base *<span style="color: #000000;"> sign;
    }
}</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/2666/my-simple-solution" target="_blank">https://discuss.leetcode.com/topic/2666/my-simple-solution</a></p>
<p><a href="https://discuss.leetcode.com/topic/15891/8ms-c-solution-easy-to-understand" target="_blank">https://discuss.leetcode.com/topic/15891/8ms-c-solution-easy-to-understand</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p>
<p> </p>
</div></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2014-11-27 07:35</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4125537" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4125537);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4125588.html" id="cb_post_title_url">[LeetCode] Reverse Integer 翻转整数</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Reverse digits of an integer.</p>
<p style="font-family: monospace;"> <strong>Example1:</strong> x = 123, return 321<br/>
<strong>Example2:</strong> x = -123, return -321
</p>
<div class="spoilers" style="display: block;"><strong>Have you thought about this?</strong>
<p>Here are some good questions to ask before coding. Bonus points for you if you have already thought through this!</p>
<p>If the integer's last digit is 0, what should the output be? ie, cases such as 10, 100.</p>
<p>Did you notice that the reversed integer might overflow? Assume the 
input is a 32-bit integer, then the reverse of 1000000003 overflows. How
 should you handle such cases?</p>
<p>For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.</p>
<p>
<strong><span style="color: red;">Update (2014-11-10):</span></strong><br/>
Test cases had been added to test the overflow behavior.
</p>
</div>
<div class="spoilers" style="display: block;"> </div>
<div class="spoilers" style="display: block;">翻转数字问题需要注意的就是溢出问题，看了许多网上的解法，由于之前的OJ没有对溢出进行测试，所以网上很多人的解法没有处理溢出问题也能通过OJ。现在OJ更新了溢出测试，所以还是要考虑到。为什么会存在溢出问题呢，我们知道int型的数值范围是 -2147483648～2147483647， 那么如果我们要翻转 1000000009 这个在范围内的数得到 9000000001，而翻转后的数就超过了范围。</div>
<div class="spoilers" style="display: block;">我最开始的想法是，用long long 型数据，其数值范围为 -9223372036854775808~9223372036854775807， 远大于int型这样就不会出现溢出问题。代码如下：</div>
<div class="spoilers" style="display: block;"> </div>
<div class="spoilers" style="display: block;">解法一：</div>
<div class="spoilers" style="display: block;">
<div class="cnblogs_code">
<pre><span style="color: #008000;">/*</span><span style="color: #008000;">*
 * Correct but can refactor the code.
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> reverse(<span style="color: #0000ff;">int</span><span style="color: #000000;"> x) {
        </span><span style="color: #0000ff;">long</span> <span style="color: #0000ff;">long</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">bool</span> isPositive = <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (x &lt; <span style="color: #800080;">0</span><span style="color: #000000;">) {
            isPositive </span>= <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            x </span>*= -<span style="color: #800080;">1</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">while</span> (x &gt; <span style="color: #800080;">0</span><span style="color: #000000;">) {
            res </span>= res * <span style="color: #800080;">10</span> + x % <span style="color: #800080;">10</span><span style="color: #000000;">;
            x </span>/= <span style="color: #800080;">10</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">if</span> (res &gt; INT_MAX) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (isPositive) <span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">return</span> -<span style="color: #000000;">res;
    }
};</span></pre>
</div>
<p> </p>
<p>提交通过后，OJ给出了官方解答，一看比自己的写的更精简一些，它没有特意处理正负号，仔细一想，果然正负号不影响计算，而且没有用long long型数据，感觉写的更好一些，那么就贴出来吧：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> reverse(<span style="color: #0000ff;">int</span><span style="color: #000000;"> x) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (x != <span style="color: #800080;">0</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">if</span> (abs(res) &gt; INT_MAX / <span style="color: #800080;">10</span>) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
            res </span>= res * <span style="color: #800080;">10</span> + x % <span style="color: #800080;">10</span><span style="color: #000000;">;
            x </span>/= <span style="color: #800080;">10</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>在贴出答案的同时，OJ还提了一个问题 To check for overflow/underflow, we could check if ret &gt; 214748364 or ret &lt; –214748364 before multiplying by 10. On the other hand, we do not need to check if ret == 214748364, why? （214748364 即为 INT_MAX / <span style="color: #800080;">10</span>）</p>
<p>为什么不用check是否等于214748364呢，因为输入的x也是一个整型数，所以x的范围也应该在 -2147483648～2147483647 之间，那么x的第一位只能是1或者2，翻转之后res的最后一位只能是1或2，所以res只能是 2147483641 或 2147483642 都在int的范围内。但是它们对应的x为 1463847412 和 2463847412，后者超出了数值范围。所以当过程中res等于 214748364 时， 输入的x只能为 1463847412， 翻转后的结果为 2147483641，都在正确的范围内，所以不用check。</p>
<p>我们也可以用long long型变量保存计算结果，最后返回的时候判断是否在int返回内，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> reverse(<span style="color: #0000ff;">int</span><span style="color: #000000;"> x) {
        </span><span style="color: #0000ff;">long</span> <span style="color: #0000ff;">long</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (x != <span style="color: #800080;">0</span><span style="color: #000000;">) {
            res </span>= <span style="color: #800080;">10</span> * res + x % <span style="color: #800080;">10</span><span style="color: #000000;">;
            x </span>/= <span style="color: #800080;">10</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> (res &gt; INT_MAX || res &lt; INT_MIN) ? <span style="color: #800080;">0</span><span style="color: #000000;"> : res;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种方法是上面解法二的变形，其实也不难理解，因为都是用int型的，如果超出了范围，其除以10的结果就不会跟之前的结果一致，通过这点也可以进行区分，参见代码如下：</p>
<p> </p>
<p>解法四：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> reverse(<span style="color: #0000ff;">int</span><span style="color: #000000;"> x) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (x != <span style="color: #800080;">0</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">int</span> t = res * <span style="color: #800080;">10</span> + x % <span style="color: #800080;">10</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> (t / <span style="color: #800080;">10</span> != res) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
            res </span>=<span style="color: #000000;"> t;
            x </span>/= <span style="color: #800080;">10</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/34506/8-ms-simple-c-solution-which-checks-overflow/2" target="_blank">https://discuss.leetcode.com/topic/34506/8-ms-simple-c-solution-which-checks-overflow/2</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p>
</div></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2014-11-27 09:04</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4125588" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4125588);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4128268.html" id="cb_post_title_url">[LeetCode] ZigZag Converesion  之字型转换字符串</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>The string <code>"PAYPALISHIRING"</code> is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)</p>
<pre>P   A   H   N
A P L S I I G
Y   I   R
</pre>
<p>And then read line by line: <code>"PAHNAPLSIIGYIR"</code></p>
<p> </p>
<p>Write the code that will take a string and make this conversion given a number of rows:</p>
<pre>string convert(string text, int nRows);</pre>
<p><code>convert("PAYPALISHIRING", 3)</code> should return <code>"PAHNAPLSIIGYIR"</code>.</p>
<p> </p>
<p>这道题刚开始看了半天没看懂是咋样变换的，上网查了些资料，终于搞懂了，就是要把字符串摆成一个之字型的，参考了网上这位仁兄的解法 (<a href="http://www.cnblogs.com/springfor/p/3889414.html" target="_blank">http://www.cnblogs.com/springfor/p/3889414.html</a>)。</p>
<p>比如有一个字符串 “0123456789ABCDEF”，转为zigzag</p>
<p>当 n = 2 时：</p>
<p>0 2 4 6 8 A C E</p>
<p>1 3 5 7 9 B D F</p>
<p>当 n = 3 时：</p>
<p>0   4    8     C</p>
<p>1 <span style="color: #ff0000;">3</span> 5 <span style="color: #ff0000;">7</span> 9 <span style="color: #ff0000;">B</span> D <span style="color: #ff0000;">F</span></p>
<p>2    6   A     E</p>
<p>当 n = 4 时：</p>
<p>0     6        C</p>
<p>1   <span style="color: #ff0000;">5</span> 7   <span style="color: #ff0000;">B</span>  D</p>
<p>2 <span style="color: #ff0000;">4</span>   8 <span style="color: #ff0000;">A</span>    E</p>
<p>3      9       F</p>
<p> </p>
<p>我们发现，除了第一行和最后一行没有中间形成之字型的数字外，其他都有，而首位两行中相邻两个元素的index之差跟行数是相关的，为 2*nRows - 2, 根据这个特点，我们可以按顺序找到所有的黑色元素在元字符串的位置，将他们按顺序加到新字符串里面。对于红色元素出现的位置也是有规律的，每个红色元素的位置为 j + 2*nRows-2 - 2*i, 其中，j为前一个黑色元素的列数，i为当前行数。 比如当n = 4中的那个红色5，它的位置为 1 + 2*4-2 - 2*1 = 5，为原字符串的正确位置。当我们知道所有黑色元素和红色元素位置的正确算法，我们就可以一次性的把它们按顺序都加到新的字符串里面。代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> convert(<span style="color: #0000ff;">string</span> s, <span style="color: #0000ff;">int</span><span style="color: #000000;"> nRows) {
        </span><span style="color: #0000ff;">if</span> (nRows &lt;= <span style="color: #800080;">1</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;"> s;
        </span><span style="color: #0000ff;">string</span> res = <span style="color: #800000;">""</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> size = <span style="color: #800080;">2</span> * nRows - <span style="color: #800080;">2</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; nRows; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = i; j &lt; s.size(); j +=<span style="color: #000000;"> size) {
                res </span>+=<span style="color: #000000;"> s[j];
                </span><span style="color: #0000ff;">int</span> tmp = j + size - <span style="color: #800080;">2</span> *<span style="color: #000000;"> i;
                </span><span style="color: #0000ff;">if</span> (i != <span style="color: #800080;">0</span> &amp;&amp; i != nRows - <span style="color: #800080;">1</span> &amp;&amp; tmp &lt; s.size()) res +=<span style="color: #000000;"> s[tmp];
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2014-11-28 13:03</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4128268" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4128268);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4464476.html" id="cb_post_title_url">[LeetCode] Longest Palindromic Substring 最长回文子串</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a string <em>S</em>, find the longest palindromic substring in <em>S</em>. You may assume that the maximum length of <em>S</em> is 1000, and there exists one unique longest palindromic substring.</p>
<p> </p>
<p>这道题让我们求<a href="http://en.wikipedia.org/wiki/Longest_palindromic_substring" target="_blank">最长回文子串</a>，首先说下什么是回文串，就是正读反读都一样的字符串，比如 "bob", "level", "noon" 等等。那么最长回文子串就是在一个字符串中的那个最长的回文子串。LeetCode中关于回文串的题共有五道，除了这道，其他的四道为<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4125510.html" id="cb_post_title_url"> Palindrome Number</a>，<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4030114.html" id="cb_post_title_url"> Validate Palindrome</a>，<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4270008.html" id="cb_post_title_url"> Palindrome Partitioning</a>，<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4271456.html" id="cb_post_title_url">Palindrome Partitioning II</a>，我们知道传统的验证回文串的方法就是两个两个的对称验证是否相等，那么对于找回文字串的问题，就要以每一个字符为中心，像两边扩散来寻找回文串，这个算法的时间复杂度是O(n*n)，可以通过OJ，就是要注意奇偶情况，由于回文串的长度可奇可偶，比如"bob"是奇数形式的回文，"noon"就是偶数形式的回文，两种形式的回文都要搜索，对于奇数形式的，我们就从遍历到的位置为中心，向两边进行扩散，对于偶数情况，我们就把当前位置和下一个位置当作偶数行回文的最中间两个字符，然后向两边进行搜索，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> longestPalindrome(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        </span><span style="color: #0000ff;">if</span> (s.size() &lt; <span style="color: #800080;">2</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;"> s;
        </span><span style="color: #0000ff;">int</span> n = s.size(), maxLen = <span style="color: #800080;">0</span>, start = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n - <span style="color: #800080;">1</span>; ++<span style="color: #000000;">i) {
            searchPalindrome(s, i, i, start, maxLen);
            searchPalindrome(s, i, i </span>+ <span style="color: #800080;">1</span><span style="color: #000000;">, start, maxLen);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> s.substr(start, maxLen);
    }
    </span><span style="color: #0000ff;">void</span> searchPalindrome(<span style="color: #0000ff;">string</span> s, <span style="color: #0000ff;">int</span> left, <span style="color: #0000ff;">int</span> right, <span style="color: #0000ff;">int</span>&amp; start, <span style="color: #0000ff;">int</span>&amp;<span style="color: #000000;"> maxLen) {
        </span><span style="color: #0000ff;">while</span> (left &gt;= <span style="color: #800080;">0</span> &amp;&amp; right &lt; s.size() &amp;&amp; s[left] ==<span style="color: #000000;"> s[right]) {
            </span>--left; ++<span style="color: #000000;">right;
        }
        </span><span style="color: #0000ff;">if</span> (maxLen &lt; right - left - <span style="color: #800080;">1</span><span style="color: #000000;">) {
            start </span>= left + <span style="color: #800080;">1</span><span style="color: #000000;">;
            maxLen </span>= right - left - <span style="color: #800080;">1</span><span style="color: #000000;">;
        }
    }
};</span></pre>
</div>
<p> </p>
<p>我们也可以不使用子函数，直接在一个函数中搞定，我们还是要定义两个变量start和maxLen，分别表示最长回文子串的起点跟长度，在遍历s中的字符的时候，我们首先判断剩余的字符数是否小于等于maxLen的一半，是的话说明maxLen无法再变长了，直接break掉。否则就要继续判断，我们用两个变量left和right分别指向当前位置，然后我们先要做的是向右遍历跳过重复项，这个操作很必要，比如对于 noon，i在第一个o的位置，如果我们以o为最中心往两边扩散，是无法得到长度为4的回文串的，只有先跳过重复，此时left指向第一个o，right指向第二个o，然后再向两边扩散。而对于 bob，i在第一个o的位置时，无法向右跳过重复，此时left和right同时指向o，再向两边扩散也是正确的，所以可以同时处理奇数和偶数的回文串，之后的操作就是更新maxLen和start了，跟上面的操作一样，参见代码如下： </p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> longestPalindrome(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        </span><span style="color: #0000ff;">if</span> (s.size() &lt; <span style="color: #800080;">2</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;"> s;
        </span><span style="color: #0000ff;">int</span> n = s.size(), maxLen = <span style="color: #800080;">0</span>, start = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt;<span style="color: #000000;"> n;) {
            </span><span style="color: #0000ff;">if</span> (n - i &lt;= maxLen / <span style="color: #800080;">2</span>) <span style="color: #0000ff;">break</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">int</span> left = i, right =<span style="color: #000000;"> i;
            </span><span style="color: #0000ff;">while</span> (right &lt; n - <span style="color: #800080;">1</span> &amp;&amp; s[right + <span style="color: #800080;">1</span>] == s[right]) ++<span style="color: #000000;">right;
            i </span>= right + <span style="color: #800080;">1</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">while</span> (right &lt; n - <span style="color: #800080;">1</span> &amp;&amp; left &gt; <span style="color: #800080;">0</span> &amp;&amp; s[right + <span style="color: #800080;">1</span>] == s[left - <span style="color: #800080;">1</span><span style="color: #000000;">]) {
                </span>++right; --<span style="color: #000000;">left;
            }
            </span><span style="color: #0000ff;">if</span> (maxLen &lt; right - left + <span style="color: #800080;">1</span><span style="color: #000000;">) {
                maxLen </span>= right - left + <span style="color: #800080;">1</span><span style="color: #000000;">;
                start </span>=<span style="color: #000000;"> left;
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> s.substr(start, maxLen);
    }
};</span></pre>
</div>
<p> </p>
<p>此题还可以用动态规划Dynamic Programming来解，根<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4271456.html" id="cb_post_title_url">Palindrome Partitioning II 拆分回文串之二</a>的解法很类似，我们维护一个二维数组dp，其中dp[i][j]表示字符串区间[i, j]是否为回文串，当i = j时，只有一个字符，肯定是回文串，如果i = j + 1，说明是相邻字符，此时需要判断s[i]是否等于s[j]，如果i和j不相邻，即i - j &gt;= 2时，除了判断s[i]和s[j]相等之外，dp[j + 1][i - 1]若为真，就是回文串，通过以上分析，可以写出递推式如下：</p>
<p>dp[i, j] = 1                                               if i == j</p>
<p>           = s[i] == s[j]                                if j = i + 1</p>
<p>           = s[i] == s[j] &amp;&amp; dp[i + 1][j - 1]    if j &gt; i + 1      </p>
<p>这里有个有趣的现象就是如果我把下面的代码中的二维数组由int改为vector&lt;vector&lt;int&gt; &gt;后，就会超时，这说明int型的二维数组访问执行速度完爆std的vector啊，所以以后尽可能的还是用最原始的数据类型吧。</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> longestPalindrome(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        </span><span style="color: #0000ff;">if</span> (s.empty()) <span style="color: #0000ff;">return</span> <span style="color: #800000;">""</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> dp[s.size()][s.size()] = {<span style="color: #800080;">0</span>}, left = <span style="color: #800080;">0</span>, right = <span style="color: #800080;">0</span>, len = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; s.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; i; ++<span style="color: #000000;">j) {
                dp[j][i] </span>= (s[i] == s[j] &amp;&amp; (i - j &lt; <span style="color: #800080;">2</span> || dp[j + <span style="color: #800080;">1</span>][i - <span style="color: #800080;">1</span><span style="color: #000000;">]));
                </span><span style="color: #0000ff;">if</span> (dp[j][i] &amp;&amp; len &lt; i - j + <span style="color: #800080;">1</span><span style="color: #000000;">) {
                    len </span>= i - j + <span style="color: #800080;">1</span><span style="color: #000000;">;
                    left </span>=<span style="color: #000000;"> j;
                    right </span>=<span style="color: #000000;"> i;
                }
            }
            dp[i][i] </span>= <span style="color: #800080;">1</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> s.substr(left, right - left + <span style="color: #800080;">1</span><span style="color: #000000;">);
    }
};</span></pre>
</div>
<p> </p>
<p>最后要来的就是大名鼎鼎的马拉车算法Manacher's Algorithm，这个算法的神奇之处在于将时间复杂度提升到了O(n)这种逆天的地步，而算法本身也设计的很巧妙，很值得我们掌握，参见我另一篇专门介绍马拉车算法的博客<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4475985.html" id="cb_post_title_url">Manacher's Algorithm 马拉车算法</a>，代码实现如下：</p>
<p> </p>
<p>解法四：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> longestPalindrome(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        </span><span style="color: #0000ff;">string</span> t =<span style="color: #800000;">"</span><span style="color: #800000;">$#</span><span style="color: #800000;">"</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; s.size(); ++<span style="color: #000000;">i) {
            t </span>+=<span style="color: #000000;"> s[i];
            t </span>+= <span style="color: #800000;">'</span><span style="color: #800000;">#</span><span style="color: #800000;">'</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">int</span> p[t.size()] = {<span style="color: #800080;">0</span>}, id = <span style="color: #800080;">0</span>, mx = <span style="color: #800080;">0</span>, resId = <span style="color: #800080;">0</span>, resMx = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; t.size(); ++<span style="color: #000000;">i) {
            p[i] </span>= mx &gt; i ? min(p[<span style="color: #800080;">2</span> * id - i], mx - i) : <span style="color: #800080;">1</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">while</span> (t[i + p[i]] == t[i - p[i]]) ++<span style="color: #000000;">p[i];
            </span><span style="color: #0000ff;">if</span> (mx &lt; i +<span style="color: #000000;"> p[i]) {
                mx </span>= i +<span style="color: #000000;"> p[i];
                id </span>=<span style="color: #000000;"> i;
            }
            </span><span style="color: #0000ff;">if</span> (resMx &lt;<span style="color: #000000;"> p[i]) {
                resMx </span>=<span style="color: #000000;"> p[i];
                resId </span>=<span style="color: #000000;"> i;
            }
        }
        </span><span style="color: #0000ff;">return</span> s.substr((resId - resMx) / <span style="color: #800080;">2</span>, resMx - <span style="color: #800080;">1</span><span style="color: #000000;">);
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4523624.html" target="_blank">Shortest Palindrome</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/5223238.html" target="_blank">Palindrome Permutation</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/5272039.html" target="_blank">Palindrome Pairs</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/6493182.html">Longest Palindromic Subsequence</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/7404777.html">Palindromic Substrings</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-04-29 00:09</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4464476" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4464476);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4465932.html" id="cb_post_title_url">[LeetCode] Median of Two Sorted Arrays 两个有序数组的中位数</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>There are two sorted arrays nums1 and nums2 of size m and n respectively.</p>
<p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p>
<p>You may assume nums1 and nums2 cannot be both empty.</p>
<p>Example 1:</p>
<pre>nums1 = [1, 3]
nums2 = [2]

The median is 2.0
</pre>
<p>Example 2:</p>
<pre>nums1 = [1, 2]
nums2 = [3, 4]

The median is (2 + 3)/2 = 2.5</pre>
<p> </p>
<p>这道题让我们求两个有序数组的中位数，而且限制了时间复杂度为O(log (m+n))，看到这个时间复杂度，自然而然的想到了应该使用二分查找法来求解。但是这道题被定义为Hard也是有其原因的，难就难在要在两个未合并的有序数组之间使用二分法，如果这道题只有一个有序数组，让我们求中位数的话，估计就是个Easy题。那么我们可以将两个有序数组混合起来成为一个有序数组再做吗，图样图森破，这个时间复杂度限制的就是告诉你金坷垃别想啦。那么我们还是要用二分法，而且是在两个数组之间使用，感觉很高端啊。那么回顾一下中位数的定义，如果某个有序数组长度是奇数，那么其中位数就是最中间那个，如果是偶数，那么就是最中间两个数字的平均值。这里对于两个有序数组也是一样的，假设两个有序数组的长度分别为m和n，由于两个数组长度之和 m+n 的奇偶不确定，因此需要分情况来讨论，对于奇数的情况，直接找到最中间的数即可，偶数的话需要求最中间两个数的平均值。为了简化代码，不分情况讨论，我们使用一个小trick，我们分别找第 (m+n+1) / 2 个，和 (m+n+2) / 2 个，然后求其平均值即可，这对奇偶数均适用。加入 m+n 为奇数的话，那么其实 (m+n+1) / 2 和 (m+n+2) / 2 的值相等，相当于两个相同的数字相加再除以2，还是其本身。</p>
<p>好，这里我们需要定义一个函数来在两个有序数组中找到第K个元素，下面重点来看如何实现找到第K个元素。首先，为了避免产生新的数组从而增加时间复杂度，我们使用两个变量i和j分别来标记数组nums1和nums2的起始位置。然后来处理一些corner cases，比如当某一个数组的起始位置大于等于其数组长度时，说明其所有数字均已经被淘汰了，相当于一个空数组了，那么实际上就变成了在另一个数组中找数字，直接就可以找出来了。还有就是如果K=1的话，那么我们只要比较nums1和nums2的起始位置i和j上的数字就可以了。难点就在于一般的情况怎么处理？因为我们需要在两个有序数组中找到第K个元素，为了加快搜索的速度，我们要使用二分法，那么对谁二分呢，数组么？其实要对K二分，意思是我们需要分别在nums1和nums2中查找第K/2个元素，注意这里由于两个数组的长度不定，所以有可能某个数组没有第K/2个数字，所以我们需要先check一下，数组中到底存不存在第K/2个数字，如果存在就取出来，否则就赋值上一个整型最大值。如果某个数组没有第K/2个数字，那么我们就淘汰另一个数字的前K/2个数字即可。有没有可能两个数组都不存在第K/2个数字呢，这道题里是不可能的，因为我们的K不是任意给的，而是给的m+n的中间值，所以必定至少会有一个数组是存在第K/2个数字的。最后就是二分法的核心啦，比较这两个数组的第K/2小的数字midVal1和midVal2的大小，如果第一个数组的第K/2个数字小的话，那么说明我们要找的数字肯定不在nums1中的前K/2个数字，所以我们可以将其淘汰，将nums1的起始位置向后移动K/2个，并且此时的K也自减去K/2，调用递归。反之，我们淘汰nums2中的前K/2个数字，并将nums2的起始位置向后移动K/2个，并且此时的K也自减去K/2，调用递归即可，参见代码如下：</p>
<p> </p>
<p>C++ 解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">double</span> findMedianSortedArrays(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; nums1, vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums2) {
        </span><span style="color: #0000ff;">int</span> m = nums1.size(), n = nums2.size(), left = (m + n + <span style="color: #800080;">1</span>) / <span style="color: #800080;">2</span>, right = (m + n + <span style="color: #800080;">2</span>) / <span style="color: #800080;">2</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span> (findKth(nums1, <span style="color: #800080;">0</span>, nums2, <span style="color: #800080;">0</span>, left) + findKth(nums1, <span style="color: #800080;">0</span>, nums2, <span style="color: #800080;">0</span>, right)) / <span style="color: #800080;">2.0</span><span style="color: #000000;">;
    }
    </span><span style="color: #0000ff;">int</span> findKth(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; nums1, <span style="color: #0000ff;">int</span> i, vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; nums2, <span style="color: #0000ff;">int</span> j, <span style="color: #0000ff;">int</span><span style="color: #000000;"> k) {
        </span><span style="color: #0000ff;">if</span> (i &gt;= nums1.size()) <span style="color: #0000ff;">return</span> nums2[j + k - <span style="color: #800080;">1</span><span style="color: #000000;">];
        </span><span style="color: #0000ff;">if</span> (j &gt;= nums2.size()) <span style="color: #0000ff;">return</span> nums1[i + k - <span style="color: #800080;">1</span><span style="color: #000000;">];
        </span><span style="color: #0000ff;">if</span> (k == <span style="color: #800080;">1</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;"> min(nums1[i], nums2[j]);
        </span><span style="color: #0000ff;">int</span> midVal1 = (i + k / <span style="color: #800080;">2</span> - <span style="color: #800080;">1</span> &lt; nums1.size()) ? nums1[i + k / <span style="color: #800080;">2</span> - <span style="color: #800080;">1</span><span style="color: #000000;">] : INT_MAX;
        </span><span style="color: #0000ff;">int</span> midVal2 = (j + k / <span style="color: #800080;">2</span> - <span style="color: #800080;">1</span> &lt; nums2.size()) ? nums2[j + k / <span style="color: #800080;">2</span> - <span style="color: #800080;">1</span><span style="color: #000000;">] : INT_MAX;
        </span><span style="color: #0000ff;">if</span> (midVal1 &lt;<span style="color: #000000;"> midVal2) {
            </span><span style="color: #0000ff;">return</span> findKth(nums1, i + k / <span style="color: #800080;">2</span>, nums2, j, k - k / <span style="color: #800080;">2</span><span style="color: #000000;">);
        } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            </span><span style="color: #0000ff;">return</span> findKth(nums1, i, nums2, j + k / <span style="color: #800080;">2</span>, k - k / <span style="color: #800080;">2</span><span style="color: #000000;">);
        }
    }
};</span></pre>
</div>
<p> </p>
<p>Java 解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">double</span> findMedianSortedArrays(<span style="color: #0000ff;">int</span>[] nums1, <span style="color: #0000ff;">int</span><span style="color: #000000;">[] nums2) {
        </span><span style="color: #0000ff;">int</span> m = nums1.length, n = nums2.length, left = (m + n + <span style="color: #800080;">1</span>) / <span style="color: #800080;">2</span>, right = (m + n + <span style="color: #800080;">2</span>) / <span style="color: #800080;">2</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span> (findKth(nums1, <span style="color: #800080;">0</span>, nums2, <span style="color: #800080;">0</span>, left) + findKth(nums1, <span style="color: #800080;">0</span>, nums2, <span style="color: #800080;">0</span>, right)) / <span style="color: #800080;">2.0</span><span style="color: #000000;">;
    }
    </span><span style="color: #0000ff;">int</span> findKth(<span style="color: #0000ff;">int</span>[] nums1, <span style="color: #0000ff;">int</span> i, <span style="color: #0000ff;">int</span>[] nums2, <span style="color: #0000ff;">int</span> j, <span style="color: #0000ff;">int</span><span style="color: #000000;"> k) {
        </span><span style="color: #0000ff;">if</span> (i &gt;= nums1.length) <span style="color: #0000ff;">return</span> nums2[j + k - <span style="color: #800080;">1</span><span style="color: #000000;">];
        </span><span style="color: #0000ff;">if</span> (j &gt;= nums2.length) <span style="color: #0000ff;">return</span> nums1[i + k - <span style="color: #800080;">1</span><span style="color: #000000;">];
        </span><span style="color: #0000ff;">if</span> (k == <span style="color: #800080;">1</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;"> Math.min(nums1[i], nums2[j]);
        </span><span style="color: #0000ff;">int</span> midVal1 = (i + k / <span style="color: #800080;">2</span> - <span style="color: #800080;">1</span> &lt; nums1.length) ? nums1[i + k / <span style="color: #800080;">2</span> - <span style="color: #800080;">1</span><span style="color: #000000;">] : Integer.MAX_VALUE;
        </span><span style="color: #0000ff;">int</span> midVal2 = (j + k / <span style="color: #800080;">2</span> - <span style="color: #800080;">1</span> &lt; nums2.length) ? nums2[j + k / <span style="color: #800080;">2</span> - <span style="color: #800080;">1</span><span style="color: #000000;">] : Integer.MAX_VALUE;
        </span><span style="color: #0000ff;">if</span> (midVal1 &lt;<span style="color: #000000;"> midVal2) {
            </span><span style="color: #0000ff;">return</span> findKth(nums1, i + k / <span style="color: #800080;">2</span>, nums2, j, k - k / <span style="color: #800080;">2</span><span style="color: #000000;">);
        } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            </span><span style="color: #0000ff;">return</span> findKth(nums1, i, nums2, j + k / <span style="color: #800080;">2</span>, k - k / <span style="color: #800080;">2</span><span style="color: #000000;">);
        }
    }
}</span></pre>
</div>
<p> </p>
<p>上面的解法一直使用的是原数组，同时用了两个变量来分别标记当前的起始位置。我们也可以直接生成新的数组，这样就不要用起始位置变量了，不过拷贝数组的操作可能会增加时间复杂度，也许会超出限制，不过就算当个思路拓展也是极好的。首先我们要判断数组是否为空，为空的话，直接在另一个数组找第K个即可。还有一种情况是当K = 1时，表示我们要找第一个元素，只要比较两个数组的第一个元素，返回较小的那个即可。这里我们分别取出两个数组的第K/2个数字的位置坐标i和j，为了避免数组没有第K/2个数组的情况，我们每次都和数组长度做比较，取出较小值。这里跟上面的解法有些许不同，上面解法我们直接取出的是值，而这里我们取出的是位置坐标，但是思想都是很类似的。不同在于，上面解法中我们每次固定淘汰K/2个数字，而这里我们由于取出了合法的i和j，所以我们每次淘汰i或j个。评论区有网友提出，可以让 j = k-i，这样也是对的，可能还更好一些，收敛速度可能会更快一些，参见代码如下：</p>
<p> </p>
<p>C++ 解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">double</span> findMedianSortedArrays(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; nums1, vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums2) {
        </span><span style="color: #0000ff;">int</span> m = nums1.size(), n =<span style="color: #000000;"> nums2.size();
        </span><span style="color: #0000ff;">return</span> (findKth(nums1, nums2, (m + n + <span style="color: #800080;">1</span>) / <span style="color: #800080;">2</span>) + findKth(nums1, nums2, (m + n + <span style="color: #800080;">2</span>) / <span style="color: #800080;">2</span>)) / <span style="color: #800080;">2.0</span><span style="color: #000000;">;
    }
    </span><span style="color: #0000ff;">int</span> findKth(vector&lt;<span style="color: #0000ff;">int</span>&gt; nums1, vector&lt;<span style="color: #0000ff;">int</span>&gt; nums2, <span style="color: #0000ff;">int</span><span style="color: #000000;"> k) {
        </span><span style="color: #0000ff;">if</span> (nums1.empty()) <span style="color: #0000ff;">return</span> nums2[k - <span style="color: #800080;">1</span><span style="color: #000000;">];
        </span><span style="color: #0000ff;">if</span> (nums2.empty()) <span style="color: #0000ff;">return</span> nums1[k - <span style="color: #800080;">1</span><span style="color: #000000;">];
        </span><span style="color: #0000ff;">if</span> (k == <span style="color: #800080;">1</span>) <span style="color: #0000ff;">return</span> min(nums1[<span style="color: #800080;">0</span>], nums2[<span style="color: #800080;">0</span><span style="color: #000000;">]);
        </span><span style="color: #0000ff;">int</span> i = min((<span style="color: #0000ff;">int</span>)nums1.size(), k / <span style="color: #800080;">2</span>), j = min((<span style="color: #0000ff;">int</span>)nums2.size(), k / <span style="color: #800080;">2</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">if</span> (nums1[i - <span style="color: #800080;">1</span>] &gt; nums2[j - <span style="color: #800080;">1</span><span style="color: #000000;">]) {
            </span><span style="color: #0000ff;">return</span> findKth(nums1, vector&lt;<span style="color: #0000ff;">int</span>&gt;(nums2.begin() + j, nums2.end()), k -<span style="color: #000000;"> j);
        } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            </span><span style="color: #0000ff;">return</span> findKth(vector&lt;<span style="color: #0000ff;">int</span>&gt;(nums1.begin() + i, nums1.end()), nums2, k -<span style="color: #000000;"> i);
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>Java 解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">double</span> findMedianSortedArrays(<span style="color: #0000ff;">int</span>[] nums1, <span style="color: #0000ff;">int</span><span style="color: #000000;">[] nums2) {
        </span><span style="color: #0000ff;">int</span> m = nums1.length, n = nums2.length, left = (m + n + 1) / 2, right = (m + n + 2) / 2<span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span> (findKth(nums1, nums2, left) + findKth(nums1, nums2, right)) / 2.0<span style="color: #000000;">;
    }
    </span><span style="color: #0000ff;">int</span> findKth(<span style="color: #0000ff;">int</span>[] nums1, <span style="color: #0000ff;">int</span>[] nums2, <span style="color: #0000ff;">int</span><span style="color: #000000;"> k) {
        </span><span style="color: #0000ff;">int</span> m = nums1.length, n =<span style="color: #000000;"> nums2.length;
        </span><span style="color: #0000ff;">if</span> (m == 0) <span style="color: #0000ff;">return</span> nums2[k - 1<span style="color: #000000;">];
        </span><span style="color: #0000ff;">if</span> (n == 0) <span style="color: #0000ff;">return</span> nums1[k - 1<span style="color: #000000;">];
        </span><span style="color: #0000ff;">if</span> (k == 1) <span style="color: #0000ff;">return</span> Math.min(nums1[0], nums2[0<span style="color: #000000;">]);
        </span><span style="color: #0000ff;">int</span> i = Math.min(m, k / 2), j = Math.min(n, k / 2<span style="color: #000000;">);
        </span><span style="color: #0000ff;">if</span> (nums1[i - 1] &gt; nums2[j - 1<span style="color: #000000;">]) {
            </span><span style="color: #0000ff;">return</span> findKth(nums1, Arrays.copyOfRange(nums2, j, n), k -<span style="color: #000000;"> j);
        } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            </span><span style="color: #0000ff;">return</span> findKth(Arrays.copyOfRange(nums1, i, m), nums2, k -<span style="color: #000000;"> i);
        }
    }
}</span></pre>
</div>
<p> </p>
<p>此题还能用迭代形式的二分搜索法来解，是一种相当巧妙的应用，讲解在<a href="https://discuss.leetcode.com/topic/16797/very-concise-o-log-min-m-n-iterative-solution-with-detailed-explanation/2" target="_blank">这个帖子</a>中写的十分清楚，等有时间我再来写写分析过程：</p>
<p> </p>
<p>C++ 解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">double</span> findMedianSortedArrays(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; nums1, vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums2) {
        </span><span style="color: #0000ff;">int</span> m = nums1.size(), n =<span style="color: #000000;"> nums2.size();
        </span><span style="color: #0000ff;">if</span> (m &lt; n) <span style="color: #0000ff;">return</span><span style="color: #000000;"> findMedianSortedArrays(nums2, nums1);
        </span><span style="color: #0000ff;">if</span> (n == <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span> ((<span style="color: #0000ff;">double</span>)nums1[(m - <span style="color: #800080;">1</span>) / <span style="color: #800080;">2</span>] + (<span style="color: #0000ff;">double</span>)nums1[m / <span style="color: #800080;">2</span>]) / <span style="color: #800080;">2.0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> left = <span style="color: #800080;">0</span>, right = n * <span style="color: #800080;">2</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (left &lt;=<span style="color: #000000;"> right) {
            </span><span style="color: #0000ff;">int</span> mid2 = (left + right) / <span style="color: #800080;">2</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">int</span> mid1 = m + n -<span style="color: #000000;"> mid2;
            </span><span style="color: #0000ff;">double</span> L1 = mid1 == <span style="color: #800080;">0</span> ? INT_MIN : nums1[(mid1 - <span style="color: #800080;">1</span>) / <span style="color: #800080;">2</span><span style="color: #000000;">];
            </span><span style="color: #0000ff;">double</span> L2 = mid2 == <span style="color: #800080;">0</span> ? INT_MIN : nums2[(mid2 - <span style="color: #800080;">1</span>) / <span style="color: #800080;">2</span><span style="color: #000000;">];
            </span><span style="color: #0000ff;">double</span> R1 = mid1 == m * <span style="color: #800080;">2</span> ? INT_MAX : nums1[mid1 / <span style="color: #800080;">2</span><span style="color: #000000;">];
            </span><span style="color: #0000ff;">double</span> R2 = mid2 == n * <span style="color: #800080;">2</span> ? INT_MAX : nums2[mid2 / <span style="color: #800080;">2</span><span style="color: #000000;">];
            </span><span style="color: #0000ff;">if</span> (L1 &gt; R2) left = mid2 + <span style="color: #800080;">1</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (L2 &gt; R1) right = mid2 - <span style="color: #800080;">1</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">return</span> (max(L1, L2) + min(R1, R2)) / <span style="color: #800080;">2</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> -<span style="color: #800080;">1</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>Java 解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">double</span> findMedianSortedArrays(<span style="color: #0000ff;">int</span>[] nums1, <span style="color: #0000ff;">int</span><span style="color: #000000;">[] nums2) {
        </span><span style="color: #0000ff;">int</span> m = nums1.length, n =<span style="color: #000000;"> nums2.length;
        </span><span style="color: #0000ff;">if</span> (m &lt; n) <span style="color: #0000ff;">return</span><span style="color: #000000;"> findMedianSortedArrays(nums2, nums1);
        </span><span style="color: #0000ff;">if</span> (n == 0) <span style="color: #0000ff;">return</span> (nums1[(m - 1) / 2] + nums1[m / 2]) / 2.0<span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> left = 0, right = 2 *<span style="color: #000000;"> n;
        </span><span style="color: #0000ff;">while</span> (left &lt;=<span style="color: #000000;"> right) {
            </span><span style="color: #0000ff;">int</span> mid2 = (left + right) / 2<span style="color: #000000;">;
            </span><span style="color: #0000ff;">int</span> mid1 = m + n -<span style="color: #000000;"> mid2;
            </span><span style="color: #0000ff;">double</span> L1 = mid1 == 0 ? Double.MIN_VALUE : nums1[(mid1 - 1) / 2<span style="color: #000000;">];
            </span><span style="color: #0000ff;">double</span> L2 = mid2 == 0 ? Double.MIN_VALUE : nums2[(mid2 - 1) / 2<span style="color: #000000;">];
            </span><span style="color: #0000ff;">double</span> R1 = mid1 == m * 2 ? Double.MAX_VALUE : nums1[mid1 / 2<span style="color: #000000;">];
            </span><span style="color: #0000ff;">double</span> R2 = mid2 == n * 2 ? Double.MAX_VALUE : nums2[mid2 / 2<span style="color: #000000;">];
            </span><span style="color: #0000ff;">if</span> (L1 &gt; R2) left = mid2 + 1<span style="color: #000000;">;
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (L2 &gt; R1) right = mid2 - 1<span style="color: #000000;">;
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">return</span> (Math.max(L1, L2) + Math.min(R1, R2)) / 2<span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> -1<span style="color: #000000;">;
    }
}</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-04-29 14:37</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4465932" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4465932);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4480780.html" id="cb_post_title_url">[LeetCode] Longest Substring Without Repeating Characters 最长无重复字符的子串</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="question-description__2cX5">
<p>Given a string, find the length of the longest substring without repeating characters.</p>
<p>Examples:</p>
<p>Given <code>"abcabcbb"</code>, the answer is <code>"abc"</code>, which the length is 3.</p>
<p>Given <code>"bbbbb"</code>, the answer is <code>"b"</code>, with the length of 1.</p>
<p>Given <code>"pwwkew"</code>, the answer is <code>"wke"</code>, with the length of 3. Note that the answer must be a substring, <code>"pwke"</code> is a <em>subsequence</em>and not a substring.</p>
</div>
<p> </p>
<p>这道求最长无重复子串的题和之前那道 <a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4465779.html" id="cb_post_title_url">Isomorphic Strings</a> 很类似，属于LeetCode的早期经典题目，博主认为是可以跟<a href="http://www.cnblogs.com/grandyang/p/4130379.html" target="_blank">Two Sum</a>媲美的一道题。给了我们一个字符串，让我们求最长的无重复字符的子串，注意这里是子串，不是子序列，所以必须是连续的。我们先不考虑代码怎么实现，如果给一个例子中的例子"abcabcbb"，让你手动找无重复字符的子串，该怎么找。博主会一个字符一个字符的遍历，比如a，b，c，然后又出现了一个a，那么此时就应该去掉第一次出现的a，然后继续往后，又出现了一个b，则应该去掉一次出现的b，以此类推，最终发现最长的长度为3。所以说，我们需要记录之前出现过的字符，记录的方式有很多，最常见的是统计字符出现的个数，但是这道题字符出现的位置很重要，所以我们可以使用HashMap来建立字符和其出现位置之间的映射。进一步考虑，由于字符会重复出现，到底是保存所有出现的位置呢，还是只记录一个位置？我们之前手动推导的方法实际上是维护了一个滑动窗口，窗口内的都是没有重复的字符，我们需要尽可能的扩大窗口的大小。由于窗口在不停向右滑动，所以我们只关心每个字符最后出现的位置，并建立映射。窗口的右边界就是当前遍历到的字符的位置，为了求出窗口的大小，我们需要一个变量left来指向滑动窗口的左边界，这样，如果当前遍历到的字符从未出现过，那么直接扩大右边界，如果之前出现过，那么就分两种情况，在或不在滑动窗口内，如果不在滑动窗口内，那么就没事，当前字符可以加进来，如果在的话，就需要先在滑动窗口内去掉这个已经出现过的字符了，去掉的方法并不需要将左边界left一位一位向右遍历查找，由于我们的HashMap已经保存了该重复字符最后出现的位置，所以直接移动left指针就可以了。我们维护一个结果res，每次用出现过的窗口大小来更新结果res，就可以得到最终结果啦。</p>
<p>这里我们可以建立一个256位大小的整型数组来代替HashMap，这样做的原因是ASCII表共能表示256个字符，所以可以记录所有字符，然后我们需要定义两个变量res和left，其中res用来记录最长无重复子串的长度，left指向该无重复子串左边的起始位置，然后我们遍历整个字符串，对于每一个遍历到的字符，如果哈希表中该字符串对应的值为0，说明没有遇到过该字符，则此时计算最长无重复子串，i - left +１，其中ｉ是最长无重复子串最右边的位置，left是最左边的位置，还有一种情况也需要计算最长无重复子串，就是当哈希表中的值小于left，这是由于此时出现过重复的字符，left的位置更新了，如果又遇到了新的字符，就要重新计算最长无重复子串。最后每次都要在哈希表中将当前字符对应的值赋值为i+1。代码如下：</p>
<p> </p>
<p>C++ 解法一： </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> lengthOfLongestSubstring(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        </span><span style="color: #0000ff;">int</span> m[<span style="color: #800080;">256</span>] = {<span style="color: #800080;">0</span>}, res = <span style="color: #800080;">0</span>, left = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; s.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (m[s[i]] == <span style="color: #800080;">0</span> || m[s[i]] &lt;<span style="color: #000000;"> left) {
                res </span>= max(res, i - left + <span style="color: #800080;">1</span><span style="color: #000000;">);
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                left </span>=<span style="color: #000000;"> m[s[i]];
            }
            m[s[i]] </span>= i + <span style="color: #800080;">1</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>这里解释下程序中那个if条件语句中为啥要有个m[s[i]] &lt; left，我们用一个例子来说明，当输入字符串为"abbca"的时候，当i=4时，也就是即将要开始遍历最后一个字母a时，此时哈希表表中a对应1，b对应3，c对应4，left为2，即当前最长的子字符串的左边界为第二个b的位置，而第一个a已经不在当前最长的字符串的范围内了，那么对于i=4这个新进来的a，应该要加入结果中，而此时未被更新的哈希表中a为1，不是0，如果不判断它和left的关系的话，就无法更新结果，那么答案就会少一位，所以需要加m[s[i]] &lt; left。</p>
<p>下面这种写法是上面解法的精简模式，思路都一样：</p>
<p> </p>
<p>C++ 解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> lengthOfLongestSubstring(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; m(<span style="color: #800080;">256</span>, -<span style="color: #800080;">1</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, left = -<span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; s.size(); ++<span style="color: #000000;">i) {
            left </span>=<span style="color: #000000;"> max(left, m[s[i]]);
            m[s[i]] </span>=<span style="color: #000000;"> i;
            res </span>= max(res, i -<span style="color: #000000;"> left);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>Java 解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> lengthOfLongestSubstring(String s) {
        </span><span style="color: #0000ff;">int</span>[] m = <span style="color: #0000ff;">new</span> <span style="color: #0000ff;">int</span>[256<span style="color: #000000;">];
        Arrays.fill(m, </span>-1<span style="color: #000000;">);
        </span><span style="color: #0000ff;">int</span> res = 0, left = -1<span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = 0; i &lt; s.length(); ++<span style="color: #000000;">i) {
            left </span>=<span style="color: #000000;"> Math.max(left, m[s.charAt(i)]);
            m[s.charAt(i)] </span>=<span style="color: #000000;"> i;
            res </span>= Math.max(res, i -<span style="color: #000000;"> left);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
}</span></pre>
</div>
<p> </p>
<p>下面这种解法使用了set，核心算法和上面的很类似，把出现过的字符都放入set中，遇到set中没有的字符就加入set中并更新结果res，如果遇到重复的，则从左边开始删字符，直到删到重复的字符停止：</p>
<p> </p>
<p>C++ 解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> lengthOfLongestSubstring(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, left = <span style="color: #800080;">0</span>, i = <span style="color: #800080;">0</span>, n =<span style="color: #000000;"> s.size();
        unordered_set</span>&lt;<span style="color: #0000ff;">char</span>&gt;<span style="color: #000000;"> t;
        </span><span style="color: #0000ff;">while</span> (i &lt;<span style="color: #000000;"> n) {
            </span><span style="color: #0000ff;">if</span> (!<span style="color: #000000;">t.count(s[i])) {
                t.insert(s[i</span>++<span style="color: #000000;">]);
                res </span>= max(res, (<span style="color: #0000ff;">int</span><span style="color: #000000;">)t.size());
            }  </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                t.erase(s[left</span>++<span style="color: #000000;">]);
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>Java 解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> lengthOfLongestSubstring(String s) {
        </span><span style="color: #0000ff;">int</span> res = 0, left = 0, right = 0<span style="color: #000000;">;
        HashSet</span>&lt;Character&gt; t = <span style="color: #0000ff;">new</span> HashSet&lt;Character&gt;<span style="color: #000000;">();
        </span><span style="color: #0000ff;">while</span> (right &lt;<span style="color: #000000;"> s.length()) {
            </span><span style="color: #0000ff;">if</span> (!<span style="color: #000000;">t.contains(s.charAt(right))) {
                t.add(s.charAt(right</span>++<span style="color: #000000;">));
                res </span>=<span style="color: #000000;"> Math.max(res, t.size());
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                t.remove(s.charAt(left</span>++<span style="color: #000000;">));
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
}</span></pre>
</div>
<p> </p>
<p>下面这种解法思路上跟解法一和解法二没有区别，是不过使用了HashMap这个数据结构来建立字符和其最后出现位置之间的映射，其他操作均和解法二相同。</p>
<p> </p>
<p>C++ 解法四：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> lengthOfLongestSubstring(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, left = <span style="color: #800080;">0</span>, i = <span style="color: #800080;">0</span>, n =<span style="color: #000000;"> s.size();
        unordered_map</span>&lt;<span style="color: #0000ff;">char</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> m;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            left </span>=<span style="color: #000000;"> max(left, m[s[i]]);
            m[s[i]] </span>= i + <span style="color: #800080;">1</span><span style="color: #000000;">;
            res </span>= max(res, i - left + <span style="color: #800080;">1</span><span style="color: #000000;">);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/5185561.html" target="_blank">Longest Substring with At Most Two Distinct Characters</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-05-06 01:05</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4480780" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4480780);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4129891.html" id="cb_post_title_url">[LeetCode] Add Two Numbers 两个数字相加</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>You are given two linked lists representing two non-negative numbers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>
<p>Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br/>Output: 7 -&gt; 0 -&gt; 8</p>
<p> </p>
<p>这道并不是什么难题，算法很简单，链表的数据类型也不难。就是建立一个新链表，然后把输入的两个链表从头往后撸，每两个相加，添加一个新节点到新链表后面，就是要处理下进位问题。还有就是最高位的进位问题要最后特殊处理一下。代码如下：</p>
<p> </p>
<p>C++ 解法： </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    ListNode </span>*addTwoNumbers(ListNode *l1, ListNode *<span style="color: #000000;">l2) {
        ListNode </span>*res = <span style="color: #0000ff;">new</span> ListNode(-<span style="color: #800080;">1</span><span style="color: #000000;">);
        ListNode </span>*cur =<span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">int</span> carry = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (l1 ||<span style="color: #000000;"> l2) {
            </span><span style="color: #0000ff;">int</span> n1 = l1 ? l1-&gt;val : <span style="color: #800080;">0</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">int</span> n2 = l2 ? l2-&gt;val : <span style="color: #800080;">0</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">int</span> sum = n1 + n2 +<span style="color: #000000;"> carry;
            carry </span>= sum / <span style="color: #800080;">10</span><span style="color: #000000;">;
            cur</span>-&gt;next = <span style="color: #0000ff;">new</span> ListNode(sum % <span style="color: #800080;">10</span><span style="color: #000000;">);
            cur </span>= cur-&gt;<span style="color: #000000;">next;
            </span><span style="color: #0000ff;">if</span> (l1) l1 = l1-&gt;<span style="color: #000000;">next;
            </span><span style="color: #0000ff;">if</span> (l2) l2 = l2-&gt;<span style="color: #000000;">next;
        }
        </span><span style="color: #0000ff;">if</span> (carry) cur-&gt;next = <span style="color: #0000ff;">new</span> ListNode(<span style="color: #800080;">1</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">return</span> res-&gt;<span style="color: #000000;">next;
    }
};</span></pre>
</div>
<p> </p>
<p>Java 解法：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode dummy </span>= <span style="color: #0000ff;">new</span> ListNode(-1<span style="color: #000000;">);
        ListNode cur </span>=<span style="color: #000000;"> dummy;
        </span><span style="color: #0000ff;">int</span> carry = 0<span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (l1 != <span style="color: #0000ff;">null</span> || l2 != <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">int</span> d1 = l1 == <span style="color: #0000ff;">null</span> ? 0<span style="color: #000000;"> : l1.val;
            </span><span style="color: #0000ff;">int</span> d2 = l2 == <span style="color: #0000ff;">null</span> ? 0<span style="color: #000000;"> : l2.val;
            </span><span style="color: #0000ff;">int</span> sum = d1 + d2 +<span style="color: #000000;"> carry;
            carry </span>= sum &gt;= 10 ? 1 : 0<span style="color: #000000;">;
            cur.next </span>= <span style="color: #0000ff;">new</span> ListNode(sum % 10<span style="color: #000000;">);
            cur </span>=<span style="color: #000000;"> cur.next;
            </span><span style="color: #0000ff;">if</span> (l1 != <span style="color: #0000ff;">null</span>) l1 =<span style="color: #000000;"> l1.next;
            </span><span style="color: #0000ff;">if</span> (l2 != <span style="color: #0000ff;">null</span>) l2 =<span style="color: #000000;"> l2.next;
        }
        </span><span style="color: #0000ff;">if</span> (carry == 1) cur.next = <span style="color: #0000ff;">new</span> ListNode(1<span style="color: #000000;">);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> dummy.next;
    }
}</span></pre>
</div>
<p><span style="line-height: 1.5;"> </span></p>
<p>在CareerCup上的这道题还有个Follow Up，把链表存的数字方向变了，原来是表头存最低位，现在是表头存最高位，请参见我的另一篇博客<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4662599.html" id="cb_post_title_url">2.5 Add Two Numbers 两个数字相加</a> 。</p>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4395356.html" target="_blank">Multiply Strings</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4084971.html" target="_blank">Add Binary</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2014-11-29 05:57</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4129891" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4129891);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4130379.html" id="cb_post_title_url">[LeetCode] Two Sum 两数之和</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.</p>
<p>You may assume that each input would have <em>exactly</em> one solution, and you may not use the <em>same</em> element twice.</p>
<p>Example:</p>
<pre>Given nums = [2, 7, 11, 15], target = 9,

Because nums[0] + nums[1] = 2 + 7 = 9,
return [0, 1].</pre>
<p> </p>
<p>啦啦啦，欢迎开启LeetCode刷题的旅程，这将是一段漫长而又艰辛的旅程，这是一条攀登珠穆朗玛的皑皑雪山路，这是通向One Piece宝藏的伟大航路，这是无比残酷的修罗场。但请不要害怕，在老船长Grandyang博主的带领下，必将一路披荆斩棘，将各位带到成功的彼岸，不过一定要牢记的是，不要下船，不要中途放弃，要坚持，要自我修炼，不断成长！那么，起航吧～这道Two Sum的题目作为LeetCode的开篇之题，乃是经典中的经典，正所谓‘<strong>平生不识TwoSum，刷尽LeetCode也枉然</strong>’，就像英语单词书的第一个单词总是Abandon一样，很多没有毅力坚持的人就只能记住这一个单词，所以通常情况下单词书就前几页有翻动的痕迹，后面都是崭新如初，道理不需多讲，鸡汤不必多灌，明白的人自然明白。</p>
<p>这道题给了我们一个数组，还有一个目标数target，让我们找到两个数字，使其和为target，乍一看就感觉可以用暴力搜索，但是猜到OJ肯定不会允许用暴力搜索这么简单的方法，于是去试了一下，果然是Time Limit Exceeded，这个算法的时间复杂度是O(n^2)。那么只能想个O(n)的算法来实现，由于暴力搜索的方法是遍历所有的两个数字的组合，然后算其和，这样虽然节省了空间，但是时间复杂度高。一般来说，我们为了提高时间的复杂度，需要用空间来换，这算是一个trade off吧，我们只想用线性的时间复杂度来解决问题，那么就是说只能遍历一个数字，那么另一个数字呢，我们可以事先将其存储起来，使用一个HashMap，来建立数字和其坐标位置之间的映射，我们都知道HashMap是常数级的查找效率，这样，我们在遍历数组的时候，用target减去遍历到的数字，就是另一个需要的数字了，直接在HashMap中查找其是否存在即可，注意要判断查找到的数字不是第一个数字，比如target是4，遍历到了一个2，那么另外一个2不能是之前那个2，整个实现步骤为：先遍历一遍数组，建立HashMap映射，然后再遍历一遍，开始查找，找到则记录index。代码如下：</p>
<p> </p>
<p>C++ 解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; twoSum(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; nums, <span style="color: #0000ff;">int</span><span style="color: #000000;"> target) {
        unordered_map</span>&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> m;
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; nums.size(); ++<span style="color: #000000;">i) {
            m[nums[i]] </span>=<span style="color: #000000;"> i;
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; nums.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">int</span> t = target -<span style="color: #000000;"> nums[i];
            </span><span style="color: #0000ff;">if</span> (m.count(t) &amp;&amp; m[t] !=<span style="color: #000000;"> i) {
                res.push_back(i);
                res.push_back(m[t]);
                </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p>  </p>
<p>Java 解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span>[] twoSum(<span style="color: #0000ff;">int</span>[] nums, <span style="color: #0000ff;">int</span><span style="color: #000000;"> target) {
        HashMap</span>&lt;Integer, Integer&gt; m = <span style="color: #0000ff;">new</span> HashMap&lt;Integer, Integer&gt;<span style="color: #000000;">();
        </span><span style="color: #0000ff;">int</span>[] res = <span style="color: #0000ff;">new</span> <span style="color: #0000ff;">int</span>[2<span style="color: #000000;">];
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = 0; i &lt; nums.length; ++<span style="color: #000000;">i) {
            m.put(nums[i], i);
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = 0; i &lt; nums.length; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">int</span> t = target -<span style="color: #000000;"> nums[i];
            </span><span style="color: #0000ff;">if</span> (m.containsKey(t) &amp;&amp; m.get(t) !=<span style="color: #000000;"> i) {
                res[</span>0] =<span style="color: #000000;"> i;
                res[</span>1] =<span style="color: #000000;"> m.get(t);
                </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
} </span></pre>
</div>
<p> </p>
<p>或者我们可以写的更加简洁一些，把两个for循环合并成一个：</p>
<p> </p>
<p>C++ 解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; twoSum(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; nums, <span style="color: #0000ff;">int</span><span style="color: #000000;"> target) {
        unordered_map</span>&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> m;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; nums.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (m.count(target -<span style="color: #000000;"> nums[i])) {
                </span><span style="color: #0000ff;">return</span> {i, m[target -<span style="color: #000000;"> nums[i]]};
            }
            m[nums[i]] </span>=<span style="color: #000000;"> i;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> {};
    }
};</span></pre>
</div>
<p> </p>
<p>Java 解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span>[] twoSum(<span style="color: #0000ff;">int</span>[] nums, <span style="color: #0000ff;">int</span><span style="color: #000000;"> target) {
        HashMap</span>&lt;Integer, Integer&gt; m = <span style="color: #0000ff;">new</span> HashMap&lt;Integer, Integer&gt;<span style="color: #000000;">();
        </span><span style="color: #0000ff;">int</span>[] res = <span style="color: #0000ff;">new</span> <span style="color: #0000ff;">int</span>[2<span style="color: #000000;">];
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = 0; i &lt; nums.length; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (m.containsKey(target -<span style="color: #000000;"> nums[i])) {
                res[</span>0] =<span style="color: #000000;"> i;
                res[</span>1] = m.get(target -<span style="color: #000000;"> nums[i]);
                </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
            }
            m.put(nums[i], i);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
}</span></pre>
</div>
<p><span style="line-height: 1.5;"> </span></p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4515925.html" target="_blank">4Sum</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/5235086.html" target="_blank">3Sum Smaller</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4510984.html" target="_blank">3Sum Closest</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4481576.html" target="_blank">3Sum</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/5184143.html" target="_blank">Two Sum III - Data structure design</a> </p>
<p><a href="http://www.cnblogs.com/grandyang/p/5185815.html" target="_blank">Two Sum II - Input array is sorted</a> </p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2014-11-29 10:43</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4130379" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4130379);return false;">收藏</a></div>
</div>
</html>