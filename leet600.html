<html lang="zh-cn">
<head>
<meta charset="utf-8"/>
<div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5177285.html" id="cb_post_title_url">[LeetCode] Wiggle Sort 摆动排序</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given an unsorted array nums, reorder it in-place such that nums[0] &lt;= nums[1] &gt;= nums[2] &lt;= nums[3]....</p>
<p>For example, given nums = [3, 5, 2, 1, 6, 4], one possible answer is [1, 6, 2, 5, 3, 4].</p>
<p> </p>
<p>这道题让我们求摆动排序，跟<a href="http://www.cnblogs.com/grandyang/p/5139057.html">Wiggle Sort II</a>相比起来，这道题的条件宽松很多，只因为多了一个等号。由于等号的存在，当数组中有重复数字存在的情况时，也很容易满足题目的要求。这道题我们先来看一种时间复杂度为O(nlgn)的方法，思路是先给数组排个序，然后我们只要每次把第三个数和第二个数调换个位置，第五个数和第四个数调换个位置，以此类推直至数组末尾，这样我们就能完成摆动排序了，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> Time Complexity O(nlgn)</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">void</span> wiggleSort(vector&lt;<span style="color: #0000ff;">int</span>&gt; &amp;<span style="color: #000000;">nums) {
        sort(nums.begin(), nums.end());
        </span><span style="color: #0000ff;">if</span> (nums.size() &lt;= <span style="color: #800080;">2</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">2</span>; i &lt; nums.size(); i += <span style="color: #800080;">2</span><span style="color: #000000;">) {
            swap(nums[i], nums[i </span>- <span style="color: #800080;">1</span><span style="color: #000000;">]);
        }
    }
};</span></pre>
</div>
<p> </p>
<p>这道题还有一种O(n)的解法，根据题目要求的nums[0] &lt;= nums[1] &gt;= nums[2] &lt;= nums[3]....，我们可以总结出如下规律：</p>
<p>当i为奇数时，nums[i] &gt;= nums[i - 1]</p>
<p>当i为偶数时，nums[i] &lt;= nums[i - 1]</p>
<p>那么我们只要对每个数字，根据其奇偶性，跟其对应的条件比较，如果不符合就和前面的数交换位置即可，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> Time Complexity O(n)</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">void</span> wiggleSort(vector&lt;<span style="color: #0000ff;">int</span>&gt; &amp;<span style="color: #000000;">nums) {
        </span><span style="color: #0000ff;">if</span> (nums.size() &lt;= <span style="color: #800080;">1</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt; nums.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> ((i % <span style="color: #800080;">2</span> == <span style="color: #800080;">1</span> &amp;&amp; nums[i] &lt; nums[i - <span style="color: #800080;">1</span>]) || (i % <span style="color: #800080;">2</span> == <span style="color: #800080;">0</span> &amp;&amp; nums[i] &gt; nums[i - <span style="color: #800080;">1</span><span style="color: #000000;">])) {
                swap(nums[i], nums[i </span>- <span style="color: #800080;">1</span><span style="color: #000000;">]);
            }
        }
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/5139057.html">Wiggle Sort II</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://segmentfault.com/a/1190000003783283" target="_blank">https://segmentfault.com/a/1190000003783283</a></p>
<p><a href="http://www.cnblogs.com/jcliBlogger/p/4797531.html" target="_blank">http://www.cnblogs.com/jcliBlogger/p/4797531.html</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p>
<p> </p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-02-02 13:22</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5177285" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5177285);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4800552.html" id="cb_post_title_url">[LeetCode] Perfect Squares 完全平方数</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a positive integer <em>n</em>, find the least number of perfect square numbers (for example, <code>1, 4, 9, 16, ...</code>) which sum to <em>n</em>.</p>
<p>For example, given <em>n</em> = <code>12</code>, return <code>3</code> because <code>12 = 4 + 4 + 4</code>; given <em>n</em> = <code>13</code>, return <code>2</code> because <code>13 = 4 + 9</code>.</p>
<p><strong>Credits:</strong><br/>Special thanks to <a href="https://leetcode.com/discuss/user/jianchao.li.fighter">@jianchao.li.fighter</a> for adding this problem and creating all test cases.</p>
<p> </p>
<p>又是超哥一个人辛苦的更新题目，一个人托起LeetCode免费题的一片天空啊，赞一个~ 这道题说是给我们一个正整数，求它最少能由几个完全平方数组成。这道题是考察<a href="https://zh.wikipedia.org/wiki/%E5%9B%9B%E5%B9%B3%E6%96%B9%E5%92%8C%E5%AE%9A%E7%90%86" target="_blank">四平方和定理</a>，to be honest, 这是我第一次听说这个定理，天啦撸，我的数学是语文老师教的么?! 闲话不多扯，回来做题。先来看第一种很高效的方法，根据四平方和定理，任意一个正整数均可表示为4个整数的平方和，其实是可以表示为4个以内的平方数之和，那么就是说返回结果只有1,2,3或4其中的一个，首先我们将数字化简一下，由于一个数如果含有因子4，那么我们可以把4都去掉，并不影响结果，比如2和8,3和12等等，返回的结果都相同，读者可自行举更多的栗子。还有一个可以化简的地方就是，如果一个数除以8余7的话，那么肯定是由4个完全平方数组成，这里就不证明了，因为我也不会证明，读者可自行举例验证。那么做完两步后，一个很大的数有可能就会变得很小了，大大减少了运算时间，下面我们就来尝试的将其拆为两个平方数之和，如果拆成功了那么就会返回1或2，因为其中一个平方数可能为0. (注：由于输入的n是正整数，所以不存在两个平方数均为0的情况)。注意下面的<span style="color: #ff0000;">!!a + !!b</span>这个表达式，可能很多人不太理解这个的意思，其实很简单，感叹号<span style="color: #ff0000;">!</span>表示逻辑取反，那么一个正整数逻辑取反为0，再取反为1，所以用两个感叹号<span style="color: #ff0000;">!!</span>的作用就是看a和b是否为正整数，都为正整数的话返回2，只有一个是正整数的话返回1，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> numSquares(<span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        </span><span style="color: #0000ff;">while</span> (n % <span style="color: #800080;">4</span> == <span style="color: #800080;">0</span>) n /= <span style="color: #800080;">4</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (n % <span style="color: #800080;">8</span> == <span style="color: #800080;">7</span>) <span style="color: #0000ff;">return</span> <span style="color: #800080;">4</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> a = <span style="color: #800080;">0</span>; a * a &lt;= n; ++<span style="color: #000000;">a) {
            </span><span style="color: #0000ff;">int</span> b = sqrt(n - a *<span style="color: #000000;"> a);
            </span><span style="color: #0000ff;">if</span> (a * a + b * b ==<span style="color: #000000;"> n) {
                </span><span style="color: #0000ff;">return</span> !!a + !!<span style="color: #000000;">b;
            }
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">3</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>这道题远不止这一种解法，我们还可以用动态规划Dynamic Programming来做，我们建立一个长度为n+1的一维dp数组，将第一个值初始化为0，其余值都初始化为INT_MAX, i从0循环到n，j从1循环到i+j*j &lt;= n的位置，然后每次更新dp[i+j*j]的值，动态更新dp数组，其中dp[i]表示正整数i能少能由多个完全平方数组成，那么我们求n，就是返回dp[n]即可，也就是dp数组的最后一个数字，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> DP</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> numSquares(<span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; dp(n + <span style="color: #800080;">1</span><span style="color: #000000;">, INT_MAX);
        dp[</span><span style="color: #800080;">0</span>] = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt;= n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">1</span>; i + j * j &lt;= n; ++<span style="color: #000000;">j) {
                dp[i </span>+ j * j] = min(dp[i + j * j], dp[i] + <span style="color: #800080;">1</span><span style="color: #000000;">);
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> dp.back();
    }
};</span></pre>
</div>
<p> </p>
<p>下面再来看一种DP解法，这种解法跟上面有些不同，上面那种解法是初始化了整个长度为n+1的dp数字，但是初始化的顺序不定的，而这个种方法只初始化了第一个值为0，那么在循环里计算，每次增加一个dp数组的长度，里面那个for循环一次循环结束就算好下一个数由几个完全平方数组成，直到增加到第n+1个，返回即可，想更直观的看这两种DP方法的区别，建议每次循环后都打印出dp数字的值来观察其更新的顺序，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> DP</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> numSquares(<span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; dp(<span style="color: #800080;">1</span>, <span style="color: #800080;">0</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">while</span> (dp.size() &lt;=<span style="color: #000000;"> n) {
            </span><span style="color: #0000ff;">int</span> m = dp.size(), val =<span style="color: #000000;"> INT_MAX;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i * i &lt;= m; ++<span style="color: #000000;">i) {
                val </span>= min(val, dp[m - i * i] + <span style="color: #800080;">1</span><span style="color: #000000;">);
            }
            dp.push_back(val);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> dp.back();
    }
};</span></pre>
</div>
<p> </p>
<p>最后我们来介绍一种递归Recursion的解法，这种方法的好处是写法简洁，但是运算效率不敢恭维。我们的目的是遍历所有比n小的完全平方数，然后对n与完全平方数的差值递归调用函数，目的是不断更新最终结果，知道找到最小的那个，参见代码如下：</p>
<p> </p>
<p>解法四：</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> Recrusion</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> numSquares(<span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        </span><span style="color: #0000ff;">int</span> res = n, num = <span style="color: #800080;">2</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (num * num &lt;=<span style="color: #000000;"> n) {
            </span><span style="color: #0000ff;">int</span> a = n / (num * num), b = n % (num *<span style="color: #000000;"> num);
            res </span>= min(res, a +<span style="color: #000000;"> numSquares(b));
            </span>++<span style="color: #000000;">num;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>PS：解法二三四的运算效率真的不高，强推解法一，高效又易懂，如果想强行优化后三个算法，可以将解法一的前两个if判断加到后三个的算法的开头，能很大的提高运算效率。</p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://leetcode.com/discuss/56983/simple-java-dp-solution" target="_blank">https://leetcode.com/discuss/56983/simple-java-dp-solution</a><br/><a href="https://leetcode.com/discuss/56993/static-dp-c-12-ms-python-172-ms-ruby-384-ms" target="_blank">https://leetcode.com/discuss/56993/static-dp-c-12-ms-python-172-ms-ruby-384-ms</a><br/><a href="https://leetcode.com/discuss/57089/my-recursive-solution-java" target="_blank">https://leetcode.com/discuss/57089/my-recursive-solution-java</a><br/><a href="http://bookshadow.com/weblog/2015/09/09/leetcode-perfect-squares/" target="_blank">http://bookshadow.com/weblog/2015/09/09/leetcode-perfect-squares/</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-09-11 12:06</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4800552" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4800552);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4790469.html" id="cb_post_title_url">[LeetCode] First Bad Version 第一个坏版本</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.</p>
<p>Suppose you have <code>n</code> versions <code>[1, 2, ..., n]</code> and you want to find out the first bad one, which causes all the following ones to be bad.</p>
<p>You are given an API <code>bool isBadVersion(version)</code> which will return whether <code>version</code> is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.</p>
<p>Credits:<br/>Special thanks to <a href="https://leetcode.com/discuss/user/jianchao.li.fighter">@jianchao.li.fighter</a> for adding this problem and creating all test cases.</p>
<p> </p>
<p>话说这个叫李建超的哥们太赞了，自从LeetCode开始收费后，大多数的免费题都是这哥们出的，还写了所有的test cases，32个赞。这道题说是有一系列版本，其中有一个版本是坏的，而且后面跟着的全是坏的，给了一个API函数可以用来判定当前版本是否是坏的，让我们尽可能少的调用这个API，找出第一个坏版本。那么这种搜索题最先开始考虑用二分查找法把，效率高嘛。由于这题很有规律，好版本和坏版本一定有个边界，那么我们用二分法来找这个边界，对mid值调用API函数，如果是坏版本，说明边界在左边，则把mid赋值给right，如果是好版本，则说明边界在右边，则把mid+1赋给left，最后返回left即可。需要注意的是，OJ里有个坑，那就是如果left和right都特别大的话，那么left+right可能会溢出，我们的处理方法就是变成left + (right - left) / 2，很好的避免的溢出问题，参见代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> Forward declaration of isBadVersion API.</span>
<span style="color: #0000ff;">bool</span> isBadVersion(<span style="color: #0000ff;">int</span><span style="color: #000000;"> version);

</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> firstBadVersion(<span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        </span><span style="color: #0000ff;">int</span> left = <span style="color: #800080;">1</span>, right =<span style="color: #000000;"> n;
        </span><span style="color: #0000ff;">while</span> (left &lt;<span style="color: #000000;"> right) {
            </span><span style="color: #0000ff;">int</span> mid = left + (right - left) / <span style="color: #800080;">2</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> (isBadVersion(mid)) right =<span style="color: #000000;"> mid;
            </span><span style="color: #0000ff;">else</span> left = mid + <span style="color: #800080;">1</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> left;
    }
};</span></pre>
</div>
<p> </p>
<p>如果习惯了二分搜索法从0开始找，可以用下面的方法：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> Forward declaration of isBadVersion API.</span>
<span style="color: #0000ff;">bool</span> isBadVersion(<span style="color: #0000ff;">int</span><span style="color: #000000;"> version);

</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> firstBadVersion(<span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        </span><span style="color: #0000ff;">int</span> left = <span style="color: #800080;">0</span>, right = n - <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (left &lt;<span style="color: #000000;"> right) {
            </span><span style="color: #0000ff;">int</span> mid = left + (right - left) / <span style="color: #800080;">2</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> (isBadVersion(mid + <span style="color: #800080;">1</span>)) right =<span style="color: #000000;"> mid;
            </span><span style="color: #0000ff;">else</span> left = mid + <span style="color: #800080;">1</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> right + <span style="color: #800080;">1</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-09-08 02:30</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4790469" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4790469);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5310649.html" id="cb_post_title_url">[LeetCode] Find the Celebrity 寻找名人</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Suppose you are at a party with <code>n</code> people (labeled from <code>0</code> to <code>n - 1</code>) and among them, there may exist one celebrity. The definition of a celebrity is that all the other <code>n - 1</code>people know him/her but he/she does not know any of them.</p>
<p>Now you want to find out who the celebrity is or verify that there is not one. The only thing you are allowed to do is to ask questions like: "Hi, A. Do you know B?" to get information of whether A knows B. You need to find out the celebrity (or verify there is not one) by asking as few questions as possible (in the asymptotic sense).</p>
<p>You are given a helper function <code>bool knows(a, b)</code> which tells you whether A knows B. Implement a function <code>int findCelebrity(n)</code>, your function should minimize the number of calls to <code>knows</code>.</p>
<p>Note: There will be exactly one celebrity if he/she is in the party. Return the celebrity's label if there is a celebrity in the party. If there is no celebrity, return <code>-1</code>.</p>
<p> </p>
<p>这道题让我们在一群人中寻找名人，所谓名人就是每个人都认识他，他却不认识任何人，限定了只有1个或0个名人，给定了一个API函数，输入a和b，用来判断a是否认识b，让我们尽可能少的调用这个函数，来找出人群中的名人。我最先想的方法是建立个一维数组用来标记每个人的名人候选状态，开始均初始化为true，表示每个人都是名人候选人，然后我们一个人一个人的验证其是否为名人，对于候选者i，我们遍历所有其他人j，如果i认识j，或者j不认识i，说明i不可能是名人，那么我们标记其为false，然后验证下一个候选者，反之如果i不认识j，或者j认识i，说明j不可能是名人，标记之。对于每个候选者i，如果遍历了一圈而其候选者状态仍为true，说明i就是名人，返回即可，如果遍历完所有人没有找到名人，返回-1，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> findCelebrity(<span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        vector</span>&lt;<span style="color: #0000ff;">bool</span>&gt; candidate(n, <span style="color: #0000ff;">true</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; n; ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> (candidate[i] &amp;&amp; i !=<span style="color: #000000;"> j) {
                    </span><span style="color: #0000ff;">if</span> (knows(i, j) || !<span style="color: #000000;">knows(j, i)) {
                        candidate[i] </span>= <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                        </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                        candidate[j] </span>= <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                    }
                }
            }
            </span><span style="color: #0000ff;">if</span> (candidate[i]) <span style="color: #0000ff;">return</span><span style="color: #000000;"> i;
        }
        </span><span style="color: #0000ff;">return</span> -<span style="color: #800080;">1</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>我们其实可以不用一维数组来标记每个人的状态，我们对于不是名人的i，直接break，继续检查下一个，但是由于我们没有标记后面的候选人的状态，所以有可能会重复调用一些knows函数，所以下面这种方法虽然省了空间，但是调用knows函数的次数可能会比上面的方法次数要多，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> findCelebrity(<span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>, j = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (j = <span style="color: #800080;">0</span>; j &lt; n; ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> (i != j &amp;&amp; (knows(i, j) || !knows(j, i))) <span style="color: #0000ff;">break</span><span style="color: #000000;">;
            }
            </span><span style="color: #0000ff;">if</span> (j == n) <span style="color: #0000ff;">return</span><span style="color: #000000;"> i;
        }
        </span><span style="color: #0000ff;">return</span> -<span style="color: #800080;">1</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种方法是网上比较流行的一种方法，设定候选人res为0，原理是先遍历一遍，对于遍历到的人i，若候选人res认识i，则将候选人res设为i，完成一遍遍历后，我们来检测候选人res是否真正是名人，我们如果判断不是名人，则返回-1，如果并没有冲突，返回res，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> findCelebrity(<span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (knows(res, i)) res =<span style="color: #000000;"> i;
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (res != i &amp;&amp; (knows(res, i) || !knows(i, res))) <span style="color: #0000ff;">return</span> -<span style="color: #800080;">1</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://leetcode.com/discuss/56413/java-solution-two-pass" target="_blank">https://leetcode.com/discuss/56413/java-solution-two-pass</a></p>
<p><a href="https://leetcode.com/discuss/56770/solution-lines-easy-understanding-with-simple-explanation" target="_blank">https://leetcode.com/discuss/56770/solution-lines-easy-understanding-with-simple-explanation</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-03-23 13:00</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5310649" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5310649);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5231220.html" id="cb_post_title_url">[LeetCode] Paint Fence 粉刷篱笆</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p>  </p>
<p>There is a fence with n posts, each post can be painted with one of the k colors.</p>
<p>You have to paint all the posts such that no more than two adjacent fence posts have the same color.</p>
<p>Return the total number of ways you can paint the fence.</p>
<p>Note:<br/>n and k are non-negative integers.</p>
<p> </p>
<p>这道题让我们粉刷篱笆，有n个部分需要刷，有k种颜色的油漆，规定了不能有超过两个的相同颜色涂的部分，问我们总共有多少种刷法。那么我们首先来分析一下，如果n=0的话，说明没有需要刷的部分，直接返回0即可，如果n为1的话，那么有几种颜色，就有几种刷法，所以应该返回k，当n=2时，k=2时，我们可以分两种情况来统计，一种是相邻部分没有相同的，一种相同部分有相同的颜色，那么对于没有相同的，对于第一个格子，我们有k种填法，对于下一个相邻的格子，由于不能相同，所以我们只有k-1种填法。而有相同部分颜色的刷法和上一个格子的不同颜色刷法相同，因为我们下一格的颜色和之前那个格子颜色刷成一样的即可，最后总共的刷法就是把不同和相同两个刷法加起来，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> numWays(<span style="color: #0000ff;">int</span> n, <span style="color: #0000ff;">int</span><span style="color: #000000;"> k) {
        </span><span style="color: #0000ff;">if</span> (n == <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> same = <span style="color: #800080;">0</span>, diff =<span style="color: #000000;"> k;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">2</span>; i &lt;= n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">int</span> t =<span style="color: #000000;"> diff;
            diff </span>= (same + diff) * (k - <span style="color: #800080;">1</span><span style="color: #000000;">);
            same </span>=<span style="color: #000000;"> t;
        }
        </span><span style="color: #0000ff;">return</span> same +<span style="color: #000000;"> diff;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种解法和上面那方法几乎一样，只不过多了一个变量，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> numWays(<span style="color: #0000ff;">int</span> n, <span style="color: #0000ff;">int</span><span style="color: #000000;"> k) {
        </span><span style="color: #0000ff;">if</span> (n == <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> same = <span style="color: #800080;">0</span>, diff = k, res = same +<span style="color: #000000;"> diff;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">2</span>; i &lt;= n; ++<span style="color: #000000;">i) {
            same </span>=<span style="color: #000000;"> diff;
            diff </span>= res * (k - <span style="color: #800080;">1</span><span style="color: #000000;">);
            res </span>= same +<span style="color: #000000;"> diff;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p> </p>
<p><span style="line-height: 1.5;">参考资料：</span></p>
<p class="p1"><span class="s1"><a href="https://leetcode.com/discuss/56173/o-n-time-java-solution-o-1-space">https://leetcode.com/discuss/56173/o-n-time-java-solution-o-1-space</a></span></p>
<p class="p1"><span class="s1"><a href="https://leetcode.com/discuss/85147/complete-explanation-o-n-time-o-1-space">https://leetcode.com/discuss/85147/complete-explanation-o-n-time-o-1-space</a></span></p>
<p class="p1"> </p>
<p class="p1"><span class="s1"><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></span></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-03-01 15:31</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5231220" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5231220);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4782695.html" id="cb_post_title_url">[LeetCode] H-Index II 求H指数之二</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p><strong>Hint:</strong></p>
<ol id="hints">
<li class="hint animated fadeInLeft" style="display: list-item;">Expected runtime complexity is in <em>O</em>(log <em>n</em>) and the input is sorted.</li>
</ol>
<p> </p>
<p>这题是之前那道<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4781203.html" id="cb_post_title_url">H-Index 求H指数</a>的拓展，输入数组是有序的，让我们在O(log n)的时间内完成计算，看到这个时间复杂度，应该有很敏锐的意识应该用二分查找法，我们最先初始化left和right为0和数组长度len-1，然后取中间值mid，比较citations[mid]和len-mid做比较，如果前者大，则right移到mid之前，反之right移到mid之后，终止条件是left&gt;right，最后返回len-left即可，参见代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> hIndex(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> citations) {
        </span><span style="color: #0000ff;">int</span> len = citations.size(), left = <span style="color: #800080;">0</span>, right = len - <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (left &lt;=<span style="color: #000000;"> right) {
            </span><span style="color: #0000ff;">int</span> mid = <span style="color: #800080;">0.5</span> * (left +<span style="color: #000000;"> right);
            </span><span style="color: #0000ff;">if</span> (citations[mid] == len - mid) <span style="color: #0000ff;">return</span> len -<span style="color: #000000;"> mid;
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (citations[mid] &gt; len - mid) right = mid - <span style="color: #800080;">1</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">else</span> left = mid + <span style="color: #800080;">1</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> len -<span style="color: #000000;"> left;
    }
};</span></pre>
</div>
<p><span style="line-height: 1.5;"> </span></p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p>
<p> </p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-09-05 05:45</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4782695" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4782695);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4781203.html" id="cb_post_title_url">[LeetCode] H-Index 求H指数</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher's h-index.</p>
<p>According to the <a href="https://en.wikipedia.org/wiki/H-index" target="_blank">definition of h-index on Wikipedia</a>: "A scientist has index <em>h</em> if <em>h</em> of his/her <em>N</em> papers have <strong>at least</strong> <em>h</em> citations each, and the other <em>N − h</em> papers have <strong>no more than</strong> <em>h</em> citations each."</p>
<p>For example, given <code>citations = [3, 0, 6, 1, 5]</code>, which means the researcher has <code>5</code> papers in total and each of them had received <code>3, 0, 6, 1, 5</code> citations respectively. Since the researcher has <code>3</code> papers with <strong>at least</strong> <code>3</code> citations each and the remaining two with <strong>no more than</strong> <code>3</code> citations each, his h-index is <code>3</code>.</p>
<p><strong>Note</strong>: If there are several possible values for <code>h</code>, the maximum one is taken as the h-index.</p>
<p> </p>
<p>这道题让我们求<a href="https://zh.wikipedia.org/wiki/H%E6%8C%87%E6%95%B0" target="_blank">H指数</a>，这个质数是用来衡量研究人员的学术水平的质数，定义为一个人的学术文章有n篇分别被引用了n次，那么H指数就是n。而且wiki上直接给出了算法，可以按照如下方法确定某人的H指数：1、将其发表的所有SCI论文按被引次数从高到低排序；2、从前往后查找排序后的列表，直到某篇论文的序号大于该论文被引次数。所得序号减一即为H指数。我也就没多想，直接按照上面的方法写出了代码：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> hIndex(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> citations) {
        sort(citations.begin(), citations.end(), greater</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;">());
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; citations.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (i &gt;= citations[i]) <span style="color: #0000ff;">return</span><span style="color: #000000;"> i;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> citations.size();
    }
};</span></pre>
</div>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-09-04 07:54</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4781203" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4781203);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4772780.html" id="cb_post_title_url">[LeetCode] Integer to English Words 整数转为英文单词</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Convert a non-negative integer to its english words representation. Given input is guaranteed to be less than 2<sup>31</sup> - 1.</p>
<p>For example,<br/>
</p>
<pre>123 -&gt; "One Hundred Twenty Three"
12345 -&gt; "Twelve Thousand Three Hundred Forty Five"
1234567 -&gt; "One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven"</pre>
<p><strong>Hint:</strong></p>
<ol id="hints">
<li class="hint animated fadeInLeft" style="display: list-item;">Did you see a pattern in dividing the number into chunk of words? For example, 123 and 123000.</li>
<li class="hint animated fadeInLeft" style="display: list-item;">Group the number by thousands (3 digits). You can write a helper function that takes a number less than 1000 and convert just that chunk to words.</li>
<li class="hint animated fadeInLeft" style="display: list-item;">There are many edge cases. What are some good test cases? Does your code work with input such as 0? Or 1000010? (middle chunk is zero and should not be printed out)</li>
</ol>
<p> </p>
<p>这道题让我们把一个整型数转为用英文单词描述，就像在check上写钱数的方法，我最开始的方法特别复杂，因为我用了几个switch语句来列出所有的单词，但是我看网上大神们的解法都是用数组来枚举的，特别的巧妙而且省地方，膜拜学习中。题目中给足了提示，首先告诉我们要3个一组的进行处理，而且题目中限定了输入数字范围为0到2<sup>31</sup> - 1之间，最高只能到billion位，3个一组也只需处理四组即可，那么我们需要些一个处理三个一组数字的函数，我们需要把1到19的英文单词都列出来，放到一个数组里，还要把20,30，... 到90的英文单词列出来放到另一个数组里，然后我们需要用写技巧，比如一个三位数n，百位数表示为n/100，后两位数一起表示为n%100，十位数表示为n%100/10，个位数表示为n%10，然后我们看后两位数是否小于20，小于的话直接从数组中取出单词，如果大于等于20的话，则分别将十位和个位数字的单词从两个数组中取出来。然后再来处理百位上的数字，还要记得加上Hundred。主函数中调用四次这个帮助函数，然后中间要插入"Thousand", "Million", "Billion"到对应的位置，最后check一下末尾是否有空格，把空格都删掉，返回的时候检查下输入是否为0，是的话要返回'Zero'。参见代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> numberToWords(<span style="color: #0000ff;">int</span><span style="color: #000000;"> num) {
        </span><span style="color: #0000ff;">string</span> res = convertHundred(num % <span style="color: #800080;">1000</span><span style="color: #000000;">);
        vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; v = {<span style="color: #800000;">"</span><span style="color: #800000;">Thousand</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">Million</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">Billion</span><span style="color: #800000;">"</span><span style="color: #000000;">};
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; <span style="color: #800080;">3</span>; ++<span style="color: #000000;">i) {
            num </span>/= <span style="color: #800080;">1000</span><span style="color: #000000;">;
            res </span>= num % <span style="color: #800080;">1000</span> ? convertHundred(num % <span style="color: #800080;">1000</span>) + <span style="color: #800000;">"</span> <span style="color: #800000;">"</span> + v[i] + <span style="color: #800000;">"</span> <span style="color: #800000;">"</span> +<span style="color: #000000;"> res : res;
        }
        </span><span style="color: #0000ff;">while</span> (res.back() == <span style="color: #800000;">'</span> <span style="color: #800000;">'</span><span style="color: #000000;">) res.pop_back();
        </span><span style="color: #0000ff;">return</span> res.empty() ? <span style="color: #800000;">"</span><span style="color: #800000;">Zero</span><span style="color: #800000;">"</span><span style="color: #000000;"> : res;
    }
    </span><span style="color: #0000ff;">string</span> convertHundred(<span style="color: #0000ff;">int</span><span style="color: #000000;"> num) {
        vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; v1 = {<span style="color: #800000;">""</span>, <span style="color: #800000;">"</span><span style="color: #800000;">One</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">Two</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">Three</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">Four</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">Five</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">Six</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">Seven</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">Eight</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">Nine</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">Ten</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">Eleven</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">Twelve</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">Thirteen</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">Fourteen</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">Fifteen</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">Sixteen</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">Seventeen</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">Eighteen</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">Nineteen</span><span style="color: #800000;">"</span><span style="color: #000000;">};
        vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; v2 = {<span style="color: #800000;">""</span>, <span style="color: #800000;">""</span>, <span style="color: #800000;">"</span><span style="color: #800000;">Twenty</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">Thirty</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">Forty</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">Fifty</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">Sixty</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">Seventy</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">Eighty</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">Ninety</span><span style="color: #800000;">"</span><span style="color: #000000;">};
        </span><span style="color: #0000ff;">string</span><span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">int</span> a = num / <span style="color: #800080;">100</span>, b = num % <span style="color: #800080;">100</span>, c = num % <span style="color: #800080;">10</span><span style="color: #000000;">;
        res </span>= b &lt; <span style="color: #800080;">20</span> ? v1[b] : v2[b / <span style="color: #800080;">10</span>] + (c ? <span style="color: #800000;">"</span> <span style="color: #800000;">"</span> + v1[c] : <span style="color: #800000;">""</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">if</span> (a &gt; <span style="color: #800080;">0</span>) res = v1[a] + <span style="color: #800000;">"</span><span style="color: #800000;"> Hundred</span><span style="color: #800000;">"</span> + (b ? <span style="color: #800000;">"</span> <span style="color: #800000;">"</span> + res : <span style="color: #800000;">""</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://leetcode.com/discuss/55268/short-clean-c-code-with-explanation" target="_blank">https://leetcode.com/discuss/55268/short-clean-c-code-with-explanation</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p>
<p> </p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-08-31 12:18</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4772780" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4772780);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5247398.html" id="cb_post_title_url">[LeetCode] Closest Binary Search Tree Value II 最近的二分搜索树的值之二</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a non-empty binary search tree and a target value, find <em>k</em> values in the BST that are closest to the target.</p>
<p>Note:</p>
<ul>
<li>Given target value is a floating point.</li>
<li>You may assume <em>k</em> is always valid, that is: <em>k</em> ≤ total nodes.</li>
<li>You are guaranteed to have only one unique set of <em>k</em> values in the BST that are closest to the target.</li>
</ul>
<p> </p>
<p>Follow up:<br/>Assume that the BST is balanced, could you solve it in less than <em>O</em>(<em>n</em>) runtime (where <em>n</em> = total nodes)?</p>
<p>Hint:</p>
<p>1. Consider implement these two helper functions:<br/>　　i. getPredecessor(N), which returns the next smaller node to N.<br/>　　ii. getSuccessor(N), which returns the next larger node to N.<br/>2. Try to assume that each node has a parent pointer, it makes the problem much easier.<br/>3. Without parent pointer we just need to keep track of the path from the root to the current node using a stack.<br/>4. You would need two stacks to track the path in finding predecessor and successor node separately.</p>
<p> </p>
<p>这道题是之前那道<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/5237170.html" id="homepage1_HomePageDays_DaysList_ctl02_DayList_TitleUrl_0">Closest Binary Search Tree Value</a>的拓展，那道题只让我们找出离目标值最近的一个节点值，而这道题让我们找出离目标值最近的k个节点值，难度瞬间增加了不少，我最先想到的方法是用中序遍历将所有节点值存入到一个一维数组中，由于二分搜索树的性质，这个一维数组是有序的，然后我们再在有序数组中需要和目标值最近的k个值就简单的多，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; closestKValues(TreeNode* root, <span style="color: #0000ff;">double</span> target, <span style="color: #0000ff;">int</span><span style="color: #000000;"> k) {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> res, v;
        inorder(root, v);
        </span><span style="color: #0000ff;">int</span> idx = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">double</span> diff = numeric_limits&lt;<span style="color: #0000ff;">double</span>&gt;<span style="color: #000000;">::max();
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; v.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (diff &gt;= abs(target -<span style="color: #000000;"> v[i])) {
                diff </span>= abs(target -<span style="color: #000000;"> v[i]);
                idx </span>=<span style="color: #000000;"> i;
            }
        }
        </span><span style="color: #0000ff;">int</span> left = idx - <span style="color: #800080;">1</span>, right = idx + <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; k; ++<span style="color: #000000;">i) {
            res.push_back(v[idx]);
            </span><span style="color: #0000ff;">if</span> (left &gt;= <span style="color: #800080;">0</span> &amp;&amp; right &lt;<span style="color: #000000;"> v.size()) {
                </span><span style="color: #0000ff;">if</span> (abs(v[left] - target) &gt; abs(v[right] -<span style="color: #000000;"> target)) {
                    idx </span>=<span style="color: #000000;"> right;
                    </span>++<span style="color: #000000;">right;
                } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    idx </span>=<span style="color: #000000;"> left;
                    </span>--<span style="color: #000000;">left;
                }
            } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (left &gt;= <span style="color: #800080;">0</span><span style="color: #000000;">) {
                idx </span>=<span style="color: #000000;"> left;
                </span>--<span style="color: #000000;">left;
            } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (right &lt;<span style="color: #000000;"> v.size()) {
                idx </span>=<span style="color: #000000;"> right;
                </span>++<span style="color: #000000;">right;
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">void</span> inorder(TreeNode *root, vector&lt;<span style="color: #0000ff;">int</span>&gt; &amp;<span style="color: #000000;">v) {
        </span><span style="color: #0000ff;">if</span> (!root) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
        inorder(root</span>-&gt;<span style="color: #000000;">left, v);
        v.push_back(root</span>-&gt;<span style="color: #000000;">val);
        inorder(root</span>-&gt;<span style="color: #000000;">right, v);
    }
};</span></pre>
</div>
<p> </p>
<p>还有一种解法是直接在中序遍历的过程中完成比较，当遍历到一个节点时，如果此时结果数组不到k个，我们直接将此节点值加入res中，如果该节点值和目标值的差值的绝对值小于res的首元素和目标值差值的绝对值，说明当前值更靠近目标值，则将首元素删除，末尾加上当前节点值，反之的话说明当前值比res中所有的值都更偏离目标值，由于中序遍历的特性，之后的值会更加的遍历，所以此时直接返回最终结果即可，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; closestKValues(TreeNode* root, <span style="color: #0000ff;">double</span> target, <span style="color: #0000ff;">int</span><span style="color: #000000;"> k) {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> res;
        inorder(root, target, k, res);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">void</span> inorder(TreeNode *root, <span style="color: #0000ff;">double</span> target, <span style="color: #0000ff;">int</span> k, vector&lt;<span style="color: #0000ff;">int</span>&gt; &amp;<span style="color: #000000;">res) {
        </span><span style="color: #0000ff;">if</span> (!root) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
        inorder(root</span>-&gt;<span style="color: #000000;">left, target, k, res);
        </span><span style="color: #0000ff;">if</span> (res.size() &lt; k) res.push_back(root-&gt;<span style="color: #000000;">val);
        </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (abs(root-&gt;val - target) &lt; abs(res[<span style="color: #800080;">0</span>] -<span style="color: #000000;"> target)) {
            res.erase(res.begin());
            res.push_back(root</span>-&gt;<span style="color: #000000;">val);
        } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">return</span><span style="color: #000000;">;
        inorder(root</span>-&gt;<span style="color: #000000;">right, target, k, res);
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种方法是上面那种方法的迭代写法，原理一模一样，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; closestKValues(TreeNode* root, <span style="color: #0000ff;">double</span> target, <span style="color: #0000ff;">int</span><span style="color: #000000;"> k) {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> res;
        stack</span>&lt;TreeNode*&gt;<span style="color: #000000;"> s;
        TreeNode </span>*p =<span style="color: #000000;"> root;
        </span><span style="color: #0000ff;">while</span> (p || !<span style="color: #000000;">s.empty()) {
            </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> (p) {
                s.push(p);
                p </span>= p-&gt;<span style="color: #000000;">left;
            }
            p </span>=<span style="color: #000000;"> s.top(); s.pop();
            </span><span style="color: #0000ff;">if</span> (res.size() &lt; k) res.push_back(p-&gt;<span style="color: #000000;">val);
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (abs(p-&gt;val - target) &lt; abs(res[<span style="color: #800080;">0</span>] -<span style="color: #000000;"> target)) {
                res.erase(res.begin());
                res.push_back(p</span>-&gt;<span style="color: #000000;">val);
            } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">break</span><span style="color: #000000;">;
            p </span>= p-&gt;<span style="color: #000000;">right;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>在来看一种利用最大堆来解题的方法，堆里保存的一个差值diff和节点值的pair，我们中序遍历二叉树(也可以用其他遍历方法)，然后对于每个节点值都计算一下和目标值之差的绝对值，由于最大堆的性质，diff大的自动拍到最前面，我们维护k个pair，如果超过了k个，就把堆前面大的pair删掉，最后留下的k个pair，我们将pair中的节点值取出存入res中返回即可，参见代码如下： </p>
<p> </p>
<p>解法四：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; closestKValues(TreeNode* root, <span style="color: #0000ff;">double</span> target, <span style="color: #0000ff;">int</span><span style="color: #000000;"> k) {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> res;
        priority_queue</span>&lt;pair&lt;<span style="color: #0000ff;">double</span>, <span style="color: #0000ff;">int</span>&gt;&gt;<span style="color: #000000;"> q;
        inorder(root, target, k, q);
        </span><span style="color: #0000ff;">while</span> (!<span style="color: #000000;">q.empty()) {
            res.push_back(q.top().second);
            q.pop();
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">void</span> inorder(TreeNode *root, <span style="color: #0000ff;">double</span> target, <span style="color: #0000ff;">int</span> k, priority_queue&lt;pair&lt;<span style="color: #0000ff;">double</span>, <span style="color: #0000ff;">int</span>&gt;&gt; &amp;<span style="color: #000000;">q) {
        </span><span style="color: #0000ff;">if</span> (!root) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
        inorder(root</span>-&gt;<span style="color: #000000;">left, target, k, q);
        q.push({abs(root</span>-&gt;val - target), root-&gt;<span style="color: #000000;">val});
        </span><span style="color: #0000ff;">if</span> (q.size() &gt;<span style="color: #000000;"> k) q.pop();
        inorder(root</span>-&gt;<span style="color: #000000;">right, target, k, q);
    }
};</span></pre>
</div>
<p> </p>
<p>下面的这种方法用了两个栈，pre和suc，其中pre存小于目标值的数，suc存大于目标值的数，开始初始化pre和suc的时候，要分别将最接近目标值的稍小值和稍大值压入pre和suc，然后我们循环k次，每次比较pre和suc的栈顶元素，看谁更接近目标值，将其存入结果res中，然后更新取出元素的栈，依次类推直至取完k个数返回即可，参见代码如下：</p>
<p> </p>
<p>解法五：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; closestKValues(TreeNode* root, <span style="color: #0000ff;">double</span> target, <span style="color: #0000ff;">int</span><span style="color: #000000;"> k) {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> res;
        stack</span>&lt;TreeNode*&gt;<span style="color: #000000;"> pre, suc;
        </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> (root) {
            </span><span style="color: #0000ff;">if</span> (root-&gt;val &lt;=<span style="color: #000000;"> target) {
                pre.push(root);
                root </span>= root-&gt;<span style="color: #000000;">right;
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                suc.push(root);
                root </span>= root-&gt;<span style="color: #000000;">left;
            }
        }
        </span><span style="color: #0000ff;">while</span> (k-- &gt; <span style="color: #800080;">0</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">if</span> (suc.empty() || !pre.empty() &amp;&amp; target - pre.top()-&gt;val &lt; suc.top()-&gt;val -<span style="color: #000000;"> target) {
                res.push_back(pre.top()</span>-&gt;<span style="color: #000000;">val);
                getPredecessor(pre);
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                res.push_back(suc.top()</span>-&gt;<span style="color: #000000;">val);
                getSuccessor(suc);
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">void</span> getPredecessor(stack&lt;TreeNode*&gt; &amp;<span style="color: #000000;">pre) {
        TreeNode </span>*t =<span style="color: #000000;"> pre.top(); pre.pop();
        </span><span style="color: #0000ff;">if</span> (t-&gt;<span style="color: #000000;">left) {
            pre.push(t</span>-&gt;<span style="color: #000000;">left);
            </span><span style="color: #0000ff;">while</span> (pre.top()-&gt;right) pre.push(pre.top()-&gt;<span style="color: #000000;">right);
        }
    }
    </span><span style="color: #0000ff;">void</span> getSuccessor(stack&lt;TreeNode*&gt; &amp;<span style="color: #000000;">suc) {
        TreeNode </span>*t =<span style="color: #000000;"> suc.top(); suc.pop();
        </span><span style="color: #0000ff;">if</span> (t-&gt;<span style="color: #000000;">right) {
            suc.push(t</span>-&gt;<span style="color: #000000;">right);
            </span><span style="color: #0000ff;">while</span> (suc.top()-&gt;left) suc.push(suc.top()-&gt;<span style="color: #000000;">left);
        }
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/5237170.html" id="homepage1_HomePageDays_DaysList_ctl02_DayList_TitleUrl_0">Closest Binary Search Tree Value</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://leetcode.com/discuss/69220/2-ms-o-n-and-6-ms-o-logn-java-solution" target="_blank">https://leetcode.com/discuss/69220/2-ms-o-n-and-6-ms-o-logn-java-solution</a></p>
<p><a href="https://leetcode.com/discuss/77954/easy-o-n-c-solution-using-priority_queue" target="_blank">https://leetcode.com/discuss/77954/easy-o-n-c-solution-using-priority_queue</a></p>
<p><a href="https://leetcode.com/discuss/64713/clear-java-solution-with-one-stack-one-linkedlist" target="_blank">https://leetcode.com/discuss/64713/clear-java-solution-with-one-stack-one-linkedlist</a></p>
<p><a href="https://leetcode.com/discuss/83431/c-simple-inorder-solution-with-o-n-runtime-and-o-k-memory" target="_blank">https://leetcode.com/discuss/83431/c-simple-inorder-solution-with-o-n-runtime-and-o-k-memory</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-03-06 14:32</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5247398" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5247398);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5265628.html" id="cb_post_title_url">[LeetCode] Encode and Decode Strings 加码解码字符串</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Design an algorithm to encode a list of strings to a string. The encoded string is then sent over the network and is decoded back to the original list of strings.</p>
<p>Machine 1 (sender) has the function:</p>
<pre>string encode(vector&lt;string&gt; strs) {
  // ... your code
  return encoded_string;
}</pre>
<p>Machine 2 (receiver) has the function:</p>
<pre>vector&lt;string&gt; decode(string s) {
  //... your code
  return strs;
}</pre>
<p> </p>
<p>So Machine 1 does:</p>
<pre>string encoded_string = encode(strs);</pre>
<p> </p>
<p>and Machine 2 does:</p>
<pre>vector&lt;string&gt; strs2 = decode(encoded_string);</pre>
<p> </p>
<p><code>strs2</code> in Machine 2 should be the same as <code>strs</code> in Machine 1.</p>
<p>Implement the <code>encode</code> and <code>decode</code> methods.</p>
<p>Note:</p>
<ul>
<li>The string may contain any possible characters out of 256 valid ascii characters. Your algorithm should be generalized enough to work on any possible characters.</li>
<li>Do not use class member/global/static variables to store states. Your encode and decode algorithms should be stateless.</li>
<li>Do not rely on any library method such as <code>eval</code> or serialize methods. You should implement your own encode/decode algorithm.</li>
</ul>
<p> </p>
<p>这道题让我们给字符加码再解码，先有码再无码，然后题目中并没有限制我们加码的方法，那么我们的方法只要能成功的把有码变成无码就行了，具体变换方法我们自己设计。由于我们需要把一个字符串集变成一个字符串，然后把这个字符串再还原成原来的字符串集，最开始我想能不能在每一个字符串中间加个空格把它们连起来，然后再按空格来隔开，但是这种方法的问题是原来的一个字符串中如果含有空格，那么还原的时候就会被分隔成两个字符串，所以我们必须还要加上长度的信息，我们的加码方法是长度+"/"+字符串，比如对于"a","ab","abc"，我们就变成"1/a2/ab3/abc"，那么我们解码的时候就有规律可寻，先寻找"/"，然后之前的就是要取出的字符个数，从“/"后取出相应个数即可，以此类推直至没有"/"了，这样我们就得到高清无码的字符串集了，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Codec {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> Encodes a list of strings to a single string.</span>
    <span style="color: #0000ff;">string</span> encode(vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp;<span style="color: #000000;"> strs) {
        </span><span style="color: #0000ff;">string</span> res = <span style="color: #800000;">""</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto a : strs) {
            res.append(to_string(a.size())).append(</span><span style="color: #800000;">"</span><span style="color: #800000;">/</span><span style="color: #800000;">"</span><span style="color: #000000;">).append(a);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> Decodes a single string to a list of strings.</span>
    vector&lt;<span style="color: #0000ff;">string</span>&gt; decode(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        vector</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (i &lt;<span style="color: #000000;"> s.size()) {
            auto found </span>= s.find(<span style="color: #800000;">"</span><span style="color: #800000;">/</span><span style="color: #800000;">"</span><span style="color: #000000;">, i);
            </span><span style="color: #0000ff;">int</span> len =<span style="color: #000000;"> atoi(s.substr(i, found).c_str());
            res.push_back(s.substr(found </span>+ <span style="color: #800080;">1</span><span style="color: #000000;">, len));
            i </span>= found + len + <span style="color: #800080;">1</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>上面的方法是用一个变量i来记录当前遍历到的位置，我们也可以通过修改修改s，将已经解码的字符串删掉，最终s变为空的时候停止循环，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Codec {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> Encodes a list of strings to a single string.</span>
    <span style="color: #0000ff;">string</span> encode(vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp;<span style="color: #000000;"> strs) {
        </span><span style="color: #0000ff;">string</span> res = <span style="color: #800000;">""</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto a : strs) {
            res.append(to_string(a.size())).append(</span><span style="color: #800000;">"</span><span style="color: #800000;">/</span><span style="color: #800000;">"</span><span style="color: #000000;">).append(a);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> Decodes a single string to a list of strings.</span>
    vector&lt;<span style="color: #0000ff;">string</span>&gt; decode(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        vector</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">while</span> (!s.empty()<span style="color: #000000;">) {
            </span><span style="color: #0000ff;">int</span> found = s.find(<span style="color: #800000;">"</span><span style="color: #800000;">/</span><span style="color: #800000;">"</span><span style="color: #000000;">);
            </span><span style="color: #0000ff;">int</span> len = atoi(s.substr(<span style="color: #800080;">0</span><span style="color: #000000;">, found).c_str());
            s </span>= s.substr(found + <span style="color: #800080;">1</span><span style="color: #000000;">);
            res.push_back(s.substr(</span><span style="color: #800080;">0</span><span style="color: #000000;">, len));
            s </span>=<span style="color: #000000;"> s.substr(len);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://leetcode.com/discuss/55020/ac-java-solution" target="_blank">https://leetcode.com/discuss/55020/ac-java-solution</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-03-11 14:46</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5265628" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5265628);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5237170.html" id="cb_post_title_url">[LeetCode] Closest Binary Search Tree Value 最近的二分搜索树的值</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a non-empty binary search tree and a target value, find the value in the BST that is closest to the target.</p>
<p>Note:</p>
<ul>
<li>Given target value is a floating point.</li>
<li>You are guaranteed to have only one unique value in the BST that is closest to the target.</li>
</ul>
<p> </p>
<p>这道题让我们找一个二分搜索数的跟给定值最接近的一个节点值，由于是二分搜索树，所以我最先想到用中序遍历来做，一个一个的比较，维护一个最小值，不停的更新，实际上这种方法并没有提高效率，用其他的遍历方法也可以，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> closestValue(TreeNode* root, <span style="color: #0000ff;">double</span><span style="color: #000000;"> target) {
        </span><span style="color: #0000ff;">double</span> d = numeric_limits&lt;<span style="color: #0000ff;">double</span>&gt;<span style="color: #000000;">::max();
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        stack</span>&lt;TreeNode*&gt;<span style="color: #000000;"> s;
        TreeNode </span>*p =<span style="color: #000000;"> root;
        </span><span style="color: #0000ff;">while</span> (p || !<span style="color: #000000;">s.empty()) {
            </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> (p) {
                s.push(p);
                p </span>= p-&gt;<span style="color: #000000;">left;
            }
            p </span>=<span style="color: #000000;"> s.top(); s.pop();
            </span><span style="color: #0000ff;">if</span> (d &gt;= abs(target - p-&gt;<span style="color: #000000;">val)) {
                d </span>= abs(target - p-&gt;<span style="color: #000000;">val);
                res </span>= p-&gt;<span style="color: #000000;">val;
            }
            p </span>= p-&gt;<span style="color: #000000;">right;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>实际我们可以利用二分搜索树的特点(左&lt;根&lt;右)来快速定位，由于根节点是中间值，我们在往下遍历时，我们根据目标值和根节点的值大小关系来比较，如果目标值小于节点值，则我们应该找更小的值，于是我们到左子树去找，反之我们去右子树找，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> closestValue(TreeNode* root, <span style="color: #0000ff;">double</span><span style="color: #000000;"> target) {
        </span><span style="color: #0000ff;">int</span> res = root-&gt;<span style="color: #000000;">val;
        </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> (root) {
            </span><span style="color: #0000ff;">if</span> (abs(res - target) &gt;= abs(root-&gt;val -<span style="color: #000000;"> target)) {
                res </span>= root-&gt;<span style="color: #000000;">val;
            }
            root </span>= target &lt; root-&gt;val ? root-&gt;left : root-&gt;<span style="color: #000000;">right;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>以上两种方法都是迭代的方法，下面我们来看递归的写法，下面这种递归的写法和上面迭代的方法思路相同，都是根据二分搜索树的性质来优化查找，但是递归的写法用的是回溯法，先遍历到叶节点，然后一层一层的往回走，把最小值一层一层的运回来，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> closestValue(TreeNode* root, <span style="color: #0000ff;">double</span><span style="color: #000000;"> target) {
        </span><span style="color: #0000ff;">int</span> a = root-&gt;<span style="color: #000000;">val;
        TreeNode </span>*t = target &lt; a ? root-&gt;left : root-&gt;<span style="color: #000000;">right;
        </span><span style="color: #0000ff;">if</span> (!t) <span style="color: #0000ff;">return</span><span style="color: #000000;"> a;
        </span><span style="color: #0000ff;">int</span> b =<span style="color: #000000;"> closestValue(t, target);
        </span><span style="color: #0000ff;">return</span> abs(a - target) &lt; abs(b - target) ?<span style="color: #000000;"> a : b;
    }
};</span></pre>
</div>
<p> </p>
<p>再来看另一种递归的写法，思路和上面的都相同，写法上略有不同，用if来分情况，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> closestValue(TreeNode* root, <span style="color: #0000ff;">double</span><span style="color: #000000;"> target) {
        </span><span style="color: #0000ff;">int</span> res = root-&gt;<span style="color: #000000;">val;
        </span><span style="color: #0000ff;">if</span> (target &lt; root-&gt;val &amp;&amp; root-&gt;<span style="color: #000000;">left) {
            </span><span style="color: #0000ff;">int</span> l = closestValue(root-&gt;<span style="color: #000000;">left, target);
            </span><span style="color: #0000ff;">if</span> (abs(res - target) &gt;= abs(l - target)) res =<span style="color: #000000;"> l;
        } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (target &gt; root-&gt;val &amp;&amp; root-&gt;<span style="color: #000000;">right) {
            </span><span style="color: #0000ff;">int</span> r = closestValue(root-&gt;<span style="color: #000000;">right, target);
            </span><span style="color: #0000ff;">if</span> (abs(res - target) &gt;= abs(r - target)) res =<span style="color: #000000;"> r;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>最后来看一种分治法的写法，这种方法相当于解法一的递归写法，并没有利用到二分搜索树的性质来优化搜索，参见代码如下：</p>
<p> </p>
<p>解法四：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> closestValue(TreeNode* root, <span style="color: #0000ff;">double</span><span style="color: #000000;"> target) {
        </span><span style="color: #0000ff;">double</span> diff = numeric_limits&lt;<span style="color: #0000ff;">double</span>&gt;<span style="color: #000000;">::max();
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        helper(root, target, diff, res);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">void</span> helper(TreeNode *root, <span style="color: #0000ff;">double</span> target, <span style="color: #0000ff;">double</span> &amp;diff, <span style="color: #0000ff;">int</span> &amp;<span style="color: #000000;">res) {
        </span><span style="color: #0000ff;">if</span> (!root) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (diff &gt;= abs(root-&gt;val -<span style="color: #000000;"> target)) {
            diff </span>= abs(root-&gt;val -<span style="color: #000000;"> target);
            res </span>= root-&gt;<span style="color: #000000;">val;
        }
        helper(root</span>-&gt;<span style="color: #000000;">left, target, diff, res);
        helper(root</span>-&gt;<span style="color: #000000;">right, target, diff, res);
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料:</p>
<p class="p1"><span class="s1"><a href="https://leetcode.com/discuss/84105/c-clean-solution">https://leetcode.com/discuss/84105/c-clean-solution</a></span></p>
<p class="p1"><span class="s1"><a href="https://leetcode.com/discuss/85514/sharing-my-12ms-c-solution">https://leetcode.com/discuss/85514/sharing-my-12ms-c-solution</a></span></p>
<p class="p1"><span class="s1"><a href="https://leetcode.com/discuss/54438/4-7-lines-recursive-iterative-ruby-c-java-python">https://leetcode.com/discuss/54438/4-7-lines-recursive-iterative-ruby-c-java-python</a></span></p>
<p class="p1"> </p>
<div id="cnblogs_post_body">
<div>
<p class="p1"><span class="s1"><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></span></p>
<p> </p>
</div>
</div>
<p class="p1"><span class="s1"> </span></p>
<p> </p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-03-03 06:59</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5237170" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5237170);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5250200.html" id="cb_post_title_url">[LeetCode] Alien Dictionary 另类字典</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="row">
<div class="col-md-12">
<div class="row">
<div class="col-md-12">
<div class="question-content">
<p>There is a new alien language which uses the latin alphabet. However, the order among letters are unknown to you. You receive a list of words from the dictionary, where words are sorted lexicographically by the rules of this new language. Derive the order of letters in this language.</p>
<p>For example,<br/>Given the following words in dictionary,</p>
<pre>[
  "wrt",
  "wrf",
  "er",
  "ett",
  "rftt"
]
</pre>
<p> </p>
<p>The correct order is: <code>"wertf"</code>.</p>
<p>Note:</p>
<ol>
<li>You may assume all letters are in lowercase.</li>
<li>If the order is invalid, return an empty string.</li>
<li>There may be multiple valid order of letters, return any one of them is fine.</li>
</ol>
<p> </p>
<p>这道题让给了我们一些按“字母顺序”排列的单词，但是这个字母顺序不是我们熟知的顺序，而是另类的顺序，让我们根据这些“有序”的单词来找出新的字母顺序，这实际上是一道有向图的问题，跟之前的那两道<a href="http://www.cnblogs.com/grandyang/p/4504793.html" target="_blank">Course Schedule II</a>和<a href="http://www.cnblogs.com/grandyang/p/4484571.html" target="_blank">Course Schedule</a>的解法很类似，我们先来看BFS的解法，我们需要一个set来保存我们可以推测出来的顺序关系，比如题目中给的例子，我们可以推出的顺序关系有：</p>
<div class="cnblogs_code">
<pre>t-&gt;<span style="color: #000000;">f
w</span>-&gt;<span style="color: #000000;">e
r</span>-&gt;<span style="color: #000000;">t
e</span>-&gt;r</pre>
</div>
<p>那么set就用来保存这些pair，我们还需要另一个set来保存所有出现过的字母，需要一个一维数组in来保存每个字母的入度，另外还要一个queue来辅助拓扑遍历，我们先遍历单词集，把所有字母先存入ch，然后我们每两个相邻的单词比较，找出顺序pair，然后我们根据这些pair来赋度，我们把ch中入度为0的字母都排入queue中，然后开始遍历，如果字母在set中存在，则将其pair中对应的字母的入度减1，若此时入度减为0了，则将对应的字母排入queue中并且加入结果res中，直到遍历完成，我们看结果res和ch中的元素个数是否相同，若不相同则说明可能有环存在，返回空字符串，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> alienOrder(vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp;<span style="color: #000000;"> words) {
        </span><span style="color: #0000ff;">set</span>&lt;pair&lt;<span style="color: #0000ff;">char</span>, <span style="color: #0000ff;">char</span>&gt; &gt;<span style="color: #000000;"> s;
        unordered_set</span>&lt;<span style="color: #0000ff;">char</span>&gt;<span style="color: #000000;"> ch;
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; <span style="color: #0000ff;">in</span>(<span style="color: #800080;">256</span>, <span style="color: #800080;">0</span><span style="color: #000000;">);
        queue</span>&lt;<span style="color: #0000ff;">char</span>&gt;<span style="color: #000000;"> q;
        </span><span style="color: #0000ff;">string</span> res = <span style="color: #800000;">""</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto a : words) ch.insert(a.begin(), a.end());
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; words.size() - <span style="color: #800080;">1</span>; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">int</span> mn = min(words[i].size(), words[i + <span style="color: #800080;">1</span>].size()), j = <span style="color: #800080;">0</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">for</span> (; j &lt; min(words[i].size(), words[i + <span style="color: #800080;">1</span>].size()); ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> (words[i][j] != words[i + <span style="color: #800080;">1</span><span style="color: #000000;">][j]) {
                    s.insert(make_pair(words[i][j], words[i </span>+ <span style="color: #800080;">1</span><span style="color: #000000;">][j]));
                    </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                }
            }
            </span><span style="color: #0000ff;">if</span> (j == mn &amp;&amp; words[i].size() &gt; words[i + <span style="color: #800080;">1</span>].size()) <span style="color: #0000ff;">return</span> <span style="color: #800000;">""</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">for</span> (auto a : s) ++<span style="color: #0000ff;">in</span><span style="color: #000000;">[a.second];
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto a : ch) {
            </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">in</span>[a] == <span style="color: #800080;">0</span><span style="color: #000000;">) {
                q.push(a);
                res </span>+=<span style="color: #000000;"> a;
            } 
        }
        </span><span style="color: #0000ff;">while</span> (!<span style="color: #000000;">q.empty()) {
            </span><span style="color: #0000ff;">char</span> c =<span style="color: #000000;"> q.front(); q.pop();
            </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto a : s) {
                </span><span style="color: #0000ff;">if</span> (a.first ==<span style="color: #000000;"> c) {
                    </span>--<span style="color: #0000ff;">in</span><span style="color: #000000;">[a.second];
                    </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">in</span>[a.second] == <span style="color: #800080;">0</span><span style="color: #000000;">) {
                        q.push(a.second);
                        res </span>+=<span style="color: #000000;"> a.second;
                    }
                }
            }
        }
        </span><span style="color: #0000ff;">return</span> res.size() == ch.size() ? res : <span style="color: #800000;">""</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>下面来看一种DFS的解法，思路和BFS的很类似，我们需要建立一个二维的bool数组g，然后把出现过的字母的对应的位置都赋为true，然后我们把可以推出的顺序的对应位置也赋为true，然后我们就开始递归调用，如果递归函数有返回false的，说明有冲突，则返回false，递归调用结束后结果res中存了入度不为0的字母，最后把入度为0的字母加到最后面，最后把结果res翻转一下即可，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> alienOrder(vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp;<span style="color: #000000;"> words) {
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">bool</span>&gt;&gt; g(<span style="color: #800080;">26</span>, vector&lt;<span style="color: #0000ff;">bool</span>&gt;(<span style="color: #800080;">26</span>, <span style="color: #0000ff;">false</span><span style="color: #000000;">));
        vector</span>&lt;<span style="color: #0000ff;">bool</span>&gt; path(<span style="color: #800080;">26</span>, <span style="color: #0000ff;">false</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">string</span> res = <span style="color: #800000;">""</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">string</span><span style="color: #000000;"> word : words) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span><span style="color: #000000;"> c : word) {
                g[c </span>- <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span>][c - <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span>] = <span style="color: #0000ff;">true</span><span style="color: #000000;">;
            }
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; words.size() - <span style="color: #800080;">1</span>; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">int</span> mn = min(words[i].size(), words[i + <span style="color: #800080;">1</span>].size()), j = <span style="color: #800080;">0</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">for</span> (; j &lt; mn; ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> (words[i][j] != words[i + <span style="color: #800080;">1</span><span style="color: #000000;">][j]) {
                    g[words[i][j] </span>- <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span>][words[i + <span style="color: #800080;">1</span>][j] - <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span>] = <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                }
            }
            </span><span style="color: #0000ff;">if</span> (j == mn &amp;&amp; words[i].size() &gt; words[i + <span style="color: #800080;">1</span>].size()) <span style="color: #0000ff;">return</span> <span style="color: #800000;">""</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; <span style="color: #800080;">26</span>; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (!dfs(g, i, path, res)) <span style="color: #0000ff;">return</span> <span style="color: #800000;">""</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; <span style="color: #800080;">26</span>; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (g[i][i]) res += (<span style="color: #0000ff;">char</span>)(i + <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span><span style="color: #000000;">);
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">string</span><span style="color: #000000;">(res.rbegin(), res.rend());
    }
    </span><span style="color: #0000ff;">bool</span> dfs(vector&lt;vector&lt;<span style="color: #0000ff;">bool</span>&gt;&gt; &amp;g, <span style="color: #0000ff;">int</span> idx, vector&lt;<span style="color: #0000ff;">bool</span>&gt; &amp;path, <span style="color: #0000ff;">string</span> &amp;<span style="color: #000000;">res) {
        </span><span style="color: #0000ff;">if</span> (!g[idx][idx]) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        path[idx] </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; <span style="color: #800080;">26</span>; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (i == idx || !g[idx][i]) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> (path[i]) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> (!dfs(g, i, path, res)) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        }
        path[idx] </span>= <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        g[idx][idx] </span>= <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        res </span>+= (<span style="color: #0000ff;">char</span>)(idx + <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
</div>
</div>
</div>
</div>
</div>
<div id="interviewed_div">类似题目：</div>
<div>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/5000291.html" id="homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0">Minimum Height Trees</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4504793.html" target="_blank">Course Schedule II</a></p>
<a href="http://www.cnblogs.com/grandyang/p/4484571.html" target="_blank">Course Schedule</a></div>
<div> </div>
<div>
<p>参考资料：</p>
<p><a href="https://leetcode.com/discuss/72402/fast-java-solution-3ms-dfs-topological-sort" target="_blank">https://leetcode.com/discuss/72402/fast-java-solution-3ms-dfs-topological-sort</a></p>
<p><a href="https://discuss.leetcode.com/topic/33546/my-concise-java-solution-based-on-topological-sorting/7" target="_blank">https://discuss.leetcode.com/topic/33546/my-concise-java-solution-based-on-topological-sorting/7</a></p>
</div>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p>
<p> </p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-03-07 13:35</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5250200" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5250200);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4756677.html" id="cb_post_title_url">[LeetCode] Missing Number 丢失的数字</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given an array containing <em>n</em> distinct numbers taken from <code>0, 1, 2, ..., n</code>, find the one that is missing from the array.</p>
<p>For example,<br/>
Given <em>nums</em> = <code>[0, 1, 3]</code> return <code>2</code>.
</p>
<p>
<strong>Note</strong>:<br/>
Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity?
</p>
<p> </p>
<p>这道题给我们n个数字，是0到n之间的数但是有一个数字去掉了，让我们寻找这个数字，要求线性的时间复杂度和常数级的空间复杂度。那么最直观的一个方法是用等差数列的求和公式求出0到n之间所有的数字之和，然后再遍历数组算出给定数字的累积和，然后做减法，差值就是丢失的那个数字，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> missingNumber(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        </span><span style="color: #0000ff;">int</span> sum = <span style="color: #800080;">0</span>, n =<span style="color: #000000;"> nums.size();
        </span><span style="color: #0000ff;">for</span> (auto &amp;<span style="color: #000000;">a : nums) {
            sum </span>+=<span style="color: #000000;"> a;
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0.5</span> * n * (n + <span style="color: #800080;">1</span>) -<span style="color: #000000;"> sum;
    }
};</span></pre>
</div>
<p> </p>
<p>这题还有一种解法，使用位操作Bit Manipulation来解的，用到了异或操作的特性，相似的题目有<a href="http://www.cnblogs.com/Given%20an%20array%20of%20integers,%20every%20element%20appears%20three%20times%20except%20for%20one.%20Find%20that%20single%20one.%20%20Note:%20Your%20algorithm%20should%20have%20a%20linear%20runtime%20complexity.%20Could%20you%20implement%20it%20without%20using%20extra%20memory" target="_blank">Single Number 单独的数字,</a> <a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4263927.html" id="cb_post_title_url">Single Number II 单独的数字之二</a><span class="postTitle2">和<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4741122.html" id="cb_post_title_url">Single Number III 单独的数字之三</a>。那么思路是既然0到n之间少了一个数，我们将这个少了一个数的数组合0到n之间完整的数组异或一下，那么相同的数字都变为0了，剩下的就是少了的那个数字了，参加代码如下：</span></p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> missingNumber(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; nums.size(); ++<span style="color: #000000;">i) {
            res </span>^= (i + <span style="color: #800080;">1</span>) ^<span style="color: #000000;"> nums[i];
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>这道题还可以用二分查找法来做，我们首先要对数组排序，然后我们用二分查找法算出中间元素的下标，然后用元素值和下标值之间做对比，如果元素值大于下标值，则说明缺失的数字在左边，此时将right赋为mid，反之则将left赋为mid+1。那么看到这里，作为读者的你可能会提出，排序的时间复杂度都不止O(n)，何必要多此一举用二分查找，还不如用上面两种方法呢。对，你说的没错，但是在面试的时候，有可能人家给你的数组就是排好序的，那么此时用二分查找法肯定要优于上面两种方法，所以这种方法最好也要掌握以下~</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> missingNumber(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        sort(nums.begin(), nums.end());
        </span><span style="color: #0000ff;">int</span> left = <span style="color: #800080;">0</span>, right =<span style="color: #000000;"> nums.size();
        </span><span style="color: #0000ff;">while</span> (left &lt;<span style="color: #000000;"> right) {
            </span><span style="color: #0000ff;">int</span> mid = left + (right - left) / <span style="color: #800080;">2</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> (nums[mid] &gt; mid) right =<span style="color: #000000;"> mid;
            </span><span style="color: #0000ff;">else</span> left = mid + <span style="color: #800080;">1</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> right;
    }
};</span></pre>
</div>
<p> </p>
<p>在CareerCup中有一道类似的题，<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4747429.html" id="cb_post_title_url">5.7 Find Missing Integer 查找丢失的数</a>，但是那道题不让我们直接访问整个int数字，而是只能访问其二进制表示数中的某一位，强行让我们使用位操作Bit Manipulation来解题，也是蛮有意思的一道题。</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-08-25 10:10</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4756677" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4756677);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5315227.html" id="cb_post_title_url">[LeetCode] Palindrome Permutation II 回文全排列之二</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a string <code>s</code>, return all the palindromic permutations (without duplicates) of it. Return an empty list if no palindromic permutation could be form.</p>
<p>For example:</p>
<p>Given <code>s = "aabb"</code>, return <code>["abba", "baab"]</code>.</p>
<p>Given <code>s = "abc"</code>, return <code>[]</code>.</p>
<p>Hint:</p>
<ol id="hints">
<li class="hint animated fadeInLeft">If a palindromic permutation exists, we just need to generate the first half of the string.</li>
</ol>
<p> </p>
<p>这道题是之前那道<a class="entrylistItemTitle" href="http://www.cnblogs.com/grandyang/p/5223238.html" id="CategoryEntryList1_EntryStoryList_ctl00_Entries_TitleUrl_27">Palindrome Permutation</a>的拓展，那道题只是让判断存不存在回文全排列，而这题让我们返回所有的回文全排列，此题给了我们充分的提示：如果回文全排列存在，我们只需要生成前半段字符串即可，后面的直接根据前半段得到。那么我们再进一步思考，由于回文字符串有奇偶两种情况，偶数回文串例如abba，可以平均分成前后半段，而奇数回文串例如abcba，需要分成前中后三段，需要注意的是中间部分只能是一个字符，那么我们可以分析得出，如果一个字符串的回文字符串要存在，那么奇数个的字符只能有0个或1个，其余的必须是偶数个，所以我们可以用哈希表来记录所有字符的出现个数，然后我们找出出现奇数次数的字符加入mid中，如果有两个或两个以上的奇数个数的字符，那么返回空集，我们对于每个字符，不管其奇偶，都将其个数除以2的个数的字符加入t中，这样做的原因是如果是偶数个，那么将其一般加入t中，如果是奇数，如果有1个，那么除以2是0，不会有字符加入t，如果是3个，那么除以2是1，取一个加入t。等我们获得了t之后，t是就是前半段字符，我们对其做全排列，每得到一个全排列，我们加上mid和该全排列的逆序列就是一种所求的回文字符串，这样我们就可以得到所有的回文全排列了。在全排序的子函数中有一点需要注意的是，如果我们直接用数组来保存结果时，并且t中如果有重复字符的话可能会出现重复项，比如 t = "baa" 的话，那么最终生成的结果会有重复项，不信可以自己尝试一下。这里简单的说明一下，当 start=0，i=1 时，我们交换后得到 aba，在之后当 start=1，i=2 时，交换后可以得到 aab。但是在之后回到第一层当baa后，当 start=0，i=2 时，交换后又得到了 aab，重复就产生了。那么其实最简单当去重复的方法就是将结果res定义成HashSet，利用其去重复的特性，可以保证我们得到的是没有重复的，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; generatePalindromes(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        unordered_set</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> res;
        unordered_map</span>&lt;<span style="color: #0000ff;">char</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> m;
        </span><span style="color: #0000ff;">string</span> t = <span style="color: #800000;">""</span>, mid = <span style="color: #800000;">""</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (auto a : s) ++<span style="color: #000000;">m[a];
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto it : m) {
            </span><span style="color: #0000ff;">if</span> (it.second % <span style="color: #800080;">2</span> == <span style="color: #800080;">1</span>) mid +=<span style="color: #000000;"> it.first;
            t </span>+= <span style="color: #0000ff;">string</span>(it.second / <span style="color: #800080;">2</span><span style="color: #000000;">, it.first);
            </span><span style="color: #0000ff;">if</span> (mid.size() &gt; <span style="color: #800080;">1</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;"> {};
        }
        permute(t, </span><span style="color: #800080;">0</span><span style="color: #000000;">, mid, res);
        </span><span style="color: #0000ff;">return</span> vector&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;">(res.begin(), res.end());
    }
    </span><span style="color: #0000ff;">void</span> permute(<span style="color: #0000ff;">string</span> &amp;t, <span style="color: #0000ff;">int</span> start, <span style="color: #0000ff;">string</span> mid, unordered_set&lt;<span style="color: #0000ff;">string</span>&gt; &amp;<span style="color: #000000;">res) {
        </span><span style="color: #0000ff;">if</span> (start &gt;=<span style="color: #000000;"> t.size()) {
            res.insert(t </span>+ mid + <span style="color: #0000ff;">string</span><span style="color: #000000;">(t.rbegin(), t.rend()));
        } 
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = start; i &lt; t.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (i != start &amp;&amp; t[i] == t[start]) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
            swap(t[i], t[start]);
            permute(t, start </span>+ <span style="color: #800080;">1</span><span style="color: #000000;">, mid, res);
            swap(t[i], t[start]);
        }
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种方法和上面的方法很相似，不同之处来于求全排列的方法略有不同，上面那种方法是通过交换字符的位置来生成不同的字符串，而下面这种方法是通过加不同的字符来生成全排列字符串，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; generatePalindromes(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        vector</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> res;
        unordered_map</span>&lt;<span style="color: #0000ff;">char</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> m;
        </span><span style="color: #0000ff;">string</span> t = <span style="color: #800000;">""</span>, mid = <span style="color: #800000;">""</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (auto a : s) ++<span style="color: #000000;">m[a];
        </span><span style="color: #0000ff;">for</span> (auto &amp;<span style="color: #000000;">it : m) {
            </span><span style="color: #0000ff;">if</span> (it.second % <span style="color: #800080;">2</span> == <span style="color: #800080;">1</span>) mid +=<span style="color: #000000;"> it.first;
            it.second </span>/= <span style="color: #800080;">2</span><span style="color: #000000;">;
            t </span>+= <span style="color: #0000ff;">string</span><span style="color: #000000;">(it.second, it.first);
            </span><span style="color: #0000ff;">if</span> (mid.size() &gt; <span style="color: #800080;">1</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;"> {};
        }
        permute(t, m, mid, </span><span style="color: #800000;">""</span><span style="color: #000000;">, res);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">void</span> permute(<span style="color: #0000ff;">string</span> &amp;t, unordered_map&lt;<span style="color: #0000ff;">char</span>, <span style="color: #0000ff;">int</span>&gt; &amp;m, <span style="color: #0000ff;">string</span> mid, <span style="color: #0000ff;">string</span> <span style="color: #0000ff;">out</span>, vector&lt;<span style="color: #0000ff;">string</span>&gt; &amp;<span style="color: #000000;">res) {
        </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">out</span>.size() &gt;=<span style="color: #000000;"> t.size()) {
            res.push_back(</span><span style="color: #0000ff;">out</span> + mid + <span style="color: #0000ff;">string</span>(<span style="color: #0000ff;">out</span>.rbegin(), <span style="color: #0000ff;">out</span><span style="color: #000000;">.rend()));
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;">;
        } 
        </span><span style="color: #0000ff;">for</span> (auto &amp;<span style="color: #000000;">it : m) {
            </span><span style="color: #0000ff;">if</span> (it.second &gt; <span style="color: #800080;">0</span><span style="color: #000000;">) {
                </span>--<span style="color: #000000;">it.second;
                permute(t, m, mid, </span><span style="color: #0000ff;">out</span> +<span style="color: #000000;"> it.first, res);
                </span>++<span style="color: #000000;">it.second;
            }
        }
    }
};</span></pre>
</div>
<p> </p>
<p>在来看一种利用了std提供的<span style="color: #000000;">next_permutation</span>函数来实现的方法，这样就大大减轻了我们的工作量，但是这种方法个人感觉算是有些投机取巧了，不知道面试的时候面试官允不允许这样做，贴上来拓宽一下思路也是好的：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; generatePalindromes(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        vector</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> res;
        unordered_map</span>&lt;<span style="color: #0000ff;">char</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> m;
        </span><span style="color: #0000ff;">string</span> t = <span style="color: #800000;">""</span>, mid = <span style="color: #800000;">""</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (auto a : s) ++<span style="color: #000000;">m[a];
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto it : m) {
            </span><span style="color: #0000ff;">if</span> (it.second % <span style="color: #800080;">2</span> == <span style="color: #800080;">1</span>) mid +=<span style="color: #000000;"> it.first;
            t </span>+= <span style="color: #0000ff;">string</span>(it.second / <span style="color: #800080;">2</span><span style="color: #000000;">, it.first);
            </span><span style="color: #0000ff;">if</span> (mid.size() &gt; <span style="color: #800080;">1</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;"> {};
        }
        sort(t.begin(), t.end());
        </span><span style="color: #0000ff;">do</span><span style="color: #000000;"> {
            res.push_back(t </span>+ mid + <span style="color: #0000ff;">string</span><span style="color: #000000;">(t.rbegin(), t.rend()));
        } </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> (next_permutation(t.begin(), t.end()));
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a class="entrylistItemTitle" href="http://www.cnblogs.com/grandyang/p/4428207.html" id="CategoryEntryList1_EntryStoryList_ctl00_Entries_TitleUrl_167">Next Permutation</a></p>
<p><a class="entrylistItemTitle" href="http://www.cnblogs.com/grandyang/p/5223238.html" id="CategoryEntryList1_EntryStoryList_ctl00_Entries_TitleUrl_27">Palindrome Permutation</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4359825.html" target="_blank">Permutations II</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4358848.html" target="_blank">Permutations</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-03-24 13:51</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5315227" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5315227);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5223238.html" id="cb_post_title_url">[LeetCode] Palindrome Permutation 回文全排列</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a string, determine if a permutation of the string could form a palindrome.</p>
<p>For example,<br/><code>"code"</code> -&gt; False, <code>"aab"</code> -&gt; True, <code>"carerac"</code> -&gt; True.</p>
<p>Hint:</p>
<ol>
<li class="hint animated fadeInLeft">Consider the palindromes of odd vs even length. What difference do you notice?</li>
<li class="hint animated fadeInLeft">Count the frequency of each character.</li>
<li class="hint animated fadeInLeft">If each character occurs even number of times, then it must be a palindrome. How about character which occurs odd number of times?</li>
</ol>
<p> </p>
<p>这道题让我们判断一个字符串的全排列有没有是回文字符串的，那么根据题目中的提示，我们分字符串的个数是奇偶的情况来讨论，如果是偶数的话，由于回文字符串的特性，每个字母出现的次数一定是偶数次，当字符串是奇数长度时，只有一个字母出现的次数是奇数，其余均为偶数，那么利用这个特性我们就可以解题，我们建立每个字母和其出现次数的映射，然后我们遍历哈希表，统计出现次数为奇数的字母的个数，那么只有两种情况是回文数，第一种是没有出现次数为奇数的字母，再一个就是字符串长度为奇数，且只有一个出现次数为奇数的字母，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> canPermutePalindrome(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        unordered_map</span>&lt;<span style="color: #0000ff;">char</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> m;
        </span><span style="color: #0000ff;">int</span> cnt = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (auto a : s) ++<span style="color: #000000;">m[a];
        </span><span style="color: #0000ff;">for</span> (auto it = m.begin(); it != m.end(); ++<span style="color: #000000;">it) {
            </span><span style="color: #0000ff;">if</span> (it-&gt;second % <span style="color: #800080;">2</span>) ++<span style="color: #000000;">cnt;
        }
        </span><span style="color: #0000ff;">return</span> cnt == <span style="color: #800080;">0</span> || (s.size() % <span style="color: #800080;">2</span> == <span style="color: #800080;">1</span> &amp;&amp; cnt == <span style="color: #800080;">1</span><span style="color: #000000;">);
    }
};</span></pre>
</div>
<p> </p>
<p>那么我们再来看一种解法，这种方法用到了一个set，我们遍历字符串，如果某个字母不在set中，我们加入这个字母，如果字母已经存在，我们删除该字母，那么最终如果set中没有字母或是只有一个字母时，说明是回文串，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> canPermutePalindrome(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        </span><span style="color: #0000ff;">set</span>&lt;<span style="color: #0000ff;">char</span>&gt;<span style="color: #000000;"> t;
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto a : s) {
            </span><span style="color: #0000ff;">if</span> (t.find(a) ==<span style="color: #000000;"> t.end()) t.insert(a);
            </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> t.erase(a);
        }
        </span><span style="color: #0000ff;">return</span> t.empty() || t.size() == <span style="color: #800080;">1</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>再来看一种bitset的解法，这种方法也很巧妙，我们建立一个256大小的bitset，每个字母根据其ASCII码值的不同都有其对应的位置，然后我们遍历整个字符串，遇到一个字符，就将其对应的位置的二进制数flip一下，就是0变1，1变0，那么遍历完成后，所有出现次数为偶数的对应位置还应该为0，而出现次数为奇数的时候，对应位置就为1了，那么我们最后只要统计1的个数，就知道出现次数为奇数的字母的个数了，只要个数小于2就是回文数，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> canPermutePalindrome(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        bitset</span>&lt;<span style="color: #800080;">256</span>&gt;<span style="color: #000000;"> b;
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto a : s) {
            b.flip(a);
        }
        </span><span style="color: #0000ff;">return</span> b.count() &lt; <span style="color: #800080;">2</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p class="p1"><span class="s1"><a href="https://leetcode.com/discuss/53180/1-4-lines-python-ruby-c-c-java">https://leetcode.com/discuss/53180/1-4-lines-python-ruby-c-c-java</a></span></p>
<p class="p1"><span class="s1"><a href="https://leetcode.com/discuss/53295/java-solution-w-set-one-pass-without-counters">https://leetcode.com/discuss/53295/java-solution-w-set-one-pass-without-counters</a></span></p>
<p class="p1"> </p>
<p class="p1"><span class="s1"><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></span></p>
<p> </p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-02-27 17:29</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5223238" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5223238);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5322870.html" id="cb_post_title_url">[LeetCode] Paint House II 粉刷房子之二</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>There are a row of <em>n</em> houses, each house can be painted with one of the <em>k</em> colors. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.</p>
<p>The cost of painting each house with a certain color is represented by a <code><em>n</em> x <em>k</em></code> cost matrix. For example, <code>costs[0][0]</code> is the cost of painting house 0 with color 0; <code>costs[1][2]</code>is the cost of painting house 1 with color 2, and so on... Find the minimum cost to paint all houses.</p>
<p>Note:<br/>All costs are positive integers.</p>
<p>Follow up:<br/>Could you solve it in <em>O</em>(<em>nk</em>) runtime?</p>
<p> </p>
<p>这道题是之前那道<a href="http://www.cnblogs.com/grandyang/p/5319384.html" target="_blank">Paint House</a>的拓展，那道题只让用红绿蓝三种颜色来粉刷房子，而这道题让我们用k种颜色，这道题不能用之前那题的解法，会TLE。这题的解法的<span style="line-height: 1.5;">思路还是用DP，但是在找不同颜色的最小值不是遍历所有不同颜色，而是用min1和min2来记录之前房子的最小和第二小的花费的颜色，如果当前房子颜色和min1相同，那么我们用min2对应的值计算，反之我们用min1对应的值，这种解法实际上也包含了求次小值的方法，感觉也是一种很棒的解题思路，参见代码如下：</span></p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> minCostII(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> costs) {
        </span><span style="color: #0000ff;">if</span> (costs.empty() || costs[<span style="color: #800080;">0</span>].empty()) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; dp =<span style="color: #000000;"> costs;
        </span><span style="color: #0000ff;">int</span> min1 = -<span style="color: #800080;">1</span>, min2 = -<span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; dp.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">int</span> last1 = min1, last2 =<span style="color: #000000;"> min2;
            min1 </span>= -<span style="color: #800080;">1</span>; min2 = -<span style="color: #800080;">1</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; dp[i].size(); ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> (j !=<span style="color: #000000;"> last1) {
                    dp[i][j] </span>+= last1 &lt; <span style="color: #800080;">0</span> ? <span style="color: #800080;">0</span> : dp[i - <span style="color: #800080;">1</span><span style="color: #000000;">][last1];
                } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    dp[i][j] </span>+= last2 &lt; <span style="color: #800080;">0</span> ? <span style="color: #800080;">0</span> : dp[i - <span style="color: #800080;">1</span><span style="color: #000000;">][last2];
                }
                </span><span style="color: #0000ff;">if</span> (min1 &lt; <span style="color: #800080;">0</span> || dp[i][j] &lt;<span style="color: #000000;"> dp[i][min1]) {
                    min2 </span>= min1; min1 =<span style="color: #000000;"> j;
                } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (min2 &lt; <span style="color: #800080;">0</span> || dp[i][j] &lt;<span style="color: #000000;"> dp[i][min2]) {
                    min2 </span>=<span style="color: #000000;"> j;
                }
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> dp.back()[min1];
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种解法不需要建立二维dp数组，直接用三个变量就可以保存需要的信息即可，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> minCostII(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> costs) {
        </span><span style="color: #0000ff;">if</span> (costs.empty() || costs[<span style="color: #800080;">0</span>].empty()) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> min1 = <span style="color: #800080;">0</span>, min2 = <span style="color: #800080;">0</span>, idx1 = -<span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; costs.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">int</span> m1 = INT_MAX, m2 = m1, id1 = -<span style="color: #800080;">1</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; costs[i].size(); ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">int</span> cost = costs[i][j] + (j == idx1 ?<span style="color: #000000;"> min2 : min1);
                </span><span style="color: #0000ff;">if</span> (cost &lt;<span style="color: #000000;"> m1) {
                    m2 </span>= m1; m1 = cost; id1 =<span style="color: #000000;"> j;
                } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (cost &lt;<span style="color: #000000;"> m2) {
                    m2 </span>=<span style="color: #000000;"> cost;
                }
            }
            min1 </span>= m1; min2 = m2; idx1 =<span style="color: #000000;"> id1;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> min1;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4650187.html">Product of Array Except Self</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4656517.html">Sliding Window Maximum</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/5319384.html" target="_blank">Paint House</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/5231220.html" target="_blank">Paint Fence</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://leetcode.com/discuss/54415/ac-java-solution-without-extra-space" target="_blank">https://leetcode.com/discuss/54415/ac-java-solution-without-extra-space</a></p>
<p><a href="https://discuss.leetcode.com/topic/30659/easiest-o-1-space-java-solution" target="_blank">https://discuss.leetcode.com/topic/30659/easiest-o-1-space-java-solution</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-03-26 14:26</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5322870" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5322870);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4743837.html" id="cb_post_title_url">[LeetCode] Ugly Number II 丑陋数之二</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Write a program to find the <code>n</code>-th ugly number.</p>
<p>Ugly numbers are positive numbers whose prime factors only include <code>2, 3, 5</code>. For example, <code>1, 2, 3, 4, 5, 6, 8, 9, 10, 12</code> is the sequence of the first <code>10</code> ugly numbers.</p>
<p>Note that <code>1</code> is typically treated as an ugly number.</p>
<p><strong>Hint:</strong></p>
<ol id="hints">
<li class="hint animated fadeInLeft" style="display: list-item;">The naive approach is to call <code>isUgly</code> for every number until you reach the n<sup>th</sup> one. Most numbers are <em>not</em> ugly. Try to focus your effort on generating only the ugly ones.</li>
<li class="hint animated fadeInLeft" style="display: list-item;">An ugly number must be multiplied by either 2, 3, or 5 from a smaller ugly number.</li>
<li class="hint animated fadeInLeft" style="display: list-item;">The key is how to maintain the order of the ugly numbers. Try a similar approach of merging from three sorted lists: L<sub>1</sub>, L<sub>2</sub>, and L<sub>3</sub>.</li>
<li class="hint animated fadeInLeft" style="display: list-item;">Assume you have U<sub>k</sub>, the k<sup>th</sup> ugly number. Then U<sub>k+1</sub> must be Min(L<sub>1</sub> * 2, L<sub>2</sub> * 3, L<sub>3</sub> * 5).</li>
</ol>
<p> </p>
<p>这道题是之前那道<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4741934.html" id="homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0">Ugly Number 丑陋数</a>的延伸，这里让我们找到第n个丑陋数，还好题目中给了很多提示，基本上相当于告诉我们解法了，根据提示中的信息，我们知道丑陋数序列可以拆分为下面3个子列表：</p>
<div>(1) <span style="color: #ff0000;"><strong>1x2</strong></span>,  2x2, <span style="color: #ff0000;"><strong>2x2</strong></span>, 3x2, <span style="color: #ff0000;"><strong>3x2</strong></span>, <span style="color: #ff0000;"><strong>4x2</strong></span>, 5x2...</div>
<div>(2) 1x3,  <span style="color: #ff0000;"><strong>1x3</strong></span>, 2x3, 2x3, <span style="color: #ff0000;"><strong>2x3</strong></span>, 3x3, <strong><span style="color: #ff0000;">3x3</span></strong>...</div>
<div>(3) 1x5,  1x5, 1x5, <strong><span style="color: #ff0000;">1x5</span>,</strong> 2x5, 2x5, 2x5...</div>
<p>仔细观察上述三个列表，我们可以发现每个子列表都是一个丑陋数分别乘以2,3,5，而要求的丑陋数就是从已经生成的序列中取出来的，我们每次都从三个列表中取出当前最小的那个加入序列，请参见代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> nthUglyNumber(<span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; res(<span style="color: #800080;">1</span>, <span style="color: #800080;">1</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">int</span> i2 = <span style="color: #800080;">0</span>, i3 = <span style="color: #800080;">0</span>, i5 = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (res.size() &lt;<span style="color: #000000;"> n) {
            </span><span style="color: #0000ff;">int</span> m2 = res[i2] * <span style="color: #800080;">2</span>, m3 = res[i3] * <span style="color: #800080;">3</span>, m5 = res[i5] * <span style="color: #800080;">5</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">int</span> mn =<span style="color: #000000;"> min(m2, min(m3, m5));
            </span><span style="color: #0000ff;">if</span> (mn == m2) ++<span style="color: #000000;">i2;
            </span><span style="color: #0000ff;">if</span> (mn == m3) ++<span style="color: #000000;">i3;
            </span><span style="color: #0000ff;">if</span> (mn == m5) ++<span style="color: #000000;">i5;
            res.push_back(mn);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res.back();
    }
};</span></pre>
</div>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-08-19 23:28</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4743837" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4743837);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4741934.html" id="cb_post_title_url">[LeetCode] Ugly Number 丑陋数</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Write a program to check whether a given number is an ugly number.</p>
<p>Ugly numbers are positive numbers whose prime factors only include <code>2, 3, 5</code>. For example, <code>6, 8</code> are ugly while <code>14</code> is not ugly since it includes another prime factor <code>7</code>.</p>
<p>Note that <code>1</code> is typically treated as an ugly number.</p>
<p> </p>
<p>这道题让我们检测一个数是否为丑陋数，所谓丑陋数就是其质数因子只能是2,3,5。那么最直接的办法就是不停的除以这些质数，如果剩余的数字是1的话就是丑陋数了，有两种写法，如下所示：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> isUgly(<span style="color: #0000ff;">int</span><span style="color: #000000;"> num) {
        </span><span style="color: #0000ff;">while</span> (num &gt;= <span style="color: #800080;">2</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">if</span> (num % <span style="color: #800080;">2</span> == <span style="color: #800080;">0</span>) num /= <span style="color: #800080;">2</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (num % <span style="color: #800080;">3</span> == <span style="color: #800080;">0</span>) num /= <span style="color: #800080;">3</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (num % <span style="color: #800080;">5</span> == <span style="color: #800080;">0</span>) num /= <span style="color: #800080;">5</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> num == <span style="color: #800080;">1</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> isUgly(<span style="color: #0000ff;">int</span><span style="color: #000000;"> num) {
        </span><span style="color: #0000ff;">if</span> (num &lt;= <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (num % <span style="color: #800080;">2</span> == <span style="color: #800080;">0</span>) num /= <span style="color: #800080;">2</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (num % <span style="color: #800080;">3</span> == <span style="color: #800080;">0</span>) num /= <span style="color: #800080;">3</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (num % <span style="color: #800080;">5</span> == <span style="color: #800080;">0</span>) num /= <span style="color: #800080;">5</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span> num == <span style="color: #800080;">1</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/5144918.html" target="_blank">Super Ugly Number</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4743837.html" target="_blank">Ugly Number II</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://leetcode.com/discuss/60914/my-2ms-java-solution" target="_blank">https://leetcode.com/discuss/60914/my-2ms-java-solution</a></p>
<p><a href="https://leetcode.com/discuss/52703/2-4-lines-every-language" target="_blank">https://leetcode.com/discuss/52703/2-4-lines-every-language</a></p>
<p><a href="https://leetcode.com/discuss/78281/4ms-recursive-solution-in-c" target="_blank">https://leetcode.com/discuss/78281/4ms-recursive-solution-in-c</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-08-19 13:14</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4741934" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4741934);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5373841.html" id="cb_post_title_url">[LeetCode] Trips and Users 旅行和用户</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>The <code>Trips</code> table holds all taxi trips. Each trip has a unique Id, while Client_Id and Driver_Id are both foreign keys to the Users_Id at the <code>Users</code> table. Status is an ENUM type of (‘completed’, ‘cancelled_by_driver’, ‘cancelled_by_client’).</p>
<pre>+----+-----------+-----------+---------+--------------------+----------+
| Id | Client_Id | Driver_Id | City_Id |        Status      |Request_at|
+----+-----------+-----------+---------+--------------------+----------+
| 1  |     1     |    10     |    1    |     completed      |2013-10-01|
| 2  |     2     |    11     |    1    | cancelled_by_driver|2013-10-01|
| 3  |     3     |    12     |    6    |     completed      |2013-10-01|
| 4  |     4     |    13     |    6    | cancelled_by_client|2013-10-01|
| 5  |     1     |    10     |    1    |     completed      |2013-10-02|
| 6  |     2     |    11     |    6    |     completed      |2013-10-02|
| 7  |     3     |    12     |    6    |     completed      |2013-10-02|
| 8  |     2     |    12     |    12   |     completed      |2013-10-03|
| 9  |     3     |    10     |    12   |     completed      |2013-10-03| 
| 10 |     4     |    13     |    12   | cancelled_by_driver|2013-10-03|
+----+-----------+-----------+---------+--------------------+----------+
</pre>
<p>The <code>Users</code> table holds all users. Each user has an unique Users_Id, and Role is an ENUM type of (‘client’, ‘driver’, ‘partner’).</p>
<pre>+----------+--------+--------+
| Users_Id | Banned |  Role  |
+----------+--------+--------+
|    1     |   No   | client |
|    2     |   Yes  | client |
|    3     |   No   | client |
|    4     |   No   | client |
|    10    |   No   | driver |
|    11    |   No   | driver |
|    12    |   No   | driver |
|    13    |   No   | driver |
+----------+--------+--------+
</pre>
<p>Write a SQL query to find the cancellation rate of requests made by unbanned clients between Oct 1, 2013 and Oct 3, 2013. For the above tables, your SQL query should return the following rows with the cancellation rate being rounded to <em>two</em> decimal places.</p>
<pre>+------------+-------------------+
|     Day    | Cancellation Rate |
+------------+-------------------+
| 2013-10-01 |       0.33        |
| 2013-10-02 |       0.00        |
| 2013-10-03 |       0.50        |
+------------+-------------------+</pre>
<p> </p>
<p>这道题给了我们一个Trips表里面有一些Id和状态，还有请求时间，然后还有一个Users表，里面有顾客和司机的信息，然后有该顾客和司机有没有被Ban的信息，让我们返回一个结果看某个时间段内由没有被ban的顾客提出的取消率是多少，其实题目没有说清楚顾客到底包不包括司机，其实是包括的，由司机提出的取消请求也应计算进去，我们用Case When ... Then ... Else ... End关键字来做，我们用cancelled%来表示开头是cancelled的所有项，这样就包括了driver和client，然后分母是所有项，限制条件里限定了时间段，然后是没有被ban的，由于结果需要保留两位小数，所以我们用Round关键字且给定参数2即可，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">SELECT</span> t.Request_at <span style="color: #ff00ff;">Day</span>, <span style="color: #ff00ff;">ROUND</span>(<span style="color: #ff00ff;">SUM</span>(<span style="color: #ff00ff;">CASE</span> <span style="color: #0000ff;">WHEN</span> t.Status <span style="color: #808080;">LIKE</span> <span style="color: #ff0000;">'</span><span style="color: #ff0000;">cancelled%</span><span style="color: #ff0000;">'</span> <span style="color: #0000ff;">THEN</span> <span style="color: #800000; font-weight: bold;">1</span> <span style="color: #0000ff;">ELSE</span> <span style="color: #800000; font-weight: bold;">0</span> <span style="color: #0000ff;">END</span>)<span style="color: #808080;">/</span><span style="color: #ff00ff;">COUNT</span>(<span style="color: #808080;">*</span>), <span style="color: #800000; font-weight: bold;">2</span>) <span style="color: #ff0000;">'</span><span style="color: #ff0000;">Cancellation Rate</span><span style="color: #ff0000;">'</span>
<span style="color: #0000ff;">FROM</span> Trips t <span style="color: #808080;">JOIN</span> Users u <span style="color: #0000ff;">ON</span> t.Client_Id <span style="color: #808080;">=</span> u.Users_Id <span style="color: #808080;">AND</span> u.Banned <span style="color: #808080;">=</span> <span style="color: #ff0000;">'</span><span style="color: #ff0000;">No</span><span style="color: #ff0000;">'</span> 
<span style="color: #0000ff;">WHERE</span> t.Request_at <span style="color: #808080;">BETWEEN</span> <span style="color: #ff0000;">'</span><span style="color: #ff0000;">2013-10-01</span><span style="color: #ff0000;">'</span> <span style="color: #808080;">AND</span> <span style="color: #ff0000;">'</span><span style="color: #ff0000;">2013-10-03</span><span style="color: #ff0000;">'</span> <span style="color: #0000ff;">GROUP</span> <span style="color: #0000ff;">BY</span> t.Request_at;</pre>
</div>
<p> </p>
<p>上面的Case When ... Then ... Else ... End关键字也可以用If关键字来替换，实现的效果一样：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">SELECT</span> Request_at <span style="color: #ff00ff;">Day</span>, <span style="color: #ff00ff;">ROUND</span>(<span style="color: #ff00ff;">COUNT</span>(<span style="color: #0000ff;">IF</span>(Status <span style="color: #808080;">!=</span> <span style="color: #ff0000;">'</span><span style="color: #ff0000;">completed</span><span style="color: #ff0000;">'</span>, TRUE, <span style="color: #0000ff;">NULL</span>)) <span style="color: #808080;">/</span> <span style="color: #ff00ff;">COUNT</span>(<span style="color: #808080;">*</span>), <span style="color: #800000; font-weight: bold;">2</span>) <span style="color: #ff0000;">'</span><span style="color: #ff0000;">Cancellation Rate</span><span style="color: #ff0000;">'</span>
<span style="color: #0000ff;">FROM</span> Trips <span style="color: #0000ff;">WHERE</span> (Request_at <span style="color: #808080;">BETWEEN</span> <span style="color: #ff0000;">'</span><span style="color: #ff0000;">2013-10-01</span><span style="color: #ff0000;">'</span> <span style="color: #808080;">AND</span> <span style="color: #ff0000;">'</span><span style="color: #ff0000;">2013-10-03</span><span style="color: #ff0000;">'</span>) <span style="color: #808080;">AND</span> Client_Id <span style="color: #808080;">IN</span><span style="color: #000000;">
(</span><span style="color: #0000ff;">SELECT</span> Users_Id <span style="color: #0000ff;">FROM</span> Users <span style="color: #0000ff;">WHERE</span> Banned <span style="color: #808080;">=</span> <span style="color: #ff0000;">'</span><span style="color: #ff0000;">No</span><span style="color: #ff0000;">'</span>) <span style="color: #0000ff;">GROUP</span> <span style="color: #0000ff;">BY</span> Request_at;</pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://leetcode.com/discuss/52594/sharing-my-solution" target="_blank">https://leetcode.com/discuss/52594/sharing-my-solution</a></p>
<p><a href="https://leetcode.com/discuss/96599/solution-without-join" target="_blank">https://leetcode.com/discuss/96599/solution-without-join</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-04-10 12:47</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5373841" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5373841);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5257919.html" id="cb_post_title_url">[LeetCode] Graph Valid Tree 图验证树</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given <code>n</code> nodes labeled from <code>0</code> to <code>n - 1</code> and a list of undirected edges (each edge is a pair of nodes), write a function to check whether these edges make up a valid tree.</p>
<p>For example:</p>
<p>Given <code>n = 5</code> and <code>edges = [[0, 1], [0, 2], [0, 3], [1, 4]]</code>, return <code>true</code>.</p>
<p>Given <code>n = 5</code> and <code>edges = [[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]]</code>, return <code>false</code>.</p>
<p>Hint:</p>
<ol id="hints">
<li class="hint animated fadeInLeft">Given <code>n = 5</code> and <code>edges = [[0, 1], [1, 2], [3, 4]]</code>, what should your return? Is this case a valid tree?</li>
<li class="hint animated fadeInLeft">According to the <a href="https://en.wikipedia.org/wiki/Tree_(graph_theory)" target="_blank">definition of tree on Wikipedia</a>: “a tree is an undirected graph in which any two vertices are connected by <em>exactly</em> one path. In other words, any connected graph without simple cycles is a tree.”</li>
</ol>
<p>Note: you can assume that no duplicate edges will appear in <code>edges</code>. Since all edges are undirected, <code>[0, 1]</code> is the same as <code>[1, 0]</code> and thus will not appear together in <code>edges</code>.</p>
<p> </p>
<p>这道题给了我们一个无向图，让我们来判断其是否为一棵树，我们知道如果是树的话，所有的节点必须是连接的，也就是说必须是连通图，而且不能有环，所以我们的焦点就变成了验证是否是连通图和是否含有环。我们首先用DFS来做，根据pair来建立一个图的结构，用邻接链表来表示，还需要一个一位数组v来记录某个节点是否被访问过，然后我们用DFS来搜索节点0，遍历的思想是，当DFS到某个节点，先看当前节点是否被访问过，如果已经被访问过，说明环存在，直接返回false，如果未被访问过，我们现在将其状态标记为已访问过，然后我们到邻接链表里去找跟其相邻的节点继续递归遍历，注意我们还需要一个变量pre来记录上一个节点，以免回到上一个节点，这样遍历结束后，我们就把和节点0相邻的节点都标记为true，然后我们在看v里面是否还有没被访问过的节点，如果有，则说明图不是完全连通的，返回false，反之返回true，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> DFS</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> validTree(<span style="color: #0000ff;">int</span> n, vector&lt;pair&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> edges) {
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; g(n, vector&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;">());
        vector</span>&lt;<span style="color: #0000ff;">bool</span>&gt; v(n, <span style="color: #0000ff;">false</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto a : edges) {
            g[a.first].push_back(a.second);
            g[a.second].push_back(a.first);
        }
        </span><span style="color: #0000ff;">if</span> (!dfs(g, v, <span style="color: #800080;">0</span>, -<span style="color: #800080;">1</span>)) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto a : v) {
            </span><span style="color: #0000ff;">if</span> (!a) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
    </span><span style="color: #0000ff;">bool</span> dfs(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; &amp;g, vector&lt;<span style="color: #0000ff;">bool</span>&gt; &amp;v, <span style="color: #0000ff;">int</span> cur, <span style="color: #0000ff;">int</span><span style="color: #000000;"> pre) {
        </span><span style="color: #0000ff;">if</span> (v[cur]) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        v[cur] </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto a : g[cur]) {
            </span><span style="color: #0000ff;">if</span> (a !=<span style="color: #000000;"> pre) {
                </span><span style="color: #0000ff;">if</span> (!dfs(g, v, a, cur)) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            }
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>下面我们来看BFS的解法，思路很相近，需要用queue来辅助遍历，这里我们没有用一维向量来标记节点是否访问过，而是用了一个set，如果遍历到一个节点，在set中没有，则加入set，如果已经存在，则返回false，还有就是在遍历邻接链表的时候，遍历完成后需要将节点删掉，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> BFS</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> validTree(<span style="color: #0000ff;">int</span> n, vector&lt;pair&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> edges) {
        vector</span>&lt;unordered_set&lt;<span style="color: #0000ff;">int</span>&gt;&gt; g(n, unordered_set&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;">());
        unordered_set</span>&lt;<span style="color: #0000ff;">int</span>&gt; s{{<span style="color: #800080;">0</span><span style="color: #000000;">}};
        queue</span>&lt;<span style="color: #0000ff;">int</span>&gt; q{{<span style="color: #800080;">0</span><span style="color: #000000;">}};
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto a : edges) {
            g[a.first].insert(a.second);
            g[a.second].insert(a.first);
        }
        </span><span style="color: #0000ff;">while</span> (!<span style="color: #000000;">q.empty()) {
            </span><span style="color: #0000ff;">int</span> t =<span style="color: #000000;"> q.front(); q.pop();
            </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto a : g[t]) {
                </span><span style="color: #0000ff;">if</span> (s.count(a)) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                s.insert(a);
                q.push(a);
                g[a].erase(t);
            }
        }
        </span><span style="color: #0000ff;">return</span> s.size() ==<span style="color: #000000;"> n;
    }
};</span></pre>
</div>
<p> </p>
<p>我们再来看Union Find的方法，这种方法对于解决连通图的问题很有效，思想是我们遍历节点，如果两个节点相连，我们将其roots值连上，这样可以帮助我们找到环，我们初始化roots数组为-1，然后对于一个pair的两个节点分别调用find函数，得到的值如果相同的话，则说明环存在，返回false，不同的话，我们将其roots值union上，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> Union Find</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> validTree(<span style="color: #0000ff;">int</span> n, vector&lt;pair&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> edges) {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; roots(n, -<span style="color: #800080;">1</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto a : edges) {
            </span><span style="color: #0000ff;">int</span> x = find(roots, a.first), y =<span style="color: #000000;"> find(roots, a.second);
            </span><span style="color: #0000ff;">if</span> (x == y) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            roots[x] </span>=<span style="color: #000000;"> y;
        }
        </span><span style="color: #0000ff;">return</span> edges.size() == n - <span style="color: #800080;">1</span><span style="color: #000000;">;
    }
    </span><span style="color: #0000ff;">int</span> find(vector&lt;<span style="color: #0000ff;">int</span>&gt; &amp;roots, <span style="color: #0000ff;">int</span><span style="color: #000000;"> i) {
        </span><span style="color: #0000ff;">while</span> (roots[i] != -<span style="color: #800080;">1</span>) i =<span style="color: #000000;"> roots[i];
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> i;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a class="link-post-title" href="http://www.cnblogs.com/grandyang/p/5190419.html" id="link_post_title">Number of Islands II</a></p>
<p><a class="entrylistItemTitle" href="http://www.cnblogs.com/grandyang/p/5166356.html" id="CategoryEntryList1_EntryStoryList_ctl00_Entries_TitleUrl_37">Number of Connected Components in an Undirected Graph</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://leetcode.com/discuss/85398/bfs-java-solution" target="_blank">https://leetcode.com/discuss/85398/bfs-java-solution</a></p>
<p><a href="https://leetcode.com/discuss/80142/my-c-union-find-code" target="_blank">https://leetcode.com/discuss/80142/my-c-union-find-code</a></p>
<p><a href="https://leetcode.com/discuss/52563/ac-java-union-find-solution" target="_blank">https://leetcode.com/discuss/52563/ac-java-union-find-solution</a></p>
<p><a href="https://leetcode.com/discuss/86035/c-dfs-with-adjacent-list-graph" target="_blank">https://leetcode.com/discuss/86035/c-dfs-with-adjacent-list-graph</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-03-09 13:56</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5257919" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5257919);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4741122.html" id="cb_post_title_url">[LeetCode] Single Number III 单独的数字之三</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given an array of numbers <code>nums</code>, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once.</p>
<p>For example:</p>
<p>Given <code>nums = [1, 2, 1, 3, 2, 5]</code>, return <code>[3, 5]</code>.</p>
<p> <strong>Note</strong>:<br/>
</p>
<ol>
<li>The order of the result is not important. So in the above example, <code>[5, 3]</code> is also correct.</li>
<li>Your algorithm should run in linear runtime complexity. Could you implement it using only constant space complexity?</li>
</ol>
<p> </p>
<p>这道题是之前那两道<a href="http://www.cnblogs.com/Given%20an%20array%20of%20integers,%20every%20element%20appears%20three%20times%20except%20for%20one.%20Find%20that%20single%20one.%20%20Note:%20Your%20algorithm%20should%20have%20a%20linear%20runtime%20complexity.%20Could%20you%20implement%20it%20without%20using%20extra%20memory" target="_blank">Single Number 单独的数字</a>和 <a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4263927.html" id="cb_post_title_url">Single Number II 单独的数字之二</a>的再次延伸，说实话，这类位操作Bit Manipulation的题，如果之前没有遇到过类似的题目，楞想是很难相出来的，于是我只能上网搜大神们的解法，发现还真是巧妙啊。这道题其实是很巧妙的利用了<a href="http://www.cnblogs.com/Given%20an%20array%20of%20integers,%20every%20element%20appears%20three%20times%20except%20for%20one.%20Find%20that%20single%20one.%20%20Note:%20Your%20algorithm%20should%20have%20a%20linear%20runtime%20complexity.%20Could%20you%20implement%20it%20without%20using%20extra%20memory" target="_blank">Single Number 单独的数字</a>的解法，因为那道解法是可以准确的找出只出现了一次的数字，但前提是其他数字必须出现两次才行。而这题有两个数字都只出现了一次，那么我们如果能想办法把原数组分为两个小数组，不相同的两个数字分别在两个小数组中，这样分别调用<a href="http://www.cnblogs.com/Given%20an%20array%20of%20integers,%20every%20element%20appears%20three%20times%20except%20for%20one.%20Find%20that%20single%20one.%20%20Note:%20Your%20algorithm%20should%20have%20a%20linear%20runtime%20complexity.%20Could%20you%20implement%20it%20without%20using%20extra%20memory" target="_blank">Single Number 单独的数字</a>的解法就可以得到答案。那么如何实现呢，首先我们先把原数组全部异或起来，那么我们会得到一个数字，这个数字是两个不相同的数字异或的结果，我们取出其中任意一位为‘1’的位，为了方便起见，我们用 a &amp;= -a 来取出最右端为‘1’的位，然后和原数组中的数字挨个相与，那么我们要求的两个不同的数字就被分到了两个小组中，分别将两个小组中的数字都异或起来，就可以得到最终结果了，参见代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; singleNumber(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        </span><span style="color: #0000ff;">int</span> diff = accumulate(nums.begin(), nums.end(), <span style="color: #800080;">0</span>, bit_xor&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;">());</span><span style="color: #000000;">
        diff </span>&amp;= -<span style="color: #000000;">diff;</span><span style="color: #000000;">
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; res(<span style="color: #800080;">2</span>, <span style="color: #800080;">0</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">for</span> (auto &amp;<span style="color: #000000;">a : nums) {
            </span><span style="color: #0000ff;">if</span> (a &amp; diff) res[<span style="color: #800080;">0</span>] ^=<span style="color: #000000;"> a;
            </span><span style="color: #0000ff;">else</span> res[<span style="color: #800080;">1</span>] ^=<span style="color: #000000;"> a;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4263927.html" target="_blank">Single Number II</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4130577.html" target="_blank">Single Number</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://leetcode.com/discuss/52351/accepted-java-space-easy-solution-with-detail-explanations" target="_blank">https://leetcode.com/discuss/52351/accepted-java-space-easy-solution-with-detail-explanations</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-08-19 00:42</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4741122" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4741122);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5235086.html" id="cb_post_title_url">[LeetCode] 3Sum Smaller 三数之和较小值</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p><span style="line-height: 1.5;">Given an array of </span><em style="line-height: 1.5;">n</em><span style="line-height: 1.5;"> integers </span><em style="line-height: 1.5;">nums</em><span style="line-height: 1.5;"> and a </span><em style="line-height: 1.5;">target</em><span style="line-height: 1.5;">, find the number of index triplets </span><code style="line-height: 1.5;">i, j, k</code><span style="line-height: 1.5;"> with </span><code style="line-height: 1.5;">0 &lt;= i &lt; j &lt; k &lt; n</code><span style="line-height: 1.5;"> that satisfy the condition </span><code style="line-height: 1.5;">nums[i] + nums[j] + nums[k] &lt; target</code><span style="line-height: 1.5;">.</span></p>
<div class="row">
<div class="col-md-12">
<div class="row">
<div class="col-md-12">
<div class="question-content">
<p>For example, given <em>nums</em> = <code>[-2, 0, 1, 3]</code>, and <em>target</em> = 2.</p>
<p>Return 2. Because there are two triplets which sums are less than 2:</p>
<pre>[-2, 0, 1]
[-2, 0, 3]
</pre>
<p>Follow up:<br/>Could you solve it in <em>O</em>(<em>n</em>2) runtime?</p>
</div>
</div>
</div>
</div>
</div>
<div> </div>
<div>这道题是3Sum问题的一个变形，让我们求三数之和小于一个目标值，那么最简单的方法就是穷举法，将所有的可能的三个数字的组合都遍历一遍，比较三数之和跟目标值之间的大小，小于的话则结果自增1，参见代码如下:</div>
<div> </div>
<div id="interviewed_div">解法一：</div>
<div>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> O(n^3)</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> threeSumSmaller(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; nums, <span style="color: #0000ff;">int</span><span style="color: #000000;"> target) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        sort(nums.begin(), nums.end());
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; <span style="color: #0000ff;">int</span>(nums.size() - <span style="color: #800080;">2</span>); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">int</span> left = i + <span style="color: #800080;">1</span>, right = nums.size() - <span style="color: #800080;">1</span>, sum = target -<span style="color: #000000;"> nums[i];
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = left; j &lt;= right; ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> k = j + <span style="color: #800080;">1</span>; k &lt;= right; ++<span style="color: #000000;">k) {
                    </span><span style="color: #0000ff;">if</span> (nums[j] + nums[k] &lt; sum) ++<span style="color: #000000;">res;
                }
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>题目中的Follow up让我们在O(n^2)的时间复杂度内实现，那么我们借鉴之前那两道题<a href="http://www.cnblogs.com/grandyang/p/4510984.html" target="_blank">3Sum Closest</a>和<a href="http://www.cnblogs.com/grandyang/p/4481576.html" target="_blank">3Sum</a>中的方法，采用双指针来做，这里面有个trick就是当判断三个数之和小于目标值时，此时结果应该加上right-left，以为数组排序了以后，如果加上num[right]小于目标值的话，那么加上一个更小的数必定也会小于目标值，然后我们将左指针右移一位，否则我们将右指针左移一位，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> O(n^2)</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> threeSumSmaller(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; nums, <span style="color: #0000ff;">int</span><span style="color: #000000;"> target) {
        </span><span style="color: #0000ff;">if</span> (nums.size() &lt; <span style="color: #800080;">3</span>) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, n =<span style="color: #000000;"> nums.size();
        sort(nums.begin(), nums.end());
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n - <span style="color: #800080;">2</span>; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">int</span> left = i + <span style="color: #800080;">1</span>, right = n - <span style="color: #800080;">1</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">while</span> (left &lt;<span style="color: #000000;"> right) {
                </span><span style="color: #0000ff;">if</span> (nums[i] + nums[left] + nums[right] &lt;<span style="color: #000000;"> target) {
                    res </span>+= right -<span style="color: #000000;"> left;
                    </span>++<span style="color: #000000;">left;
                } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    </span>--<span style="color: #000000;">right;
                }
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4510984.html" target="_blank">3Sum Closest</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4481576.html" target="_blank">3Sum</a></p>
</div>
<div> </div>
<div>参考资料：</div>
<div>
<p class="p1"><span class="s1"><a href="https://leetcode.com/discuss/85994/13-lines-concise-and-easy-understand-c-solution">https://leetcode.com/discuss/85994/13-lines-concise-and-easy-understand-c-solution</a></span></p>
<p class="p1"><span class="s1"><a href="https://leetcode.com/discuss/56164/simple-and-easy-understanding-o-n-2-java-solution">https://leetcode.com/discuss/56164/simple-and-easy-understanding-o-n-2-java-solution</a></span></p>
<p class="p1"> </p>
<p class="p1"><span class="s1"><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></span></p>
</div></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-03-02 15:16</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5235086" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5235086);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4741028.html" id="cb_post_title_url">[LeetCode] Add Digits 加数字</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a non-negative integer <code>num</code>, repeatedly add all its digits until the result has only one digit.</p>
<p>For example:</p>
<p>Given <code>num = 38</code>, the process is like: <code>3 + 8 = 11</code>, <code>1 + 1 = 2</code>. Since <code>2</code> has only one digit, return it.</p>
<p><strong>Follow up:</strong><br/>
Could you do it without any loop/recursion in O(1) runtime?
</p>
<p><strong>Hint:</strong></p>
<ol>
<li class="hint animated fadeInLeft" style="display: list-item;">A naive implementation of the above process is trivial. Could you come up with other methods? </li>
<li class="hint animated fadeInLeft" style="display: list-item;">What are all the possible results?</li>
<li class="hint animated fadeInLeft" style="display: list-item;">How do they occur, periodically or randomly?</li>
<li class="hint animated fadeInLeft" style="display: list-item;">You may find this <a href="https://en.wikipedia.org/wiki/Digital_root" target="_blank">Wikipedia article</a> useful.</li>
</ol>
<p> </p>
<p>这道题让我们求<a href="https://zh.wikipedia.org/zh/%E6%95%B8%E6%A0%B9" target="_blank">数根</a>，所谓树根，就是将大于10的数的各个位上的数字相加，若结果还大于0的话，则继续相加，直到数字小于10为止。那么根据这个性质，我们可以写出一个解法如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> addDigits(<span style="color: #0000ff;">int</span><span style="color: #000000;"> num) {
        </span><span style="color: #0000ff;">while</span> (num / <span style="color: #800080;">10</span> &gt; <span style="color: #800080;">0</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">int</span> sum = <span style="color: #800080;">0</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">while</span> (num &gt; <span style="color: #800080;">0</span><span style="color: #000000;">) {
                sum </span>+= num % <span style="color: #800080;">10</span><span style="color: #000000;">;
                num </span>/= <span style="color: #800080;">10</span><span style="color: #000000;">;
            }
            num </span>=<span style="color: #000000;"> sum;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> num;
    }
};</span></pre>
</div>
<p> </p>
<p>但是这个解法在出题人看来又trivial又naive，需要想点高逼格的解法，一行搞定碉堡了，那么我们先来观察1到20的所有的树根：</p>
<p>1    1<br/>2    2<br/>3    3<br/>4    4<br/>5    5<br/>6    6<br/>7    7<br/>8    8    <br/>9    9    <br/>10    1<br/>11    2<br/>12    3    <br/>13    4<br/>14    5<br/>15    6<br/>16    7<br/>17    8<br/>18    9<br/>19    1<br/>20    2</p>
<p> </p>
<p>根据上面的列举，我们可以得出规律，每9个一循环，所有大于9的数的树根都是对9取余，那么对于等于9的数对9取余就是0了，为了得到其本身，而且同样也要对大于9的数适用，我们就用(n-1)%9+1这个表达式来包括所有的情况，所以解法如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> addDigits(<span style="color: #0000ff;">int</span><span style="color: #000000;"> num) {
        </span><span style="color: #0000ff;">return</span> (num - <span style="color: #800080;">1</span>) % <span style="color: #800080;">9</span> + <span style="color: #800080;">1</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p>
<p> </p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-08-18 23:36</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4741028" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4741028);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4738031.html" id="cb_post_title_url">[LeetCode] Binary Tree Paths 二叉树路径</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a binary tree, return all root-to-leaf paths.</p>
<p>For example, given the following binary tree:</p>
<p> </p>
<pre>   1
 /   \
2     3
 \
  5
</pre>
<p>All root-to-leaf paths are:</p>
<pre>["1-&gt;2-&gt;5", "1-&gt;3"]</pre>
<p> </p>
<p>这道题给我们一个二叉树，让我们返回所有根到叶节点的路径，跟之前那道<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4042156.html" id="cb_post_title_url">Path Sum II</a>很类似，比那道稍微简单一些，不需要计算路径和，只需要无脑返回所有的路径即可，那么思路还是用递归来解，博主之前就强调过，玩树的题目，十有八九都是递归，而递归的核心就是不停的DFS到叶结点，然后在回溯回去。在递归函数中，当我们遇到叶结点的时候，即没有左右子结点，那么此时一条完整的路径已经形成了，我们加上当前的叶结点后存入结果res中，然后回溯。注意这里结果res需要reference，而out是不需要引用的，不然回溯回去还要删除新添加的结点，很麻烦。为了减少判断空结点的步骤，我们在调用递归函数之前都检验一下非空即可，代码而很简洁，参见如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; binaryTreePaths(TreeNode*<span style="color: #000000;"> root) {
        vector</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">if</span> (root) helper(root, <span style="color: #800000;">""</span><span style="color: #000000;">, res);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">void</span> helper(TreeNode* node, <span style="color: #0000ff;">string</span> <span style="color: #0000ff;">out</span>, vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp;<span style="color: #000000;"> res) {
        </span><span style="color: #0000ff;">if</span> (!node-&gt;left &amp;&amp; !node-&gt;right) res.push_back(<span style="color: #0000ff;">out</span> + to_string(node-&gt;<span style="color: #000000;">val));
        </span><span style="color: #0000ff;">if</span> (node-&gt;left) helper(node-&gt;left, <span style="color: #0000ff;">out</span> + to_string(node-&gt;val) + <span style="color: #800000;">"</span><span style="color: #800000;">-&gt;</span><span style="color: #800000;">"</span><span style="color: #000000;">, res);
        </span><span style="color: #0000ff;">if</span> (node-&gt;right) helper(node-&gt;right, <span style="color: #0000ff;">out</span> + to_string(node-&gt;val) + <span style="color: #800000;">"</span><span style="color: #800000;">-&gt;</span><span style="color: #800000;">"</span><span style="color: #000000;">, res);
    }
};</span></pre>
</div>
<p> </p>
<p>下面再来看一种递归的方法，这个方法直接在一个函数中完成递归调用，不需要另写一个helper函数，核心思想和上面没有区别，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; binaryTreePaths(TreeNode*<span style="color: #000000;"> root) {
        </span><span style="color: #0000ff;">if</span> (!root) <span style="color: #0000ff;">return</span><span style="color: #000000;"> {};
        </span><span style="color: #0000ff;">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) <span style="color: #0000ff;">return</span> {to_string(root-&gt;<span style="color: #000000;">val)};
        vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; left = binaryTreePaths(root-&gt;<span style="color: #000000;">left);
        vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; right = binaryTreePaths(root-&gt;<span style="color: #000000;">right);
        left.insert(left.end(), right.begin(), right.end());
        </span><span style="color: #0000ff;">for</span> (auto &amp;<span style="color: #000000;">a : left) {
            a </span>= to_string(root-&gt;val) + <span style="color: #800000;">"</span><span style="color: #800000;">-&gt;</span><span style="color: #800000;">"</span> +<span style="color: #000000;"> a;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> left;
    }
};</span></pre>
</div>
<p> </p>
<p>还是递归写法，从论坛中扒下来的解法，核心思路都一样啦，写法各有不同而已，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; binaryTreePaths(TreeNode*<span style="color: #000000;"> root) {
        </span><span style="color: #0000ff;">if</span> (!root) <span style="color: #0000ff;">return</span><span style="color: #000000;"> {};
        </span><span style="color: #0000ff;">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) <span style="color: #0000ff;">return</span> {to_string(root-&gt;<span style="color: #000000;">val)};
        vector</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">string</span> str : binaryTreePaths(root-&gt;<span style="color: #000000;">left)) {
            res.push_back(to_string(root</span>-&gt;val) + <span style="color: #800000;">"</span><span style="color: #800000;">-&gt;</span><span style="color: #800000;">"</span> +<span style="color: #000000;"> str);
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">string</span> str : binaryTreePaths(root-&gt;<span style="color: #000000;">right)) {
            res.push_back(to_string(root</span>-&gt;val) + <span style="color: #800000;">"</span><span style="color: #800000;">-&gt;</span><span style="color: #800000;">"</span> +<span style="color: #000000;"> str);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4042156.html" target="_blank">Path Sum II</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-08-17 22:45</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4738031" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4738031);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5319384.html" id="cb_post_title_url">[LeetCode] Paint House 粉刷房子</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>There are a row of <em>n</em> houses, each house can be painted with one of the three colors: red, blue or green. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.</p>
<p>The cost of painting each house with a certain color is represented by a <code><em>n</em> x <em>3</em></code> cost matrix. For example, <code>costs[0][0]</code> is the cost of painting house 0 with color red; <code>costs[1][2]</code> is the cost of painting house 1 with color green, and so on... Find the minimum cost to paint all houses.</p>
<p>Note:<br/>All costs are positive integers.</p>
<p> </p>
<p>这道题说有n个房子，每个房子可以用红绿蓝三种颜色刷，每个房子的用每种颜色刷的花费都不同，限制条件是相邻的房子不能用相同的颜色来刷，现在让我们求刷完所有的房子的最低花费是多少。这题跟<a href="http://www.cnblogs.com/grandyang/p/4518674.html" target="_blank">House Robber II</a>和<a href="http://www.cnblogs.com/grandyang/p/4383632.html" target="_blank">House Robber</a>很类似，不过那题不是每个房子都抢，相邻的房子不抢，而这道题是每个房子都刷，相邻的房子不能刷同一种颜色。而<a class="entrylistItemTitle" href="http://www.cnblogs.com/grandyang/p/5231220.html" id="CategoryEntryList1_EntryStoryList_ctl00_Entries_TitleUrl_24">Paint Fence</a>那道题主要考察我们有多少种刷法，这几道题很类似，但都不一样，需要我们分别区分。但是它们的解题思想都一样，需要用动态规划Dynamic Programming来做，这道题我们需要维护一个二维的动态数组dp，其中dp[i][j]表示刷到第i+1房子用颜色j的最小花费，递推式为:</p>
<p>dp[i][j] = dp[i][j] + <span style="color: #800080;"><span style="color: #800080;"><span style="color: #800080;"><span style="color: #800080;"><span style="color: #800080;"><span style="color: #800080;"><span style="color: #000000;">min(dp[i - 1][(j + 1) % 3], dp[i - 1][(j + 2) % 3])；</span></span></span></span></span></span></span></p>
<p>这个也比较好理解，如果当前的房子要用红色刷，那么上一个房子只能用绿色或蓝色来刷，那么我们要求刷到当前房子，且当前房子用红色刷的最小花费就等于当前房子用红色刷的钱加上刷到上一个房子用绿色和刷到上一个房子用蓝色的较小值，这样当我们算到最后一个房子时，我们只要取出三个累计花费的最小值即可，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> minCost(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> costs) {
        </span><span style="color: #0000ff;">if</span> (costs.empty() || costs[<span style="color: #800080;">0</span>].empty()) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; dp =<span style="color: #000000;"> costs;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt; dp.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; <span style="color: #800080;">3</span>; ++<span style="color: #000000;">j) {
                dp[i][j] </span>+= min(dp[i - <span style="color: #800080;">1</span>][(j + <span style="color: #800080;">1</span>) % <span style="color: #800080;">3</span>], dp[i - <span style="color: #800080;">1</span>][(j + <span style="color: #800080;">2</span>) % <span style="color: #800080;">3</span><span style="color: #000000;">]);
            }
        }
        </span><span style="color: #0000ff;">return</span> min(min(dp.back()[<span style="color: #800080;">0</span>], dp.back()[<span style="color: #800080;">1</span>]), dp.back()[<span style="color: #800080;">2</span><span style="color: #000000;">]);
    }
};</span></pre>
</div>
<p> </p>
<p>由于只有红绿蓝三张颜色，所以我们就可以分别写出各种情况，这样写可能比上面的写法更加一目了然一些，更容易理解一点吧：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> minCost(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> costs) {
        </span><span style="color: #0000ff;">if</span> (costs.empty() || costs[<span style="color: #800080;">0</span>].empty()) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; dp =<span style="color: #000000;"> costs;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt; dp.size(); ++<span style="color: #000000;">i) {
            dp[i][</span><span style="color: #800080;">0</span>] += min(dp[i - <span style="color: #800080;">1</span>][<span style="color: #800080;">1</span>], dp[i - <span style="color: #800080;">1</span>][<span style="color: #800080;">2</span><span style="color: #000000;">]);
            dp[i][</span><span style="color: #800080;">1</span>] += min(dp[i - <span style="color: #800080;">1</span>][<span style="color: #800080;">0</span>], dp[i - <span style="color: #800080;">1</span>][<span style="color: #800080;">2</span><span style="color: #000000;">]);
            dp[i][</span><span style="color: #800080;">2</span>] += min(dp[i - <span style="color: #800080;">1</span>][<span style="color: #800080;">0</span>], dp[i - <span style="color: #800080;">1</span>][<span style="color: #800080;">1</span><span style="color: #000000;">]);
        }
        </span><span style="color: #0000ff;">return</span> min(min(dp.back()[<span style="color: #800080;">0</span>], dp.back()[<span style="color: #800080;">1</span>]), dp.back()[<span style="color: #800080;">2</span><span style="color: #000000;">]);
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4518674.html" target="_blank">House Robber II</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4383632.html" target="_blank">House Robber</a></p>
<p><a class="entrylistItemTitle" href="http://www.cnblogs.com/grandyang/p/5231220.html" id="CategoryEntryList1_EntryStoryList_ctl00_Entries_TitleUrl_24">Paint Fence</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://leetcode.com/discuss/51721/simple-java-dp-solution" target="_blank">https://leetcode.com/discuss/51721/simple-java-dp-solution</a></p>
<p><a href="https://leetcode.com/discuss/63863/simple-15-line-code-with-o-n-time-and-o-1-memory-solution-java" target="_blank">https://leetcode.com/discuss/63863/simple-15-line-code-with-o-n-time-and-o-1-memory-solution-java</a></p>
<p> </p>
<p><span class="s1"><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></span></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-03-25 14:30</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5319384" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5319384);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5327635.html" id="cb_post_title_url">[LeetCode] Verify Preorder Sequence in Binary Search Tree 验证二叉搜索树的先序序列</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given an array of numbers, verify whether it is the correct preorder traversal sequence of a binary search tree.</p>
<p>You may assume each number in the sequence is unique.</p>
<p><strong>Follow up:</strong><br/>
Could you do it using only constant space complexity?</p>
<p> </p>
<p>这道题让给了我们一个一维数组，让我们验证其是否为一个二叉搜索树的先序遍历出的顺序，我们都知道二叉搜索树的性质是左&lt;根&lt;右，如果用中序遍历得到的结果就是有序数组，而先序遍历的结果就不是有序数组了，但是难道一点规律都没有了吗，其实规律还是有的，根据二叉搜索树的性质，当前节点的值一定大于其左子树中任何一个节点值，而且其右子树中的任何一个节点值都不能小于当前节点值，那么我们可以用这个性质来验证，举个例子，比如下面这棵二叉搜索树：</p>
<div class="cnblogs_code">
<pre>     <span style="color: #800080;">5</span>
    /<span style="color: #000000;"> \
   </span><span style="color: #800080;">2</span>   <span style="color: #800080;">6</span>
  /<span style="color: #000000;"> \
 </span><span style="color: #800080;">1</span>   <span style="color: #800080;">3</span></pre>
</div>
<p>其先序遍历的结果是{5, 2, 1, 3, 6}, 我们先设一个最小值low，然后遍历数组，如果当前值小于这个最小值low，返回false，对于根节点，我们将其压入栈中，然后往后遍历，如果遇到的数字比栈顶元素小，说明是其左子树的点，继续压入栈中，直到遇到的数字比栈顶元素大，那么就是右边的值了，我们需要找到是哪个节点的右子树，所以我们更新low值并删掉栈顶元素，然后继续和下一个栈顶元素比较，如果还是大于，则继续更新low值和删掉栈顶，直到栈为空或者当前栈顶元素大于当前值停止，压入当前值，这样如果遍历完整个数组之前都没有返回false的话，最后返回true即可，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> verifyPreorder(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> preorder) {
        </span><span style="color: #0000ff;">int</span> low =<span style="color: #000000;"> INT_MIN;
        stack</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> s;
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto a : preorder) {
            </span><span style="color: #0000ff;">if</span> (a &lt; low) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">while</span> (!s.empty() &amp;&amp; a &gt;<span style="color: #000000;"> s.top()) {
                low </span>=<span style="color: #000000;"> s.top(); s.pop();
            }
            s.push(a);
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种方法和上面的思路相同，为了使空间复杂度为常量，我们不能使用stack，所以我们直接修改preorder，将low值存在preorder的特定位置即可，前提是不能影响当前的遍历，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> verifyPreorder(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> preorder) {
        </span><span style="color: #0000ff;">int</span> low = INT_MIN, i = -<span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto a : preorder) {
            </span><span style="color: #0000ff;">if</span> (a &lt; low) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">while</span> (i &gt;= <span style="color: #800080;">0</span> &amp;&amp; a &gt;<span style="color: #000000;"> preorder[i]) {
                low </span>= preorder[i--<span style="color: #000000;">];
            }
            preorder[</span>++i] =<span style="color: #000000;"> a;
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种方法使用了分治法，跟之前那道验证二叉搜索树的题<a href="http://www.cnblogs.com/grandyang/p/4298435.html" target="_blank">Validate Binary Search Tree</a>的思路很类似，我们在递归函数中维护一个下界lower和上届upper，那么当前遍历到的节点值必须在(lower, upper)区间之内，然后我们在给定的区间内搜第一个大于当前节点值的点，然后以此为分界，左右两部分分别调用递归函数，注意左半部分的upper更新为当前节点值val，表明左子树的节点值都必须小于当前节点值，而右半部分的递归的lower更新为当前节点值val，表明右子树的节点值都必须大于当前节点值，如果左右两部分的返回结果均为真，则整体返回真，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> verifyPreorder(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> preorder) {
        </span><span style="color: #0000ff;">return</span> helper(preorder, <span style="color: #800080;">0</span>, preorder.size() - <span style="color: #800080;">1</span><span style="color: #000000;">, INT_MIN, INT_MAX);
    }
    </span><span style="color: #0000ff;">bool</span> helper(vector&lt;<span style="color: #0000ff;">int</span>&gt; &amp;preorder, <span style="color: #0000ff;">int</span> start, <span style="color: #0000ff;">int</span> end, <span style="color: #0000ff;">int</span> lower, <span style="color: #0000ff;">int</span><span style="color: #000000;"> upper) {
        </span><span style="color: #0000ff;">if</span> (start &gt; end) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> val = preorder[start], i = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (val &lt;= lower || val &gt;= upper) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (i = start + <span style="color: #800080;">1</span>; i &lt;= end; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (preorder[i] &gt;= val) <span style="color: #0000ff;">break</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> helper(preorder, start + <span style="color: #800080;">1</span>, i - <span style="color: #800080;">1</span>, lower, val) &amp;&amp;<span style="color: #000000;"> helper(preorder, i, end, val, upper);
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4146981.html" target="_blank">Binary Tree Preorder Traversal</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4298435.html" target="_blank">Validate Binary Search Tree</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://leetcode.com/discuss/51543/java-o-n-and-o-1-extra-space" target="_blank">https://leetcode.com/discuss/51543/java-o-n-and-o-1-extra-space</a></p>
<p><a href="https://leetcode.com/discuss/87663/easy-to-follow-c-recursive-solution-o-nlogn" target="_blank">https://leetcode.com/discuss/87663/easy-to-follow-c-recursive-solution-o-nlogn</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-03-28 05:55</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5327635" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5327635);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5332722.html" id="cb_post_title_url">[LeetCode] Factor Combinations 因子组合</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Numbers can be regarded as product of its factors. For example,</p>
<pre>8 = 2 x 2 x 2;
  = 2 x 4.
</pre>
<p>Write a function that takes an integer <em>n</em> and return all possible combinations of its factors.</p>
<p>Note: </p>
<ol>
<li>Each combination's factors must be sorted ascending, for example: The factors of 2 and 6 is <code>[2, 6]</code>, not <code>[6, 2]</code>.</li>
<li>You may assume that <em>n</em> is always positive.</li>
<li>Factors should be greater than 1 and less than <em>n</em>.</li>
</ol>
<p> </p>
<p>Examples: <br/>input: <code>1</code><br/>output: </p>
<pre>[]
</pre>
<p>input: <code>37</code><br/>output: </p>
<pre>[]
</pre>
<p>input: <code>12</code><br/>output:</p>
<pre>[
  [2, 6],
  [2, 2, 3],
  [3, 4]
]
</pre>
<p>input: <code>32</code><br/>output:</p>
<pre>[
  [2, 16],
  [2, 2, 8],
  [2, 2, 2, 4],
  [2, 2, 2, 2, 2],
  [2, 4, 4],
  [4, 8]
]</pre>
<p> </p>
<p>这道题给了我们一个正整数n，让我们写出所有的因子相乘的形式，而且规定了因子从小到大的顺序排列，那么对于这种需要列出所有的情况的题目，通常都是用回溯法来求解的，由于题目中说明了1和n本身不能算其因子，那么我们可以从2开始遍历到n，如果当前的数i可以被n整除，说明i是n的一个因子，我们将其存入一位数组out中，然后递归调用n/i，此时不从2开始遍历，而是从i遍历到n/i，停止的条件是当n等于1时，如果此时out中有因子，我们将这个组合存入结果res中，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; getFactors(<span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;<span style="color: #000000;"> res;
        helper(n, </span><span style="color: #800080;">2</span><span style="color: #000000;">, {}, res);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">void</span> helper(<span style="color: #0000ff;">int</span> n, <span style="color: #0000ff;">int</span> start, vector&lt;<span style="color: #0000ff;">int</span>&gt; <span style="color: #0000ff;">out</span>, vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; &amp;<span style="color: #000000;">res) {
        </span><span style="color: #0000ff;">if</span> (n == <span style="color: #800080;">1</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">out</span>.size() &gt; <span style="color: #800080;">1</span>) res.push_back(<span style="color: #0000ff;">out</span><span style="color: #000000;">);
        } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = start; i &lt;= n; ++<span style="color: #000000;">i) {
                </span><span style="color: #0000ff;">if</span> (n % i == <span style="color: #800080;">0</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">out</span><span style="color: #000000;">.push_back(i);
                    helper(n </span>/ i, i, <span style="color: #0000ff;">out</span><span style="color: #000000;">, res);
                    </span><span style="color: #0000ff;">out</span><span style="color: #000000;">.pop_back();
                }
            }
        }
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种方法用了个小trick，我们仔细观察题目中给的两个例子的结果，可以发现每个组合的第一个数字都没有超过n的平方根，这个也很好理解，由于要求序列是从小到大排列的，那么如果第一个数字大于了n的平方根，而且n本身又不算因子，那么后面那个因子也必然要与n的平方根，这样乘起来就必然会超过n，所以不会出现这种情况。那么我们刚开始在2到n的平方根之间进行遍历，如果遇到因子，先复制原来的一位数组out为一个新的一位数组new_out，然后把此因子i加入new_out，然后再递归调用n/i，并且从i遍历到n/i的平方根，之后再把n/i放入new_out，并且存入结果res，由于层层迭代的调用，凡是本身能继续拆分成更小因数的都能在之后的迭代中拆分出来，并且加上之前结果，最终都会存res中，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; getFactors(<span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;<span style="color: #000000;"> res;
        helper(n, </span><span style="color: #800080;">2</span><span style="color: #000000;">, {}, res);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">void</span> helper(<span style="color: #0000ff;">int</span> n, <span style="color: #0000ff;">int</span> start, vector&lt;<span style="color: #0000ff;">int</span>&gt; <span style="color: #0000ff;">out</span>, vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; &amp;<span style="color: #000000;">res) {
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = start; i &lt;= sqrt(n); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (n % i == <span style="color: #800080;">0</span><span style="color: #000000;">) {
                vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; new_out = <span style="color: #0000ff;">out</span><span style="color: #000000;">;
                new_out.push_back(i);
                helper(n </span>/<span style="color: #000000;"> i, i, new_out, res);
                new_out.push_back(n </span>/<span style="color: #000000;"> i);
                res.push_back(new_out);
            }
        }
    }
};</span></pre>
</div>
<p> </p>
<p>上面两种解法虽有些小不同，但是构成结果的顺序都是相同，对于题目中给的两个例子n = 12和n = 32，结果如下：</p>
<div class="cnblogs_code">
<pre>n = <span style="color: #800080;">12</span>
<span style="color: #800080;">2</span> <span style="color: #800080;">2</span> <span style="color: #800080;">3</span>
<span style="color: #800080;">2</span> <span style="color: #800080;">6</span>
<span style="color: #800080;">3</span> <span style="color: #800080;">4</span><span style="color: #000000;">

n </span>= <span style="color: #800080;">32</span>
<span style="color: #800080;">2</span> <span style="color: #800080;">2</span> <span style="color: #800080;">2</span> <span style="color: #800080;">2</span> <span style="color: #800080;">2</span>
<span style="color: #800080;">2</span> <span style="color: #800080;">2</span> <span style="color: #800080;">2</span> <span style="color: #800080;">4</span>
<span style="color: #800080;">2</span> <span style="color: #800080;">2</span> <span style="color: #800080;">8</span>
<span style="color: #800080;">2</span> <span style="color: #800080;">4</span> <span style="color: #800080;">4</span>
<span style="color: #800080;">2</span> <span style="color: #800080;">16</span>
<span style="color: #800080;">4</span> <span style="color: #800080;">8</span></pre>
</div>
<p> </p>
<p>上面两种方法得到的结果跟题目中给的答案的顺序不同，虽然顺序不同，但是并不影响其通过OJ。我们下面就给出生成题目中的顺序的解法，这种方法也不难理解，还是从2遍历到n的平方根，如果i是因子，那么我们递归调用n/i，结果用v来保存，然后我们新建一个包含i和n/i两个因子的序列out，然后将其存入结果res, 然后我们再遍历之前递归n/i的所得到的序列，如果i小于等于某个序列的第一个数字，那么我们将其插入该序列的首位置，然后将序列存入结果res中，我们举个例子，比n = 12，那么刚开始i = 2，是因子，然后对6调用递归，得到{2, 3}，然后此时将{2, 6}先存入结果中，然后发现i(此时为2)小于等于{2, 3}中的第一个数字2，那么将2插入首位置得到{2, 2, 3}加入结果，然后此时i变成3，还是因子，对4调用递归，得到{2, 2}，此时先把{3, 4}存入结果，然后发现i(此时为3)大于{2, 2}中的第一个数字2，不做任何处理直接返回，这样我们就得到正确的结果了：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; getFactors(<span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;<span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">2</span>; i * i &lt;= n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (n % i == <span style="color: #800080;">0</span><span style="color: #000000;">) {
                vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; v = getFactors(n /<span style="color: #000000;"> i);
                vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; <span style="color: #0000ff;">out</span>{i, n /<span style="color: #000000;"> i};
                res.push_back(</span><span style="color: #0000ff;">out</span><span style="color: #000000;">);
                </span><span style="color: #0000ff;">for</span> (auto <span style="color: #000000;">a : v) {
                    </span><span style="color: #0000ff;">if</span> (i &lt;= a[<span style="color: #800080;">0</span><span style="color: #000000;">]) {
                        a.insert(a.begin(), i);
                        res.push_back(a);
                    }
                }
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>这种方法对于对于题目中给的两个例子n = 12和n = 32，结果和题目中给的相同：</p>
<div class="cnblogs_code">
<pre>n = <span style="color: #800080;">12</span>
<span style="color: #800080;">2</span> <span style="color: #800080;">6</span>
<span style="color: #800080;">2</span> <span style="color: #800080;">2</span> <span style="color: #800080;">3</span>
<span style="color: #800080;">3</span> <span style="color: #800080;">4</span><span style="color: #000000;">

n </span>= <span style="color: #800080;">32</span>
<span style="color: #800080;">2</span> <span style="color: #800080;">16</span>
<span style="color: #800080;">2</span> <span style="color: #800080;">2</span> <span style="color: #800080;">8</span>
<span style="color: #800080;">2</span> <span style="color: #800080;">2</span> <span style="color: #800080;">2</span> <span style="color: #800080;">4</span>
<span style="color: #800080;">2</span> <span style="color: #800080;">2</span> <span style="color: #800080;">2</span> <span style="color: #800080;">2</span> <span style="color: #800080;">2</span>
<span style="color: #800080;">2</span> <span style="color: #800080;">4</span> <span style="color: #800080;">4</span>
<span style="color: #800080;">4</span> <span style="color: #800080;">8</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a class="link-post-title" href="http://www.cnblogs.com/grandyang/p/4537983.html" id="link_post_title">Combination Sum III</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4419386.html" target="_blank">Combination Sum II</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4419259.html" target="_blank">Combination Sum</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://leetcode.com/discuss/62457/concise-and-straightforward-java-solution" target="_blank">https://leetcode.com/discuss/62457/concise-and-straightforward-java-solution</a></p>
<p><a href="https://leetcode.com/discuss/65106/share-clean-and-simple-0ms-c-solution-with-explanation" target="_blank">https://leetcode.com/discuss/65106/share-clean-and-simple-0ms-c-solution-with-explanation</a></p>
<p><a href="https://leetcode.com/discuss/87331/17-lines-concise-and-easy-understand-solution-backtracking" target="_blank">https://leetcode.com/discuss/87331/17-lines-concise-and-easy-understand-solution-backtracking</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-03-29 13:55</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5332722" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5332722);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5244720.html" id="cb_post_title_url">[LeetCode] Meeting Rooms II 会议室之二</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given an array of meeting time intervals consisting of start and end times <code>[[s1,e1],[s2,e2],...]</code> (si &lt; ei), find the minimum number of conference rooms required.</p>
<p>For example,<br/>Given <code>[[0, 30],[5, 10],[15, 20]]</code>,<br/>return <code>2</code>.</p>
<p> </p>
<p>这道题是之前那道<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/5240774.html" id="homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0">Meeting Rooms</a>的拓展，那道题只让我们是否能参加所有的会，也就是看会议之间有没有时间冲突，而这道题让我们求最少需要安排几个会议室，有时间冲突的肯定需要安排在不同的会议室。这道题有好几种解法，我们先来看使用TreeMap来做的，我们遍历时间区间，对于起始时间，映射值自增1，对于结束时间，映射值自减1，然后我们定义结果变量res，和房间数rooms，我们遍历TreeMap，时间从小到大，房间数每次加上映射值，然后更新结果res，遇到起始时间，映射是正数，则房间数会增加，如果一个时间是一个会议的结束时间，也是另一个会议的开始时间，则映射值先减后加仍为0，并不用分配新的房间，而结束时间的映射值为负数更不会增加房间数，利用这种思路我们可以写出代码如下:</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> minMeetingRooms(vector&lt;Interval&gt;&amp;<span style="color: #000000;"> intervals) {
        map</span>&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> m;
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto a : intervals) {
            </span>++<span style="color: #000000;">m[a.start];
            </span>--<span style="color: #000000;">m[a.end];
        }
        </span><span style="color: #0000ff;">int</span> rooms = <span style="color: #800080;">0</span>, res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto it : m) {
            res </span>= max(res, rooms +=<span style="color: #000000;"> it.second);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>第二种方法是用两个一维数组来做，分别保存起始时间和结束时间，然后各自排个序，我们定义结果变量res和结束时间指针endpos，然后我们开始遍历，如果当前起始时间小于结束时间指针的时间，则结果自增1，反之结束时间指针自增1，这样我们可以找出重叠的时间段，从而安排新的会议室，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> minMeetingRooms(vector&lt;Interval&gt;&amp;<span style="color: #000000;"> intervals) {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> starts, ends;
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, endpos = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto a : intervals) {
            starts.push_back(a.start);
            ends.push_back(a.end);
        }
        sort(starts.begin(), starts.end());
        sort(ends.begin(), ends.end());
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; intervals.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (starts[i] &lt; ends[endpos]) ++<span style="color: #000000;">res;
            </span><span style="color: #0000ff;">else</span> ++<span style="color: #000000;">endpos;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>再来一看一种使用最小堆来解题的方法，这种方法先把所有的时间区间按照起始时间排序，然后新建一个最小堆，开始遍历时间区间，如果堆不为空，且首元素小于等于当前区间的起始时间，我们去掉堆中的首元素，把当前区间的结束时间压入堆，由于最小堆是小的在前面，那么假如首元素小于等于起始时间，说明上一个会议已经结束，可以用该会议室开始下一个会议了，所以不用分配新的会议室，遍历完成后堆中元素的个数即为需要的会议室的个数，参见代码如下；</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> minMeetingRooms(vector&lt;Interval&gt;&amp;<span style="color: #000000;"> intervals) {
        sort(intervals.begin(), intervals.end(), [](</span><span style="color: #0000ff;">const</span> Interval &amp;a, <span style="color: #0000ff;">const</span> Interval &amp;b){<span style="color: #0000ff;">return</span> a.start &lt;<span style="color: #000000;"> b.start;});
        priority_queue</span>&lt;<span style="color: #0000ff;">int</span>, vector&lt;<span style="color: #0000ff;">int</span>&gt;, greater&lt;<span style="color: #0000ff;">int</span>&gt;&gt;<span style="color: #000000;"> q;
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto a : intervals) {
            </span><span style="color: #0000ff;">if</span> (!q.empty() &amp;&amp; q.top() &lt;=<span style="color: #000000;"> a.start) q.pop();
            q.push(a.end);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> q.size();
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/5240774.html" id="homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0">Meeting Rooms</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://leetcode.com/discuss/50948/c-o-n-log-n-584-ms-3-solutions" target="_blank">https://leetcode.com/discuss/50948/c-o-n-log-n-584-ms-3-solutions</a></p>
<p><a href="https://leetcode.com/discuss/71846/super-easy-java-solution-beats-98-8%25" target="_blank">https://leetcode.com/discuss/71846/super-easy-java-solution-beats-98-8%25</a></p>
<p><a href="https://leetcode.com/discuss/64686/concise-c-solution-with-min_heap-sort-greedy" target="_blank">https://leetcode.com/discuss/64686/concise-c-solution-with-min_heap-sort-greedy</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-03-05 13:58</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5244720" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5244720);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5240774.html" id="cb_post_title_url">[LeetCode] Meeting Rooms 会议室</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given an array of meeting time intervals consisting of start and end times <code>[[s1,e1],[s2,e2],...]</code> (si &lt; ei), determine if a person could attend all meetings.</p>
<p>For example,<br/>Given <code>[[0, 30],[5, 10],[15, 20]]</code>,<br/>return <code>false</code>.</p>
<p> </p>
<p>这道题给了我们一堆会议的时间，问我们能不能同时参见所有的会议，这实际上就是求区间是否有交集的问题，那么最简单暴力的方法就是每两个区间比较一下，看是否有overlap，有的话直接返回false就行了。比较两个区间a和b是否有overlap，我们可以检测两种情况，如果a的起始位置大于等于b的起始位置，且此时a的起始位置小于b的结束位置，那么一定有overlap，另一种情况是a和b互换个位置，如果b的起始位置大于等于a的起始位置，且此时b的起始位置小于a的结束位置，那么一定有overlap，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> canAttendMeetings(vector&lt;Interval&gt;&amp;<span style="color: #000000;"> intervals) {
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; intervals.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = i + <span style="color: #800080;">1</span>; j &lt; intervals.size(); ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> ((intervals[i].start &gt;= intervals[j].start &amp;&amp; intervals[i].start &lt; intervals[j].end) || (intervals[j].start &gt;= intervals[i].start &amp;&amp; intervals[j].start &lt; intervals[i].end)) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            }
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>我们可以先给所有区间排个序，用起始时间的先后来排，然后我们从第二个区间开始，如果开始时间早于前一个区间的结束时间，则说明会议时间有冲突，返回false，遍历完成后没有冲突，则返回true，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> canAttendMeetings(vector&lt;Interval&gt;&amp;<span style="color: #000000;"> intervals) {
        sort(intervals.begin(), intervals.end(), [](</span><span style="color: #0000ff;">const</span> Interval &amp;a, <span style="color: #0000ff;">const</span> Interval &amp;b){<span style="color: #0000ff;">return</span> a.start &lt;<span style="color: #000000;"> b.start;});
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt; intervals.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (intervals[i].start &lt; intervals[i - <span style="color: #800080;">1</span><span style="color: #000000;">].end) {
                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            }
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4370601.html" target="_blank">Merge Intervals</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/5244720.html" target="_blank">Meeting Rooms II</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<div id="cnblogs_post_body">
<p class="p1"><span class="s1"><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></span></p>
</div></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-03-04 07:13</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5240774" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5240774);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5209621.html" id="cb_post_title_url">[LeetCode] Flatten 2D Vector 压平二维向量</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Implement an iterator to flatten a 2d vector.</p>
<p>For example,<br/>Given 2d vector =</p>
<pre>[
  [1,2],
  [3],
  [4,5,6]
]
</pre>
<p> </p>
<p>By calling <em>next</em> repeatedly until <em>hasNext</em> returns false, the order of elements returned by <em>next</em> should be: <code>[1,2,3,4,5,6]</code>.</p>
<p>Hint:</p>
<ol id="hints">
<li class="hint animated fadeInLeft">How many variables do you need to keep track?</li>
<li class="hint animated fadeInLeft">Two variables is all you need. Try with <code>x</code> and <code>y</code>.</li>
<li class="hint animated fadeInLeft">Beware of empty rows. It could be the first few rows.</li>
<li class="hint animated fadeInLeft">To write correct code, think about the <a href="https://en.wikipedia.org/wiki/Invariant_(computer_science)" target="_blank">invariant</a> to maintain. What is it?</li>
<li class="hint animated fadeInLeft">The invariant is <code>x</code> and <code>y</code> must always point to a valid point in the 2d vector. Should you maintain your invariant <em>ahead of time</em> or <em>right when you need it</em>?</li>
<li class="hint animated fadeInLeft">Not sure? Think about how you would implement <code>hasNext()</code>. Which is more complex?</li>
<li class="hint animated fadeInLeft">Common logic in two different places should be refactored into a common method.</li>
</ol>
<p>Follow up:<br/>As an added challenge, try to code it using only <a href="http://www.cplusplus.com/reference/iterator/iterator/" target="_blank">iterators in C++</a> or <a href="http://docs.oracle.com/javase/7/docs/api/java/util/Iterator.html" target="_blank">iterators in Java</a>.</p>
<p> </p>
<p>这道题让我们压平一个二维向量数组，并且实现一个iterator的功能，包括next和hasNext函数，那么最简单的方法就是将二维数组按顺序先存入到一个一维数组里，然后此时只要维护一个变量i来记录当前遍历到的位置，hasNext函数看当前坐标是否小于元素总数，next函数即为取出当前位置元素，坐标后移一位，参见代码如下：                      </p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Vector2D {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    Vector2D(vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> vec2d) {
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto a : vec2d) {
            v.insert(v.end(), a.begin(), a.end());
        }    
    }
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> next() {
        </span><span style="color: #0000ff;">return</span> v[i++<span style="color: #000000;">];
    }
    </span><span style="color: #0000ff;">bool</span><span style="color: #000000;"> hasNext() {
        </span><span style="color: #0000ff;">return</span> i &lt;<span style="color: #000000;"> v.size();
    }
</span><span style="color: #0000ff;">private</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> v;
    </span><span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span><span style="color: #000000;">;
};</span></pre>
</div>
<p> </p>
<p>下面我们来看另一种解法，不直接转换为一维数组，而是维护两个变量x和y，我们将x和y初始化为0，对于hasNext函数，我们检查当前x是否小于总行数，y是否和当前行的列数相同，如果相同，说明要转到下一行，则x自增1，y初始化为0，若此时x还是小于总行数，说明下一个值可以被取出来，那么在next函数就可以直接取出行为x，列为y的数字，并将y自增1，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Vector2D {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    Vector2D(vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> vec2d) {
        v </span>=<span style="color: #000000;"> vec2d;
        x </span>= y = <span style="color: #800080;">0</span><span style="color: #000000;">;
    }
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> next() {
        </span><span style="color: #0000ff;">return</span> v[x][y++<span style="color: #000000;">];
    }
    </span><span style="color: #0000ff;">bool</span><span style="color: #000000;"> hasNext() {
        </span><span style="color: #0000ff;">while</span> (x &lt; v.size() &amp;&amp; y ==<span style="color: #000000;"> v[x].size()) {
            </span>++<span style="color: #000000;">x; 
            y </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> x &lt;<span style="color: #000000;"> v.size();
    }    
</span><span style="color: #0000ff;">private</span><span style="color: #000000;">:
    vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;<span style="color: #000000;"> v;
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> x, y;
};</span></pre>
</div>
<p> </p>
<p>题目中的Follow up让我们用interator来做，C++中iterator不像Java中的那么强大，自己本身并没有包含next和hasNext函数，所以我们得自己来实现，我们将x定义为行的iterator，再用个end指向二维数组的末尾，定义一个整型变量y来指向列位置，实现思路和上一种解法完全相同，只是写法略有不同，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Vector2D {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    Vector2D(vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> vec2d) {
        x </span>=<span style="color: #000000;"> vec2d.begin();
        end </span>=<span style="color: #000000;"> vec2d.end();
    }
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> next() {
        </span><span style="color: #0000ff;">return</span> (*x)[y++<span style="color: #000000;">];
    }
    </span><span style="color: #0000ff;">bool</span><span style="color: #000000;"> hasNext() {
        </span><span style="color: #0000ff;">while</span> (x != end &amp;&amp; y == (*<span style="color: #000000;">x).size()) {
            </span>++<span style="color: #000000;">x; 
            y </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> x !=<span style="color: #000000;"> end;
    }
</span><span style="color: #0000ff;">private</span><span style="color: #000000;">:
    vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;<span style="color: #000000;">::iterator x, end;
    </span><span style="color: #0000ff;">int</span> y = <span style="color: #800080;">0</span><span style="color: #000000;">;
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://leetcode.com/discuss/52614/2-short-c-solution" target="_blank">https://leetcode.com/discuss/52614/2-short-c-solution</a></p>
<p><a href="https://leetcode.com/discuss/50292/7-9-lines-added-java-and-c-o-1-space" target="_blank">https://leetcode.com/discuss/50292/7-9-lines-added-java-and-c-o-1-space</a></p>
<p><a href="https://leetcode.com/discuss/50259/20ms-c-solution-with-explanations?show=50295#a50295" target="_blank">https://leetcode.com/discuss/50259/20ms-c-solution-with-explanations?show=50295#a50295</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-02-23 13:37</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5209621" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5209621);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5206862.html" id="cb_post_title_url">[LeetCode] Count Univalue Subtrees 计数相同值子树的个数</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="row">
<div class="col-md-12">
<div class="row">
<div class="col-md-12">
<div class="question-content">
<p>Given a binary tree, count the number of uni-value subtrees.</p>
<p>A Uni-value subtree means all nodes of the subtree have the same value.</p>
<p>For example:<br/>Given binary tree,</p>
<pre>              5
             / \
            1   5
           / \   \
          5   5   5
</pre>
<p> </p>
<p>return <code>4</code>.</p>
<p> </p>
<p>这道题让我们求相同值子树的个数，就是所有节点值都相同的子树的个数，之前有道求最大BST子树的题<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/5188938.html" id="homepage1_HomePageDays_DaysList_ctl07_DayList_TitleUrl_0">Largest BST Subtree</a>，感觉挺像的，都是关于子树的问题，解题思路也可以参考一下，我们可以用递归来做，第一种解法的思路是先序遍历树的所有的节点，然后对每一个节点调用判断以当前节点为根的字数的所有节点是否相同，判断方法可以参考之前那题<a href="http://www.cnblogs.com/grandyang/p/4053384.html" target="_blank">Same Tree</a>，用的是分治法的思想，分别对左右字数分别调用递归，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">int</span> countUnivalSubtrees(TreeNode*<span style="color: #000000;"> root) {
        </span><span style="color: #0000ff;">if</span> (!root) <span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">if</span> (isUnival(root, root-&gt;val)) ++<span style="color: #000000;">res;
        countUnivalSubtrees(root</span>-&gt;<span style="color: #000000;">left);
        countUnivalSubtrees(root</span>-&gt;<span style="color: #000000;">right);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">bool</span> isUnival(TreeNode *root, <span style="color: #0000ff;">int</span><span style="color: #000000;"> val) {
        </span><span style="color: #0000ff;">if</span> (!root) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span> root-&gt;val == val &amp;&amp; isUnival(root-&gt;left, val) &amp;&amp; isUnival(root-&gt;<span style="color: #000000;">right, val);
    }
}; </span></pre>
</div>
<p> </p>
<p>但是上面的那种解法不是很高效，含有大量的重复check，我们想想能不能一次遍历就都搞定，我们这样想，符合条件的相同值的字数肯定是有叶节点的，而且叶节点也都相同(注意单独的一个叶节点也被看做是一个相同值子树)，那么我们可以从下往上check，采用后序遍历的顺序，左右根，我们还是递归调用函数，对于当前遍历到的节点，如果对其左右子节点分别递归调用函数，返回均为true的话，那么说明当前节点的值和左右子树的值都相同，那么又多了一棵树，所以结果自增1，然后返回当前节点值和给定值(其父节点值)是否相同，从而回归上一层递归调用。这里特别说明一下在子函数中要使用的那个单竖杠或，为什么不用双竖杠的或，因为单竖杠的或是位或，就是说左右两部分都需要被计算，然后再或，C++这里将true当作1，false当作0，然后进行Bit OR 运算。不能使用双竖杠或的原因是，如果是双竖杠或，一旦左半边为true了，整个就直接是true了，右半边就不会再计算了，这样的话，一旦右子树中有值相同的子树也不会被计算到结果res中了，参见代码如下：</p>
</div>
</div>
</div>
</div>
</div>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> countUnivalSubtrees(TreeNode*<span style="color: #000000;"> root) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        isUnival(root, </span>-<span style="color: #800080;">1</span><span style="color: #000000;">, res);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">bool</span> isUnival(TreeNode* root, <span style="color: #0000ff;">int</span> val, <span style="color: #0000ff;">int</span>&amp;<span style="color: #000000;"> res) {
        </span><span style="color: #0000ff;">if</span> (!root) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (!isUnival(root-&gt;left, root-&gt;val, res) | !isUnival(root-&gt;right, root-&gt;<span style="color: #000000;">val, res)) {
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        }
        </span>++<span style="color: #000000;">res;
        </span><span style="color: #0000ff;">return</span> root-&gt;val ==<span style="color: #000000;"> val;
    }
};</span></pre>
</div>
<p> </p>
<p>我们还可以变一种写法，让递归函数直接返回以当前节点为根的相同值子树的个数，然后参数里维护一个引用类型的布尔变量，表示以当前节点为根的子树是否为相同值子树，我们首先对当前节点的左右子树分别调用递归函数，然后把结果加起来，我们现在要来看当前节点是不是和其左右子树节点值相同，当前我们首先要确认左右子节点的布尔型变量均为true，这样保证左右子节点分别都是相同值子树的根，然后我们看如果左子节点存在，那么左子节点值需要和当前节点值相同，如果右子节点存在，那么右子节点值要和当前节点值相同，若上述条件均满足的话，说明当前节点也是相同值子树的根节点，返回值再加1，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> countUnivalSubtrees(TreeNode*<span style="color: #000000;"> root) {
        </span><span style="color: #0000ff;">bool</span> b = <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> isUnival(root, b);
    }
    </span><span style="color: #0000ff;">int</span> isUnival(TreeNode *root, <span style="color: #0000ff;">bool</span> &amp;<span style="color: #000000;">b) {
        </span><span style="color: #0000ff;">if</span> (!root) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">bool</span> l = <span style="color: #0000ff;">true</span>, r = <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> res = isUnival(root-&gt;left, l) + isUnival(root-&gt;<span style="color: #000000;">right, r);
        b </span>= l &amp;&amp; r &amp;&amp; (root-&gt;left ? root-&gt;val == root-&gt;left-&gt;val : <span style="color: #0000ff;">true</span>) &amp;&amp; (root-&gt;right ? root-&gt;val == root-&gt;right-&gt;val : <span style="color: #0000ff;">true</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">return</span> res +<span style="color: #000000;"> b;
    }
};</span></pre>
</div>
<p> </p>
<p>上面三种都是令人看得头晕的递归写法，那么我们也来看一种迭代的写法，迭代写法是在后序遍历<a href="http://www.cnblogs.com/grandyang/p/4251757.html" target="_blank">Binary Tree Postorder Traversal</a>的基础上修改而来，我们需要用set来保存所有相同值子树的根节点，对于我们遍历到的节点，如果其左右子节点均不存在，那么此节点为叶节点，符合题意，加入结果set中，如果左子节点不存在，那么右子节点必须已经在结果set中，而且当前节点值需要和右子节点值相同才能将当前节点加入结果set中，同样的，如果右子节点不存在，那么左子节点必须已经存在set中，而且当前节点值要和左子节点值相同才能将当前节点加入结果set中。最后，如果左右子节点均存在，那么必须都已经在set中，并且左右子节点值都要和根节点值相同才能将当前节点加入结果set中，其余部分跟后序遍历的迭代写法一样，参见代码如下：</p>
<p> </p>
<p>解法四：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> countUnivalSubtrees(TreeNode*<span style="color: #000000;"> root) {
        </span><span style="color: #0000ff;">set</span>&lt;TreeNode*&gt;<span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">if</span> (!root) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        stack</span>&lt;TreeNode*&gt;<span style="color: #000000;"> s;
        s.push(root);
        TreeNode </span>*head =<span style="color: #000000;"> root;
        </span><span style="color: #0000ff;">while</span> (!<span style="color: #000000;">s.empty()) {
            TreeNode </span>*t =<span style="color: #000000;"> s.top(); 
            </span><span style="color: #0000ff;">if</span> ((!t-&gt;left &amp;&amp; !t-&gt;right) || t-&gt;left == head || t-&gt;right ==<span style="color: #000000;"> head) {
                </span><span style="color: #0000ff;">if</span> (!t-&gt;left &amp;&amp; !t-&gt;<span style="color: #000000;">right) {
                    res.insert(t);
                } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (!t-&gt;left &amp;&amp; res.find(t-&gt;right) != res.end() &amp;&amp; t-&gt;right-&gt;val == t-&gt;<span style="color: #000000;">val) {
                    res.insert(t);
                } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (!t-&gt;right &amp;&amp; res.find(t-&gt;left) != res.end() &amp;&amp; t-&gt;left-&gt;val == t-&gt;<span style="color: #000000;">val) {
                    res.insert(t);
                } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (t-&gt;left &amp;&amp; t-&gt;right &amp;&amp; res.find(t-&gt;left) != res.end() &amp;&amp; res.find(t-&gt;right) != res.end() &amp;&amp; t-&gt;left-&gt;val == t-&gt;val &amp;&amp; t-&gt;right-&gt;val == t-&gt;<span style="color: #000000;">val) {
                    res.insert(t);
                }
                s.pop();
                head </span>=<span style="color: #000000;"> t;
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                </span><span style="color: #0000ff;">if</span> (t-&gt;right) s.push(t-&gt;<span style="color: #000000;">right);
                </span><span style="color: #0000ff;">if</span> (t-&gt;left) s.push(t-&gt;<span style="color: #000000;">left);
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res.size();
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/6828687.html" target="_blank">Subtree of Another Tree</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/7636259.html"> Longest Univalue Path</a></p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/5188938.html" id="homepage1_HomePageDays_DaysList_ctl07_DayList_TitleUrl_0">Largest BST Subtree</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4251757.html" target="_blank">Binary Tree Postorder Traversal</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4053384.html" target="_blank">Same Tree</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://leetcode.com/discuss/66705/c-7-lines-solution" target="_blank">https://leetcode.com/discuss/66705/c-7-lines-solution</a></p>
<p><a href="https://leetcode.com/discuss/69376/my-c-solution-easy-to-understand" target="_blank">https://leetcode.com/discuss/69376/my-c-solution-easy-to-understand</a></p>
<p><a href="https://leetcode.com/discuss/54295/my-accepted-java-iterative-solution" target="_blank">https://leetcode.com/discuss/54295/my-accepted-java-iterative-solution</a></p>
<p><a href="https://leetcode.com/discuss/64078/recursive-and-iterative-solution-with-detailed-explanation" target="_blank">https://leetcode.com/discuss/64078/recursive-and-iterative-solution-with-detailed-explanation</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-02-22 13:34</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5206862" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5206862);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5204770.html" id="cb_post_title_url">[LeetCode] Group Shifted Strings 群组偏移字符串</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="row">
<div class="col-md-12">
<div class="row">
<div class="col-md-12">
<div class="question-content">
<p>Given a string, we can "shift" each of its letter to its successive letter, for example: <code>"abc" -&gt; "bcd"</code>. We can keep "shifting" which forms the sequence:</p>
<pre>"abc" -&gt; "bcd" -&gt; ... -&gt; "xyz"</pre>
<p>Given a list of strings which contains only lowercase alphabets, group all strings that belong to the same shifting sequence.</p>
<p>For example, given: <code>["abc", "bcd", "acef", "xyz", "az", "ba", "a", "z"]</code>, <br/>Return:</p>
<pre>[
  ["abc","bcd","xyz"],
  ["az","ba"],
  ["acef"],
  ["a","z"]
]</pre>
<p> </p>
<p>Note: For the return value, each <em>inner</em> list's elements must follow the lexicographic order.</p>
</div>
</div>
</div>
</div>
</div>
<div id="interviewed_div"> </div>
<p>这道题让我们重组偏移字符串，所谓偏移字符串，就是一个字符串的每个字符按照字母顺序表偏移相同量得到的另一个字符串，两者互为偏移字符串，注意相同字符串是偏移字符串的一种特殊情况，因为偏移量为0。现在给了我们一堆长度不同的字符串，让我们把互为偏移字符串的归并到一起，我最开始想的是建立字符度和该长度的所有偏移字符串的映射，但是很明显的错误是相同长度的不一定都是偏移字符串，比如'ab'和'ba‘，所以只能用哈希表来建立一个字符串和所有和此字符串是偏移字符串的集合之间的映射，由于题目要求结果是按字母顺序的，所以用multiset来保存结果，一来可以保存重复字符串，二来可以自动排序。然后我还写了一个判断二个字符串是否互为偏移字符串的函数，注意在比较两个字母距离时采用了加26，再对26取余的trick。我们遍历给定字符串集，对于遍历到的字符串，我们再遍历哈希表，和每个关键字调用isShifted函数来比较，如果互为偏移字符串，则加入其对应的字符串集，并标记flag，最后遍历完哈希表，没有跟任何关键字互为偏移，那么就新建一个映射，最后要做的就是把multiset转换为vector即可，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> Correct but complicated</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;vector&lt;<span style="color: #0000ff;">string</span>&gt;&gt; groupStrings(vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp;<span style="color: #000000;"> strings) {
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">string</span>&gt; &gt;<span style="color: #000000;"> res;
        unordered_map</span>&lt;<span style="color: #0000ff;">string</span>, multiset&lt;<span style="color: #0000ff;">string</span>&gt;&gt;<span style="color: #000000;"> m;
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto a : strings) {
            </span><span style="color: #0000ff;">bool</span> b = <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">for</span> (auto it = m.begin(); it != m.end(); ++<span style="color: #000000;">it) {
                </span><span style="color: #0000ff;">if</span> (isShifted(it-&gt;<span style="color: #000000;">first, a)) {
                    it</span>-&gt;<span style="color: #000000;">second.insert(a);
                    b </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                }
            }
            </span><span style="color: #0000ff;">if</span> (!b) m[a] =<span style="color: #000000;"> {a};
        }
        </span><span style="color: #0000ff;">for</span> (auto it = m.begin(); it != m.end(); ++<span style="color: #000000;">it) {
            res.push_back(vector</span>&lt;<span style="color: #0000ff;">string</span>&gt;(it-&gt;second.begin(), it-&gt;<span style="color: #000000;">second.end()));
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">bool</span> isShifted(<span style="color: #0000ff;">string</span> s1, <span style="color: #0000ff;">string</span><span style="color: #000000;"> s2) {
        </span><span style="color: #0000ff;">if</span> (s1.size() != s2.size()) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> diff = (s1[<span style="color: #800080;">0</span>] + <span style="color: #800080;">26</span> - s2[<span style="color: #800080;">0</span>]) % <span style="color: #800080;">26</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt; s1.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> ((s1[i] + <span style="color: #800080;">26</span> - s2[i]) % <span style="color: #800080;">26</span> != diff) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>上面那个方法挺复杂的，其实有更好的方法，网友的智慧无穷啊，上面那个方法的不高效之处在于对于每个遍历到的字符串，都要和哈希表中所有的关键字都比较一次，而其实我们可以更加巧妙的利用偏移字符串的特点，那就是字符串的每个字母和首字符的相对距离都是相等的，比如abc和efg互为偏移，对于abc来说，b和a的距离是1，c和a的距离是2，对于efg来说，f和e的距离是1，g和e的距离是2。再来看一个例子，az和yx，z和a的距离是25，x和y的距离也是25(直接相减是-1，这就是要加26然后取余的原因)，那么这样的话，所有互为偏移的字符串都有个unique的距离差，我们根据这个来建立映射就可以很好的进行单词分组了，这个思路真实太赞了，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;vector&lt;<span style="color: #0000ff;">string</span>&gt;&gt; groupStrings(vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp;<span style="color: #000000;"> strings) {
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">string</span>&gt; &gt;<span style="color: #000000;"> res;
        unordered_map</span>&lt;<span style="color: #0000ff;">string</span>, multiset&lt;<span style="color: #0000ff;">string</span>&gt;&gt;<span style="color: #000000;"> m;
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto a : strings) {
            </span><span style="color: #0000ff;">string</span> t = <span style="color: #800000;">""</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span><span style="color: #000000;"> c : a) {
                t </span>+= to_string((c + <span style="color: #800080;">26</span> - a[<span style="color: #800080;">0</span>]) % <span style="color: #800080;">26</span>) + <span style="color: #800000;">"</span><span style="color: #800000;">,</span><span style="color: #800000;">"</span><span style="color: #000000;">;
            }
            m[t].insert(a);
        }
        </span><span style="color: #0000ff;">for</span> (auto it = m.begin(); it != m.end(); ++<span style="color: #000000;">it) {
            res.push_back(vector</span>&lt;<span style="color: #0000ff;">string</span>&gt;(it-&gt;second.begin(), it-&gt;<span style="color: #000000;">second.end()));
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://leetcode.com/discuss/70907/c-concise-solution-using-unordered_map" target="_blank">https://leetcode.com/discuss/70907/c-concise-solution-using-unordered_map</a></p>
<p><a href="https://leetcode.com/discuss/81897/12-lines-java-solution-with-explanation" target="_blank">https://leetcode.com/discuss/81897/12-lines-java-solution-with-explanation</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-02-21 12:51</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5204770" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5204770);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5203228.html" id="cb_post_title_url">[LeetCode] Strobogrammatic Number III 对称数之三</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="row">
<div class="col-md-12">
<div class="row">
<div class="col-md-12">
<div class="question-content">
<p>A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).</p>
<p>Write a function to count the total strobogrammatic numbers that exist in the range of low &lt;= num &lt;= high.</p>
<p>For example,<br/>Given low = "50", high = "100", return 3. Because 69, 88, and 96 are three strobogrammatic numbers.</p>
<p>Note:<br/>Because the range might be a large number, the <em>low</em> and <em>high</em> numbers are represented as string.</p>
<p> </p>
<div>
<div class="btn btn-xs btn-warning" id="tags">Show Tags</div>
</div>
<div>
<div class="btn btn-xs btn-warning" id="similar">Show Similar Problems</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="interviewed_div"> </div>
<p>这道题是之前那两道<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/5200919.html" id="homepage1_HomePageDays_DaysList_ctl01_DayList_TitleUrl_0">Strobogrammatic Number II</a>和<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/5196960.html" id="homepage1_HomePageDays_DaysList_ctl02_DayList_TitleUrl_0">Strobogrammatic Number</a>的拓展，又增加了难度，让我们找到给定范围内的对称数的个数，我们当然不能一个一个的判断是不是对称数，我们也不能直接每个长度调用第二道中的方法，保存所有的对称数，然后再统计个数，这样OJ会提示内存超过允许的范围，所以我们的解法是基于第二道的基础上，不保存所有的结果，而是在递归中直接计数，根据之前的分析，需要初始化n=0和n=1的情况，然后在其基础上进行递归，递归的长度len从low到high之间遍历，然后我们看当前单词长度有没有达到len，如果达到了，我们首先要去掉开头是0的多位数，然后去掉长度和low相同但小于low的数，和长度和high相同但大于high的数，然后结果自增1，然后分别给当前单词左右加上那五对对称数，继续递归调用，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> strobogrammaticInRange(<span style="color: #0000ff;">string</span> low, <span style="color: #0000ff;">string</span><span style="color: #000000;"> high) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = low.size(); i &lt;= high.size(); ++<span style="color: #000000;">i) {
            find(low, high, </span><span style="color: #800000;">""</span><span style="color: #000000;">, i, res);
            find(low, high, </span><span style="color: #800000;">"</span><span style="color: #800000;">0</span><span style="color: #800000;">"</span><span style="color: #000000;">, i, res);
            find(low, high, </span><span style="color: #800000;">"</span><span style="color: #800000;">1</span><span style="color: #800000;">"</span><span style="color: #000000;">, i, res);
            find(low, high, </span><span style="color: #800000;">"</span><span style="color: #800000;">8</span><span style="color: #800000;">"</span><span style="color: #000000;">, i, res);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">void</span> find(<span style="color: #0000ff;">string</span> low, <span style="color: #0000ff;">string</span> high, <span style="color: #0000ff;">string</span> path, <span style="color: #0000ff;">int</span> len, <span style="color: #0000ff;">int</span> &amp;<span style="color: #000000;">res) {
        </span><span style="color: #0000ff;">if</span> (path.size() &gt;=<span style="color: #000000;"> len) {
            </span><span style="color: #0000ff;">if</span> (path.size() != len || (len != <span style="color: #800080;">1</span> &amp;&amp; path[<span style="color: #800080;">0</span>] == <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span>)) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> ((len == low.size() &amp;&amp; path.compare(low) &lt; <span style="color: #800080;">0</span>) || (len == high.size() &amp;&amp; path.compare(high) &gt; <span style="color: #800080;">0</span><span style="color: #000000;">)) {
                </span><span style="color: #0000ff;">return</span><span style="color: #000000;">;
            }
            </span>++<span style="color: #000000;">res;
        }
        find(low, high, </span><span style="color: #800000;">"</span><span style="color: #800000;">0</span><span style="color: #800000;">"</span> + path + <span style="color: #800000;">"</span><span style="color: #800000;">0</span><span style="color: #800000;">"</span><span style="color: #000000;">, len, res);
        find(low, high, </span><span style="color: #800000;">"</span><span style="color: #800000;">1</span><span style="color: #800000;">"</span> + path + <span style="color: #800000;">"</span><span style="color: #800000;">1</span><span style="color: #800000;">"</span><span style="color: #000000;">, len, res);
        find(low, high, </span><span style="color: #800000;">"</span><span style="color: #800000;">6</span><span style="color: #800000;">"</span> + path + <span style="color: #800000;">"</span><span style="color: #800000;">9</span><span style="color: #800000;">"</span><span style="color: #000000;">, len, res);
        find(low, high, </span><span style="color: #800000;">"</span><span style="color: #800000;">8</span><span style="color: #800000;">"</span> + path + <span style="color: #800000;">"</span><span style="color: #800000;">8</span><span style="color: #800000;">"</span><span style="color: #000000;">, len, res);
        find(low, high, </span><span style="color: #800000;">"</span><span style="color: #800000;">9</span><span style="color: #800000;">"</span> + path + <span style="color: #800000;">"</span><span style="color: #800000;">6</span><span style="color: #800000;">"</span><span style="color: #000000;">, len, res);
    }
};</span></pre>
</div>
<p> </p>
<p>上述代码可以稍微优化一下，得到如下的代码：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> strobogrammaticInRange(<span style="color: #0000ff;">string</span> low, <span style="color: #0000ff;">string</span><span style="color: #000000;"> high) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        find(low, high, </span><span style="color: #800000;">""</span><span style="color: #000000;">, res);
        find(low, high, </span><span style="color: #800000;">"</span><span style="color: #800000;">0</span><span style="color: #800000;">"</span><span style="color: #000000;">, res);
        find(low, high, </span><span style="color: #800000;">"</span><span style="color: #800000;">1</span><span style="color: #800000;">"</span><span style="color: #000000;">, res);
        find(low, high, </span><span style="color: #800000;">"</span><span style="color: #800000;">8</span><span style="color: #800000;">"</span><span style="color: #000000;">, res);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">void</span> find(<span style="color: #0000ff;">string</span> low, <span style="color: #0000ff;">string</span> high, <span style="color: #0000ff;">string</span> w, <span style="color: #0000ff;">int</span> &amp;<span style="color: #000000;">res) {
        </span><span style="color: #0000ff;">if</span> (w.size() &gt;= low.size() &amp;&amp; w.size() &lt;=<span style="color: #000000;"> high.size()) {
            </span><span style="color: #0000ff;">if</span> ((w.size() == low.size() &amp;&amp; w.compare(low) &lt; <span style="color: #800080;">0</span>) || (w.size() == high.size() &amp;&amp; w.compare(high) &gt; <span style="color: #800080;">0</span><span style="color: #000000;">)) {
                </span><span style="color: #0000ff;">return</span><span style="color: #000000;">;
            }
            </span><span style="color: #0000ff;">if</span> (!(w.size() &gt; <span style="color: #800080;">1</span> &amp;&amp; w[<span style="color: #800080;">0</span>] == <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span>)) ++<span style="color: #000000;">res;
        }
        </span><span style="color: #0000ff;">if</span> (w.size() + <span style="color: #800080;">2</span> &gt; high.size()) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
        find(low, high, </span><span style="color: #800000;">"</span><span style="color: #800000;">0</span><span style="color: #800000;">"</span> + w + <span style="color: #800000;">"</span><span style="color: #800000;">0</span><span style="color: #800000;">"</span><span style="color: #000000;">, res);
        find(low, high, </span><span style="color: #800000;">"</span><span style="color: #800000;">1</span><span style="color: #800000;">"</span> + w + <span style="color: #800000;">"</span><span style="color: #800000;">1</span><span style="color: #800000;">"</span><span style="color: #000000;">, res);
        find(low, high, </span><span style="color: #800000;">"</span><span style="color: #800000;">6</span><span style="color: #800000;">"</span> + w + <span style="color: #800000;">"</span><span style="color: #800000;">9</span><span style="color: #800000;">"</span><span style="color: #000000;">, res);
        find(low, high, </span><span style="color: #800000;">"</span><span style="color: #800000;">8</span><span style="color: #800000;">"</span> + w + <span style="color: #800000;">"</span><span style="color: #800000;">8</span><span style="color: #800000;">"</span><span style="color: #000000;">, res);
        find(low, high, </span><span style="color: #800000;">"</span><span style="color: #800000;">9</span><span style="color: #800000;">"</span> + w + <span style="color: #800000;">"</span><span style="color: #800000;">6</span><span style="color: #800000;">"</span><span style="color: #000000;">, res);
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/5200919.html" id="homepage1_HomePageDays_DaysList_ctl01_DayList_TitleUrl_0">Strobogrammatic Number II</a></p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/5196960.html" id="homepage1_HomePageDays_DaysList_ctl02_DayList_TitleUrl_0">Strobogrammatic Number</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://leetcode.com/discuss/73721/easiest-20ms-94%25-java-solution" target="_blank">https://leetcode.com/discuss/73721/easiest-20ms-94%25-java-solution</a></p>
<p><a href="https://leetcode.com/discuss/59824/my-java-solution-easy-to-understand" target="_blank">https://leetcode.com/discuss/59824/my-java-solution-easy-to-understand</a></p>
<p><a href="https://leetcode.com/discuss/55468/clear-java-ac-solution-using-strobogrammatic-number-method" target="_blank">https://leetcode.com/discuss/55468/clear-java-ac-solution-using-strobogrammatic-number-method</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p>
<p> </p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-02-20 14:28</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5203228" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5203228);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5200919.html" id="cb_post_title_url">[LeetCode] Strobogrammatic Number II 对称数之二</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).</p>
<p>Find all strobogrammatic numbers that are of length = n.</p>
<p>For example,<br/>Given n = 2, return <code>["11","69","88","96"]</code>.</p>
<p>Hint:</p>
<ol>
<li class="hint animated fadeInLeft">Try to use recursion and notice that it should recurse with <em>n</em> - 2 instead of <em>n</em> - 1.</li>
</ol>
<p> </p>
<p>这道题是之前那道<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/5196960.html" id="homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0">Strobogrammatic Number</a>的拓展，那道题让我们判断一个数是否是对称数，而这道题让我们找出长度为n的所有的对称数，我们肯定不能一个数一个数的来判断，那样太不高效了，而且OJ肯定也不会答应。题目中给了提示说可以用递归来做，而且提示了递归调用n-2，而不是n-1。我们先来列举一下n为0,1,2,3,4的情况：</p>
<p>n = 0:   none</p>
<p>n = 1:   0, 1, 8</p>
<p>n = 2:   11, 69, 88, 96</p>
<p>n = 3:   101, 609, 808, 906, 111, 619, 818, 916, 181, 689, 888, 986</p>
<p>n = 4:   1001, 6009, 8008, 9006, 1111, 6119, 8118, 9116, 1691, 6699, 8698, 9696, 1881, 6889, 8888, 9886, 1961, 6969, 8968, 9966</p>
<p>我们注意观察n=0和n=2，可以发现后者是在前者的基础上，每个数字的左右增加了[1 1], [6 9], [8 8], [9 6]，看n=1和n=3更加明显，在0的左右增加[1 1]，变成了101, 在0的左右增加[6 9]，变成了609, 在0的左右增加[8 8]，变成了808, 在0的左右增加[9 6]，变成了906, 然后在分别在1和8的左右两边加那四组数，我们实际上是从m=0层开始，一层一层往上加的，需要注意的是当加到了n层的时候，左右两边不能加[0 0]，因为0不能出现在两位数及多位数的开头，在中间递归的过程中，需要有在数字左右两边各加上0的那种情况，参见代码如下：  </p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; findStrobogrammatic(<span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> find(n, n);
    }
    vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; find(<span style="color: #0000ff;">int</span> m, <span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        </span><span style="color: #0000ff;">if</span> (m == <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span> {<span style="color: #800000;">""</span><span style="color: #000000;">};
        </span><span style="color: #0000ff;">if</span> (m == <span style="color: #800080;">1</span>) <span style="color: #0000ff;">return</span> {<span style="color: #800000;">"</span><span style="color: #800000;">0</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">1</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">8</span><span style="color: #800000;">"</span><span style="color: #000000;">};
        vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; t = find(m - <span style="color: #800080;">2</span><span style="color: #000000;">, n), res;
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto a : t) {
            </span><span style="color: #0000ff;">if</span> (m != n) res.push_back(<span style="color: #800000;">"</span><span style="color: #800000;">0</span><span style="color: #800000;">"</span> + a + <span style="color: #800000;">"</span><span style="color: #800000;">0</span><span style="color: #800000;">"</span><span style="color: #000000;">);
            res.push_back(</span><span style="color: #800000;">"</span><span style="color: #800000;">1</span><span style="color: #800000;">"</span> + a + <span style="color: #800000;">"</span><span style="color: #800000;">1</span><span style="color: #800000;">"</span><span style="color: #000000;">);
            res.push_back(</span><span style="color: #800000;">"</span><span style="color: #800000;">6</span><span style="color: #800000;">"</span> + a + <span style="color: #800000;">"</span><span style="color: #800000;">9</span><span style="color: #800000;">"</span><span style="color: #000000;">);
            res.push_back(</span><span style="color: #800000;">"</span><span style="color: #800000;">8</span><span style="color: #800000;">"</span> + a + <span style="color: #800000;">"</span><span style="color: #800000;">8</span><span style="color: #800000;">"</span><span style="color: #000000;">);
            res.push_back(</span><span style="color: #800000;">"</span><span style="color: #800000;">9</span><span style="color: #800000;">"</span> + a + <span style="color: #800000;">"</span><span style="color: #800000;">6</span><span style="color: #800000;">"</span><span style="color: #000000;">);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>这道题还有迭代的解法，感觉也相当的巧妙，需要从奇偶来考虑，奇数赋为0,1,8，偶数赋为空，如果是奇数，就从i=3开始搭建，因为计算i=3需要i=1，而我们已经初始化了i=1的情况，如果是偶数，我们从i=2开始搭建，我们也已经初始化了i=0的情况，所以我们可以用for循环来搭建到i=n的情况，思路和递归一样，写法不同而已，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; findStrobogrammatic(<span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; one{<span style="color: #800000;">"</span><span style="color: #800000;">0</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">1</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">8</span><span style="color: #800000;">"</span>}, two{<span style="color: #800000;">""</span>}, res =<span style="color: #000000;"> two;
        </span><span style="color: #0000ff;">if</span> (n % <span style="color: #800080;">2</span> == <span style="color: #800080;">1</span>) res =<span style="color: #000000;"> one;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = (n % <span style="color: #800080;">2</span>) + <span style="color: #800080;">2</span>; i &lt;= n; i += <span style="color: #800080;">2</span><span style="color: #000000;">) {
            vector</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> t;
            </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto a : res) {
                </span><span style="color: #0000ff;">if</span> (i != n) t.push_back(<span style="color: #800000;">"</span><span style="color: #800000;">0</span><span style="color: #800000;">"</span> + a + <span style="color: #800000;">"</span><span style="color: #800000;">0</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                t.push_back(</span><span style="color: #800000;">"</span><span style="color: #800000;">1</span><span style="color: #800000;">"</span> + a + <span style="color: #800000;">"</span><span style="color: #800000;">1</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                t.push_back(</span><span style="color: #800000;">"</span><span style="color: #800000;">6</span><span style="color: #800000;">"</span> + a + <span style="color: #800000;">"</span><span style="color: #800000;">9</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                t.push_back(</span><span style="color: #800000;">"</span><span style="color: #800000;">8</span><span style="color: #800000;">"</span> + a + <span style="color: #800000;">"</span><span style="color: #800000;">8</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                t.push_back(</span><span style="color: #800000;">"</span><span style="color: #800000;">9</span><span style="color: #800000;">"</span> + a + <span style="color: #800000;">"</span><span style="color: #800000;">6</span><span style="color: #800000;">"</span><span style="color: #000000;">);
            }
            res </span>=<span style="color: #000000;"> t;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/5196960.html" id="homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0">Strobogrammatic Number</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/5203228.html" target="_blank">Strobogrammatic Number III</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://leetcode.com/discuss/68215/simple-java-solution-without-recursion" target="_blank">https://leetcode.com/discuss/68215/simple-java-solution-without-recursion</a></p>
<p><a href="https://leetcode.com/discuss/85991/14-lines-concise-and-easy-understand-c-solution" target="_blank">https://leetcode.com/discuss/85991/14-lines-concise-and-easy-understand-c-solution</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-02-19 14:29</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5200919" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5200919);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5196960.html" id="cb_post_title_url">[LeetCode] Strobogrammatic Number 对称数</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).</p>
<p>Write a function to determine if a number is strobogrammatic. The number is represented as a string.</p>
<p>Example 1:</p>
<pre>Input:  "69"
Output: true
</pre>
<p>Example 2:</p>
<pre>Input:  "88"
Output: true</pre>
<p>Example 3:</p>
<pre>Input:  "962"
Output: false</pre>
<p> </p>
<p>这道题定义了一种对称数，就是说一个数字旋转180度和原来一样，也就是倒过来看一样，比如609，倒过来还是609等等，满足这种条件的数字其实没有几个，只有0,1,8,6,9。这道题其实可以看做求回文数的一种特殊情况，我们还是用双指针来检测，那么首尾两个数字如果相等的话，那么只有它们是0,1,8中间的一个才行，如果它们不相等的话，必须一个是6一个是9，或者一个是9一个是6，其他所有情况均返回false，参见代码如下；</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> isStrobogrammatic(<span style="color: #0000ff;">string</span><span style="color: #000000;"> num) {
        </span><span style="color: #0000ff;">int</span> l = <span style="color: #800080;">0</span>, r = num.size() - <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (l &lt;=<span style="color: #000000;"> r) {
            </span><span style="color: #0000ff;">if</span> (num[l] ==<span style="color: #000000;"> num[r]) {
                </span><span style="color: #0000ff;">if</span> (num[l] != <span style="color: #800000;">'</span><span style="color: #800000;">1</span><span style="color: #800000;">'</span> &amp;&amp; num[l] != <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span> &amp;&amp; num[l] != <span style="color: #800000;">'</span><span style="color: #800000;">8</span><span style="color: #800000;">'</span><span style="color: #000000;">){
                    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                }
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                </span><span style="color: #0000ff;">if</span> ((num[l] != <span style="color: #800000;">'</span><span style="color: #800000;">6</span><span style="color: #800000;">'</span> || num[r] != <span style="color: #800000;">'</span><span style="color: #800000;">9</span><span style="color: #800000;">'</span>) &amp;&amp; (num[l] != <span style="color: #800000;">'</span><span style="color: #800000;">9</span><span style="color: #800000;">'</span> || num[r] != <span style="color: #800000;">'</span><span style="color: #800000;">6</span><span style="color: #800000;">'</span><span style="color: #000000;">)) {
                    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                }
            }
            </span>++l; --<span style="color: #000000;">r;
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>由于满足题意的数字不多，所以我们可以用哈希表来做，把所有符合题意的映射都存入哈希表中，然后双指针扫描，看对应位置的两个数字是否在哈希表里存在映射，若不存在，返回false，遍历完成返回true，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> isStrobogrammatic(<span style="color: #0000ff;">string</span><span style="color: #000000;"> num) {
        unordered_map</span>&lt;<span style="color: #0000ff;">char</span>, <span style="color: #0000ff;">char</span>&gt; m {{<span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span>}, {<span style="color: #800000;">'</span><span style="color: #800000;">1</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">1</span><span style="color: #800000;">'</span>}, {<span style="color: #800000;">'</span><span style="color: #800000;">8</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">8</span><span style="color: #800000;">'</span>}, {<span style="color: #800000;">'</span><span style="color: #800000;">6</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">9</span><span style="color: #800000;">'</span>}, {<span style="color: #800000;">'</span><span style="color: #800000;">9</span><span style="color: #800000;">'</span>, <span style="color: #800000;">'</span><span style="color: #800000;">6</span><span style="color: #800000;">'</span><span style="color: #000000;">}};
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt;= num.size() / 2; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (m[num[i]] != num[num.size() - i - <span style="color: #800080;">1</span>]) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/5200919.html" target="_blank">Strobogrammatic Number II</a> </p>
<p><a href="http://www.cnblogs.com/grandyang/p/5203228.html" target="_blank">Strobogrammatic Number III</a> </p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-02-18 00:54</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5196960" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5196960);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5192426.html" id="cb_post_title_url">[LeetCode] Shortest Word Distance III 最短单词距离之三</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>This is a follow up of Shortest Word Distance. The only difference is now word1 could be the same as word2.</p>
<p>Given a list of words and two words word1 and word2, return the shortest distance between these two words in the list.</p>
<p>word1 and word2 may be the same and they represent two individual words in the list.</p>
<p>For example,<br/>Assume that words = ["practice", "makes", "perfect", "coding", "makes"].</p>
<p>Given word1 = “makes”, word2 = “coding”, return 1.<br/>Given word1 = "makes", word2 = "makes", return 3.</p>
<p>Note:<br/>You may assume word1 and word2 are both in the list. </p>
<p> </p>
<p>这道题还是让我们求最短单词距离，有了之前两道题<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/5187640.html" id="homepage1_HomePageDays_DaysList_ctl02_DayList_TitleUrl_0">Shortest Word Distance II</a>和<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/5187041.html" id="homepage1_HomePageDays_DaysList_ctl03_DayList_TitleUrl_0">Shortest Word Distance</a>的基础，就大大降低了题目本身的难度。这道题增加了一个条件，就是说两个单词可能会相同，所以在第一题中的解法的基础上做一些修改，我最先想的解法是基于第一题中的解法二，由于会有相同的单词的情况，那么p1和p2就会相同，这样结果就会变成0，显然不对，所以我们要对word1和word2是否的相等的情况分开处理，如果相等了，由于p1和p2会相同，所以我们需要一个变量t来记录上一个位置，这样如果t不为-1，且和当前的p1不同，我们可以更新结果，如果word1和word2不等，那么还是按原来的方法做，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> shortestWordDistance(vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp; words, <span style="color: #0000ff;">string</span> word1, <span style="color: #0000ff;">string</span><span style="color: #000000;"> word2) {
        </span><span style="color: #0000ff;">int</span> p1 = -<span style="color: #800080;">1</span>, p2 = -<span style="color: #800080;">1</span>, res =<span style="color: #000000;"> INT_MAX;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; words.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">int</span> t =<span style="color: #000000;"> p1;
            </span><span style="color: #0000ff;">if</span> (words[i] == word1) p1 =<span style="color: #000000;"> i;
            </span><span style="color: #0000ff;">if</span> (words[i] == word2) p2 =<span style="color: #000000;"> i;
            </span><span style="color: #0000ff;">if</span> (p1 != -<span style="color: #800080;">1</span> &amp;&amp; p2 != -<span style="color: #800080;">1</span><span style="color: #000000;">) {
                </span><span style="color: #0000ff;">if</span> (word1 == word2 &amp;&amp; t != -<span style="color: #800080;">1</span> &amp;&amp; t !=<span style="color: #000000;"> p1) {
                    res </span>= min(res, abs(t -<span style="color: #000000;"> p1));
                } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (p1 !=<span style="color: #000000;"> p2) {
                    res </span>= min(res, abs(p1 -<span style="color: #000000;"> p2));
                }
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>上述代码其实可以优化一下，我们并不需要变量t来记录上一个位置，我们将p1初始化为数组长度，p2初始化为数组长度的相反数，然后当word1和word2相等的情况，我们用p1来保存p2的结果，p2赋为当前的位置i，这样我们就可以更新结果了，如果word1和word2不相等，则还跟原来的做法一样，这种思路真是挺巧妙的，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> shortestWordDistance(vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp; words, <span style="color: #0000ff;">string</span> word1, <span style="color: #0000ff;">string</span><span style="color: #000000;"> word2) {
        </span><span style="color: #0000ff;">int</span> p1 = words.size(), p2 = -words.size(), res =<span style="color: #000000;"> INT_MAX;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; words.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (words[i] == word1) p1 = word1 == word2 ?<span style="color: #000000;"> p2 : i;
            </span><span style="color: #0000ff;">if</span> (words[i] == word2) p2 =<span style="color: #000000;"> i;
            res </span>= min(res, abs(p1 -<span style="color: #000000;"> p2));
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>我们再来看一种更进一步优化的方法，只用一个变量idx，这个idx的作用就相当于记录上一次的位置，当前idx不等-1时，说明当前i和idx不同，然后我们在word1和word2相同或者words[i]和words[idx]相同的情况下更新结果，最后别忘了将idx赋为i，参见代码如下；</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> shortestWordDistance(vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp; words, <span style="color: #0000ff;">string</span> word1, <span style="color: #0000ff;">string</span><span style="color: #000000;"> word2) {
        </span><span style="color: #0000ff;">int</span> idx = -<span style="color: #800080;">1</span>, res =<span style="color: #000000;"> INT_MAX;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; words.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (words[i] == word1 || words[i] ==<span style="color: #000000;"> word2) {
                </span><span style="color: #0000ff;">if</span> (idx != -<span style="color: #800080;">1</span> &amp;&amp; (word1 == word2 || words[i] !=<span style="color: #000000;"> words[idx])) {
                    res </span>= min(res, i -<span style="color: #000000;"> idx);
                }
                idx </span>=<span style="color: #000000;"> i;
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/5187640.html" id="homepage1_HomePageDays_DaysList_ctl02_DayList_TitleUrl_0">Shortest Word Distance II</a></p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/5187041.html" id="homepage1_HomePageDays_DaysList_ctl03_DayList_TitleUrl_0">Shortest Word Distance</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://leetcode.com/discuss/69493/c-o-n-solution" target="_blank">https://leetcode.com/discuss/69493/c-o-n-solution</a></p>
<p><a href="https://leetcode.com/discuss/70327/short-solution-lines-modified-from-shortest-word-distance" target="_blank">https://leetcode.com/discuss/70327/short-solution-lines-modified-from-shortest-word-distance</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p>
<p> </p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-02-16 13:15</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5192426" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5192426);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5187640.html" id="cb_post_title_url">[LeetCode] Shortest Word Distance II 最短单词距离之二</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Design a class which receives a list of words in the constructor, and implements a method that takes two words <em>word1</em> and <em>word2</em> and return the shortest distance between these two words in the list.</p>
<p>For example,<br/>Assume that words = <code>["practice", "makes", "perfect", "coding", "makes"]</code>.</p>
<p>Given <em>word1</em> = <code>“coding”</code>, <em>word2</em> = <code>“practice”</code>, return 3.<br/>Given <em>word1</em> = <code>"makes"</code>, <em>word2</em> = <code>"coding"</code>, return 1.</p>
<p>Note:<br/>You may assume that <em>word1</em> does not equal to <em>word2</em>, and <em>word1</em> and <em>word2</em> are both in the list.</p>
<p> </p>
<p>这道题是之前那道<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/5187041.html" id="homepage1_HomePageDays_DaysList_ctl02_DayList_TitleUrl_0">Shortest Word Distance</a>的拓展，不同的是这次我们需要多次调用求最短单词距离的函数，那么用之前那道题的解法二和三就非常不高效，而当时我们摒弃的解法一的思路却可以用到这里，我们用哈希表来建立每个单词和其所有出现的位置的映射，然后在找最短单词距离时，我们只需要取出该单词在哈希表中映射的位置数组进行两两比较即可，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> WordDistance {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    WordDistance(vector</span>&lt;<span style="color: #0000ff;">string</span>&gt;&amp;<span style="color: #000000;"> words) {
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; words.size(); ++<span style="color: #000000;">i) {
            m[words[i]].push_back(i);
        }
    }

    </span><span style="color: #0000ff;">int</span> shortest(<span style="color: #0000ff;">string</span> word1, <span style="color: #0000ff;">string</span><span style="color: #000000;"> word2) {
        </span><span style="color: #0000ff;">int</span> res =<span style="color: #000000;"> INT_MAX;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; m[word1].size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; m[word2].size(); ++<span style="color: #000000;">j) {
                res </span>= min(res, abs(m[word1][i] -<span style="color: #000000;"> m[word2][j]));
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    
</span><span style="color: #0000ff;">private</span><span style="color: #000000;">:
    unordered_map</span>&lt;<span style="color: #0000ff;">string</span>, vector&lt;<span style="color: #0000ff;">int</span>&gt; &gt;<span style="color: #000000;"> m;
};</span></pre>
</div>
<p> </p>
<p>我们可以优化上述的代码，使查询的复杂度由上面的O(MN)变为O(M+N)，其中M和N为两个单词的长度，我们需要两个指针i和j来指向位置数组中的某个位置，开始初始化都为0，然后比较位置数组中的数字，将较小的一个的指针向后移动一位，直至其中一个数组遍历完成即可，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> WordDistance {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    WordDistance(vector</span>&lt;<span style="color: #0000ff;">string</span>&gt;&amp;<span style="color: #000000;"> words) {
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; words.size(); ++<span style="color: #000000;">i) {
            m[words[i]].push_back(i);
        }
    }

    </span><span style="color: #0000ff;">int</span> shortest(<span style="color: #0000ff;">string</span> word1, <span style="color: #0000ff;">string</span><span style="color: #000000;"> word2) {
        </span><span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>, j = <span style="color: #800080;">0</span>, res =<span style="color: #000000;"> INT_MAX;
        </span><span style="color: #0000ff;">while</span> (i &lt; m[word1].size() &amp;&amp; j &lt;<span style="color: #000000;"> m[word2].size()) {
            res </span>= min(res, abs(m[word1][i] -<span style="color: #000000;"> m[word2][j]));
            m[word1][i] </span>&lt; m[word2][j] ? ++i : ++<span style="color: #000000;">j;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    
</span><span style="color: #0000ff;">private</span><span style="color: #000000;">:
    unordered_map</span>&lt;<span style="color: #0000ff;">string</span>, vector&lt;<span style="color: #0000ff;">int</span>&gt; &gt;<span style="color: #000000;"> m;
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/5187041.html" id="homepage1_HomePageDays_DaysList_ctl02_DayList_TitleUrl_0">Shortest Word Distance</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/5192426.html" target="_blank">Shortest Word Distance III</a> </p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://leetcode.com/discuss/51698/9-line-o-n-c-solution" target="_blank">https://leetcode.com/discuss/51698/9-line-o-n-c-solution</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p>
<p> </p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-02-13 14:57</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5187640" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5187640);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5187041.html" id="cb_post_title_url">[LeetCode] Shortest Word Distance 最短单词距离</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a list of words and two words <em>word1</em> and <em>word2</em>, return the shortest distance between these two words in the list.</p>
<p>For example,<br/>Assume that words = <code>["practice", "makes", "perfect", "coding", "makes"]</code>.</p>
<p>Given <em>word1</em> = <code>“coding”</code>, <em>word2</em> = <code>“practice”</code>, return 3.<br/>Given <em>word1</em> = <code>"makes"</code>, <em>word2</em> = <code>"coding"</code>, return 1.</p>
<p>Note:<br/>You may assume that <em>word1</em> does not equal to <em>word2</em>, and <em>word1</em> and <em>word2</em> are both in the list.</p>
<p> </p>
<p>这道题让我们给了我们一个单词数组，又给定了两个单词，让我们求这两个单词之间的最小距离，限定了两个单词不同，而且都在数组中。我最先想到的方法比较笨，我首先想的是要用哈希表来做，建立每个单词和其所有出现位置数组的映射，但是后来想想，反正建立映射也要遍历一遍数组，我们还不如直接遍历一遍数组，直接把两个给定单词所有出现的位置分别存到两个数组里，然后我们在对两个数组进行两两比较更新结果，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> shortestDistance(vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp; words, <span style="color: #0000ff;">string</span> word1, <span style="color: #0000ff;">string</span><span style="color: #000000;"> word2) {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> idx1, idx2;
        </span><span style="color: #0000ff;">int</span> res =<span style="color: #000000;"> INT_MAX;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; words.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (words[i] ==<span style="color: #000000;"> word1) idx1.push_back(i);
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (words[i] ==<span style="color: #000000;"> word2) idx2.push_back(i);
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; idx1.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; idx2.size(); ++<span style="color: #000000;">j) {
                res </span>= min(res, abs(idx1[i] -<span style="color: #000000;"> idx2[j]));
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>上面的那种方法并不高效，我们其实需要遍历一次数组就可以了，我们用两个变量p1,p2初始化为-1，然后我们遍历数组，遇到单词1，就将其位置存在p1里，若遇到单词2，就将其位置存在p2里，如果此时p1, p2都不为-1了，那么我们更新结果，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> shortestDistance(vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp; words, <span style="color: #0000ff;">string</span> word1, <span style="color: #0000ff;">string</span><span style="color: #000000;"> word2) {
        </span><span style="color: #0000ff;">int</span> p1 = -<span style="color: #800080;">1</span>, p2 = -<span style="color: #800080;">1</span>, res =<span style="color: #000000;"> INT_MAX;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; words.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (words[i] == word1) p1 =<span style="color: #000000;"> i;
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (words[i] == word2) p2 =<span style="color: #000000;"> i;
            </span><span style="color: #0000ff;">if</span> (p1 != -<span style="color: #800080;">1</span> &amp;&amp; p2 != -<span style="color: #800080;">1</span>) res = min(res, abs(p1 -<span style="color: #000000;"> p2));
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种方法只用一个辅助变量idx，初始化为-1，然后遍历数组，如果遇到等于两个单词中的任意一个的单词，我们在看idx是否为-1，若不为-1，且指向的单词和当前遍历到的单词不同，我们更新结果，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> shortestDistance(vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp; words, <span style="color: #0000ff;">string</span> word1, <span style="color: #0000ff;">string</span><span style="color: #000000;"> word2) {
        </span><span style="color: #0000ff;">int</span> idx = -<span style="color: #800080;">1</span>, res =<span style="color: #000000;"> INT_MAX;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; words.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (words[i] == word1 || words[i] ==<span style="color: #000000;"> word2) {
                </span><span style="color: #0000ff;">if</span> (idx != -<span style="color: #800080;">1</span> &amp;&amp; words[idx] !=<span style="color: #000000;"> words[i]) {
                    res </span>= min(res, i -<span style="color: #000000;"> idx);
                }
                idx </span>=<span style="color: #000000;"> i;
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/5187640.html" id="homepage1_HomePageDays_DaysList_ctl02_DayList_TitleUrl_0">Shortest Word Distance II</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/5192426.html" target="_blank">Shortest Word Distance III</a> </p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://leetcode.com/discuss/50234/ac-java-clean-solution" target="_blank">https://leetcode.com/discuss/50234/ac-java-clean-solution</a></p>
<p><a href="https://leetcode.com/discuss/61820/java-only-need-to-keep-one-index" target="_blank">https://leetcode.com/discuss/61820/java-only-need-to-keep-one-index</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-02-12 14:55</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5187041" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5187041);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4694988.html" id="cb_post_title_url">[LeetCode] Valid Anagram 验证变位词</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given two strings <em>s</em> and <em>t</em>, write a function to determine if <em>t</em> is an anagram of <em>s</em>.</p>
<p>For example,<br/>
<em>s</em> = "anagram", <em>t</em> = "nagaram", return true.<br/>
<em>s</em> = "rat", <em>t</em> = "car", return false.
</p>
<p><strong>Note:</strong><br/>
You may assume the string contains only lowercase alphabets.</p>
<p> </p>
<p>这不算一道难题，核心点就在于使用哈希表映射，我们还是用一个数组来代替哈希表，使用类似方法的题目有<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4340948.html" id="cb_post_title_url">Minimum Window Substring 最小窗口子串</a>，<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4465779.html" id="cb_post_title_url">Isomorphic Strings 同构字符串</a>，<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4480780.html" id="cb_post_title_url">Longest Substring Without Repeating Characters 最长无重复子串</a> 和 <a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4648044.html" id="cb_post_title_url">1.1 Unique Characters of a String 字符串中不同的字符</a>。我们先判断两个字符串长度是否相同，不相同直接返回false。然后把s中所有的字符出现个数统计起来，存入一个大小为26的数组中，因为题目中限定了输入字符串为小写字母组成。然后我们再来统计t字符串，如果发现不匹配则返回false。 参见代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> isAnagram(<span style="color: #0000ff;">string</span> s, <span style="color: #0000ff;">string</span><span style="color: #000000;"> t) {
        </span><span style="color: #0000ff;">if</span> (s.size() != t.size()) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> m[<span style="color: #800080;">26</span>] = {<span style="color: #800080;">0</span><span style="color: #000000;">};
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; s.size(); ++i) ++m[s[i] - <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span><span style="color: #000000;">];
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; t.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (--m[t[i] - <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span>] &lt; <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-08-02 01:07</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4694988" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4694988);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4682458.html" id="cb_post_title_url">[LeetCode] Different Ways to Add Parentheses 添加括号的不同方式</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a string of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. The valid operators are <code>+</code>, <code>-</code>and <code>*</code>.</p>
<p><br/>Example 1</p>
<p>Input: <code>"2-1-1"</code>.</p>
<pre>((2-1)-1) = 0
(2-(1-1)) = 2</pre>
<p>Output: <code>[0, 2]</code></p>
<p><br/>Example 2</p>
<p>Input: <code>"2*3-4*5"</code></p>
<pre>(2*(3-(4*5))) = -34
((2*3)-(4*5)) = -14
((2*(3-4))*5) = -10
(2*((3-4)*5)) = -10
(((2*3)-4)*5) = 10</pre>
<p>Output: <code>[-34, -14, -10, -10, 10]</code></p>
<p> </p>
<p>这道题让给我们一个可能含有加减乘的表达式，让我们在任意位置添加括号，求出所有可能表达式的不同值。这道题跟之前的那道<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4301096.html" id="cb_post_title_url">Unique Binary Search Trees II 独一无二的二叉搜索树之二</a>用的方法一样，用递归来解，划分左右子树，递归构造。</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; diffWaysToCompute(<span style="color: #0000ff;">string</span><span style="color: #000000;"> input) {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; input.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (input[i] == <span style="color: #800000;">'</span><span style="color: #800000;">+</span><span style="color: #800000;">'</span> || input[i] == <span style="color: #800000;">'</span><span style="color: #800000;">-</span><span style="color: #800000;">'</span> || input[i] == <span style="color: #800000;">'</span><span style="color: #800000;">*</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; left = diffWaysToCompute(input.substr(<span style="color: #800080;">0</span><span style="color: #000000;">, i));
                vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; right = diffWaysToCompute(input.substr(i + <span style="color: #800080;">1</span><span style="color: #000000;">));
                </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; left.size(); ++<span style="color: #000000;">j) {
                    </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> k = <span style="color: #800080;">0</span>; k &lt; right.size(); ++<span style="color: #000000;">k) {
                        </span><span style="color: #0000ff;">if</span> (input[i] == <span style="color: #800000;">'</span><span style="color: #800000;">+</span><span style="color: #800000;">'</span>) res.push_back(left[j] +<span style="color: #000000;"> right[k]);
                        </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (input[i] == <span style="color: #800000;">'</span><span style="color: #800000;">-</span><span style="color: #800000;">'</span>) res.push_back(left[j] -<span style="color: #000000;"> right[k]);
                        </span><span style="color: #0000ff;">else</span> res.push_back(left[j] *<span style="color: #000000;"> right[k]);
                    }
                }
            }
        }
        </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (res.empty()) res.push_back(atoi(input.c_str()));
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4944875.html">Remove Invalid Parentheses 移除非法括号</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4424731.html" target="_blank">Longest Valid Parentheses</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4444160.html" target="_blank">Generate Parentheses</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4424587.html" target="_blank">Valid Parentheses</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="http://www.cnblogs.com/ganganloveu/p/4681439.html" target="_blank">http://www.cnblogs.com/ganganloveu/p/4681439.html</a></p>
<p><a href="https://leetcode.com/discuss/48488/c-4ms-recursive-method" target="_blank">https://leetcode.com/discuss/48488/c-4ms-recursive-method</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-07-28 12:54</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4682458" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4682458);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4669134.html" id="cb_post_title_url">[LeetCode] Search a 2D Matrix II 搜索一个二维矩阵之二</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Write an efficient algorithm that searches for a value in an <em>m</em> x <em>n</em> matrix. This matrix has the following properties:</p>
<p> </p>
<ul>
<li>Integers in each row are sorted in ascending from left to right.</li>
<li>Integers in each column are sorted in ascending from top to bottom.</li>
</ul>
<p>For example,</p>
<p>Consider the following matrix:</p>
<pre>[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]
</pre>
<p>Given <strong>target</strong> = <code>5</code>, return <code>true</code>.</p>
<p>Given <strong>target</strong> = <code>20</code>, return <code>false</code>.</p>
<p> </p>
<p>突然发现LeetCode很喜欢从LintCode上盗题，这是逼我去刷LintCode的节奏么?! 这道题让我们在一个二维数组中快速的搜索的一个数字，这个二维数组各行各列都是按递增顺序排列的，是之前那道<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4323301.html" id="cb_post_title_url">Search a 2D Matrix 搜索一个二维矩阵</a>的延伸，那道题的不同在于每行的第一个数字比上一行的最后一个数字大，是一个整体蛇形递增的数组。所以那道题可以将二维数组展开成一个一位数组用一次二查搜索。而这道题没法那么做，这道题有它自己的特点。如果我们观察题目中给的那个例子，我们可以发现有两个位置的数字很有特点，左下角和右上角的数。左下角的18，往上所有的数变小，往右所有数增加，那么我们就可以和目标数相比较，如果目标数大，就往右搜，如果目标数小，就往上搜。这样就可以判断目标数是否存在。当然我们也可以把起始数放在右上角，往左和下搜，停止条件设置正确就行。代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> searchMatrix(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt; &gt; &amp;matrix, <span style="color: #0000ff;">int</span><span style="color: #000000;"> target) {
        </span><span style="color: #0000ff;">if</span> (matrix.empty() || matrix[<span style="color: #800080;">0</span>].empty()) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (target &lt; matrix[<span style="color: #800080;">0</span>][<span style="color: #800080;">0</span>] || target &gt; matrix.back().back()) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> x = matrix.size() - <span style="color: #800080;">1</span>, y = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (<span style="color: #0000ff;">true</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">if</span> (matrix[x][y] &gt; target) --<span style="color: #000000;">x;
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (matrix[x][y] &lt; target) ++<span style="color: #000000;">y;
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> (x &lt; <span style="color: #800080;">0</span> || y &gt;= matrix[<span style="color: #800080;">0</span>].size()) <span style="color: #0000ff;">break</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p>
<p> </p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-07-23 00:58</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4669134" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4669134);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4656517.html" id="cb_post_title_url">[LeetCode] Sliding Window Maximum 滑动窗口最大值</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given an array <em>nums</em>, there is a sliding window of size <em>k</em> which is moving from the very left of the array to the very right. You can only see the <em>k</em> numbers in the window. Each time the sliding window moves right by one position.</p>
<p>For example,<br/>Given <em>nums</em> = <code>[1,3,-1,-3,5,3,6,7]</code>, and <em>k</em> = 3.</p>
<pre>Window position                Max
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
</pre>
<p>Therefore, return the max sliding window as <code>[3,3,5,5,6,7]</code>.</p>
<p>Note: <br/>You may assume <em>k</em> is always valid, 1 ≤ k ≤ input array's size.</p>
<p>Follow up:<br/>Could you solve it in linear time?</p>
<p>Hint:</p>
<ol>
<li class="hint animated fadeInLeft">How about using a data structure such as deque (double-ended queue)?</li>
<li class="hint animated fadeInLeft">The queue size need not be the same as the window’s size.</li>
<li class="hint animated fadeInLeft">Remove redundant elements and the queue should store only elements that need to be considered.</li>
</ol>
<p> </p>
<p>这道题给定了一个数组，还给了一个窗口大小k，让我们每次向右滑动一个数字，每次返回窗口内的数字的最大值，而且要求我们代码的时间复杂度为O(n)。提示我们要用双向队列deque来解题，并提示我们窗口中只留下有用的值，没用的全移除掉。果然Hard的题目我就是不会做，网上看到了别人的解法才明白，解法又巧妙有简洁，膜拜啊。大概思路是用双向队列保存数字的下标，遍历整个数组，如果此时队列的首元素是i - k的话，表示此时窗口向右移了一步，则移除队首元素。然后比较队尾元素和将要进来的值，如果小的话就都移除，然后此时我们把队首元素加入结果中即可，参见代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; maxSlidingWindow(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; nums, <span style="color: #0000ff;">int</span><span style="color: #000000;"> k) {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> res;
        deque</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> q;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; nums.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (!q.empty() &amp;&amp; q.front() == i -<span style="color: #000000;"> k) q.pop_front();
            </span><span style="color: #0000ff;">while</span> (!q.empty() &amp;&amp; nums[q.back()] &lt;<span style="color: #000000;"> nums[i]) q.pop_back();
            q.push_back(i);
            </span><span style="color: #0000ff;">if</span> (i &gt;= k - <span style="color: #800080;">1</span><span style="color: #000000;">) res.push_back(nums[q.front()]);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://leetcode.com/discuss/46594/clean-c-o-n-solution-using-a-deque" target="_blank">https://leetcode.com/discuss/46594/clean-c-o-n-solution-using-a-deque</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-07-18 12:09</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4656517" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4656517);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4650187.html" id="cb_post_title_url">[LeetCode] Product of Array Except Self 除本身之外的数组之积</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given an array of <em>n</em> integers where <em>n</em> &gt; 1, <code>nums</code>, return an array <code>output</code> such that <code>output[i]</code> is equal to the product of all the elements of <code>nums</code> except <code>nums[i]</code>.</p>
<p>Solve it <strong>without division</strong> and in O(<em>n</em>).</p>
<p>For example, given <code>[1,2,3,4]</code>, return <code>[24,12,8,6]</code>.</p>
<p><strong>Follow up:</strong><br/>
Could you solve it with constant space complexity? (Note: The output array <strong>does not</strong> count as extra space for the purpose of space complexity analysis.)</p>
<p> </p>
<p>这道题给定我们一个数组，让我们返回一个新数组，对于每一个位置上的数是其他位置上数的乘积，并且限定了时间复杂度O(n)，并且不让我们用除法。如果让用除法的话，那这道题就应该属于Easy，因为可以先遍历一遍数组求出所有数字之积，然后除以对应位置的上的数字。但是这道题禁止我们使用除法，那么我们只能另辟蹊径。我们想，对于某一个数字，如果我们知道其前面所有数字的乘积，同时也知道后面所有的数乘积，那么二者相乘就是我们要的结果，所以我们只要分别创建出这两个数组即可，分别从数组的两个方向遍历就可以分别创建出乘积累积数组。参见代码如下：</p>
<p> </p>
<p>C++ 解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; productExceptSelf(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        </span><span style="color: #0000ff;">int</span> n =<span style="color: #000000;"> nums.size();
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; fwd(n, <span style="color: #800080;">1</span>), bwd(n, <span style="color: #800080;">1</span><span style="color: #000000;">), res(n);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n - <span style="color: #800080;">1</span>; ++<span style="color: #000000;">i) {
            fwd[i </span>+ <span style="color: #800080;">1</span>] = fwd[i] *<span style="color: #000000;"> nums[i];
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = n - <span style="color: #800080;">1</span>; i &gt; <span style="color: #800080;">0</span>; --<span style="color: #000000;">i) {
            bwd[i </span>- <span style="color: #800080;">1</span>] = bwd[i] *<span style="color: #000000;"> nums[i];
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            res[i] </span>= fwd[i] *<span style="color: #000000;"> bwd[i];
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>Java 解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span>[] productExceptSelf(<span style="color: #0000ff;">int</span><span style="color: #000000;">[] nums) {
        </span><span style="color: #0000ff;">int</span> n =<span style="color: #000000;"> nums.length;
        </span><span style="color: #0000ff;">int</span>[] res = <span style="color: #0000ff;">new</span> <span style="color: #0000ff;">int</span><span style="color: #000000;">[n];
        </span><span style="color: #0000ff;">int</span>[] fwd = <span style="color: #0000ff;">new</span> <span style="color: #0000ff;">int</span>[n], bwd = <span style="color: #0000ff;">new</span> <span style="color: #0000ff;">int</span><span style="color: #000000;">[n];
        fwd[</span>0] = 1; bwd[n - 1] = 1<span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = 1; i &lt; n; ++<span style="color: #000000;">i) {
            fwd[i] </span>= fwd[i - 1] * nums[i - 1<span style="color: #000000;">];
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = n - 2; i &gt;= 0; --<span style="color: #000000;">i) {
            bwd[i] </span>= bwd[i + 1] * nums[i + 1<span style="color: #000000;">];
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = 0; i &lt; n; ++<span style="color: #000000;">i) {
            res[i] </span>= fwd[i] *<span style="color: #000000;"> bwd[i];
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
}</span></pre>
</div>
<p> </p>
<p>我们可以对上面的方法进行空间上的优化，由于最终的结果都是要乘到结果res中，所以我们可以不用单独的数组来保存乘积，而是直接累积到res中，我们先从前面遍历一遍，将乘积的累积存入res中，然后从后面开始遍历，用到一个临时变量right，初始化为1，然后每次不断累积，最终得到正确结果，参见代码如下：</p>
<p> </p>
<p>C++ 解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; productExceptSelf(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; res(nums.size(), <span style="color: #800080;">1</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt; nums.size(); ++<span style="color: #000000;">i) {
            res[i] </span>= res[i - <span style="color: #800080;">1</span>] * nums[i - <span style="color: #800080;">1</span><span style="color: #000000;">];
        }
        </span><span style="color: #0000ff;">int</span> right = <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = nums.size() - <span style="color: #800080;">1</span>; i &gt;= <span style="color: #800080;">0</span>; --<span style="color: #000000;">i) {
            res[i] </span>*=<span style="color: #000000;"> right;
            right </span>*=<span style="color: #000000;"> nums[i];
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>Java 解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span>[] productExceptSelf(<span style="color: #0000ff;">int</span><span style="color: #000000;">[] nums) {
        </span><span style="color: #0000ff;">int</span> n = nums.length, right = 1<span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span>[] res = <span style="color: #0000ff;">new</span> <span style="color: #0000ff;">int</span><span style="color: #000000;">[n];
        res[</span>0] = 1<span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = 1; i &lt; n; ++<span style="color: #000000;">i) {
            res[i] </span>= res[i - 1] * nums[i - 1<span style="color: #000000;">];
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = n - 1; i &gt;= 0; --<span style="color: #000000;">i) {
            res[i] </span>*=<span style="color: #000000;"> right;
            right </span>*=<span style="color: #000000;"> nums[i];
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
}</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/18864/simple-java-solution-in-o-n-without-extra-space" target="_blank">https://discuss.leetcode.com/topic/18864/simple-java-solution-in-o-n-without-extra-space</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-07-16 08:29</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4650187" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4650187);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4647576.html" id="cb_post_title_url">[LeetCode] Delete Node in a Linked List 删除链表的节点</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.</p>
<p>Supposed the linked list is <code>1 -&gt; 2 -&gt; 3 -&gt; 4</code> and you are given the third node with value <code>3</code>, the linked list should become <code>1 -&gt; 2 -&gt; 4</code> after calling your function.</p>
<p> </p>
<p>这道题让我们删除链表的一个节点，更通常不同的是，没有给我们链表的起点，只给我们了一个要删的节点，跟我们以前遇到的情况不太一样，我们之前要删除一个节点的方法是要有其前一个节点的位置，然后将其前一个节点的next连向要删节点的下一个，然后delete掉要删的节点即可。这道题的处理方法是先把当前节点的值用下一个节点的值覆盖了，然后我们删除下一个节点即可，代码如下：</p>
<p> </p>
<p>C++ 解法：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">void</span> deleteNode(ListNode*<span style="color: #000000;"> node) {
        node</span>-&gt;val = node-&gt;next-&gt;<span style="color: #000000;">val;
        ListNode </span>*tmp = node-&gt;<span style="color: #000000;">next;
        node</span>-&gt;next = tmp-&gt;<span style="color: #000000;">next;
        </span><span style="color: #0000ff;">delete</span><span style="color: #000000;"> tmp;
    }
};</span></pre>
</div>
<p> </p>
<p>Java 解法：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> deleteNode(ListNode node) {
        node.val </span>=<span style="color: #000000;"> node.next.val;
        node.next </span>=<span style="color: #000000;"> node.next.next;
    }
}</span></pre>
</div>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-07-15 10:20</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4647576" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4647576);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4641968.html" id="cb_post_title_url">[LeetCode] Lowest Common Ancestor of a Binary Tree 二叉树的最小共同父节点</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.</p>
<p>According to the <a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor" target="_blank">definition of LCA on Wikipedia</a>: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”</p>
<p>Given the following binary tree:  root = [3,5,1,6,2,0,8,null,null,7,4]</p>
<pre>        _______3______
       /              \
    ___5__          ___1__
   /      \        /      \
   6      _2       0       8
         /  \
         7   4
</pre>
<p>Example 1:</p>
<pre>Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
Output: 3
Explanation: The LCA of of nodes <code>5</code> and <code>1</code> is <code>3.</code>
</pre>
<p>Example 2:</p>
<pre>Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
Output: 5
Explanation: The LCA of nodes <code>5</code> and <code>4</code> is <code>5</code>, since a node can be a descendant of itself
             according to the LCA definition.</pre>
<p>Note:</p>
<ul>
<li>All of the nodes' values will be unique.</li>
<li>p and q are different and both values will exist in the binary tree.</li>
</ul>
<p> </p>
<p>这道求二叉树的最小共同父节点的题是之前那道 <a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4640572.html" id="cb_post_title_url">Lowest Common Ancestor of a Binary Search Tree</a> 的Follow Up。跟之前那题不同的地方是，这道题是普通是二叉树，不是二叉搜索树，所以就不能利用其特有的性质，所以我们只能在二叉树中来搜索p和q，然后从路径中找到最后一个相同的节点即为父节点，我们可以用递归来实现，在递归函数中，我们首先看当前结点是否为空，若为空则直接返回空，若为p或q中的任意一个，也直接返回当前结点。否则的话就对其左右子结点分别调用递归函数，由于这道题限制了p和q一定都在二叉树中存在，那么如果当前结点不等于p或q，p和q要么分别位于左右子树中，要么同时位于左子树，或者同时位于右子树，那么我们分别来讨论：</p>
<p>若p和q要么分别位于左右子树中，那么对左右子结点调用递归函数，会分别返回p和q结点的位置，而当前结点正好就是p和q的最小共同父结点，直接返回当前结点即可，这就是题目中的例子1的情况。</p>
<p>若p和q同时位于左子树，这里有两种情况，一种情况是left会返回p和q中较高的那个位置，而right会返回空，所以我们最终返回非空的left即可，这就是题目中的例子2的情况。还有一种情况是会返回p和q的最小父结点，就是说当前结点的左子树中的某个结点才是p和q的最小父结点，会被返回。</p>
<p>若p和q同时位于右子树，同样这里有两种情况，一种情况是right会返回p和q中较高的那个位置，而left会返回空，所以我们最终返回非空的right即可，还有一种情况是会返回p和q的最小父结点，就是说当前结点的右子树中的某个结点才是p和q的最小父结点，会被返回，写法很简洁，代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    TreeNode</span>* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode*<span style="color: #000000;"> q) {
       </span><span style="color: #0000ff;">if</span> (!root || p == root || q == root) <span style="color: #0000ff;">return</span><span style="color: #000000;"> root;
       TreeNode </span>*left = lowestCommonAncestor(root-&gt;<span style="color: #000000;">left, p, q);
       TreeNode </span>*right = lowestCommonAncestor(root-&gt;<span style="color: #000000;">right, p , q);
       </span><span style="color: #0000ff;">if</span> (left &amp;&amp; right) <span style="color: #0000ff;">return</span><span style="color: #000000;"> root;
       </span><span style="color: #0000ff;">return</span> left ?<span style="color: #000000;"> left : right;
    }
};</span></pre>
</div>
<p> </p>
<p>上述代码可以进行优化一下，如果当前结点不为空，且既不是p也不是q，那么根据上面的分析，p和q的位置就有三种情况，p和q要么分别位于左右子树中，要么同时位于左子树，或者同时位于右子树。我们需要优化的情况就是当p和q同时为于左子树或右子树中，而且返回的结点并不是p或q，那么就是p和q的最小父结点了，已经求出来了，就不用再对右结点调用递归函数了，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    TreeNode</span>* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode*<span style="color: #000000;"> q) {
       </span><span style="color: #0000ff;">if</span> (!root || p == root || q == root) <span style="color: #0000ff;">return</span><span style="color: #000000;"> root;
       TreeNode </span>*left = lowestCommonAncestor(root-&gt;<span style="color: #000000;">left, p, q);
       </span><span style="color: #0000ff;">if</span> (left &amp;&amp; left != p &amp;&amp; left != q) <span style="color: #0000ff;">return</span><span style="color: #000000;"> left;
       TreeNode </span>*right = lowestCommonAncestor(root-&gt;<span style="color: #000000;">right, p , q);<br/></span><span style="color: #0000ff;">　　　　if</span> (left &amp;&amp; right) <span style="color: #0000ff;">return</span><span style="color: #000000;"> root;
       </span><span style="color: #0000ff;">return</span> left ?<span style="color: #000000;"> left : right;
    }
};</span></pre>
</div>
<p> </p>
<p>此题还有一种情况，题目中没有明确说明p和q是否是树中的节点，如果不是，应该返回NULL，而上面的方法就不正确了，对于这种情况请参见 Cracking the Coding Interview 5th Edition 的第233-234页。</p>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4640572.html">Lowest Common Ancestor of a Binary Search Tree</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-07-13 07:10</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4641968" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4641968);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4640572.html" id="cb_post_title_url">[LeetCode] Lowest Common Ancestor of a Binary Search Tree 二叉搜索树的最小共同父节点</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.</p>
<p>According to the <a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor" target="_blank">definition of LCA on Wikipedia</a>: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).”</p>
<pre>        _______6______
       /              \
    ___2__          ___8__
   /      \        /      \
   0      _4       7       9
         /  \
         3   5
</pre>
<p>For example, the lowest common ancestor (LCA) of nodes <code>2</code> and <code>8</code> is <code>6</code>. Another example is LCA of nodes <code>2</code> and <code>4</code> is <code>2</code>, since a node can be a descendant of itself according to the LCA definition.</p>
<p> </p>
<p>这道题让我们求二叉搜索树的最小共同父节点, LeetCode中关于BST的题有<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4298435.html" id="cb_post_title_url">Validate Binary Search Tree 验证二叉搜索树</a>， <a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4298069.html" id="cb_post_title_url">Recover Binary Search Tree 复原二叉搜索树</a>， <a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4231455.html" id="cb_post_title_url">Binary Search Tree Iterator 二叉搜索树迭代器</a>， <a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4299608.html" id="cb_post_title_url">Unique Binary Search Trees 独一无二的二叉搜索树</a>， <a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4301096.html" id="cb_post_title_url">Unique Binary Search Trees II 独一无二的二叉搜索树之二</a>，<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4295245.html" id="cb_post_title_url">Convert Sorted Array to Binary Search Tree 将有序数组转为二叉搜索树</a> , <a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4295618.html" id="cb_post_title_url">Convert Sorted List to Binary Search Tree 将有序链表转为二叉搜索树</a> 和 <a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4620012.html" id="cb_post_title_url">Kth Smallest Element in a BST 二叉搜索树中的第K小的元素</a>。这道题我们可以用递归来求解，我们首先来看题目中给的例子，由于二叉搜索树的特点是左&lt;根&lt;右，所以根节点的值一直都是中间值，大于左子树的所有节点值，小于右子树的所有节点值，那么我们可以做如下的判断，如果根节点的值大于p和q之间的较大值，说明p和q都在左子树中，那么此时我们就进入根节点的左子节点继续递归，如果根节点小于p和q之间的较小值，说明p和q都在右子树中，那么此时我们就进入根节点的右子节点继续递归，如果都不是，则说明当前根节点就是最小共同父节点，直接返回即可，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    TreeNode</span>* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode*<span style="color: #000000;"> q) {
        </span><span style="color: #0000ff;">if</span> (!root) <span style="color: #0000ff;">return</span><span style="color: #000000;"> NULL;
        </span><span style="color: #0000ff;">if</span> (root-&gt;val &gt; max(p-&gt;val, q-&gt;<span style="color: #000000;">val)) 
            </span><span style="color: #0000ff;">return</span> lowestCommonAncestor(root-&gt;<span style="color: #000000;">left, p, q);
        </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (root-&gt;val &lt; min(p-&gt;val, q-&gt;<span style="color: #000000;">val)) 
            </span><span style="color: #0000ff;">return</span> lowestCommonAncestor(root-&gt;<span style="color: #000000;">right, p, q);
        </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">return</span><span style="color: #000000;"> root;
    }
};</span></pre>
</div>
<p> </p>
<p>当然，此题也有非递归的写法，用个while循环来代替递归调用即可，然后不停的更新当前的根节点，也能实现同样的效果，代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    TreeNode</span>* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode*<span style="color: #000000;"> q) {
        </span><span style="color: #0000ff;">while</span> (<span style="color: #0000ff;">true</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">if</span> (root-&gt;val &gt; max(p-&gt;val, q-&gt;val)) root = root-&gt;<span style="color: #000000;">left;
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (root-&gt;val &lt; min(p-&gt;val, q-&gt;val)) root = root-&gt;<span style="color: #000000;">right;
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">break</span><span style="color: #000000;">;
        }      
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> root;
    }
};</span></pre>
</div>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-07-12 10:08</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4640572" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4640572);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4635425.html" id="cb_post_title_url">[LeetCode] Palindrome Linked List 回文链表</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a singly linked list, determine if it is a palindrome. Follow up: Could you do it in O(n) time and O(1) space?</p>
<p>这道题让我们判断一个链表是否为回文链表，LeetCode中关于回文串的题共有六道，除了这道，其他的五道为<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4125510.html" id="cb_post_title_url"> Palindrome Number 验证回文数字</a>，<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4030114.html" id="cb_post_title_url"> Validate Palindrome 验证回文字符串</a>，<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4270008.html" id="cb_post_title_url"> Palindrome Partitioning 拆分回文串</a>，<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4271456.html" id="cb_post_title_url">Palindrome Partitioning II 拆分回文串之二</a> 和 <a href="http://www.cnblogs.com/grandyang/p/4464476.html" target="_blank">Longest Palindromic Substring 最长回文串</a>.链表比字符串难的地方就在于不能通过坐标来直接访问，而只能从头开始遍历到某个位置。那么根据回文串的特点，我们需要比较对应位置的值是否相等，那么我们首先需要找到链表的中点，这个可以用快慢指针来实现，使用方法可以参见之前的两篇<a href="http://www.cnblogs.com/grandyang/p/4295618.html" target="_blank">Convert Sorted List to Binary Search Tree 将有序链表转为二叉搜索树</a> 和 <a href="http://www.cnblogs.com/grandyang/p/4254860.html" target="_blank">Reorder List 链表重排序</a>，我们使用快慢指针找中点的原理是fast和slow两个指针，每次快指针走两步，慢指针走一步，等快指针走完时，慢指针的位置就是中点。我们还需要用栈，每次慢指针走一步，都把值存入栈中，等到达中点时，链表的前半段都存入栈中了，由于栈的后进先出的性质，就可以和后半段链表按照回文对应的顺序比较了。代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> isPalindrome(ListNode*<span style="color: #000000;"> head) {
        </span><span style="color: #0000ff;">if</span> (!head || !head-&gt;next) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        ListNode </span>*slow = head, *fast =<span style="color: #000000;"> head;
        stack</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> s;
        s.push(head</span>-&gt;<span style="color: #000000;">val);
        </span><span style="color: #0000ff;">while</span> (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;<span style="color: #000000;">next) {
            slow </span>= slow-&gt;<span style="color: #000000;">next;
            fast </span>= fast-&gt;next-&gt;<span style="color: #000000;">next;
            s.push(slow</span>-&gt;<span style="color: #000000;">val);
        }
        </span><span style="color: #0000ff;">if</span> (!fast-&gt;<span style="color: #000000;">next) s.pop();
        </span><span style="color: #0000ff;">while</span> (slow-&gt;<span style="color: #000000;">next) {
            slow </span>= slow-&gt;<span style="color: #000000;">next;
            </span><span style="color: #0000ff;">int</span> tmp =<span style="color: #000000;"> s.top(); s.pop();
            </span><span style="color: #0000ff;">if</span> (tmp != slow-&gt;val) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>这道题的Follow Up让我们用O(1)的空间，那就是说我们不能使用stack了，那么如果代替stack的作用呢，用stack的目的是为了利用其后进先出的特点，好倒着取出前半段的元素。那么现在我们不用stack了，如何倒着取元素呢。我们可以在找到中点后，将后半段的链表翻转一下，这样我们就可以按照回文的顺序比较了，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> isPalindrome(ListNode*<span style="color: #000000;"> head) {
        </span><span style="color: #0000ff;">if</span> (!head || !head-&gt;next) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        ListNode </span>*slow = head, *fast =<span style="color: #000000;"> head;
        </span><span style="color: #0000ff;">while</span> (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;<span style="color: #000000;">next) {
            slow </span>= slow-&gt;<span style="color: #000000;">next;
            fast </span>= fast-&gt;next-&gt;<span style="color: #000000;">next;
        }
        ListNode </span>*last = slow-&gt;next, *pre =<span style="color: #000000;"> head;
        </span><span style="color: #0000ff;">while</span> (last-&gt;<span style="color: #000000;">next) {
            ListNode </span>*tmp = last-&gt;<span style="color: #000000;">next;
            last</span>-&gt;next = tmp-&gt;<span style="color: #000000;">next;
            tmp</span>-&gt;next = slow-&gt;<span style="color: #000000;">next;
            slow</span>-&gt;next =<span style="color: #000000;"> tmp;
        }
        </span><span style="color: #0000ff;">while</span> (slow-&gt;<span style="color: #000000;">next) {
            slow </span>= slow-&gt;<span style="color: #000000;">next;
            </span><span style="color: #0000ff;">if</span> (pre-&gt;val != slow-&gt;val) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            pre </span>= pre-&gt;<span style="color: #000000;">next;
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-07-10 12:38</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4635425" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4635425);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4629032.html" id="cb_post_title_url">[LeetCode] Number of Digit One 数字1的个数</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given an integer n, count the total number of digit 1 appearing in all non-negative integers less than or equal to n.</p>
<p> For example:<br/> 
Given n = 13,<br/>
Return 6, because digit 1 occurred in the following numbers: 1, 10, 11, 12, 13.
</p>
<p><strong>Hint:</strong></p>
<ol>
<li class="hint animated fadeInLeft" style="display: list-item;">Beware of overflow.</li>
</ol>
<p> </p>
<p>这道题让我们比给定数小的所有数中1出现的个数，之前有道类似的题<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4325432.html" id="cb_post_title_url">Number of 1 Bits 位1的个数</a>，那道题是求转为二进数后1的个数，我开始以为这道题也是要用那题的方法，其实不是的，这题实际上相当于一道找规律的题。那么为了找出规律，我们就先来列举下所有含1的数字，并每10个统计下个数，如下所示：</p>
<p>1的个数          含1的数字                                                                        数字范围</p>
<p>1                   <span style="color: #ff0000;">1</span>                                                                                     [1, 9]</p>
<p>11                 <span style="color: #ff0000;">1</span>0  <span style="color: #ff0000;">11</span>  <span style="color: #ff0000;">1</span>2  <span style="color: #ff0000;">1</span>3  <span style="color: #ff0000;">1</span>4  <span style="color: #ff0000;">1</span>5  <span style="color: #ff0000;">1</span>6  <span style="color: #ff0000;">1</span>7  <span style="color: #ff0000;">1</span>8  <span style="color: #ff0000;">1</span>9                              [10, 19]</p>
<p>1                   2<span style="color: #ff0000;">1</span>                                                                                   [20, 29]</p>
<p>1                   3<span style="color: #ff0000;">1</span>                                                                                   [30, 39]</p>
<p>1                   4<span style="color: #ff0000;">1</span>                                                                                   [40, 49]</p>
<p>1                   5<span style="color: #ff0000;">1</span>                                                                                   [50, 59]</p>
<p>1                   6<span style="color: #ff0000;">1</span>                                                                                   [60, 69]</p>
<p>1                   7<span style="color: #ff0000;">1</span>                                                                                   [70, 79]</p>
<p>1                   8<span style="color: #ff0000;">1 </span>                                                                                  [80, 89]</p>
<p>1                   9<span style="color: #ff0000;">1</span>                                                                                   [90, 99]</p>
<p>11                 <span style="color: #ff0000;">1</span>00  <span style="color: #ff0000;">1</span>0<span style="color: #ff0000;">1</span>  <span style="color: #ff0000;">1</span>02  <span style="color: #ff0000;">1</span>03  <span style="color: #ff0000;">1</span>04  <span style="color: #ff0000;">1</span>05  <span style="color: #ff0000;">1</span>06 <span style="color: #ff0000;"> 1</span>07  <span style="color: #ff0000;">1</span>08  <span style="color: #ff0000;">1</span>09          [100, 109]</p>
<p> 21                 <span style="color: #ff0000;">11</span>0  <span style="color: #ff0000;">111</span>  <span style="color: #ff0000;">11</span>2  <span style="color: #ff0000;">11</span>3  <span style="color: #ff0000;">11</span>4  <span style="color: #ff0000;">11</span>5  <span style="color: #ff0000;">11</span>6  <span style="color: #ff0000;">11</span>7  <span style="color: #ff0000;">11</span>8  <span style="color: #ff0000;">11</span>9             [110, 119]</p>
<p>11                 <span style="color: #ff0000;">1</span>20  <span style="color: #ff0000;">1</span>2<span style="color: #ff0000;">1</span>  <span style="color: #ff0000;">1</span>22  <span style="color: #ff0000;">1</span>23  <span style="color: #ff0000;">1</span>24  <span style="color: #ff0000;">1</span>25  <span style="color: #ff0000;">1</span>26  <span style="color: #ff0000;">1</span>27  <span style="color: #ff0000;">1</span>28  <span style="color: #ff0000;">1</span>29          [120, 129]</p>
<p>...                  ...                                                                                  ...</p>
<p> </p>
<p>通过上面的列举我们可以发现，100以内的数字，除了10-19之间有11个‘1’之外，其余都只有1个。如果我们不考虑[10, 19]区间上那多出来的10个‘1’的话，那么我们在对任意一个两位数，十位数上的数字(加1)就代表1出现的个数，这时候我们再把多出的10个加上即可。比如56就有(5+1)+10=16个。如何知道是否要加上多出的10个呢，我们就要看十位上的数字是否大于等于2，是的话就要加上多余的10个'1'。那么我们就可以用(x+8)/10来判断一个数是否大于等于2。对于三位数区间 [100, 199] 内的数也是一样，除了[110, 119]之间多出的10个数之外，共21个‘1’，其余的每10个数的区间都只有11个‘1’，所以 [100, 199] 内共有21 + 11 * 9 = 120个‘1’。那么现在想想[0, 999]区间内‘1’的个数怎么求？根据前面的结果，[0, 99] 内共有20个，[100, 199] 内共有120个，而其他每100个数内‘1’的个数也应该符合之前的规律，即也是20个，那么总共就有 120 + 20 * 9 = 300 个‘1’。那么还是可以用相同的方法来判断并累加1的个数，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> countDigitOne(<span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, a = <span style="color: #800080;">1</span>, b = <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (n &gt; <span style="color: #800080;">0</span><span style="color: #000000;">) {
            res </span>+= (n + <span style="color: #800080;">8</span>) / <span style="color: #800080;">10</span> * a + (n % <span style="color: #800080;">10</span> == <span style="color: #800080;">1</span>) *<span style="color: #000000;"> b;
            b </span>+= n % <span style="color: #800080;">10</span> *<span style="color: #000000;"> a;
            a </span>*= <span style="color: #800080;">10</span><span style="color: #000000;">;
            n </span>/= <span style="color: #800080;">10</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> countDigitOne(<span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">long</span> k = <span style="color: #800080;">1</span>; k &lt;= n; k *= <span style="color: #800080;">10</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">long</span> r = n / k, m = n %<span style="color: #000000;"> k;
            res </span>+= (r + <span style="color: #800080;">8</span>) / <span style="color: #800080;">10</span> * k + (r % <span style="color: #800080;">10</span> == <span style="color: #800080;">1</span> ? m + <span style="color: #800080;">1</span> : <span style="color: #800080;">0</span><span style="color: #000000;">);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4219878.html" target="_blank">Factorial Trailing Zeroes</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-07-08 02:50</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4629032" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4629032);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4626238.html" id="cb_post_title_url">[LeetCode] Implement Queue using Stacks 用栈来实现队列</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Implement the following operations of a queue using stacks.</p>
<ul>
<li>push(x) -- Push element x to the back of queue.</li>
<li>pop() -- Removes the element from in front of queue.</li>
<li>peek() -- Get the front element.</li>
<li>empty() -- Return whether the queue is empty.</li>
</ul>
<p><strong>Notes:</strong></p>
<ul>
<li>You must use <em>only</em> standard operations of a stack -- which means only <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, and <code>is empty</code> operations are valid.</li>
<li>Depending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack.</li>
<li>You may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue).</li>
</ul>
<p> </p>
<p>这道题让我们用栈来实现队列，之前我们做过一道相反的题目<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4568796.html" id="cb_post_title_url">Implement Stack using Queues 用队列来实现栈</a>，是用队列来实现栈。这道题颠倒了个顺序，起始并没有太大的区别，栈和队列的核心不同点就是栈是先进后出，而队列是先进先出，那么我们要用栈的先进后出的特性来模拟出队列的先进先出。那么怎么做呢，其实很简单，只要我们在插入元素的时候每次都都从前面插入即可，比如如果一个队列是1,2,3,4，那么我们在栈中保存为4,3,2,1，那么返回栈顶元素1，也就是队列的首元素，则问题迎刃而解。所以此题的难度是push函数，我们需要一个辅助栈tmp，把s的元素也逆着顺序存入tmp中，此时加入新元素x，再把tmp中的元素存回来，这样就是我们要的顺序了，其他三个操作也就直接调用栈的操作即可，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> MyQueue {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">* Initialize your data structure here. </span><span style="color: #008000;">*/</span><span style="color: #000000;">
    MyQueue() {}
    
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">* Push element x to the back of queue. </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">void</span> push(<span style="color: #0000ff;">int</span><span style="color: #000000;"> x) {
        stack</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> tmp;
        </span><span style="color: #0000ff;">while</span> (!<span style="color: #000000;">st.empty()) {
            tmp.push(st.top()); st.pop();
        }
        st.push(x);
        </span><span style="color: #0000ff;">while</span> (!<span style="color: #000000;">tmp.empty()) {
            st.push(tmp.top()); tmp.pop();
        }
    }
    
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">* Removes the element from in front of queue and returns that element. </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">int</span><span style="color: #000000;"> pop() {
        </span><span style="color: #0000ff;">int</span> val =<span style="color: #000000;"> st.top(); st.pop();
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> val;
    }
    
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">* Get the front element. </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">int</span><span style="color: #000000;"> peek() {
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> st.top();
    }
    
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">* Returns whether the queue is empty. </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">bool</span><span style="color: #000000;"> empty() {
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> st.empty();
    }
    
</span><span style="color: #0000ff;">private</span><span style="color: #000000;">:
    stack</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> st;
};</span></pre>
</div>
<p> </p>
<p>上面那个解法虽然简单，但是效率不高，因为每次在push的时候，都要翻转两边栈，下面这个方法使用了两个栈_new和_old，其中新进栈的都先缓存在_new中，入股要pop和peek的时候，才将_new中所有元素移到_old中操作，提高了效率，代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> MyQueue {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">* Initialize your data structure here. </span><span style="color: #008000;">*/</span><span style="color: #000000;">
    MyQueue() {}
    
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">* Push element x to the back of queue. </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">void</span> push(<span style="color: #0000ff;">int</span><span style="color: #000000;"> x) {
        _new.push(x);
    }
    
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">* Removes the element from in front of queue and returns that element. </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">int</span><span style="color: #000000;"> pop() {
        shiftStack();
        </span><span style="color: #0000ff;">int</span> val =<span style="color: #000000;"> _old.top(); _old.pop();
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> val;
    }
    
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">* Get the front element. </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">int</span><span style="color: #000000;"> peek() {
        shiftStack();
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> _old.top();
    }
    
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">* Returns whether the queue is empty. </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">bool</span><span style="color: #000000;"> empty() {
        </span><span style="color: #0000ff;">return</span> _old.empty() &amp;&amp;<span style="color: #000000;"> _new.empty();
    }
    
    </span><span style="color: #0000ff;">void</span><span style="color: #000000;"> shiftStack() {
        </span><span style="color: #0000ff;">if</span> (!_old.empty()) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (!<span style="color: #000000;">_new.empty()) {
            _old.push(_new.top());
            _new.pop();
        }
    }
    
</span><span style="color: #0000ff;">private</span><span style="color: #000000;">:
    stack</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> _old, _new;
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4568796.html" target="_blank">Implement Stack using Queues</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-07-07 10:30</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4626238" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4626238);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4623394.html" id="cb_post_title_url">[LeetCode] Power of Two 判断2的次方数</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given an integer, write a function to determine if it is a power of two.</p>
<p>Example 1:</p>
<pre>Input: 1
Output: true</pre>
<p>Example 2:</p>
<pre>Input: 16
Output: true</pre>
<p>Example 3:</p>
<pre>Input: 218
Output: false</pre>
<p> </p>
<p>这道题让我们判断一个数是否为2的次方数，而且要求时间和空间复杂度都为常数，那么对于这种玩数字的题，我们应该首先考虑位操作 Bit Operation。在LeetCode中，位操作的题有很多，比如比如 <a class="entrylistItemTitle" href="http://www.cnblogs.com/grandyang/p/4284205.html" id="CategoryEntryList1_EntryStoryList_ctl00_Entries_TitleUrl_24">Repeated DNA Sequences</a>，<a class="entrylistItemTitle" href="http://www.cnblogs.com/grandyang/p/4130577.html" id="CategoryEntryList1_EntryStoryList_ctl00_Entries_TitleUrl_57">Single Number</a>,  <a class="entrylistItemTitle" href="http://www.cnblogs.com/grandyang/p/4263927.html" id="CategoryEntryList1_EntryStoryList_ctl00_Entries_TitleUrl_35">Single Number II</a>，<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4315649.html" id="cb_post_title_url"> Grey Code</a>，<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4321355.html" id="cb_post_title_url"> Reverse Bits</a>，<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4431646.html" id="cb_post_title_url">Bitwise AND of Numbers Range</a>，<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4325432.html" id="cb_post_title_url">Number of 1 Bits</a> 和 <a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4431949.html" id="cb_post_title_url">Divide Two Integers</a> 等等。那么我们来观察下2的次方数的二进制写法的特点：</p>
<p>1     2       4         8         16 　　....</p>
<p>1    10    100    1000    10000　....</p>
<p>那么我们很容易看出来2的次方数都只有一个1，剩下的都是0，所以我们的解题思路就有了，我们只要每次判断最低位是否为1，然后向右移位，最后统计1的个数即可判断是否是2的次方数，代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> isPowerOfTwo(<span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        </span><span style="color: #0000ff;">int</span> cnt = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (n &gt; <span style="color: #800080;">0</span><span style="color: #000000;">) {
            cnt </span>+= (n &amp; <span style="color: #800080;">1</span><span style="color: #000000;">);
            n </span>&gt;&gt;= <span style="color: #800080;">1</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> cnt == <span style="color: #800080;">1</span><span style="color: #000000;">;
    } 
};</span></pre>
</div>
<p> </p>
<p>这道题还有一个技巧，如果一个数是2的次方数的话，根据上面分析，那么它的二进数必然是最高位为1，其它都为0，那么如果此时我们减1的话，则最高位会降一位，其余为0的位现在都为变为1，那么我们把两数相与，就会得到0，用这个性质也能来解题，而且只需一行代码就可以搞定，如下所示：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> isPowerOfTwo(<span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        </span><span style="color: #0000ff;">return</span> (n &gt; <span style="color: #800080;">0</span>) &amp;&amp; (!(n &amp; (n - <span style="color: #800080;">1</span><span style="color: #000000;">)));
    } 
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4325432.html" target="_blank">Number of 1 Bits</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/5403783.html" target="_blank">Power of Four</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/5138212.html">Power of Three</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-07-06 04:40</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4623394" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4623394);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4620012.html" id="cb_post_title_url">[LeetCode] Kth Smallest Element in a BST 二叉搜索树中的第K小的元素</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a binary search tree, write a function <code>kthSmallest</code> to find the <strong>k</strong>th smallest element in it.</p>
<p><strong>Note: </strong><br/>
You may assume k is always valid, 1 ≤ k ≤ BST's total elements.</p>
<p><strong>Follow up:</strong><br/>
What if the BST is modified (insert/delete operations) often and you 
need to find the kth smallest frequently? How would you optimize the 
kthSmallest routine?</p>
<p><strong>Hint:</strong></p>
<ol id="hints">
<li class="hint animated fadeInLeft" style="display: list-item;">Try to utilize the property of a BST.</li>
<li class="hint animated fadeInLeft" style="display: list-item;">What if you could modify the BST node's structure?</li>
<li class="hint animated fadeInLeft" style="display: list-item;">The optimal runtime complexity is O(height of BST).</li>
</ol>
<p><strong>Credits:</strong><br/>Special thanks to <a href="https://leetcode.com/discuss/user/ts">@ts</a> for adding this problem and creating all test cases.</p>
<p> </p>
<p>这又是一道关于<a href="http://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%B0%8B%E6%A8%B9" target="_blank">二叉搜索树</a> Binary Search Tree 的题， LeetCode中关于BST的题有<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4298435.html" id="cb_post_title_url">Validate Binary Search Tree 验证二叉搜索树</a>， <a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4298069.html" id="cb_post_title_url">Recover Binary Search Tree 复原二叉搜索树</a>， <a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4231455.html" id="cb_post_title_url">Binary Search Tree Iterator 二叉搜索树迭代器</a>， <a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4299608.html" id="cb_post_title_url">Unique Binary Search Trees 独一无二的二叉搜索树</a>， <a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4301096.html" id="cb_post_title_url">Unique Binary Search Trees II 独一无二的二叉搜索树之二</a>，<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4295245.html" id="cb_post_title_url">Convert Sorted Array to Binary Search Tree 将有序数组转为二叉搜索树</a> 和 <a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4295618.html" id="cb_post_title_url">Convert Sorted List to Binary Search Tree 将有序链表转为二叉搜索树</a>。</p>
<p>那么这道题给的提示是让我们用BST的性质来解题，最重要的性质是就是左&lt;根&lt;右，那么如果用中序遍历所有的节点就会得到一个有序数组。所以解题的关键还是中序遍历啊。关于二叉树的中序遍历可以参见我之前的博客<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4297300.html" id="cb_post_title_url">Binary Tree Inorder Traversal 二叉树的中序遍历</a>，里面有很多种方法可以用，我们先来看一种非递归的方法，中序遍历最先遍历到的是最小的结点，那么我们只要用一个计数器，每遍历一个结点，计数器自增1，当计数器到达k时，返回当前结点值即可，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> kthSmallest(TreeNode* root, <span style="color: #0000ff;">int</span><span style="color: #000000;"> k) {
        </span><span style="color: #0000ff;">int</span> cnt = <span style="color: #800080;">0</span><span style="color: #000000;">;
        stack</span>&lt;TreeNode*&gt;<span style="color: #000000;"> s;
        TreeNode </span>*p =<span style="color: #000000;"> root;
        </span><span style="color: #0000ff;">while</span> (p || !<span style="color: #000000;">s.empty()) {
            </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> (p) {
                s.push(p);
                p </span>= p-&gt;<span style="color: #000000;">left;
            }
            p </span>=<span style="color: #000000;"> s.top(); s.pop();
            </span>++<span style="color: #000000;">cnt;
            </span><span style="color: #0000ff;">if</span> (cnt == k) <span style="color: #0000ff;">return</span> p-&gt;<span style="color: #000000;">val;
            p </span>= p-&gt;<span style="color: #000000;">right;
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>当然，此题我们也可以用递归来解，还是利用中序遍历来解，代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> kthSmallest(TreeNode* root, <span style="color: #0000ff;">int</span><span style="color: #000000;"> k) {
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> kthSmallestDFS(root, k);
    }
    </span><span style="color: #0000ff;">int</span> kthSmallestDFS(TreeNode* root, <span style="color: #0000ff;">int</span> &amp;<span style="color: #000000;">k) {
        </span><span style="color: #0000ff;">if</span> (!root) <span style="color: #0000ff;">return</span> -<span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> val = kthSmallestDFS(root-&gt;<span style="color: #000000;">left, k);
        </span><span style="color: #0000ff;">if</span> (k == <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;"> val;
        </span><span style="color: #0000ff;">if</span> (--k == <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span> root-&gt;<span style="color: #000000;">val;
        </span><span style="color: #0000ff;">return</span> kthSmallestDFS(root-&gt;<span style="color: #000000;">right, k);
    }
};</span></pre>
</div>
<p> </p>
<p>再来看一种分治法的思路，由于BST的性质，我们可以快速定位出第k小的元素是在左子树还是右子树，我们首先计算出左子树的结点个数总和cnt，如果k小于等于左子树结点总和cnt，说明第k小的元素在左子树中，直接对左子结点调用递归即可。如果k大于cnt+1，说明目标值在右子树中，对右子结点调用递归函数，注意此时的k应为k-cnt-1，应为已经减少了cnt+1个结点。如果k正好等于cnt+1，说明当前结点即为所求，返回当前结点值即可，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> kthSmallest(TreeNode* root, <span style="color: #0000ff;">int</span><span style="color: #000000;"> k) {
        </span><span style="color: #0000ff;">int</span> cnt = count(root-&gt;<span style="color: #000000;">left);
        </span><span style="color: #0000ff;">if</span> (k &lt;=<span style="color: #000000;"> cnt) {
            </span><span style="color: #0000ff;">return</span> kthSmallest(root-&gt;<span style="color: #000000;">left, k);
        } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (k &gt; cnt + <span style="color: #800080;">1</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">return</span> kthSmallest(root-&gt;right, k - cnt - <span style="color: #800080;">1</span><span style="color: #000000;">);
        }
        </span><span style="color: #0000ff;">return</span> root-&gt;<span style="color: #000000;">val;
    }
    </span><span style="color: #0000ff;">int</span> count(TreeNode*<span style="color: #000000;"> node) {
        </span><span style="color: #0000ff;">if</span> (!node) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">1</span> + count(node-&gt;left) + count(node-&gt;<span style="color: #000000;">right);
    }
};</span></pre>
</div>
<p> </p>
<p>这道题的Follow up中说假设该BST被修改的很频繁，而且查找第k小元素的操作也很频繁，问我们如何优化。其实最好的方法还是像上面的解法那样利用分治法来快速定位目标所在的位置，但是每个递归都遍历左子树所有结点来计算个数的操作并不高效，所以我们应该修改原树结点的结构，使其保存包括当前结点和其左右子树所有结点的个数，这样我们使用的时候就可以快速得到任何左子树结点总数来帮我们快速定位目标值了。定义了新结点结构体，然后就要生成新树，还是用递归的方法生成新树，注意生成的结点的count值要累加其左右子结点的count值。然后在求第k小元素的函数中，我们先生成新的树，然后调用递归函数。在递归函数中，不能直接访问左子结点的count值，因为左子节结点不一定存在，所以我们先判断，如果左子结点存在的话，那么跟上面解法的操作相同。如果不存在的话，当此时k为1的时候，直接返回当前结点值，否则就对右子结点调用递归函数，k自减1，参见代码如下：</p>
<p> </p>
<p>解法四：</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> Follow up</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">struct</span><span style="color: #000000;"> MyTreeNode {
        </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> val;
        </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> count;
        MyTreeNode </span>*<span style="color: #000000;">left;
        MyTreeNode </span>*<span style="color: #000000;">right;
        MyTreeNode(</span><span style="color: #0000ff;">int</span> x) : val(x), count(<span style="color: #800080;">1</span><span style="color: #000000;">), left(NULL), right(NULL) {}
    };
    
    MyTreeNode</span>* build(TreeNode*<span style="color: #000000;"> root) {
        </span><span style="color: #0000ff;">if</span> (!root) <span style="color: #0000ff;">return</span><span style="color: #000000;"> NULL;
        MyTreeNode </span>*node = <span style="color: #0000ff;">new</span> MyTreeNode(root-&gt;<span style="color: #000000;">val);
        node</span>-&gt;left = build(root-&gt;<span style="color: #000000;">left);
        node</span>-&gt;right = build(root-&gt;<span style="color: #000000;">right);
        </span><span style="color: #0000ff;">if</span> (node-&gt;left) node-&gt;count += node-&gt;left-&gt;<span style="color: #000000;">count;
        </span><span style="color: #0000ff;">if</span> (node-&gt;right) node-&gt;count += node-&gt;right-&gt;<span style="color: #000000;">count;
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> node;
    }
    
    </span><span style="color: #0000ff;">int</span> kthSmallest(TreeNode* root, <span style="color: #0000ff;">int</span><span style="color: #000000;"> k) {
        MyTreeNode </span>*node =<span style="color: #000000;"> build(root);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> helper(node, k);
    }
    
    </span><span style="color: #0000ff;">int</span> helper(MyTreeNode* node, <span style="color: #0000ff;">int</span><span style="color: #000000;"> k) {
        </span><span style="color: #0000ff;">if</span> (node-&gt;<span style="color: #000000;">left) {
            </span><span style="color: #0000ff;">int</span> cnt = node-&gt;left-&gt;<span style="color: #000000;">count;
            </span><span style="color: #0000ff;">if</span> (k &lt;=<span style="color: #000000;"> cnt) {
                </span><span style="color: #0000ff;">return</span> helper(node-&gt;<span style="color: #000000;">left, k);
            } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (k &gt; cnt + <span style="color: #800080;">1</span><span style="color: #000000;">) {
                </span><span style="color: #0000ff;">return</span> helper(node-&gt;right, k - <span style="color: #800080;">1</span> -<span style="color: #000000;"> cnt);
            }
            </span><span style="color: #0000ff;">return</span> node-&gt;<span style="color: #000000;">val;
        } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            </span><span style="color: #0000ff;">if</span> (k == <span style="color: #800080;">1</span>) <span style="color: #0000ff;">return</span> node-&gt;<span style="color: #000000;">val;
            </span><span style="color: #0000ff;">return</span> helper(node-&gt;right, k - <span style="color: #800080;">1</span><span style="color: #000000;">);
        }
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4297300.html" target="_blank">Binary Tree Inorder Traversal</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/7590156.html">Second Minimum Node In a Binary Tree</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/17668/what-if-you-could-modify-the-bst-node-s-structure">https://discuss.leetcode.com/topic/17668/what-if-you-could-modify-the-bst-node-s-structure</a></p>
<p><a href="https://discuss.leetcode.com/topic/17810/3-ways-implemented-in-java-python-binary-search-in-order-iterative-recursive">https://discuss.leetcode.com/topic/17810/3-ways-implemented-in-java-python-binary-search-in-order-iterative-recursive</a></p>
<p><a href="https://discuss.leetcode.com/topic/32792/java-divide-and-conquer-solution-considering-augmenting-tree-structure-for-the-follow-up">https://discuss.leetcode.com/topic/32792/java-divide-and-conquer-solution-considering-augmenting-tree-structure-for-the-follow-up</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-07-03 23:53</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4620012" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4620012);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4606822.html" id="cb_post_title_url">[LeetCode] Majority Element II 求众数之二</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given an integer array of size <em>n</em>, find all elements that appear more than <code>⌊ n/3 ⌋</code> times. The algorithm should run in linear time and in O(1) space.</p>
<p><strong>Hint:</strong></p>
<ol id="hints">
<li class="hint animated fadeInLeft" style="display: list-item;">How many majority elements could it possibly have?</li>
<li class="hint animated fadeInLeft" style="display: list-item;">Do you have a better hint? <a href="mailto:admin@leetcode.com?subject=Hints%20for%20Majority%20Element%20II" target="_blank">Suggest it</a>!</li>
</ol>
<p> </p>
<p>这道题让我们求出现次数大于n/3的众数，而且限定了时间和空间复杂度，那么就不能排序，也不能使用哈希表，这么苛刻的限制条件只有一种方法能解了，那就是摩尔投票法 Moore Voting，这种方法在之前那道题<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4233501.html" id="cb_post_title_url">Majority Element 求众数</a>中也使用了。题目中给了一条很重要的提示，让我们先考虑可能会有多少个众数，经过举了很多例子分析得出，任意一个数组出现次数大于n/3的众数最多有两个，具体的证明我就不会了，我也不是数学专业的。那么有了这个信息，我们使用投票法的核心是找出两个候选众数进行投票，需要两遍遍历，第一遍历找出两个候选众数，第二遍遍历重新投票验证这两个候选众数是否为众数即可，选候选众数方法和前面那篇<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4233501.html" id="cb_post_title_url">Majority Element 求众数</a>一样，由于之前那题题目中限定了一定会有众数存在，故而省略了验证候选众数的步骤，这道题却没有这种限定，即满足要求的众数可能不存在，所以要有验证。代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; majorityElement(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">int</span> m = <span style="color: #800080;">0</span>, n = <span style="color: #800080;">0</span>, cm = <span style="color: #800080;">0</span>, cn = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (auto &amp;<span style="color: #000000;">a : nums) {
            </span><span style="color: #0000ff;">if</span> (a == m) ++<span style="color: #000000;">cm;
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (a ==n) ++<span style="color: #000000;">cn;
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (cm == <span style="color: #800080;">0</span>) m = a, cm = <span style="color: #800080;">1</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (cn == <span style="color: #800080;">0</span>) n = a, cn = <span style="color: #800080;">1</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">else</span> --cm, --<span style="color: #000000;">cn;
        }
        cm </span>= cn = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (auto &amp;<span style="color: #000000;">a : nums) {
            </span><span style="color: #0000ff;">if</span> (a == m) ++<span style="color: #000000;">cm;
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (a == n) ++<span style="color: #000000;">cn;
        }
        </span><span style="color: #0000ff;">if</span> (cm &gt; nums.size() / <span style="color: #800080;">3</span><span style="color: #000000;">) res.push_back(m);
        </span><span style="color: #0000ff;">if</span> (cn &gt; nums.size() / <span style="color: #800080;">3</span><span style="color: #000000;">) res.push_back(n);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4233501.html" target="_blank">Majority Element</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://leetcode.com/discuss/42806/boyer-moore-majority-vote-algorithm-generalization" target="_blank">https://leetcode.com/discuss/42806/boyer-moore-majority-vote-algorithm-generalization</a></p>
<p><a href="https://leetcode.com/discuss/42771/java-o-n-time-o-1-space-simplified-solution" target="_blank">https://leetcode.com/discuss/42771/java-o-n-time-o-1-space-simplified-solution</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-06-29 09:52</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4606822" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4606822);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4603555.html" id="cb_post_title_url">[LeetCode] Summary Ranges 总结区间</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a sorted integer array without duplicates, return the summary of its ranges.</p>
<p>For example, given <code>[0,1,2,4,5,7]</code>, return <code>["0-&gt;2","4-&gt;5","7"].</code></p>
<p><strong>Credits:</strong><br/>Special thanks to <a href="https://leetcode.com/discuss/user/jianchao.li.fighter">@jianchao.li.fighter</a> for adding this problem and creating all test cases.</p>
<p> </p>
<p>这道题给定我们一个有序数组，让我们总结区间，具体来说就是让我们找出连续的序列，然后首尾两个数字之间用个“-&gt;"来连接，那么我只需遍历一遍数组即可，每次检查下一个数是不是递增的，如果是，则继续往下遍历，如果不是了，我们还要判断此时是一个数还是一个序列，一个数直接存入结果，序列的话要存入首尾数字和箭头“-&gt;"。我们需要两个变量i和j，其中i是连续序列起始数字的位置，j是连续数列的长度，当j为1时，说明只有一个数字，若大于1，则是一个连续序列，代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; summaryRanges(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        vector</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>, n =<span style="color: #000000;"> nums.size();
        </span><span style="color: #0000ff;">while</span> (i &lt;<span style="color: #000000;"> n) {
            </span><span style="color: #0000ff;">int</span> j = <span style="color: #800080;">1</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">while</span> (i + j &lt; n &amp;&amp; nums[i + j] - nums[i] == j) ++<span style="color: #000000;">j;
            res.push_back(j </span>&lt;= <span style="color: #800080;">1</span> ? to_string(nums[i]) : to_string(nums[i]) + <span style="color: #800000;">"</span><span style="color: #800000;">-&gt;</span><span style="color: #800000;">"</span> + to_string(nums[i + j - <span style="color: #800080;">1</span><span style="color: #000000;">]));
            i </span>+=<span style="color: #000000;"> j;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://leetcode.com/discuss/42204/7-13-lines-in-c" target="_blank">https://leetcode.com/discuss/42204/7-13-lines-in-c</a></p>
<p><a href="https://leetcode.com/discuss/42298/9-lines-c-0ms-solution" target="_blank">https://leetcode.com/discuss/42298/9-lines-c-0ms-solution</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-06-27 02:25</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4603555" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4603555);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4601208.html" id="cb_post_title_url">[LeetCode] Basic Calculator II 基本计算器之二</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Implement a basic calculator to evaluate a simple expression string.</p>
<p>The expression string contains only <strong>non-negative</strong> integers, <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> operators and empty spaces <code> </code>. The integer division should truncate toward zero.</p>
<p>You may assume that the given expression is always valid.</p>
<p>Some examples:<br/>
</p>
<pre>"3+2*2" = 7
" 3/2 " = 1
" 3+5 / 2 " = 5
</pre>
<p><strong>Note:</strong> <strong>Do not</strong> use the <code>eval</code> built-in library function.</p>
<p><strong>Credits:</strong><br/>Special thanks to <a href="https://leetcode.com/discuss/user/ts">@ts</a> for adding this problem and creating all test cases.</p>
<p> </p>
<p>这道题是之前那道<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4570699.html" id="cb_post_title_url">Basic Calculator 基本计算器</a>的拓展，不同之处在于那道题的计算符号只有加和减，而这题加上了乘除，那么就牵扯到了运算优先级的问题，好在这道题去掉了括号，还适当的降低了难度，估计再出一道的话就该加上括号了。不管那么多，这道题先按木有有括号来处理，由于存在运算优先级，我们采取的措施是使用一个栈保存数字，如果该数字之前的符号是加或减，那么把当前数字压入栈中，注意如果是减号，则加入当前数字的相反数，因为减法相当于加上一个相反数。如果之前的符号是乘或除，那么从栈顶取出一个数字和当前数字进行乘或除的运算，再把结果压入栈中，那么完成一遍遍历后，所有的乘或除都运算完了，再把栈中所有的数字都加起来就是最终结果了。代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> calculate(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, num = <span style="color: #800080;">0</span>, n =<span style="color: #000000;"> s.size();
        </span><span style="color: #0000ff;">char</span> op = <span style="color: #800000;">'</span><span style="color: #800000;">+</span><span style="color: #800000;">'</span><span style="color: #000000;">;
        stack</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> st;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (s[i] &gt;= <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                num </span>= num * <span style="color: #800080;">10</span> + s[i] - <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span><span style="color: #000000;">;
            }
            </span><span style="color: #0000ff;">if</span> ((s[i] &lt; <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span> &amp;&amp; s[i] != <span style="color: #800000;">'</span> <span style="color: #800000;">'</span>) || i == n - <span style="color: #800080;">1</span><span style="color: #000000;">) {
                </span><span style="color: #0000ff;">if</span> (op == <span style="color: #800000;">'</span><span style="color: #800000;">+</span><span style="color: #800000;">'</span><span style="color: #000000;">) st.push(num);
                </span><span style="color: #0000ff;">if</span> (op == <span style="color: #800000;">'</span><span style="color: #800000;">-</span><span style="color: #800000;">'</span>) st.push(-<span style="color: #000000;">num);
                </span><span style="color: #0000ff;">if</span> (op == <span style="color: #800000;">'</span><span style="color: #800000;">*</span><span style="color: #800000;">'</span> || op == <span style="color: #800000;">'</span><span style="color: #800000;">/</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">int</span> tmp = (op == <span style="color: #800000;">'</span><span style="color: #800000;">*</span><span style="color: #800000;">'</span>) ? st.top() * num : st.top() /<span style="color: #000000;"> num;
                    st.pop();
                    st.push(tmp);
                }
                op </span>=<span style="color: #000000;"> s[i];
                num </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
            } 
        }
        </span><span style="color: #0000ff;">while</span> (!<span style="color: #000000;">st.empty()) {
            res </span>+=<span style="color: #000000;"> st.top();
            st.pop();
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>在做了<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/8873471.html" id="homepage1_HomePageDays_DaysList_ctl03_DayList_TitleUrl_0">Basic Calculator III</a>之后，再反过头来看这道题，发现只要将处理括号的部分去掉直接就可以在这道题上使用，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> calculate(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, curRes = <span style="color: #800080;">0</span>, num = <span style="color: #800080;">0</span>, n =<span style="color: #000000;"> s.size();
        </span><span style="color: #0000ff;">char</span> op = <span style="color: #800000;">'</span><span style="color: #800000;">+</span><span style="color: #800000;">'</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">char</span> c =<span style="color: #000000;"> s[i];
            </span><span style="color: #0000ff;">if</span> (c &gt;= <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span> &amp;&amp; c &lt;= <span style="color: #800000;">'</span><span style="color: #800000;">9</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                num </span>= num * <span style="color: #800080;">10</span> + c - <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span><span style="color: #000000;">;
            }
            </span><span style="color: #0000ff;">if</span> (c == <span style="color: #800000;">'</span><span style="color: #800000;">+</span><span style="color: #800000;">'</span> || c == <span style="color: #800000;">'</span><span style="color: #800000;">-</span><span style="color: #800000;">'</span> || c == <span style="color: #800000;">'</span><span style="color: #800000;">*</span><span style="color: #800000;">'</span> || c == <span style="color: #800000;">'</span><span style="color: #800000;">/</span><span style="color: #800000;">'</span> || i == n - <span style="color: #800080;">1</span><span style="color: #000000;">) {
                </span><span style="color: #0000ff;">switch</span><span style="color: #000000;"> (op) {
                    </span><span style="color: #0000ff;">case</span> <span style="color: #800000;">'</span><span style="color: #800000;">+</span><span style="color: #800000;">'</span>: curRes += num; <span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">case</span> <span style="color: #800000;">'</span><span style="color: #800000;">-</span><span style="color: #800000;">'</span>: curRes -= num; <span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">case</span> <span style="color: #800000;">'</span><span style="color: #800000;">*</span><span style="color: #800000;">'</span>: curRes *= num; <span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">case</span> <span style="color: #800000;">'</span><span style="color: #800000;">/</span><span style="color: #800000;">'</span>: curRes /= num; <span style="color: #0000ff;">break</span><span style="color: #000000;">;
                }
                </span><span style="color: #0000ff;">if</span> (c == <span style="color: #800000;">'</span><span style="color: #800000;">+</span><span style="color: #800000;">'</span> || c == <span style="color: #800000;">'</span><span style="color: #800000;">-</span><span style="color: #800000;">'</span> || i == n - <span style="color: #800080;">1</span><span style="color: #000000;">) {
                    res </span>+=<span style="color: #000000;"> curRes;
                    curRes </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
                }
                op </span>=<span style="color: #000000;"> c;
                num </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
            } 
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-06-25 23:13</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4601208" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4601208);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4572877.html" id="cb_post_title_url">[LeetCode] Invert Binary Tree 翻转二叉树</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Invert a binary tree.</p>
<pre>     4
   /   \
  2     7
 / \   / \
1   3 6   9</pre>
<p>to</p>
<pre>     4
   /   \
  7     2
 / \   / \
9   6 3   1</pre>
<p><strong>Trivia:</strong><br/>
This problem was inspired by <a href="https://twitter.com/mxcl/status/608682016205344768" target="_blank">this original tweet</a> by <a href="https://twitter.com/mxcl" target="_blank">Max Howell</a>:</p>
<blockquote>Google: 90% of our engineers use the software you wrote 
(Homebrew), but you can’t invert a binary tree on a whiteboard so fuck 
off.</blockquote>
<div class="row"> </div>
<p>这道题让我们翻转二叉树，是树的基本操作之一，不算难题。最下面那句话实在有些木有节操啊，不知道是Google说给谁的。反正这道题确实难度不大，可以用递归和非递归两种方法来解。先来看递归的方法，写法非常简洁，五行代码搞定，交换当前左右节点，并直接调用递归即可，代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> Recursion</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    TreeNode</span>* invertTree(TreeNode*<span style="color: #000000;"> root) {
        </span><span style="color: #0000ff;">if</span> (!root) <span style="color: #0000ff;">return</span><span style="color: #000000;"> NULL;
        TreeNode </span>*tmp = root-&gt;<span style="color: #000000;">left;
        root</span>-&gt;left = invertTree(root-&gt;<span style="color: #000000;">right);
        root</span>-&gt;right =<span style="color: #000000;"> invertTree(tmp);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> root;
    }
};</span></pre>
</div>
<p> </p>
<p>非递归的方法也不复杂，跟二叉树的层序遍历一样，需要用queue来辅助，先把根节点排入队列中，然后从队中取出来，交换其左右节点，如果存在则分别将左右节点在排入队列中，以此类推直到队列中木有节点了停止循环，返回root即可。代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> Non-Recursion</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    TreeNode</span>* invertTree(TreeNode*<span style="color: #000000;"> root) {
        </span><span style="color: #0000ff;">if</span> (!root) <span style="color: #0000ff;">return</span><span style="color: #000000;"> NULL;
        queue</span>&lt;TreeNode*&gt;<span style="color: #000000;"> q;
        q.push(root);
        </span><span style="color: #0000ff;">while</span> (!<span style="color: #000000;">q.empty()) {
            TreeNode </span>*node =<span style="color: #000000;"> q.front(); q.pop();
            TreeNode </span>*tmp = node-&gt;<span style="color: #000000;">left;
            node</span>-&gt;left = node-&gt;<span style="color: #000000;">right;
            node</span>-&gt;right =<span style="color: #000000;"> tmp;
            </span><span style="color: #0000ff;">if</span> (node-&gt;left) q.push(node-&gt;<span style="color: #000000;">left);
            </span><span style="color: #0000ff;">if</span> (node-&gt;right) q.push(node-&gt;<span style="color: #000000;">right);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> root;
    }
};</span></pre>
</div>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-06-13 00:54</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4572877" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4572877);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4568796.html" id="cb_post_title_url">[LeetCode] Implement Stack using Queues 用队列来实现栈</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Implement the following operations of a stack using queues.</p>
<ul>
<li>push(x) -- Push element x onto stack.</li>
<li>pop() -- Removes the element on top of the stack.</li>
<li>top() -- Get the top element.</li>
<li>empty() -- Return whether the stack is empty.</li>
</ul>
<p>Notes:</p>
<ul>
<li>You may assume that all operations are valid (for example, no pop or top operations will be called on an empty stack).</li>
<li>Depending on your language, queue may not be supported natively. You may simulate a queue by using a list or deque (double-ended queue), as long as you use only standard operations of a queue -- which means only <code>push to back</code>, <code>pop from front</code>, <code>size</code>, and <code>is empty</code> operations are valid.</li>
</ul>
<p> </p>
<p>Credits:<br/>Special thanks to <a href="https://leetcode.com/discuss/user/jianchao.li.fighter">@jianchao.li.fighter</a> for adding this problem and all test cases.</p>
<p> </p>
<p>这道题让我们用队列来实现栈，队列和栈作为两种很重要的数据结构，它们最显著的区别就是，队列是先进先出，而栈是先进后出。题目要求中又给定了限制条件只能用queue的最基本的操作，像back()这样的操作是禁止使用的。那么怎么样才能让先进先出的特性模拟出先进后出呢，这里就需要另外一个队列来辅助操作，我们总共需要两个队列，其中一个队列用来放最后加进来的数，模拟栈顶元素。剩下所有的数都按顺序放入另一个队列中。当push操作时，将新数字先加入模拟栈顶元素的队列中，如果此时队列中有数字，则将原本有的数字放入另一个队中，让新数字在这队中，用来模拟栈顶元素。当top操作时，如果模拟栈顶的队中有数字则直接返回，如果没有则到另一个队列中通过平移数字取出最后一个数字加入模拟栈顶的队列中。当pop操作时，先执行下top()操作，保证模拟栈顶的队列中有数字，然后再将该数字移除即可。当empty操作时，当两个队列都为空时，栈为空。代码如下：</p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Stack {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> Push element x onto stack.</span>
    <span style="color: #0000ff;">void</span> push(<span style="color: #0000ff;">int</span><span style="color: #000000;"> x) {
        q2.push(x);
        </span><span style="color: #0000ff;">while</span> (q2.size() &gt; <span style="color: #800080;">1</span><span style="color: #000000;">) {
            q1.push(q2.front());
            q2.pop();
        }
    }

    </span><span style="color: #008000;">//</span><span style="color: #008000;"> Removes the element on top of the stack.</span>
    <span style="color: #0000ff;">void</span> pop(<span style="color: #0000ff;">void</span><span style="color: #000000;">) {
        top();
        q2.pop();
    }

    </span><span style="color: #008000;">//</span><span style="color: #008000;"> Get the top element.</span>
    <span style="color: #0000ff;">int</span> top(<span style="color: #0000ff;">void</span><span style="color: #000000;">) {
        </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (q2.empty()) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; (<span style="color: #0000ff;">int</span>)q1.size() - <span style="color: #800080;">1</span>; ++<span style="color: #000000;">i) {
                q1.push(q1.front());
                q1.pop();
            }
            q2.push(q1.front());
            q1.pop();
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> q2.front();
    }

    </span><span style="color: #008000;">//</span><span style="color: #008000;"> Return whether the stack is empty.</span>
    <span style="color: #0000ff;">bool</span> empty(<span style="color: #0000ff;">void</span><span style="color: #000000;">) {
        </span><span style="color: #0000ff;">return</span> q1.empty() &amp;&amp;<span style="color: #000000;"> q2.empty();
    }
    
</span><span style="color: #0000ff;">private</span><span style="color: #000000;">:
    queue</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> q1, q2;
};</span></pre>
</div>
<p> </p>
<p>这道题还有另一种解法，可以参见另一道类似的题<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4626238.html" id="cb_post_title_url">Implement Queue using Stacks 用栈来实现队列</a>，我个人来讲比较偏爱下面这种方法，比较好记，只要实现对了push函数，后面三个直接调用队列的函数即可。这种方法的原理就是每次把新加入的数插到前头，这样队列保存的顺序和栈的顺序是相反的，它们的取出方式也是反的，那么反反得正，就是我们需要的顺序了。我们需要一个辅助队列tmp，把s的元素也逆着顺序存入tmp中，此时加入新元素x，再把tmp中的元素存回来，这样就是我们要的顺序了，其他三个操作也就直接调用队列的操作即可，参见代码如下：</p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Stack {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> Push element x onto stack.</span>
    <span style="color: #0000ff;">void</span> push(<span style="color: #0000ff;">int</span><span style="color: #000000;"> x) {
        queue</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> tmp;
        </span><span style="color: #0000ff;">while</span> (!<span style="color: #000000;">q.empty()) {
            tmp.push(q.front());
            q.pop();
        }
        q.push(x);
        </span><span style="color: #0000ff;">while</span> (!<span style="color: #000000;">tmp.empty()) {
            q.push(tmp.front());
            tmp.pop();
        }
    }

    </span><span style="color: #008000;">//</span><span style="color: #008000;"> Removes the element on top of the stack.</span>
    <span style="color: #0000ff;">void</span><span style="color: #000000;"> pop() {
        q.pop();
    }

    </span><span style="color: #008000;">//</span><span style="color: #008000;"> Get the top element.</span>
    <span style="color: #0000ff;">int</span><span style="color: #000000;"> top() {
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> q.front();
    }

    </span><span style="color: #008000;">//</span><span style="color: #008000;"> Return whether the stack is empty.</span>
    <span style="color: #0000ff;">bool</span><span style="color: #000000;"> empty() {
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> q.empty();
    }
    
</span><span style="color: #0000ff;">private</span><span style="color: #000000;">:
    queue</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> q;
};</span></pre>
</div>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-06-11 12:49</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4568796" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4568796);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4570699.html" id="cb_post_title_url">[LeetCode] Basic Calculator 基本计算器</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Implement a basic calculator to evaluate a simple expression string.</p>
<p>The expression string may contain open <code>(</code> and closing parentheses <code>)</code>, the plus <code>+</code> or minus sign <code>-</code>, <strong>non-negative</strong> integers and empty spaces <code> </code>.</p>
<p>You may assume that the given expression is always valid.</p>
<p>Some examples:<br/>
</p>
<pre>"1 + 1" = 2
" 2-1 + 2 " = 3
"(1+(4+5+2)-3)+(6+8)" = 23
</pre>
<p><strong>Note:</strong> <strong>Do not</strong> use the <code>eval</code> built-in library function.</p>
<p> </p>
<p>这道题让我们实现一个基本的计算器来计算简单的算数表达式，而且题目限制了表达式中只有加减号，数字，括号和空格，没有乘除，那么就没啥计算的优先级之分了。于是这道题就变的没有那么复杂了。我们需要一个栈来辅助计算，用个变量sign来表示当前的符号，我们遍历给定的字符串s，如果遇到了数字，由于可能是个多位数，所以我们要用while循环把之后的数字都读进来，然后用sign*num来更新结果res；如果遇到了加号，则sign赋为1，如果遇到了符号，则赋为-1；如果遇到了左括号，则把当前结果res和符号sign压入栈，res重置为0，sign重置为1；如果遇到了右括号，结果res乘以栈顶的符号，栈顶元素出栈，结果res加上栈顶的数字，栈顶元素出栈。代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> calculate(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, sign = <span style="color: #800080;">1</span>, n =<span style="color: #000000;"> s.size();
        stack</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> st;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">char</span> c =<span style="color: #000000;"> s[i];
            </span><span style="color: #0000ff;">if</span> (c &gt;= <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                </span><span style="color: #0000ff;">int</span> num = <span style="color: #800080;">0</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">while</span> (i &lt; n &amp;&amp; s[i] &gt;= <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                    num </span>= <span style="color: #800080;">10</span> * num + s[i++] - <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span><span style="color: #000000;">;
                }
                res </span>+= sign *<span style="color: #000000;"> num;
                </span>--<span style="color: #000000;">i;
            } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (c == <span style="color: #800000;">'</span><span style="color: #800000;">+</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                sign </span>= <span style="color: #800080;">1</span><span style="color: #000000;">;
            } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (c == <span style="color: #800000;">'</span><span style="color: #800000;">-</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                sign </span>= -<span style="color: #800080;">1</span><span style="color: #000000;">;
            } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (c == <span style="color: #800000;">'</span><span style="color: #800000;">(</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                st.push(res);
                st.push(sign);
                res </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
                sign </span>= <span style="color: #800080;">1</span><span style="color: #000000;">;
            } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (c == <span style="color: #800000;">'</span><span style="color: #800000;">)</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                res </span>*=<span style="color: #000000;"> st.top(); st.pop();
                res </span>+=<span style="color: #000000;"> st.top(); st.pop();
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种方法和上面的基本一样，只不过对于数字的处理略微不同，上面的方法是连续读入数字，而这种方法是使用了一个变量来保存读入的num，所以在遇到其他字符的时候，都要用sign*num来更新结果res，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> calculate(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, num = <span style="color: #800080;">0</span>, sign = <span style="color: #800080;">1</span>, n =<span style="color: #000000;"> s.size();
        stack</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> st;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">char</span> c =<span style="color: #000000;"> s[i];
            </span><span style="color: #0000ff;">if</span> (c &gt;= <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                num </span>= <span style="color: #800080;">10</span> * num + (c - <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span><span style="color: #000000;">);
            } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (c == <span style="color: #800000;">'</span><span style="color: #800000;">+</span><span style="color: #800000;">'</span> || c == <span style="color: #800000;">'</span><span style="color: #800000;">-</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                res </span>+= sign *<span style="color: #000000;"> num;
                num </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
                sign </span>= (c == <span style="color: #800000;">'</span><span style="color: #800000;">+</span><span style="color: #800000;">'</span>) ? <span style="color: #800080;">1</span> : -<span style="color: #800080;">1</span><span style="color: #000000;">;
             } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (c == <span style="color: #800000;">'</span><span style="color: #800000;">(</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                st.push(res);
                st.push(sign);
                res </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
                sign </span>= <span style="color: #800080;">1</span><span style="color: #000000;">;
            } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (c == <span style="color: #800000;">'</span><span style="color: #800000;">)</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                res </span>+= sign *<span style="color: #000000;"> num;
                num </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
                res </span>*=<span style="color: #000000;"> st.top(); st.pop();
                res </span>+=<span style="color: #000000;"> st.top(); st.pop();
            }
        }
        res </span>+= sign *<span style="color: #000000;"> num;
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>在做了<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/8873471.html" id="homepage1_HomePageDays_DaysList_ctl03_DayList_TitleUrl_0">Basic Calculator III</a>之后，再反过头来看这道题，发现递归处理括号的方法在这道题也同样适用，我们用一个变量cnt，遇到左括号自增1，遇到右括号自减1，当cnt为0的时候，说明括号正好完全匹配，这个trick在验证括号是否valid的时候经常使用到。然后我们就是根据左右括号的位置提取出中间的子字符串调用递归函数，返回值赋给num，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> calculate(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, num = <span style="color: #800080;">0</span>, sign = <span style="color: #800080;">1</span>, n =<span style="color: #000000;"> s.size();
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">char</span> c =<span style="color: #000000;"> s[i];
            </span><span style="color: #0000ff;">if</span> (c &gt;= <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span> &amp;&amp; c &lt;= <span style="color: #800000;">'</span><span style="color: #800000;">9</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                num </span>= <span style="color: #800080;">10</span> * num + (c - <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span><span style="color: #000000;">);
            } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (c == <span style="color: #800000;">'</span><span style="color: #800000;">(</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                </span><span style="color: #0000ff;">int</span> j = i, cnt = <span style="color: #800080;">0</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">for</span> (; i &lt; n; ++<span style="color: #000000;">i) {
                    </span><span style="color: #0000ff;">if</span> (s[i] == <span style="color: #800000;">'</span><span style="color: #800000;">(</span><span style="color: #800000;">'</span>) ++<span style="color: #000000;">cnt;
                    </span><span style="color: #0000ff;">if</span> (s[i] == <span style="color: #800000;">'</span><span style="color: #800000;">)</span><span style="color: #800000;">'</span>) --<span style="color: #000000;">cnt;
                    </span><span style="color: #0000ff;">if</span> (cnt == <span style="color: #800080;">0</span>) <span style="color: #0000ff;">break</span><span style="color: #000000;">;
                }
                num </span>= calculate(s.substr(j + <span style="color: #800080;">1</span>, i - j - <span style="color: #800080;">1</span><span style="color: #000000;">));
            }
            </span><span style="color: #0000ff;">if</span> (c == <span style="color: #800000;">'</span><span style="color: #800000;">+</span><span style="color: #800000;">'</span> || c == <span style="color: #800000;">'</span><span style="color: #800000;">-</span><span style="color: #800000;">'</span> || i == n - <span style="color: #800080;">1</span><span style="color: #000000;">) {
                res </span>+= sign *<span style="color: #000000;"> num;
                num </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
                sign </span>= (c == <span style="color: #800000;">'</span><span style="color: #800000;">+</span><span style="color: #800000;">'</span>) ? <span style="color: #800080;">1</span> : -<span style="color: #800080;">1</span><span style="color: #000000;">;
             } 
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/8934427.html" id="homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0">Basic Calculator IV</a></p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/8873471.html" id="homepage1_HomePageDays_DaysList_ctl03_DayList_TitleUrl_0">Basic Calculator III</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4601208.html" target="_blank">Basic Calculator II</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-06-12 02:30</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4570699" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4570699);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4563153.html" id="cb_post_title_url">[LeetCode] Rectangle Area 矩形面积</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Find the total area covered by two rectilinear rectangles in a2D plane.</p>
<p>Each rectangle is defined by its bottom left corner and top right corner as shown in the figure.</p>
<div><img alt="Rectangle Area" border="0" src="https://leetcode.com/static/images/problemset/rectangle_area.png"/></div>
<div>
<p>Assume that the total area is never beyond the maximum possible value of int.</p>
</div>
<p>Credits:<br/>Special thanks to <a href="https://leetcode.com/discuss/user/mithmatt">@mithmatt</a> for adding this problem, creating the above image and all test cases.</p>
<p> </p>
<p>这道题不算一道很难的题，但是我还是花了很久才做出来，刚开始我尝试找出所以有重叠的情况，发现有很多种情况，很麻烦。后来换了一种思路，尝试先找出所有的不相交的情况，只有四种，一个矩形在另一个的上下左右四个位置不重叠，这四种情况下返回两个矩形面积之和。其他所有情况下两个矩形是有交集的，这时候我们只要算出长和宽，即可求出交集区域的大小，然后从两个巨型面积之和中减去交集面积就是最终答案。求交集区域的长和宽也不难，由于交集都是在中间，所以横边的左端点是两个矩形左顶点横坐标的较大值，右端点是两个矩形右顶点的较小值，同理，竖边的下端点是两个矩形下顶点纵坐标的较大值，上端点是两个矩形上顶点纵坐标的较小值。代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> computeArea(<span style="color: #0000ff;">int</span> A, <span style="color: #0000ff;">int</span> B, <span style="color: #0000ff;">int</span> C, <span style="color: #0000ff;">int</span> D, <span style="color: #0000ff;">int</span> E, <span style="color: #0000ff;">int</span> F, <span style="color: #0000ff;">int</span> G, <span style="color: #0000ff;">int</span><span style="color: #000000;"> H) {
        </span><span style="color: #0000ff;">int</span> sum = (C - A) * (D - B) + (H - F) * (G -<span style="color: #000000;"> E);
        </span><span style="color: #0000ff;">if</span> (E &gt;= C || F &gt;= D || B &gt;= H || A &gt;= G) <span style="color: #0000ff;">return</span><span style="color: #000000;"> sum;
        </span><span style="color: #0000ff;">return</span> sum - ((min(G, C) - max(A, E)) * (min(D, H) -<span style="color: #000000;"> max(B, F)));
    }
};</span></pre>
</div>
<p> </p>
<p>当然，这三行还可以丧心病狂地合成一行，那么LeetCode中我遇见的第一次一行解题的方法如下所示：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> computeArea(<span style="color: #0000ff;">int</span> A, <span style="color: #0000ff;">int</span> B, <span style="color: #0000ff;">int</span> C, <span style="color: #0000ff;">int</span> D, <span style="color: #0000ff;">int</span> E, <span style="color: #0000ff;">int</span> F, <span style="color: #0000ff;">int</span> G, <span style="color: #0000ff;">int</span><span style="color: #000000;"> H) {
        </span><span style="color: #0000ff;">return</span> (C - A) * (D - B) + (H - F) * (G - E) - (max((min(G, C) - max(A, E)), <span style="color: #800080;">0</span>) * max((min(D, H) - max(B, F)), <span style="color: #800080;">0</span><span style="color: #000000;">));
    }
};</span></pre>
</div>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-06-09 12:56</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4563153" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4563153);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4567827.html" id="cb_post_title_url">[LeetCode] Count Complete Tree Nodes 求完全二叉树的节点个数</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a <strong>complete</strong> binary tree, count the number of nodes.</p>
<p><strong><span style="text-decoration: underline;">Definition of a complete binary tree from <a href="http://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees" target="_blank">Wikipedia</a>:</span></strong><br/>
In a complete binary tree every level, except possibly the last, is 
completely filled, and all nodes in the last level are as far left as 
possible. It can have between 1 and 2<sup>h</sup> nodes inclusive at the last level h.</p>
<p> </p>
<p>这道题给定了一棵完全二叉树，让我们求其节点的个数。很多人分不清完全二叉树和满二叉树的区别，下面让我们来看看维基百科上对二者的定义：</p>
<p><a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91" target="_blank">完全二叉树 (Complete Binary Tree)</a>：</p>
<p>A Complete Binary Tree （CBT) is a binary tree in which every level, except possibly the last, is completely filled, and all nodes are as far left as possible.</p>
<p>对于一颗二叉树，假设其深度为d（d&gt;1）。除了第d层外，其它各层的节点数目均已达最大值，且第d层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树；</p>
<p>换句话说，完全二叉树从根结点到倒数第二层满足完美二叉树，最后一层可以不完全填充，其叶子结点都靠左对齐。</p>
<p><a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91" target="_blank">完美二叉树 (Perfect Binary Tree)</a>：</p>
<p>A Perfect Binary Tree(PBT) is a tree with all leaf nodes at the same depth. All internal nodes have degree 2.</p>
<p>二叉树的第i层至多拥有<span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y"><img alt="2^{i-1}" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/de838b503259acc792dd682654445984ea6e4c6d"/>个节点数；深度为k的二叉树至多总共有<span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y"><img alt="{\displaystyle 2^{\begin{aligned}k+1\end{aligned}}-1}" class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f24729d4eae59094b7ed114e09dcbf142f32cde8"/>个节点数，而总计拥有节点数匹配的，称为“满二叉树”</span></span></span></span>；</p>
<p><a href="http://www.cnblogs.com/idorax/p/6441043.html" target="_blank">完满二叉树 (Full Binary Tree):</a></p>
<p>A Full Binary Tree (FBT) is a tree in which every node other than the leaves has two children.</p>
<p>换句话说，所有非叶子结点的度都是2。（只要你有孩子，你就必然是有两个孩子。）</p>
<p><a class="rg_l" href="http://www.google.com/imgres?imgurl=http://zy.swust.net.cn/02/2/sjjg/images/chap06/C6P3.gif&amp;imgrefurl=http://zy.swust.net.cn/02/2/sjjg/page/chap06/060201.asp&amp;h=200&amp;w=500&amp;tbnid=ASz3gK5eek0jvM:&amp;zoom=1&amp;docid=u6zq2P7Qe63VCM&amp;ei=JmR4VfHKOMPWsAWwn4LICw&amp;tbm=isch&amp;ved=0CCEQMygEMARqFQoTCPH1y7HEhcYCFUMrrAodsI8AuQ" style="width: 355px; height: 142px; left: 0px;"><img alt="Image result for 满二叉树" class="rg_i" data-sz="f" name="ASz3gK5eek0jvM:" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAWMAAACOCAMAAADTsZk7AAACEFBMVEX///8AAAAAjv///5n/AAD//5sAjP8Aiv8Ak////5YAlf8An////50Akf8Al////8t1dXX//6L//7P29vYAmf///2H//8Gr4v85OTn//4P//7jv7+8sLCz//5H//6v//3nIyMh4tP/J4v9kZGRLS0vw8PDe7qnj4+Onp6eDg4P//8hwcHCMjIzBwcEbGxu3t7e76Or1//9VVVUwo/SEwP///3KdnZ0+Pj7U1NT//1sAo/+/2eQWFhb/+////zAmJibs9f/b6f93s/9suP/o///z98z/OwDc8/9csP85uP9Jn//W9P+0zeav1P/u6f+27////0eiz///X0Ga3P/T4f+H0f90wP//axD/q3z/WCEAovK4yf//6Hv/ABqRz+alwf9zueb/NyX/2qz/s3Jhxv+/5///l0v/5m7/9DTV6dXf7sbU6OX/oT5Tovry89Pgvb7/1X//zXj/65HU+tT/zU3/pmC0wv//6q+v3texycf/1zz/xYv/bFL/PTmzqsfS2uz/f0v/hkf/SC7/ty3/dR+Gr83/653/jFjBwK/o/8v/1XL/x5j/VlOHq/+Xyuya3OHM1f+87NL/jS//aTH/fhz/4if/y1n/tGL/im7/s0b90rX/oGb/rJP/oEr/5kv/oyD/uEz/eQD/1Rz/rAM4tt7/uo7/fTTL87//wyn/kwD/WgFqyuOhvOH/xQ180M6QyNIK/FBXAAAeoUlEQVR4nO19i18a177vPGGGgRmQGRQURDDh4QN5KeILRBAxJsEH1tREbLXxETzRpDe5affZTcxpbrJP00bz2L37bk3TfXsS257+i3ctQASdMZhqTO6Hbz9N6te11vzWb37rt9b6/daaIkgFFVRQQQUVVFBBBRVUUEEFFfx/j9Dg4GDotIU4HAMjPoDh0xbjHeGe788Eg8FMQ/i0JZFGyEexTDDIU6qPUsvhOMVMjI1N9Aep79ynLYwEeuKyua7lpaXlK0HFyGkLc3T0eLHHK5zTVMUtprGJD1PJ7hT2OOo0aTQaLqqgPj5LnlE95gwaDY5rlNEGfv60xRHFiHzCaTDi5Noabbrh5T9MQ5BGmE+tGGhSP/3FKql8yCdCpy2QGPhg1ICT+tV7oxq66gr7sXkLn2yF05B6YZ14SdOG37APcd4blldzJlzf+Tq2XU9rnMHUR2bIQyxXheuF3jexLUFJRzHfaQskghFsWUfjwsWnxIJgpKsy8dBpS3Q0DA1xVbS/8w7x+8VO/QesY9zf+Zr4ufeigH+kOhYuEju9vZ31H7COaX3nziSQ0Q90nAmdtkRHw5AM+oot4nVvp6A0rmDJ0xZIBCHsCvAVW7PbQEYjfZb5EO3gMIzIlnVK2j+11SnocVPDBznnIQlZtAo33rwqABk1adUPpy3PETHo9S6ZaKXf79eT+KIioj1tgcRgYdJOHDfq9XrcuMgM9Zy2PEdFkup/aKJxEqeNi152/LTFEYU7RaWXDEqNRmm6rVB9iO7scIyzquAip1NquNsUo+gPnbY8okiy2KXvF2/c6PqVj0TY1MBpy3M0jPDMhFc+lE6nvfL48Kd8xnLaEongO0XmBwpjvJdUsu8Qt0/mPX/aEh0FM7w8jAyOJTAVlrAAPzccZD+4oTjMKCbgX2NjY/PZHd4Iz3+IliCOUAqL7N+XTqiGQqchiyTGvapP91FhOZP8SPbToQzWHzrAVquCH5KVWFh+v4qB5HFVf+i9i/IOCHsp0XhxKEJ9OLPKDM+KxVt7UtjHsKO2yBmJxXzPCMN8GIFw9wx2KST+G58q8WEGu4swo2CkXYKFYarfoywFhCwQhb0mnC9CUmXDvLy6R6zWqSGclSNU+DmCxQ9bALkjit2xGH5/PUjGZXIANpJ7GpgvvgtJl56Pq7KRi2SmpNZpIeTjoRiyYH5hFurHGt7icn9QZV1JKMlke8D7QictJJJgvW0POe6Gj1HBVEc4Iz5fFDAQ5xNuRMHHd2udZiBjjGJ8NziOa4vzKvjzsCq74jwcAwkqiVyg+MgTUPOJj1edsJn0+PgJTlcFYFgMAj82HmRG3rZAm1B4U8W1Ts+Sh+XMMmeAcjjHoD1amPIS6GPySIKfd2Z7oGtjvKETldJC9XMcSdM4jeuWVd7qw+aLAj5VUA2cUwlrkaBW/EQlPATuIahinAbQcD6VZYQqN30eDrJdnI4EHaBJ57kTjt8H+YdOJfkiRnxhpHXfK1SJsozSC2rhq6OXY/dxWvcHeyozNUASm+eq6LVN4t4jXKPzUlS83IXZIJZy6mj8CyI2+xWpS5/oyYAB+RWnEn9BbLye8hvxs8FMWTGJbC367uVXr2evGsmz/Ntd4InAnVJFgRWPEusb1+pxzfeq8tO6E/JFHWm8Smzc+eUbXPlfspO0kmxCyfjjxrP79wV92Um7XC3/642dN7BW4pQ2Ju5Lc04TPf309evYTb/SuHiEdNLQJfB29MKz7Z+mboKhiEVOUMwRrEuH+29uxLafdcLEaHneP5dO3SSIN9l06inqmDMZhfWdnd8vCnr6yDoWbhJE7E6n/sR1DLVFbD7rPUryOZ+yXni1s3CqOvYOAR3/SKwv9PYK9NF07IU67lxYePO003jCOgaeVYc/IO7H3lyEidFgquxaa788vxabzNY6RX/sNK3NTk4RYBCSxu/l5YciJuRLBvzzjfWnxHPwdk7WHyNeljN9Ept9uiX4aWUXO1ZuLeetWYLYyNY6xXWFqku39nVs6sdO4CpMTLD8yOugzOfU/J0gpl4K9bQmzZxoEKaamouacE29n8aVi5e8ZUpZTU1ETaTG78dhrfhpRZVDjHfRqVQa/fVKvOq/qTINBKInrrjNaUjc71fiptvM3MnJCNFA+aImI1jFK21eedkh7H6Fj8vVCnhPeit6CKpl3jYd3IMYq3x85iiZ82GeueLUwJqac0HV3AlbSVKRWYwCpKmjZBV91G4tnv3u5IR7G6oVfHoJiLEYpyJHO5wwnGAjsAdLaVU8yfMnG1UOB1UYgIqZO1JO1KeAtTA+dT6lip+eJTfkxMBUR17buCeobMeZiR5kOE6dZEL1B0Y2Pu5L+Xj+SIoKJXhQKzITBqNsBitvB34C+I5NhGciKd8P1e+gJCyeSkU+DUE/4Y4oGk7MX0zI8gZgkR1hygCDFCsqPh/k3xqsOwkMBhUFzfqwC0esPUIV+8Zqhj+ZIG3PhKxwHDPIHEVNGWyw6KfBoMz3/s9qWRLYXmLXHT/qwdKItySYH8rIkyfQB5hoLjjhMdkRbiNYqP4SeUINqvigVOETgoVni033fBnR+WKEmYZSwu1THP+G9Xxc5tuz3XAwU/7RRh+7bw0CzxG9V6fsnpHtm2pH5EfaSSTlof2UxauqPl5TvsCXnk5qoMpeu4W8B+PyI6VmdcJwp2T7jc49xBxhZdRDXTpIhuZUx7kd6ZmX7ztbFVZlyq08IrbBP++Vvbdz4KGMyAQQCg6VP6VcELf6JB9856VyKAkvPhelYJMKdv88GqdgkeShad3wDCzDYGK/G85Q/bByyLfvWceA8/PV1fMFMx30ysSc7wV2orq6+q06GrCAUnFGXL6wNx9+6bGU09YeenwK3gvAKHZPTvhUzD5d9kyw2TIsMyb+dCS7buczoAyvEj/5llQww6FI7lm84og7r0NwIa5gGIanvJZsk2OUaBBnOKMCpRhF4lDNhOMsD0pRQQnXCw9shZBhnyLbVvmL0gZqbtnJcdxyms/AOgM+NrJPxQMJWaQLFOG6fLKMRLs9cVlqOcpxD7vSmHiiNEkxPJte5rLPUvSXKd7b4MP4x21tbV3nGNkMkGJMJrrnGeNZWKrtCnPYCmNexfzaBUsBzyYxx48wwSSvSmXbGpKVGVr2UXMcp4HgrsB9/UAG8+1XYwQbi3LwcrQh+qvEDW53SvU4ylWBMlXONCbejwsqaoRzwkeZuAnqePzzjCKzwnEmpYFbSinG3D7xZaKFjS9ynE5p4lbi0icAworEX3NtRRuoGalCCUq1GOV0oA/RNCZVqgSD8jjnVOJG/SNSo/PJ5sfZgxvPat63UmUk6dXVRzgnkacdwSJOnRHHjavTRkNaIToiq7Gk04nT11dXr5uccdlxrJlDMu9DJ0njOE5rot7gENYvZgGD3sQiZ6Jx0INbKwmpk4PuDLOsg5fAydVvnRGZ1GozztwGba0BZVTp0nw54fEUvwxUXF//lLhKapa8QUY+v98VuSNslKOV9ZsE8SWu5OSi+ZAEtqjDSf305ixo5wYjVsYdjK+AZz2fJYjZac2i9zhyOD6+DVpIff3VL0nNMsaK78ZmsB+AWpRXpwhi1RCgGsSd7bz8V66KNtY/Gr23prkhsgLNwqJ4HAVtjRIE8UKpU5WxWhmIz3Ek6b85tRnbqsc1VyiRo5dh2RyQsH5zZ+OmYKQNv8rERJSl4AXqO8TUlmDEq+Ji+VUL/5ijSf+Prxd2NuCNs+CfP+4bZlKcjjYKwjZB4LTTx4gX8+auR89ObtzU0wZvUEQ4gHhm0QDaukNM+nFc83j/Tmq3FOZ0kvj0duf27DRe9UcZozHM+DjS+Pzy650NoZ7UnKNEYh9hLKnTGP2XCWK9008ab8vFdCxvg5ci7xFTP3fW41W/BkUePc+0cbhRuNg79RO81Zc8husN88xjDlf6t+7/NDkFxJfQS48sAgy0foEgYjcF0vSHhBuIR1aACWzFiJ0f/UZNm/g5WfdQEBicX+jdhtfZjStlRMugjpWPYteeEtsXQcPnxIQMYz4whITXr37fATqml8V13KWjyX8Sb7ZjMBv93+I6vsDh9ULv09gCeJYpebSAqShgk0q9sDP5M/FKMErqGIvocFq4uP5se0MgjX9gIdHG4mkOJ/3bxJs3U4LR9CQooWOY7xYuviJ+h1etF8s4qjUYTHHKVeAhY9sXoSGIxfzDsgmdkn7+7HVsG9rx96I6ll1x0uQ3Ows7TzsFWsqOr3A4/GbEq97s7VTmz0960I5JI3i1YIz5pXUsi+g0tPD62c/ES6hjKTtOQR1v7izENgS95raUHXuhjheIp7298NxGOVHfuHcFx6/+SDy7KAB/nOZFioQSXqfpOvDxsc5OPV2VCIq1I08Af7wai4ERVE+bvAcuDgEMBNNg6vRPEgvwWaYh0XaOBjgMceWLbBocmEiaF53N3F4e+OMXRIz4RRBwU1zCH2cy0Fe8hH3w0+B9ia6f3MAfg8lpndjuFYCvuF3O6qgaGKCSvHpX8PtJ5W3RXSgyoeji1r55cFPwg8XZbfE358OeGHDloy/gDWTNb+I3T/uxZR1JPrh21V+PK9uOFveXQIRZBD7KvzEl+JXGZUwiqDKDPanCr29e2xLAhPxfrNS6QtYF1ij+m9c665X0Wa9XvC0LBYYO+dX954JA0waqnM/kuIMM7LhRb8SV0Uviw3eY8d4w4UqjXknTTxhxKzifYBcNRhLX07jxSZAVLROWeZd0sB0jrlm6hB1HduSCLAIzyI9W9TSt6cckZtEwm1mpopV6vd5I6yIKiVJAFaBU9g44rUlJHV0Z8AYXq2gStoUrr5S1PkbGFfw5J04qSXI5cSASlMcPLA9PHChxg5nnJS5wW3jFbSd4E3jVIq+QCGSOUTAdD56l7OJ5Nn4cV7UiqshDjZIEG4ezKYntJXywYmiligQ7FVz3L+nNtIWCNgDbMqVVYt4uixGKvVEFdIErSVCqvD6EMqpUF0BafKefxXBc1Q/LRFTS16sscWwOlvFi0osyCyNP556VCc9gieO4b59SeLuWHp592OWVTUjHmcZ4tm3x7NmzXRnqkHiFJej9HpRa6srIDokMjgRVjxeXzp69nWYlX8R+nFdRGEZRqolD3Pe8goK5cBmVkA51zzO5fHmKkh5AgxMUeBRGTYSQnjHJq3JHQCgOBIOhPAVzaDrMR8mCXm9QJjs0VzCYwEApL8aMHRYWHI7IYSleVna6e1jBj4xbMoef6OlXwKtU88iI9HhEkqpPh0EhmKk5rK3xeDxvv4Pxw0yvLFyQA48439/QkJHYluUxzPiGfQ0NkbdmY86DtvrfGrMMgbYaDl62lcJ4kIIGYMEOO9EzzuYPM/UEJaeqngSVV5hbdCtdQKQQqAhlsIbDSr4VI/zuFDLIxA97XZH9EfH3CeDBsx62J84eIkWkMGNPqKSWXBf2sklh5rCbAXs6Rtwp9s+krJNFyYQGScEQaEGn+JW/GXY3MWBRSO8Kw1hi9z+Hg1L2EinaI87LD3FVkeKAWzVPWd7RXwykFJG9Rw4ccvx1MHjChy8PgTuCFT7bMBD0SlpUv2rP2fVLLC/DbPEBxzmF9NxYomNknH/H42TuYGkyYUQ6dOCTn9p3H0IRVZFY1ZLnVCx8USp9QCa+mZqhiquHImIRixxKdYwMZGSpkHjJwzDO8qXy9sSl1owXDnxu42TRM15dXT2eHZ1goTLTs8eOUQeir8OgbHUPEilRX1yVY0vhHmLGqqtDhZ9Dcl+hhX1L6khksITt8WGZbMpapOwBnIcZ4XF4BE1eskYAHYiLpK9gyro6foS0/59HT5KFKVUFzBdYgruHy/MsWCH3lJZlYcKXTSmKLXdEQUFWMVGsDfcPbC5Vu8dWU58iwxRsgWH7SzQXYXNspsAmecYyPJRtgU0ctgYbjuRy0Jl+tnjDNDjGw3Sygtp3riKfslZ5w+/vwN1AAkuda2trO5eSJZKy4Ph+FksMFJWVZdm2tEpR5DDj2NCVLIsVX+ydYzMH2AZ+ThHMJYOp4jjhBM/k2b3N/nyCwhTJtlxKWPpuT1LBprM56GDJ6YRBRhbpynZAxRZ7qN2U9WOm/N3Cn8VAHOaXdfDb29+rqEy4hFVCFivEENwF1rms2jvH1I81RDknYDlR1rlMFdiBoCqyAlkTtxjfu5s+ooivcJxBWcomVbvsSgST8p5gsMBCmipuKV30AYLzGexc1AkfH72NFel+RtGfT1nfiLy3qz9JdiZqounrALrH7EwRa9DQJEkbAZssYnXfwoTv2q3b7O4sNcKmogaTkcRpWnebbShiOcCSxrXP/ic7lO/lMJNZybJr1z/7N2r3rOkwn2VhItnwb6rdvQos69Rk08uGh0MSN5R7FMEboBB5/frqGhfZGzA+7ApXZaSV16/jhnNsatct7EtZv59DjWE2E62ilZ9fJohR0sDkUz15tn71y2kSN2TYXZaJVt39z/r6+s//cu+zK3nWHWducNNf362v16+O/q3ARgC79vUv9fX/mL187z/ypwd7GhR/5da++aZ++i+X/zL77/mpvcCCJu4S/54/xZBlTcZpwF598OB/YeLeIsnPcxpc+YAgiM81S4Ule4iPRw20cvrB7OxXuCFC7QaafPyyU/MtbJP+8lYbdlxnZg6HBfsrMIN64v76F0bcFMhv3bIs/miKIK7pi9lx563RKUG4Rmx+8qUzfyAmjCU50+rsttApfHn5egn71ew14Q5xd+3rz/hc0nwwGM+xV3durn39f/lLJWxn582pzdnPeG+ezXCmR7NTQudLYnb2Vlr0xFwoGHfqaPoqsX3tJRhGv8nyvE+26DTh0zHil9gj3FT4zm6YSXO6F8Q1QXgZu3xPMmV9zIhg8PiAEHv605ZAGrn8HdUIFq3C12Kx9ckfS1nDGvHy4u9AyNEXzktDObllNp3mnwS83Lv5jfIAu7B+c3OUS8vzbBKyW70L25O/fFGVlu2ynOlzwL4iXkz9vYRdvbzeu3B58sGaqUuGiACmHjVk/Rax/VTwk3jX7vZ4jlkx0PS12KvXsZs0bdg9CJZN9X1++Q540tTqf0qm8o8ZUJu0ANT2c+7j1UU6fk482yZeA7ZIx7dG7wsLOz/13pyddv4rr0151DBNvOzt7d0m/LiuiP0Wss92Yi+Uml29Ycmqb4kfe3t/J2L3ruN52wSsAbLPYtsbxD/IPZYz/TK10NtLELEX+LJcTPzB4BinMQq9G+BtCnqyazeEMuddMeD+l7GnxNOLfrxIxxc45ehT0OT9hecx0+P38yHFrI79WzuTP/V26ukSO756b5J4s4/9hJjuXCAW7hBfkHsWu2IYvXe1t3eB2PDjzqF9bGzz5lXalM6NSqhNyALFdW5+ju9pPsu+igFt/gMvsuO/Ec/Bu3smfPEAl7LjOaBj//pk7PVFv5EssWO8Xlh/ugNMp1jHV7i/E1sXf44tLMRevC87HsEWga/YXH96XwBeYTEvY47d2oDX9EnjSoH96zejRqFzZ5LYpOmC55WduzX7QujsvUPcMZayXwqd60SMGDU6mUheJXHA1nc+nZyMzX5rYHY9b1wH2d5nPxNX6aoidnRU3/lsY/0X4pHhPyTsOO7UkNOx17F16Ct+2w2ypsArBi5wa/ZVp0DTt4r8sY544O98M7mwM7um8THvZRsSVnzHaei7s5v+7P8LYXcFocgAN/coBnO2gFUUVht/+4rUC1tgfsHxP6j8p8fiwegn03pBEP5ZD1lLnmWin3wLy979J46b88nGnn7mxv/5Vu8H3vgfOPkkf8JxlxWErbsl7NLoV3r/jwQx+7nSKbEL8fFtHD19b3YDqJhewdg8HVJE4DGwzZfwm+KmmULIKsIszl4n/VuzxL1p2va+PmzUwLaBRc51mFHFbyt2V7cNijYD+WBVhDXi2ewrvsjvrnkn2MdcjiWL2LECq8RX+N017wgVAatxPFvWmdk9FFRg9TSpK2b/9y0an36xStNVUl/wGVbEoyawXtfDHHS6EBF2z6mWDTQOuqUn6UW+cDnogiz1mQk36qdXp3HplPVxY4Dhz1XhMKNKn+MLGyLIGpRZtquU1ZlIyD5h9+aLDHUly+L7WedBdkIxx+XY6L/4sQMsHv0Xe4AFryOtkopR+qjMQxOZyxtTe1mAMEN9b8h1K8Co9vZ5EVXqoSabPz4sZX3cGPdi2Yzq4mPMO14GuwzZ37CiMM1ARPFrG2CXStkGRbwrxxZP3xOqTJZtUxV/+2KCEme9sN2zt9P8gSPmBSQp5srS0tmHy0OyVJF7DSdk6VwHqGBRqrvHh2VT1ktdXtlJ3GCUQMgnZ+DVD3lJaluS5bPsXHGcxZ0UY5FP5bKDbM+FPFtyYECcRXKsl1cdkhXqmffKszlotjSrOTgng0IF5aXfAu0ZC2ZT1qrDU9bHjpCvv6H/gKXk2NA+1j0D2f0R3Z7/IcYiFxok2QPJYHF2uAHQb4umwxx0/8Eo2gDoQMPBMxFuSzbN/JY2K6igggoqqKCCCiqooIIKKqigggoqqKCCCiqo4OOA9kzubxv8N5eg1NbmfwV+PpPPWZ6xIbW1pRVrz5w5U6vNV0WQ2jPvQdoSAaQlR4okz4tX/Nu9Jvb34Z3/z9RZAfY0oA202BCby2WGj7R5PNknt/TZbC119gAsam9st9tbtIitrhZR2yERsFn72j01rlqbPYcA4vI0QqgDiK27tr3dhVjt7yqfFLS2M2cOSq4NBHK9EpHcBSV35SR3QHlqzS57q93lgr+1eWocsK0DfXDYdvvgcb2jqOZsxdqCClzdqBppR1G0BUECHR5rI3iHtm51bV8N2loHy7ajNXU11toWK2o1d/Q1Wm3tVntjt7WjtclmrquBqGtGXI5mR3O7GnUhDrTZWtOqRj3HbMja9hYPVKerYH5Qcm1Td18HUiR5K5C8rlhyT07yRii5ug8IW1PTVxdAzHV1zY01oFRLvg/t+/vQp0at72bIAU/ub3tLnrDZ0SattaPFVattRq02mwN12Jq6ra0uO6q2a7UutbVG3dRsQxw19u66vkB7X8Bst3vqmjx1zUWDTWu1e9S15tYAYkWb7O017a2NB4bin0MzsCuo40DzLgMkV7egzc1oe07yZig5au3eL3lzjb21rjXQ3mrzNJkh2rvNzWif3RboQB37+uCobemDfVDbmzvau9/RThzNSK0aDBztng5Q9ZnGPnUzeO12rdWB2FFHcxPa7OlA+zrMCOpRq5vUdQ6k2YHUAIs39wU8Voejsam7yWErare5w1zjUdeBnqPABDoCNcfsK84A27N6rO0IYg0USNRhRbW2miY7lFwNJW/fL3kNkFyNdKBNUPJaV0fWo9kCjY0o2oqiNUWNAd00ttRZmzpgH5pq+hoDde/mK2rhMGl3AWPu221dC+zYofag2QZrrPBPW7fD5nI4HMAIULvNZjPXqJFmtANtUXvsoIF2dWt3KwpGZVHDNvAaAiho04PWgUFmrTtmHbsatcA/1nbbEHV7gYQ6rrXlZM5L3qouSN6elbwpK7nL0WivA1be2gf+QZvOgCm7BbXtm5htrQ7EnOtDDRgQTX3vpmNbXy2itTcDHYM3nQPQMfjTjNr3JHWAN6xG61q7zYinpq4O+DAX0tzY0u2yoQ6gYxT1dDSjTai5uOVAq6PDAewNOHYwcjv6jlnHdiAy8BVgGIIBtQtU7YB2XKTjZhS+4qzk1pzkdih5qz0reYurqQP4WpcZ0dZ1d6Ot3TWlDzG3OmqAK6pFUbMD9KH1He24oxZpd5iBwI17dqx21YExZtuTVFtrs1mtYFIxI03tapfVDmwHjDhgmw5ro9bc2Gitq0E7ugOINodsHQ/aagZ/O7ptrTWewHHbcQvUMVAccK9FdtwUQJvUxSMQSt6Uk1zdrrZb7Q4geRNSAyUHXUcc6pbuQK3ahrjaHWh7O5iUtEV9OONBs8Mb9qHOE3hHO0YcZsTVZwduqGbXm2rrmgOe1rqc5FlJtQFHXWOTp8WBBsyorcZubbf3aZu7rWi7OeDwIB5HE+qocai7zda+uizACsOOdjdbUYdZa+vr6LB5Wo7bjrUeLWK3ukCrVnOBhNNEa531TEFyBEqubgQjyQwk77Bbm12tcELMS26zt9pautub0ZYWV0s76gJ/nvHk+6CuBQzsQ7MZOI2ORpvH3P2OOtY6wEITqQVOuUDZasGeIq/xVrjsOONpbKkFow5ttanVoE/2ZmBC5qYmR0sHijrO1LU0NQWam1tbA/YmdRaOMx3A+yHalo6OWhtqBgtMK/qua0sptACbg1La1HsckFxry284+qDkWmte8m6bIyu5o0hytdYDtGarQ9HGWg9YsTWCFZsDad/tg7YOzD2gDzWNtYE/2YdAdtFm+1MqCIBRp2055sXZ2+DKmoHW9c6br/eI7A7xYxB0H/J7349Q8goqqKCCCiqooIIKKqigggoqqKCCCiqooIIKKqigggoqqOAk8f8Av8dPr99iHgkAAAAASUVORK5CYII=" style="width: 355px; height: 142px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"/></a></p>
<div class="_aOd rg_ilm">
<div class="rg_ilmbg"><a class="rg_l" href="http://www.google.com/imgres?imgurl=http://zy.swust.net.cn/02/2/sjjg/images/chap06/C6P3.gif&amp;imgrefurl=http://zy.swust.net.cn/02/2/sjjg/page/chap06/060201.asp&amp;h=200&amp;w=500&amp;tbnid=ASz3gK5eek0jvM:&amp;zoom=1&amp;docid=u6zq2P7Qe63VCM&amp;ei=JmR4VfHKOMPWsAWwn4LICw&amp;tbm=isch&amp;ved=0CCEQMygEMARqFQoTCPH1y7HEhcYCFUMrrAodsI8AuQ" style="width: 355px; height: 142px; left: 0px;"><span class="rg_ilmn"> 500 × 200 - zy.swust.net.cn </span></a></div>
</div>
<p> </p>
<p>通过上面的定义，我们可以看出二者的关系是，完美二叉树一定是完全二叉树，而完全二叉树不一定是完美二叉树。那么这道题给的完全二叉树就有可能是完美二叉树，若是完美二叉树，节点个数很好求，为2的h次方-1，h为该完美二叉树的高度。这道题可以用递归和非递归两种方法来解。我们先来看递归的方法，思路是分别找出以当前节点为根节点的左子树和右子树的高度并对比，如果相等，则说明是满二叉树，直接返回节点个数，如果不相等，则节点个数为左子树的节点个数加上右子树的节点个数再加1(根节点)，其中左右子树节点个数的计算可以使用递归来计算，参见代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> countNodes(TreeNode*<span style="color: #000000;"> root) {
        </span><span style="color: #0000ff;">int</span> hLeft = <span style="color: #800080;">0</span>, hRight = <span style="color: #800080;">0</span><span style="color: #000000;">;
        TreeNode </span>*pLeft = root, *pRight =<span style="color: #000000;"> root;
        </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> (pLeft) {
            </span>++<span style="color: #000000;">hLeft;
            pLeft </span>= pLeft-&gt;<span style="color: #000000;">left;
        }
        </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> (pRight) {
            </span>++<span style="color: #000000;">hRight;
            pRight </span>= pRight-&gt;<span style="color: #000000;">right;
        }
        </span><span style="color: #0000ff;">if</span> (hLeft == hRight) <span style="color: #0000ff;">return</span> pow(<span style="color: #800080;">2</span>, hLeft) - <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span> countNodes(root-&gt;left) + countNodes(root-&gt;right) + <span style="color: #800080;">1</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>递归的解法还有一种解法如下所示：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> countNodes(TreeNode*<span style="color: #000000;"> root) {
        </span><span style="color: #0000ff;">int</span> hLeft =<span style="color: #000000;"> leftHeight(root);
        </span><span style="color: #0000ff;">int</span> hRight =<span style="color: #000000;"> rightHeight(root);
        </span><span style="color: #0000ff;">if</span> (hLeft == hRight) <span style="color: #0000ff;">return</span> pow(<span style="color: #800080;">2</span>, hLeft) - <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span> countNodes(root-&gt;left) + countNodes(root-&gt;right) + <span style="color: #800080;">1</span><span style="color: #000000;">;
    }
    </span><span style="color: #0000ff;">int</span> leftHeight(TreeNode*<span style="color: #000000;"> root) {
        </span><span style="color: #0000ff;">if</span> (!root) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">1</span> + leftHeight(root-&gt;<span style="color: #000000;">left);
    }
    </span><span style="color: #0000ff;">int</span> rightHeight(TreeNode*<span style="color: #000000;"> root) {
        </span><span style="color: #0000ff;">if</span> (!root) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">1</span> + rightHeight(root-&gt;<span style="color: #000000;">right);
    }
};</span></pre>
</div>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-06-10 23:49</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4567827" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4567827);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4550604.html" id="cb_post_title_url">[LeetCode] Maximal Square 最大正方形</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a 2D binary matrix filled with 0's and 1's, find the largest square containing all 1's and return its area.</p>
<p>For example, given the following matrix:</p>
<pre>1 0 1 0 0
1 0 <span style="color: red;">1</span> <span style="color: red;">1</span> 1
1 1 <span style="color: red;">1</span> <span style="color: red;">1</span> 1
1 0 0 1 0
</pre>
<p>Return 4.</p>
<p><strong>Credits:</strong><br/>Special thanks to <a href="https://oj.leetcode.com/discuss/user/Freezen">@Freezen</a> for adding this problem and creating all test cases.</p>
<p> </p>
<p>这道题我刚看到的时候，马上联想到了之前的一道<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4402656.html" id="cb_post_title_url">Number of Islands 岛屿的数量</a>，但是仔细一对比，发现又不太一样，那道题1的形状不确定，很适合DFS的特点，而这道题要找的是正方形，是非常有特点的形状，所以并不需要用到DFS，要论相似，我倒认为这道<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4322667.html" id="cb_post_title_url">Maximal Rectangle 最大矩形</a>更相似一些。这道题的解法不止一种，我们先来看一种brute force的方法，这种方法的机理就是就是把数组中每一个点都当成正方形的左顶点来向右下方扫描，来寻找最大正方形。具体的扫描方法是，确定了左顶点后，再往下扫的时候，正方形的竖边长度就确定了，只需要找到横边即可，这时候我们使用直方图的原理，从其累加值能反映出上面的值是否全为1，之前也有一道关于直方图的题<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4322653.html" id="homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0">Largest Rectangle in Histogram 直方图中最大的矩形</a> 。通过这种方法我们就可以找出最大的正方形，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> maximalSquare(vector&lt;vector&lt;<span style="color: #0000ff;">char</span>&gt; &gt;&amp;<span style="color: #000000;"> matrix) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; matrix.size(); ++<span style="color: #000000;">i) {
            vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; v(matrix[i].size(), <span style="color: #800080;">0</span><span style="color: #000000;">);
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = i; j &lt; matrix.size(); ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> k = <span style="color: #800080;">0</span>; k &lt; matrix[j].size(); ++<span style="color: #000000;">k) {
                    </span><span style="color: #0000ff;">if</span> (matrix[j][k] == <span style="color: #800000;">'</span><span style="color: #800000;">1</span><span style="color: #800000;">'</span>) ++<span style="color: #000000;">v[k];
                }
                res </span>= max(res, getSquareArea(v, j - i + <span style="color: #800080;">1</span><span style="color: #000000;">));
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">int</span> getSquareArea(vector&lt;<span style="color: #0000ff;">int</span>&gt; &amp;v, <span style="color: #0000ff;">int</span><span style="color: #000000;"> k) {
        </span><span style="color: #0000ff;">if</span> (v.size() &lt; k) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> count = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; v.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (v[i] != k) count = <span style="color: #800080;">0</span><span style="color: #000000;">; 
            </span><span style="color: #0000ff;">else</span> ++<span style="color: #000000;">count;
            </span><span style="color: #0000ff;">if</span> (count == k) <span style="color: #0000ff;">return</span> k *<span style="color: #000000;"> k;
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这个方法用到了建立累计和数组的方法，可以参见之前那篇博客<a href="http://www.cnblogs.com/grandyang/p/4958789.html">Range Sum Query 2D - Immutable</a>。原理是建立好了累加和数组后，我们开始遍历二维数组的每一个位置，对于任意一个位置(i, j)，我们从该位置往(0,0)点遍历所有的正方形，正方形的个数为min(i,j)+1，由于我们有了累加和矩阵，能快速的求出任意一个区域之和，所以我们能快速得到所有子正方形之和，比较正方形之和跟边长的平方是否相等，相等说明正方形中的数字均为1，更新res结果即可，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> maximalSquare(vector&lt;vector&lt;<span style="color: #0000ff;">char</span>&gt;&gt;&amp;<span style="color: #000000;"> matrix) {
        </span><span style="color: #0000ff;">if</span> (matrix.empty() || matrix[<span style="color: #800080;">0</span>].empty()) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> m = matrix.size(), n = matrix[<span style="color: #800080;">0</span>].size(), res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; sum(m, vector&lt;<span style="color: #0000ff;">int</span>&gt;(n, <span style="color: #800080;">0</span><span style="color: #000000;">));
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; matrix.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; matrix[i].size(); ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">int</span> t = matrix[i][j] - <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">if</span> (i &gt; <span style="color: #800080;">0</span>) t += sum[i - <span style="color: #800080;">1</span><span style="color: #000000;">][j];
                </span><span style="color: #0000ff;">if</span> (j &gt; <span style="color: #800080;">0</span>) t += sum[i][j - <span style="color: #800080;">1</span><span style="color: #000000;">];
                </span><span style="color: #0000ff;">if</span> (i &gt; <span style="color: #800080;">0</span> &amp;&amp; j &gt; <span style="color: #800080;">0</span>) t -= sum[i - <span style="color: #800080;">1</span>][j - <span style="color: #800080;">1</span><span style="color: #000000;">];
                sum[i][j] </span>=<span style="color: #000000;"> t;
                </span><span style="color: #0000ff;">int</span> cnt = <span style="color: #800080;">1</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> k = min(i, j); k &gt;= <span style="color: #800080;">0</span>; --<span style="color: #000000;">k) {
                    </span><span style="color: #0000ff;">int</span> d =<span style="color: #000000;"> sum[i][j];
                    </span><span style="color: #0000ff;">if</span> (i - cnt &gt;= <span style="color: #800080;">0</span>) d -= sum[i -<span style="color: #000000;"> cnt][j];
                    </span><span style="color: #0000ff;">if</span> (j - cnt &gt;= <span style="color: #800080;">0</span>) d -= sum[i][j -<span style="color: #000000;"> cnt];
                    </span><span style="color: #0000ff;">if</span> (i - cnt &gt;= <span style="color: #800080;">0</span> &amp;&amp; j - cnt &gt;= <span style="color: #800080;">0</span>) d += sum[i - cnt][j -<span style="color: #000000;"> cnt];
                    </span><span style="color: #0000ff;">if</span> (d == cnt * cnt) res =<span style="color: #000000;"> max(res, d);
                    </span>++<span style="color: #000000;">cnt;
                }
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>我们还可以进一步的优化时间复杂度到O(n<sup>2</sup>)，做法是使用DP，简历一个二维dp数组，其中dp[i][j]表示到达(i, j)位置所能组成的最大正方形的边长。我们首先来考虑边界情况，也就是当i或j为0的情况，那么在首行或者首列中，必定有一个方向长度为1，那么就无法组成长度超过1的正方形，最多能组成长度为1的正方形，条件是当前位置为1。边界条件处理完了，再来看一般情况的递推公式怎么办，对于任意一点dp[i][j]，由于该点是正方形的右下角，所以该点的右边，下边，右下边都不用考虑，关心的就是左边，上边，和左上边。这三个位置的dp值suppose都应该算好的，还有就是要知道一点，只有当前(i, j)位置为1，dp[i][j]才有可能大于0，否则dp[i][j]一定为0。当(i, j)位置为1，此时要看dp[i-1][j-1], dp[i][j-1]，和dp[i-1][j]这三个位置，我们找其中最小的值，并加上1，就是dp[i][j]的当前值了，这个并不难想，毕竟不能有0存在，所以只能取交集，最后再用dp[i][j]的值来更新结果res的值即可，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> maximalSquare(vector&lt;vector&lt;<span style="color: #0000ff;">char</span>&gt;&gt;&amp;<span style="color: #000000;"> matrix) {
        </span><span style="color: #0000ff;">if</span> (matrix.empty() || matrix[<span style="color: #800080;">0</span>].empty()) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> m = matrix.size(), n = matrix[<span style="color: #800080;">0</span>].size(), res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; dp(m, vector&lt;<span style="color: #0000ff;">int</span>&gt;(n, <span style="color: #800080;">0</span><span style="color: #000000;">));
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; m; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; n; ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> (i == <span style="color: #800080;">0</span> || j == <span style="color: #800080;">0</span>) dp[i][j] = matrix[i][j] - <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (matrix[i][j] == <span style="color: #800000;">'</span><span style="color: #800000;">1</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                    dp[i][j] </span>= min(dp[i - <span style="color: #800080;">1</span>][j - <span style="color: #800080;">1</span>], min(dp[i][j - <span style="color: #800080;">1</span>], dp[i - <span style="color: #800080;">1</span>][j])) + <span style="color: #800080;">1</span><span style="color: #000000;">;
                }
                res </span>=<span style="color: #000000;"> max(res, dp[i][j]);
            }
        }
        </span><span style="color: #0000ff;">return</span> res *<span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种解法进一步的优化了空间复杂度，此时只需要用一个一维数组就可以解决，为了处理边界情况，padding了一位，所以dp的长度是m+1，然后还需要一个变量pre来记录上一个层的dp值，我们更新的顺序是行优先，就是先往下遍历，用一个临时变量t保存当前dp值，然后看如果当前位置为1，则更新dp[i]为dp[i], dp[i-1], 和pre三者之间的最小值，再加上1，来更新结果res，如果当前位置为0，则重置当前dp值为0，因为只有一维数组，每个位置会被重复使用，参见代码如下：</p>
<p> </p>
<p>解法四：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> maximalSquare(vector&lt;vector&lt;<span style="color: #0000ff;">char</span>&gt;&gt;&amp;<span style="color: #000000;"> matrix) {
        </span><span style="color: #0000ff;">if</span> (matrix.empty() || matrix[<span style="color: #800080;">0</span>].empty()) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> m = matrix.size(), n = matrix[<span style="color: #800080;">0</span>].size(), res = <span style="color: #800080;">0</span>, pre = <span style="color: #800080;">0</span><span style="color: #000000;">;
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; dp(m + <span style="color: #800080;">1</span>, <span style="color: #800080;">0</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; n; ++<span style="color: #000000;">j) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt;= m; ++<span style="color: #000000;">i) {
                </span><span style="color: #0000ff;">int</span> t =<span style="color: #000000;"> dp[i];
                </span><span style="color: #0000ff;">if</span> (matrix[i - <span style="color: #800080;">1</span>][j] == <span style="color: #800000;">'</span><span style="color: #800000;">1</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                    dp[i] </span>= min(dp[i], min(dp[i - <span style="color: #800080;">1</span>], pre)) + <span style="color: #800080;">1</span><span style="color: #000000;">;
                    res </span>=<span style="color: #000000;"> max(res, dp[i]);
                } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    dp[i] </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
                }
                pre </span>=<span style="color: #000000;"> t;
            }
        }
        </span><span style="color: #0000ff;">return</span> res *<span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4322667.html" id="cb_post_title_url">Maximal Rectangle</a></p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4322653.html" id="homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0">Largest Rectangle in Histogram</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/15325/my-concise-solution-in-c/2">https://discuss.leetcode.com/topic/15325/my-concise-solution-in-c/2</a></p>
<p> </p>
<p><a href="https://discuss.leetcode.com/topic/15328/easy-dp-solution-in-c-with-detailed-explanations-8ms-o-n-2-time-and-o-n-space/2">https://discuss.leetcode.com/topic/15328/easy-dp-solution-in-c-with-detailed-explanations-8ms-o-n-2-time-and-o-n-space/2</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-06-03 23:22</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4550604" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4550604);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4545261.html" id="cb_post_title_url">[LeetCode] Contains Duplicate III 包含重复值之三</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given an array of integers, find out whether there are two distinct indices <em>i</em> and <em>j</em> in the array such that the difference between <strong>nums[i]</strong> and <strong>nums[j]</strong> is at most <em>t</em> and the difference between <em>i</em> and <em>j</em> is at most <em>k</em>.</p>
<p> </p>
<p>这道题跟之前两道<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4537029.html" id="homepage1_HomePageDays_DaysList_ctl01_DayList_TitleUrl_1">Contains Duplicate 包含重复值</a>和<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4539680.html" id="cb_post_title_url">Contains Duplicate II 包含重复值之二</a>的关联并不是很大，前两道起码跟重复值有关，这道题的焦点不是在重复值上面，反而是关注与不同的值之间的关系，这里有两个限制条件，两个数字的坐标差不能大于k，值差不能大于t。这道题如果用brute force会超时，所以我们只能另辟蹊径。这里我们使用map数据结构来解,用来记录数字和其下标之间的映射。 这里需要两个指针i和j，刚开始i和j都指向0，然后i开始向右走遍历数组，如果i和j之差大于k，且m中有nums[j]，则删除并j加一。这样保证了m中所有的数的下标之差都不大于k，然后我们用map数据结构的lower_bound()函数来找一个特定范围，就是大于或等于nums[i] - t的地方，所有小于这个阈值的数和nums[i]的差的绝对值会大于t (可自行带数检验)。然后检测后面的所有的数字，如果数的差的绝对值小于等于t，则返回true。最后遍历完整个数组返回false。代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> containsNearbyAlmostDuplicate(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; nums, <span style="color: #0000ff;">int</span> k, <span style="color: #0000ff;">int</span><span style="color: #000000;"> t) {
        map</span>&lt;<span style="color: #0000ff;">long</span> <span style="color: #0000ff;">long</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> m;
        </span><span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; nums.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (i - j &gt; k) m.erase(nums[j++<span style="color: #000000;">]);
            auto a </span>= m.lower_bound((<span style="color: #0000ff;">long</span> <span style="color: #0000ff;">long</span>)nums[i] -<span style="color: #000000;"> t);
            </span><span style="color: #0000ff;">if</span> (a != m.end() &amp;&amp; abs(a-&gt;first - nums[i]) &lt;= t) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
            m[nums[i]] </span>=<span style="color: #000000;"> i;
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
    }
}; </span></pre>
</div>
<p> </p>
<p>相似题目：</p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4537029.html" id="homepage1_HomePageDays_DaysList_ctl01_DayList_TitleUrl_1">Contains Duplicate 包含重复值</a></p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4539680.html" id="cb_post_title_url">Contains Duplicate II 包含重复值之二</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://leetcode.com/discuss/38195/short-c-solution" target="_blank">https://leetcode.com/discuss/38195/short-c-solution</a></p>
<p><a href="http://www.cnblogs.com/easonliu/p/4544073.html" target="_blank">http://www.cnblogs.com/easonliu/p/4544073.html</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-06-01 23:33</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4545261" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4545261);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4539680.html" id="cb_post_title_url">[LeetCode] Contains Duplicate II 包含重复值之二</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p><span style="color: #ff0000;"><span style="text-decoration: line-through;">Given an array of integers and an integer k, return true if and only if there are two distinct indices i and j in the array such that nums[i] = nums[j] and the difference between i and j is at most k.</span> (Old Version)</span></p>
<p><span style="color: #339966;">Given an array of integers and an integer <em>k</em>, find out whether there are two distinct indices <em>i</em> and <em>j</em> in the array such that <strong>nums[i] = nums[j]</strong> and the difference between <em>i</em> and <em>j</em> is at most <em>k</em>. (New Version)</span></p>
<p> </p>
<p>这道题是之前那道<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4537029.html" id="homepage1_HomePageDays_DaysList_ctl01_DayList_TitleUrl_1">Contains Duplicate 包含重复值</a>的延伸，不同之处在于那道题只要我们判断下数组中是否有重复值，而这道题限制了数组中只许有一组重复的数字，而且他们坐标差不能超过k。那么我们首先需要一个哈希表，来记录每个数字和其坐标的映射，然后我们需要一个变量d来记录第一次出现重复数字的坐标差。由于题目要求只能有一组重复的数字，所以我们在遇到重复数字时，首先判断d是否已经存了值，如果d已经有值了，说明之前有过了重复数字，则直接返回false即可。如果没有，则此时给d附上值。在网上看到有些解法在这里就直接判断d和k的关系然后返回结果了，其实这样是不对的。因为题目要求只能有一组重复数，就是说如果后面又出现了重复数，就没法继续判断了。所以正确的做法应该是扫描完整个数组后在判断，先看d有没有存入结果，如果没有，则说明没出现过重复数， 返回false即可。如果d有值，再跟k比较，返回对应的结果。OJ的test case没有包含所有的情况，比如当nums = [1, 2, 3, 1, 3], k = 3时，实际上应该返回false，但是有些返回true的算法也能通过OJ。个人认为正确的解法应该入下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> Wrong Soulution</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> containsNearbyDuplicate(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; nums, <span style="color: #0000ff;">int</span><span style="color: #000000;"> k) {
        unordered_map</span>&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> m;
        </span><span style="color: #0000ff;">int</span> d = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; nums.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (m.find(nums[i]) !=<span style="color: #000000;"> m.end()) {
                </span><span style="color: #0000ff;">if</span> (d &gt; <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                d </span>= i -<span style="color: #000000;"> m[nums[i]];
            }
            m[nums[i]] </span>=<span style="color: #000000;"> i;
        }
        </span><span style="color: #0000ff;">return</span> d == <span style="color: #800080;">0</span> ? <span style="color: #0000ff;">false</span> : d &lt;=<span style="color: #000000;"> k;
    }
};</span></pre>
</div>
<p> </p>
<p>坑爹啊，题目要求变了，那么就没啥歧义了，正确解法如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> containsNearbyDuplicate(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; nums, <span style="color: #0000ff;">int</span><span style="color: #000000;"> k) {
        unordered_map</span>&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> m;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; nums.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (m.find(nums[i]) != m.end() &amp;&amp; i - m[nums[i]] &lt;= k) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">else</span> m[nums[i]] =<span style="color: #000000;"> i;
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>相似题目：</p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4537029.html" id="homepage1_HomePageDays_DaysList_ctl01_DayList_TitleUrl_1">Contains Duplicate 包含重复值</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4545261.html" target="_blank">Contains Duplicate III 包含重复值之三</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-05-30 00:06</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4539680" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4539680);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4534586.html" id="cb_post_title_url">[LeetCode] The Skyline Problem 天际线问题</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>A city's skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Now suppose you are given the locations and height of all the buildings as shown on a cityscape photo (Figure A), write a program to output the skyline formed by these buildings collectively (Figure B).</p>
<p><a href="http://tinypic.com/?ref=2a0e4qu" target="_blank"><img alt="Buildings" border="0" height="273" src="http://i62.tinypic.com/2a0e4qu.jpg" width="340"/> </a><a href="http://tinypic.com/?ref=2vtdqtf" target="_blank"><img alt="Skyline Contour" border="0" height="272" src="http://i61.tinypic.com/2vtdqtf.jpg" width="340"/></a></p>
<p>The geometric information of each building is represented by a triplet of integers <code>[Li, Ri, Hi]</code>, where <code>Li</code> and <code>Ri</code> are the x coordinates of the left and right edge of the ith building, respectively, and <code>Hi</code> is its height. It is guaranteed that <code>0 ≤ Li, Ri ≤ INT_MAX</code>, <code>0 &lt; Hi ≤ INT_MAX</code>, and <code>Ri - Li &gt; 0</code>. You may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height 0.</p>
<p>For instance, the dimensions of all buildings in Figure A are recorded as: <code>[ [2 9 10], [3 7 15], [5 12 12], [15 20 10], [19 24 8] ] </code>.</p>
<p>The output is a list of "key points" (red dots in Figure B) in the format of <code>[ [x1,y1], [x2, y2], [x3, y3], ... ]</code> that uniquely defines a skyline. A key point is the left endpoint of a horizontal line segment. Note that the last key point, where the rightmost building ends, is merely used to mark the termination of the skyline, and always has zero height. Also, the ground in between any two adjacent buildings should be considered part of the skyline contour.</p>
<p>For instance, the skyline in Figure B should be represented as:<code>[ [2 10], [3 15], [7 12], [12 0], [15 10], [20 8], [24, 0] ]</code>.</p>
<p>Notes:</p>
<ul>
<li>The number of buildings in any input list is guaranteed to be in the range <code>[0, 10000]</code>.</li>
<li>The input list is already sorted in ascending order by the left x position <code>Li</code>.</li>
<li>The output list must be sorted by the x position.</li>
<li>There must be no consecutive horizontal lines of equal height in the output skyline. For instance, <code>[...[2 3], [4 5], [7 5], [11 5], [12 7]...]</code> is not acceptable; the three lines of height 5 should be merged into one in the final output as such: <code>[...[2 3], [4 5], [12 7], ...]</code></li>
</ul>
<p> </p>
<p>Credits:<br/>Special thanks to <a href="https://oj.leetcode.com/discuss/user/stellari">@stellari</a> for adding this problem, creating these two awesome images and all test cases.</p>
<p> </p>
<p>这道题一打开又是图又是这么长的题目的，看起来感觉应该是一道相当复杂的题，但是做完之后发现也就那么回事，虽然我不会做，是学习的别人的解法。这道求天际线的题目应该算是比较新颖的题，要是非要在之前的题目中找一道类似的题，也就只有<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4370601.html" id="cb_post_title_url"> Merge Intervals 合并区间</a>了吧，但是与那题不同的是，这道题不是求被合并成的空间，而是求轮廓线的一些关键的转折点，这就比较复杂了，我们通过仔细观察题目中给的那个例子可以发现，要求的红点都跟每个小区间的左右区间点有密切的关系，而且进一步发现除了每一个封闭区间的最右边的结束点是楼的右边界点，其余的都是左边界点，而且每个红点的纵坐标都是当前重合处的最高楼的高度，但是在右边界的那个楼的就不算了。在网上搜了很多帖子，发现网友<a href="https://briangordon.github.io/2014/08/the-skyline-problem.html" target="_blank">Brian Gordon的帖子</a>图文并茂，什么动画渐变啊，横向扫描啊，简直叼到没朋友啊，但是叼到极致后就懒的一句一句的去读了，这里博主还是讲解另一位网友<a href="http://www.cnblogs.com/easonliu/p/4531020.html" target="_blank">百草园的博客</a>吧。这里用到了multiset数据结构，其好处在于其中的元素是按堆排好序的，插入新元素进去还是有序的，而且执行删除元素也可方便的将元素删掉。这里为了区分左右边界，将左边界的高度存为负数，建立左边界和负高度的pair，再建立右边界和高度的pair，存入数组中，都存进去了以后，给数组按照左边界排序，这样我们就可以按顺序来处理那些关键的节点了。我们要在multiset中放入一个0，这样在某个没有和其他建筑重叠的右边界上，我们就可以将封闭点存入结果res中。下面我们按顺序遍历这些关键节点，如果遇到高度为负值的pair，说明是左边界，那么将正高度加入multiset中，然后取出此时集合中最高的高度，即最后一个数字，然后看是否跟pre相同，这里的pre是上一个状态的高度，初始化为0，所以第一个左边界的高度绝对不为0，所以肯定会存入结果res中。接下来如果碰到了一个更高的楼的左边界的话，新高度存入multiset的话会排在最后面，那么此时cur取来也跟pre不同，可以将新的左边界点加入结果res。第三个点遇到绿色建筑的左边界点时，由于其高度低于红色的楼，所以cur取出来还是红色楼的高度，跟pre相同，直接跳过。下面遇到红色楼的右边界，此时我们首先将红色楼的高度从multiset中删除，那么此时cur取出的绿色楼的高度就是最高啦，跟pre不同，则可以将红楼的右边界横坐标和绿楼的高度组成pair加到结果res中，这样就成功的找到我们需要的拐点啦，后面都是这样类似的情况。当某个右边界点没有跟任何楼重叠的话，删掉当前的高度，那么multiset中就只剩0了，所以跟当前的右边界横坐标组成pair就是封闭点啦，具体实现参看代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;pair&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;&gt; getSkyline(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> buildings) {
        vector</span>&lt;pair&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;&gt;<span style="color: #000000;"> h, res;
        multiset</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> m;
        </span><span style="color: #0000ff;">int</span> pre = <span style="color: #800080;">0</span>, cur = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (auto &amp;<span style="color: #000000;">a : buildings) {
            h.push_back({a[</span><span style="color: #800080;">0</span>], -a[<span style="color: #800080;">2</span><span style="color: #000000;">]});
            h.push_back({a[</span><span style="color: #800080;">1</span>], a[<span style="color: #800080;">2</span><span style="color: #000000;">]});
        }
        sort(h.begin(), h.end());
        m.insert(</span><span style="color: #800080;">0</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">for</span> (auto &amp;<span style="color: #000000;">a : h) {
            </span><span style="color: #0000ff;">if</span> (a.second &lt; <span style="color: #800080;">0</span>) m.insert(-<span style="color: #000000;">a.second);
            </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> m.erase(m.find(a.second));
            cur </span>= *<span style="color: #000000;">m.rbegin();
            </span><span style="color: #0000ff;">if</span> (cur !=<span style="color: #000000;"> pre) {
                res.push_back({a.first, cur});
                pre </span>=<span style="color: #000000;"> cur;
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="http://www.cnblogs.com/easonliu/p/4531020.html" target="_blank">http://www.cnblogs.com/easonliu/p/4531020.html</a></p>
<p><a href="https://discuss.leetcode.com/topic/22482/short-java-solution" target="_blank">https://discuss.leetcode.com/topic/22482/short-java-solution</a></p>
<p><a href="https://briangordon.github.io/2014/08/the-skyline-problem.html" target="_blank">https://briangordon.github.io/2014/08/the-skyline-problem.html</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-05-27 22:24</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4534586" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4534586);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4537029.html" id="cb_post_title_url">[LeetCode] Contains Duplicate 包含重复值</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.</p>
<p> </p>
<p>这道题不算难题，就是使用一个哈希表，遍历整个数组，如果哈希表里存在，返回false，如果不存在，则将其放入哈希表中，代码如下：</p>
<p> 解法一</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> containsDuplicate(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        unordered_map</span>&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> m;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; nums.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (m.find(nums[i]) != m.end()) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
            </span>++<span style="color: #000000;">m[nums[i]];
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>这题还有另一种解法，就是先将数组排个序，然后再比较相邻两个数字是否相等，时间复杂度取决于排序方法，代码如下：</p>
<p>解法二</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> containsDuplicate(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        sort(nums.begin(), nums.end());
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt; nums.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (nums[i] == nums[i - <span style="color: #800080;">1</span>]) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>相似题目：</p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4539680.html" id="cb_post_title_url">Contains Duplicate II 包含重复值之二</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4545261.html" target="_blank">Contains Duplicate III 包含重复值之三 </a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-05-28 21:40</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4537029" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4537029);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4537983.html" id="cb_post_title_url">[LeetCode] Combination Sum III 组合之和之三</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div>
<p>Find all possible combinations of <em><strong>k</strong></em> numbers that add up to a number <em><strong>n</strong></em>, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.</p>
<p>Ensure that numbers within the set are sorted in ascending order.</p>
</div>
<div><br/>
<p> <em><strong>Example 1:</strong></em></p>
<p>Input:  <em><strong>k</strong></em> = 3,  <em><strong>n</strong></em> = 7</p>
<p>Output: </p>
<pre>[[1,2,4]]
</pre>
<br/>
<p> <em><strong>Example 2:</strong></em></p>
<p>Input:  <em><strong>k</strong></em> = 3,  <em><strong>n</strong></em> = 9</p>
<p>Output: </p>
<pre>[[1,2,6], [1,3,5], [2,3,4]]
</pre>
</div>
<p><strong>Credits:</strong><br/>Special thanks to <a href="https://leetcode.com/discuss/user/mithmatt">@mithmatt</a> for adding this problem and creating all test cases.</p>
<p> </p>
<p>这道题题是组合之和系列的第三道题，跟之前两道<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4419259.html" id="cb_post_title_url">Combination Sum 组合之和</a>，<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4419386.html" id="cb_post_title_url">Combination Sum II 组合之和之二</a>都不太一样，那两道的联系比较紧密，变化不大，而这道跟它们最显著的不同就是这道题的个数是固定的，为k。个人认为这道题跟那道<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4332522.html" id="cb_post_title_url">Combinations 组合项</a>更相似一些，但是那道题只是排序，对k个数字之和又没有要求。所以实际上这道题是它们的综合体，两者杂糅到一起就是这道题的解法了，n是k个数字之和，如果n小于0，则直接返回，如果n正好等于0，而且此时out中数字的个数正好为k，说明此时是一个正确解，将其存入结果res中，具体实现参见代码入下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt; &gt; combinationSum3(<span style="color: #0000ff;">int</span> k, <span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt; &gt;<span style="color: #000000;"> res;
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; <span style="color: #0000ff;">out</span><span style="color: #000000;">;
        combinationSum3DFS(k, n, </span><span style="color: #800080;">1</span>, <span style="color: #0000ff;">out</span><span style="color: #000000;">, res);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">void</span> combinationSum3DFS(<span style="color: #0000ff;">int</span> k, <span style="color: #0000ff;">int</span> n, <span style="color: #0000ff;">int</span> level, vector&lt;<span style="color: #0000ff;">int</span>&gt; &amp;<span style="color: #0000ff;">out</span>, vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt; &gt; &amp;<span style="color: #000000;">res) {
        </span><span style="color: #0000ff;">if</span> (n &lt; <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (n == <span style="color: #800080;">0</span> &amp;&amp; <span style="color: #0000ff;">out</span>.size() == k) res.push_back(<span style="color: #0000ff;">out</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = level; i &lt;= <span style="color: #800080;">9</span>; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">out</span><span style="color: #000000;">.push_back(i);
            combinationSum3DFS(k, n </span>- i, i + <span style="color: #800080;">1</span>, <span style="color: #0000ff;">out</span><span style="color: #000000;">, res);
            </span><span style="color: #0000ff;">out</span><span style="color: #000000;">.pop_back();
        }
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4419386.html" target="_blank">Combination Sum II</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4419259.html" target="_blank">Combination Sum</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-05-29 11:04</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4537983" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4537983);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4539757.html" id="cb_post_title_url">[LeetCode] Kth Largest Element in an Array 数组中第k大的数字</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.</p>
<p>Example 1:</p>
<pre>Input: <code>[3,2,1,5,6,4] </code>and k = 2
Output: 5
</pre>
<p>Example 2:</p>
<pre>Input: <code>[3,2,3,1,2,4,5,5,6] </code>and k = 4
Output: 4</pre>
<p>Note: <br/>You may assume k is always valid, 1 ≤ k ≤ array's length.</p>
<p> </p>
<p>这道题让我们求数组中第k大的数字，怎么求呢，当然首先想到的是给数组排序，然后求可以得到第k大的数字。先看一种利用c++的STL中的集成的排序方法，不用我们自己实现，这样的话这道题只要两行就完事了，代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> findKthLargest(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; nums, <span style="color: #0000ff;">int</span><span style="color: #000000;"> k) {
        sort(nums.begin(), nums.end());
        </span><span style="color: #0000ff;">return</span> nums[nums.size() -<span style="color: #000000;"> k];
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种解法是利用了priority_queue的自动排序的特性，跟上面的解法思路上没有什么区别，当然我们也可以换成multiset来做，一个道理，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> findKthLargest(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; nums, <span style="color: #0000ff;">int</span><span style="color: #000000;"> k) {
        priority_queue</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> q(nums.begin(), nums.end());
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; k - <span style="color: #800080;">1</span>; ++<span style="color: #000000;">i) {
            q.pop();
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> q.top();
    }
};</span></pre>
</div>
<p> </p>
<p>上面两种方法虽然简洁，但是确不是本题真正想考察的东西，可以说有一定的偷懒嫌疑。这道题最好的解法应该是下面这种做法，用到了快速排序Quick Sort的思想，这里排序的方向是从小往大排。对快排不熟悉的童鞋们随意上网搜些帖子看下吧，多如牛毛啊，总有一款适合你。核心思想是每次都要先找一个中枢点Pivot，然后遍历其他所有的数字，像这道题从小往大排的话，就把小于中枢点的数字放到左半边，把大于中枢点的放在右半边，这样中枢点是整个数组中第几大的数字就确定了，虽然左右两部分不一定是完全有序的，但是并不影响本题要求的结果，所以我们求出中枢点的位置，如果正好是k-1，那么直接返回该位置上的数字；如果大于k-1，说明要求的数字在左半部分，更新右边界，再求新的中枢点位置；反之则更新右半部分，求中枢点的位置；不得不说，这个思路真的是巧妙啊～</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> findKthLargest(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; nums, <span style="color: #0000ff;">int</span><span style="color: #000000;"> k) {
        </span><span style="color: #0000ff;">int</span> left = <span style="color: #800080;">0</span>, right = nums.size() - <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (<span style="color: #0000ff;">true</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">int</span> pos =<span style="color: #000000;"> partition(nums, left, right);
            </span><span style="color: #0000ff;">if</span> (pos == k - <span style="color: #800080;">1</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;"> nums[pos];
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (pos &gt; k - <span style="color: #800080;">1</span>) right = pos - <span style="color: #800080;">1</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">else</span> left = pos + <span style="color: #800080;">1</span><span style="color: #000000;">;
        }
    }
    </span><span style="color: #0000ff;">int</span> partition(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; nums, <span style="color: #0000ff;">int</span> left, <span style="color: #0000ff;">int</span><span style="color: #000000;"> right) {
        </span><span style="color: #0000ff;">int</span> pivot = nums[left], l = left + <span style="color: #800080;">1</span>, r =<span style="color: #000000;"> right;
        </span><span style="color: #0000ff;">while</span> (l &lt;=<span style="color: #000000;"> r) {
            </span><span style="color: #0000ff;">if</span> (nums[l] &lt; pivot &amp;&amp; nums[r] &gt;<span style="color: #000000;"> pivot) {
                swap(nums[l</span>++], nums[r--<span style="color: #000000;">]);
            }
            </span><span style="color: #0000ff;">if</span> (nums[l] &gt;= pivot) ++<span style="color: #000000;">l;
            </span><span style="color: #0000ff;">if</span> (nums[r] &lt;= pivot) --<span style="color: #000000;">r;
        }
        swap(nums[left], nums[r]);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> r;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/5139057.html">Wiggle Sort II</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/5454125.html">Top K Frequent Elements</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/5983113.html">Third Maximum Number</a></p>
<p>Kth Largest Element in a Stream</p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-05-30 04:10</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4539757" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4539757);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4523624.html" id="cb_post_title_url">[LeetCode] Shortest Palindrome 最短回文串</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a string S, you are allowed to convert it to a palindrome by adding characters in front of it. Find and return the shortest palindrome you can find by performing this transformation.</p>
<p>For example:</p>
<p>Given <code>"aacecaaa"</code>, return <code>"aaacecaaa"</code>.</p>
<p>Given <code>"abcd"</code>, return <code>"dcbabcd"</code>.</p>
<p><strong>Credits:</strong><br/>Special thanks to <a href="https://leetcode.com/discuss/user/ifanchu">@ifanchu</a> for adding this problem and creating all test cases. Thanks to <a href="https://leetcode.com/discuss/user/Freezen">@Freezen</a> for additional test cases.</p>
<p> </p>
<p>这道题让我们求最短的回文串，LeetCode中关于回文串的其他的题目有<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4125510.html" id="cb_post_title_url"> Palindrome Number 验证回文数字</a>，<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4030114.html" id="cb_post_title_url"> Validate Palindrome 验证回文字符串</a>，<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4270008.html" id="cb_post_title_url"> Palindrome Partitioning 拆分回文串</a>，<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4271456.html" id="cb_post_title_url">Palindrome Partitioning II 拆分回文串之二</a>和<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4464476.html" id="cb_post_title_url"> Longest Palindromic Substring 最长回文串</a>。题目让我们在给定字符串s的前面加上最少个字符，使之变成回文串，那么我们来看题目中给的两个例子，最坏的情况下是s中没有相同的字符，那么最小需要添加字符的个数为s.size() - 1个，第一个例子的字符串包含一个回文串，只需再在前面添加一个字符即可，还有一点需要注意的是，前面添加的字符串都是从s的末尾开始，一位一位往前添加的，那么我们只需要知道从s末尾开始需要添加到前面的个数。这道题如果用brute force无法通过OJ，所以我们需要用一些比较巧妙的方法来解。这里我们用到了KMP算法，KMP算法是一种专门用来匹配字符串的高效的算法，具体方法可以参见这篇博文<a href="http://blog.csdn.net/v_july_v/article/details/7041827" target="_blank">从头到尾彻底理解KMP</a>。我们把s和其转置r连接起来，中间加上一个其他字符，形成一个新的字符串t，我们还需要一个和t长度相同的一位数组next，其中next[i]表示从t[i]到开头的子串的相同前缀后缀的个数，具体可参考KMP算法中解释。最后我们把不相同的个数对应的字符串添加到s之前即可，代码如下：</p>
<p> </p>
<p>C++ 解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> shortestPalindrome(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        </span><span style="color: #0000ff;">string</span> r =<span style="color: #000000;"> s;
        reverse(r.begin(), r.end());
        </span><span style="color: #0000ff;">string</span> t = s + <span style="color: #800000;">"</span><span style="color: #800000;">#</span><span style="color: #800000;">"</span> +<span style="color: #000000;"> r;
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; next(t.size(), <span style="color: #800080;">0</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt; t.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">int</span> j = next[i - <span style="color: #800080;">1</span><span style="color: #000000;">];
            </span><span style="color: #0000ff;">while</span> (j &gt; <span style="color: #800080;">0</span> &amp;&amp; t[i] != t[j]) j = next[j - <span style="color: #800080;">1</span><span style="color: #000000;">];
            next[i] </span>= (j += t[i] ==<span style="color: #000000;"> t[j]);
        }
        </span><span style="color: #0000ff;">return</span> r.substr(<span style="color: #800080;">0</span>, s.size() - next.back()) +<span style="color: #000000;"> s;
    }
};</span></pre>
</div>
<p> </p>
<p>Java 解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> String shortestPalindrome(String s) {
        String r </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> StringBuilder(s).reverse().toString();
        String t </span>= s + "#" +<span style="color: #000000;"> r;
        </span><span style="color: #0000ff;">int</span>[] next = <span style="color: #0000ff;">new</span> <span style="color: #0000ff;">int</span><span style="color: #000000;">[t.length()];
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = 1; i &lt; t.length(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">int</span> j = next[i - 1<span style="color: #000000;">];
            </span><span style="color: #0000ff;">while</span> (j &gt; 0 &amp;&amp; t.charAt(i) != t.charAt(j)) j = next[j - 1<span style="color: #000000;">];
            j </span>+= (t.charAt(i) == t.charAt(j)) ? 1 : 0<span style="color: #000000;">;
            next[i] </span>=<span style="color: #000000;"> j;
        }
        </span><span style="color: #0000ff;">return</span> r.substring(0, s.length() - next[t.length() - 1]) +<span style="color: #000000;"> s;
    }
}</span></pre>
</div>
<p> </p>
<p>从上面的Java和C++的代码中，我们可以看出来C++和Java在使用双等号上的明显的不同，感觉Java对于双等号对使用更加苛刻一些，比如Java中的双等号只对primitive类数据结构(比如int, char等)有效，但是即便有效，也不能将结果直接当1或者0来用。而对于一些从Object派生出来的类，比如Integer或者String等，不能直接用双等号来比较，而是要用其自带的equals()函数来比较，因为双等号判断的是不是同一个对象，而不是他们所表示的值是否相同。同样需要注意的是，Stack的peek()函数取出的也是对象，不能直接和另一个Stack的peek()取出的对象直接双等，而是使用equals或者先将其中一个强行转换成primitive类，再和另一个强行比较。</p>
<p>下面这种方法的写法比较简洁，虽然不是明显的KMP算法，但是也有其的影子在里面，首先我们还是先将其的翻转字符串搞出来，然后比较原字符串s的前缀后翻转字符串t的对应位置的后缀是否相等，起始位置是比较s和t是否相等，如果相等，说明s本身就是回文串，不用添加任何字符，直接返回即可；如果不想等，s去掉最后一位，t去掉第一位，继续比较，以此类推直至有相等，或者循环结束，这样我们就能将两个字符串在正确的位置拼接起来了。很有意思的是，这种方法对应Java写法却会TLE，无法通过OJ。</p>
<p> </p>
<p>C++ 解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> shortestPalindrome(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        </span><span style="color: #0000ff;">string</span> t =<span style="color: #000000;"> s;
        reverse(t.begin(), t.end());
        </span><span style="color: #0000ff;">int</span> n = s.size(), i = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (i = n; i &gt;= <span style="color: #800080;">0</span>; --<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (s.substr(<span style="color: #800080;">0</span>, i) == t.substr(n -<span style="color: #000000;"> i)) {
                </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
            }
        }
        </span><span style="color: #0000ff;">return</span> t.substr(<span style="color: #800080;">0</span>, n - i) +<span style="color: #000000;"> s;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种Java写法也是在找相同的前缀后缀，但是并没有每次把前缀后缀取出来比较，而是用两个指针分别指向对应的位置比较，然后用end指向相同后缀的起始位置，最后再根据end的值来拼接两个字符串。有意思的是这种方法对应的C++写法会TLE，跟上面正好相反，那么我们是否能得出Java的substring操作略慢，而C++的reverse略慢呢，我也仅仅是猜测而已。</p>
<p> </p>
<p>Java 解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> String shortestPalindrome(String s) {
        </span><span style="color: #0000ff;">int</span> i = 0, end = s.length() - 1, j =<span style="color: #000000;"> end;
        </span><span style="color: #0000ff;">char</span> arr =<span style="color: #000000;"> s.toCharArray();
        </span><span style="color: #0000ff;">while</span> (i &lt;<span style="color: #000000;"> j) {
            </span><span style="color: #0000ff;">if</span> (arr[i] ==<span style="color: #000000;"> arr[j]) {
                </span>++i; --<span style="color: #000000;">j;
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                i </span>= 0; --end; j =<span style="color: #000000;"> end;
            }
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span> StringBuilder(s.substring(end + 1)).reverse().toString() +<span style="color: #000000;"> s;
    }
}</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="http://blog.csdn.net/v_july_v/article/details/7041827" target="_blank">http://blog.csdn.net/v_july_v/article/details/7041827</a></p>
<p><a href="https://leetcode.com/discuss/36807/c-8-ms-kmp-based-o-n-time-%26-o-n-memory-solution" target="_blank">https://leetcode.com/discuss/36807/c-8-ms-kmp-based-o-n-time-%26-o-n-memory-solution</a></p>
<p><a href="https://discuss.leetcode.com/topic/14770/my-easily-understandable-but-time-consuming-c-solution" target="_blank">https://discuss.leetcode.com/topic/14770/my-easily-understandable-but-time-consuming-c-solution</a></p>
<p><a href="https://discuss.leetcode.com/topic/25860/my-9-lines-three-pointers-java-solution-with-explanation" target="_blank">https://discuss.leetcode.com/topic/25860/my-9-lines-three-pointers-java-solution-with-explanation</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-05-23 03:09</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4523624" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4523624);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4518674.html" id="cb_post_title_url">[LeetCode] House Robber II 打家劫舍之二</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>After robbing those houses on that street, the thief has found himself a new place for his thievery so that he will not get too much attention. This time, all houses at this place are <strong>arranged in a circle.</strong> That means the first house is the neighbor of the last one. Meanwhile, the security system for these houses remain the same as for those in the previous street.</p>
<p>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight <strong>without alerting the police</strong>.</p>
<p><strong>Credits:</strong><br/>Special thanks to <a href="https://oj.leetcode.com/discuss/user/Freezen">@Freezen</a> for adding this problem and creating all test cases.</p>
<p> </p>
<p>这道题是之前那道<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4383632.html" id="cb_post_title_url">House Robber 打家劫舍</a>的拓展，现在房子排成了一个圆圈，则如果抢了第一家，就不能抢最后一家，因为首尾相连了，所以第一家和最后一家只能抢其中的一家，或者都不抢，那我们这里变通一下，如果我们把第一家和最后一家分别去掉，各算一遍能抢的最大值，然后比较两个值取其中较大的一个即为所求。那我们只需参考之前的<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4383632.html" id="cb_post_title_url">House Robber 打家劫舍</a>中的解题方法，然后调用两边取较大值，代码如下：</p>
<p>解法一</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> DP</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> rob(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        </span><span style="color: #0000ff;">if</span> (nums.size() &lt;= <span style="color: #800080;">1</span>) <span style="color: #0000ff;">return</span> nums.empty() ? <span style="color: #800080;">0</span> : nums[<span style="color: #800080;">0</span><span style="color: #000000;">];
        </span><span style="color: #0000ff;">return</span> max(rob(nums, <span style="color: #800080;">0</span>, nums.size() - <span style="color: #800080;">1</span>), rob(nums, <span style="color: #800080;">1</span><span style="color: #000000;">, nums.size()));
    }
    </span><span style="color: #0000ff;">int</span> rob(vector&lt;<span style="color: #0000ff;">int</span>&gt; &amp;nums, <span style="color: #0000ff;">int</span> left, <span style="color: #0000ff;">int</span><span style="color: #000000;"> right) {
        </span><span style="color: #0000ff;">if</span> (right - left &lt;= <span style="color: #800080;">1</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;"> nums[left];
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; dp(right, <span style="color: #800080;">0</span><span style="color: #000000;">);
        dp[left] </span>=<span style="color: #000000;"> nums[left];
        dp[left </span>+ <span style="color: #800080;">1</span>] = max(nums[left], nums[left + <span style="color: #800080;">1</span><span style="color: #000000;">]);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = left + <span style="color: #800080;">2</span>; i &lt; right; ++<span style="color: #000000;">i) {
            dp[i] </span>= max(nums[i] + dp[i - <span style="color: #800080;">2</span>], dp[i - <span style="color: #800080;">1</span><span style="color: #000000;">]);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> dp.back();
    }
};</span></pre>
</div>
<p> </p>
<p>解法二</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> rob(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        </span><span style="color: #0000ff;">if</span> (nums.size() &lt;= <span style="color: #800080;">1</span>) <span style="color: #0000ff;">return</span> nums.empty() ? <span style="color: #800080;">0</span> : nums[<span style="color: #800080;">0</span><span style="color: #000000;">];
        </span><span style="color: #0000ff;">return</span> max(rob(nums, <span style="color: #800080;">0</span>, nums.size() - <span style="color: #800080;">1</span>), rob(nums, <span style="color: #800080;">1</span><span style="color: #000000;">, nums.size()));
    }
    </span><span style="color: #0000ff;">int</span> rob(vector&lt;<span style="color: #0000ff;">int</span>&gt; &amp;nums, <span style="color: #0000ff;">int</span> left, <span style="color: #0000ff;">int</span><span style="color: #000000;"> right) {
        </span><span style="color: #0000ff;">int</span> a = <span style="color: #800080;">0</span>, b = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = left; i &lt; right; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">int</span> m = a, n =<span style="color: #000000;"> b;
            a </span>= n +<span style="color: #000000;"> nums[i];
            b </span>=<span style="color: #000000;"> max(m, n);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> max(a, b);
    }
};</span></pre>
</div>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> rob(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        </span><span style="color: #0000ff;">if</span> (nums.size() &lt;= <span style="color: #800080;">1</span>) <span style="color: #0000ff;">return</span> nums.empty() ? <span style="color: #800080;">0</span> : nums[<span style="color: #800080;">0</span><span style="color: #000000;">];
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; v1 = nums, v2 =<span style="color: #000000;"> nums;
        v1.erase(v1.begin()); v2.pop_back();
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> max(rob_house(v1), rob_house(v2));
    }
    </span><span style="color: #0000ff;">int</span> rob_house(vector&lt;<span style="color: #0000ff;">int</span>&gt; &amp;<span style="color: #000000;">nums) {
        </span><span style="color: #0000ff;">int</span> a = <span style="color: #800080;">0</span>, b = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; nums.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (i % <span style="color: #800080;">2</span> == <span style="color: #800080;">0</span><span style="color: #000000;">) {
                a </span>+=<span style="color: #000000;"> nums[i];
                a </span>=<span style="color: #000000;"> max(a, b);
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                b </span>+=<span style="color: #000000;"> nums[i];
                b </span>=<span style="color: #000000;"> max(a, b);
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> max(a, b);
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4383632.html" target="_blank">House Robber</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/5275096.html" target="_blank">House Robber III</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-05-21 03:26</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4518674" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4518674);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4516013.html" id="cb_post_title_url">[LeetCode] Word Search II 词语搜索之二</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a 2D board and a list of words from the dictionary, find all words in the board.</p>
<p>Each word must be constructed from letters of sequentially adjacent cell, where "adjacent" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.</p>
<p> For example,<br/>
Given <strong>words</strong> = <code>["oath","pea","eat","rain"]</code> and <strong>board</strong> = 
</p>
<pre>[
  ['<span style="color: #d70;">o','<span style="color: #d70;">a','a','n'],
  ['e','<span style="color: #d30;">t','<span style="color: #d00;">a','<span style="color: #d00;">e'],
  ['i','<span style="color: #d70;">h','k','r'],
  ['i','f','l','v']
]
</span></span></span></span></span></span></pre>
<p>Return <code>["eat","oath"]</code>.</p>
<p> <strong>Note:</strong><br/>
You may assume that all inputs are consist of lowercase letters <code>a-z</code>.
</p>
<div class="spoilers" style="display: block;">
<p>You would need to optimize your backtracking to pass the larger test. Could you stop backtracking earlier?</p>
<p>If the current candidate does not exist in all words' prefix, you 
could stop backtracking immediately. What kind of data structure could 
answer such query efficiently? Does a hash table work? Why or why not? 
How about a Trie? If you would like to learn how to implement a basic 
</div>
<p> </p>
<p>这道题是在之前那道<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4332313.html" id="cb_post_title_url">Word Search 词语搜索</a>的基础上做了些拓展，之前是给一个单词让判断是否存在，现在是给了一堆单词，让返回所有存在的单词，在这道题最开始更新的几个小时内，用brute force是可以通过OJ的，就是在之前那题的基础上多加一个for循环而已，但是后来出题者其实是想考察字典树的应用，所以加了一个超大的test case，以至于brute force无法通过，强制我们必须要用字典树来求解。LeetCode中有关字典树的题还有<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4491665.html" id="homepage1_HomePageDays_DaysList_ctl03_DayList_TitleUrl_0"> Implement Trie (Prefix Tree) 实现字典树(前缀树)</a>和<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4507286.html" id="cb_post_title_url">Add and Search Word - Data structure design 添加和查找单词-数据结构设计</a>，那么我们在这题中只要实现字典树中的insert功能就行了，查找单词和前缀就没有必要了，然后DFS的思路跟之前那道<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4332313.html" id="cb_post_title_url">Word Search 词语搜索</a>基本相同，请参见代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">struct</span><span style="color: #000000;"> TrieNode {
        TrieNode </span>*child[<span style="color: #800080;">26</span><span style="color: #000000;">];
        </span><span style="color: #0000ff;">string</span><span style="color: #000000;"> str;
        TrieNode() : str(</span><span style="color: #800000;">""</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">for</span> (auto &amp;a : child) a =<span style="color: #000000;"> NULL;
        }
    };
    </span><span style="color: #0000ff;">struct</span><span style="color: #000000;"> Trie {
        TrieNode </span>*<span style="color: #000000;">root;
        Trie() : root(</span><span style="color: #0000ff;">new</span><span style="color: #000000;"> TrieNode()) {}
        </span><span style="color: #0000ff;">void</span> insert(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
            TrieNode </span>*p =<span style="color: #000000;"> root;
            </span><span style="color: #0000ff;">for</span> (auto &amp;<span style="color: #000000;">a : s) {
                </span><span style="color: #0000ff;">int</span> i = a - <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">if</span> (!p-&gt;child[i]) p-&gt;child[i] = <span style="color: #0000ff;">new</span><span style="color: #000000;"> TrieNode();
                p </span>= p-&gt;<span style="color: #000000;">child[i];
            }
            p</span>-&gt;str =<span style="color: #000000;"> s;
        }
    };
    vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; findWords(vector&lt;vector&lt;<span style="color: #0000ff;">char</span>&gt; &gt;&amp; board, vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp;<span style="color: #000000;"> words) {
        vector</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">if</span> (words.empty() || board.empty() || board[<span style="color: #800080;">0</span>].empty()) <span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">bool</span>&gt; &gt; visit(board.size(), vector&lt;<span style="color: #0000ff;">bool</span>&gt;(board[<span style="color: #800080;">0</span>].size(), <span style="color: #0000ff;">false</span><span style="color: #000000;">));
        Trie T;
        </span><span style="color: #0000ff;">for</span> (auto &amp;<span style="color: #000000;">a : words) T.insert(a);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; board.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; board[i].size(); ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> (T.root-&gt;child[board[i][j] - <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span><span style="color: #000000;">]) {
                    search(board, T.root</span>-&gt;child[board[i][j] - <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span><span style="color: #000000;">], i, j, visit, res);
                }
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">void</span> search(vector&lt;vector&lt;<span style="color: #0000ff;">char</span>&gt; &gt; &amp;board, TrieNode *p, <span style="color: #0000ff;">int</span> i, <span style="color: #0000ff;">int</span> j, vector&lt;vector&lt;<span style="color: #0000ff;">bool</span>&gt; &gt; &amp;visit, vector&lt;<span style="color: #0000ff;">string</span>&gt; &amp;<span style="color: #000000;">res) { 
        </span><span style="color: #0000ff;">if</span> (!p-&gt;<span style="color: #000000;">str.empty()) {
            res.push_back(p</span>-&gt;<span style="color: #000000;">str);
            p</span>-&gt;<span style="color: #000000;">str.clear();
        }
        </span><span style="color: #0000ff;">int</span> d[][<span style="color: #800080;">2</span>] = {{-<span style="color: #800080;">1</span>, <span style="color: #800080;">0</span>}, {<span style="color: #800080;">1</span>, <span style="color: #800080;">0</span>}, {<span style="color: #800080;">0</span>, -<span style="color: #800080;">1</span>}, {<span style="color: #800080;">0</span>, <span style="color: #800080;">1</span><span style="color: #000000;">}};
        visit[i][j] </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (auto &amp;<span style="color: #000000;">a : d) {
            </span><span style="color: #0000ff;">int</span> nx = a[<span style="color: #800080;">0</span>] + i, ny = a[<span style="color: #800080;">1</span>] +<span style="color: #000000;"> j;
            </span><span style="color: #0000ff;">if</span> (nx &gt;= <span style="color: #800080;">0</span> &amp;&amp; nx &lt; board.size() &amp;&amp; ny &gt;= <span style="color: #800080;">0</span> &amp;&amp; ny &lt; board[<span style="color: #800080;">0</span>].size() &amp;&amp; !visit[nx][ny] &amp;&amp; p-&gt;child[board[nx][ny] - <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span><span style="color: #000000;">]) {
                search(board, p</span>-&gt;child[board[nx][ny] - <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span><span style="color: #000000;">], nx, ny, visit, res);
            }
        }
        visit[i][j] </span>= <span style="color: #0000ff;">false</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://leetcode.com/discuss/36367/simple-c-solution-using-trie" target="_blank">https://leetcode.com/discuss/36367/simple-c-solution-using-trie</a></p>
<p><a href="http://blog.csdn.net/ljiabin/article/details/45846527" target="_blank">http://blog.csdn.net/ljiabin/article/details/45846527</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-05-20 00:06</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4516013" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4516013);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4507286.html" id="cb_post_title_url">[LeetCode] Add and Search Word - Data structure design 添加和查找单词-数据结构设计</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Design a data structure that supports the following two operations:</p>
<pre>void addWord(word)
bool search(word)
</pre>
<p>search(word) can search a literal word or a regular expression string containing only letters <code>a-z</code> or <code>.</code>. A <code>.</code> means it can represent any one letter.</p>
<p>For example:</p>
<pre>addWord("bad")
addWord("dad")
addWord("mad")
search("pad") -&gt; false
search("bad") -&gt; true
search(".ad") -&gt; true
search("b..") -&gt; true
</pre>
<p>Note:<br/>You may assume that all words are consist of lowercase letters <code>a-z</code>.</p>
<p> </p>
<p>LeetCode出新题的速度越来越快了，有点跟不上节奏的感觉了。这道题如果做过之前的那道<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4491665.html" id="homepage1_HomePageDays_DaysList_ctl03_DayList_TitleUrl_0"> Implement Trie (Prefix Tree) 实现字典树(前缀树)</a>的话就没有太大的难度了，还是要用到字典树的结构，唯一不同的地方就是search的函数需要重新写一下，因为这道题里面'.'可以代替任意字符，所以一旦有了'.'，就需要查找所有的子树，只要有一个返回true，整个search函数就返回true，典型的DFS的问题，其他部分跟上一道实现字典树没有太大区别，代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> WordDictionary {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">struct</span><span style="color: #000000;"> TrieNode {
    </span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
        TrieNode </span>*child[<span style="color: #800080;">26</span><span style="color: #000000;">];
        </span><span style="color: #0000ff;">bool</span><span style="color: #000000;"> isWord;
        TrieNode() : isWord(</span><span style="color: #0000ff;">false</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">for</span> (auto &amp;a : child) a =<span style="color: #000000;"> NULL;
        }
    };
    
    WordDictionary() {
        root </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> TrieNode();
    }
    
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> Adds a word into the data structure.</span>
    <span style="color: #0000ff;">void</span> addWord(<span style="color: #0000ff;">string</span><span style="color: #000000;"> word) {
        TrieNode </span>*p =<span style="color: #000000;"> root;
        </span><span style="color: #0000ff;">for</span> (auto &amp;<span style="color: #000000;">a : word) {
            </span><span style="color: #0000ff;">int</span> i = a - <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> (!p-&gt;child[i]) p-&gt;child[i] = <span style="color: #0000ff;">new</span><span style="color: #000000;"> TrieNode();
            p </span>= p-&gt;<span style="color: #000000;">child[i];
        }
        p</span>-&gt;isWord = <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }

    </span><span style="color: #008000;">//</span><span style="color: #008000;"> Returns if the word is in the data structure. A word could
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> contain the dot character '.' to represent any one letter.</span>
    <span style="color: #0000ff;">bool</span> search(<span style="color: #0000ff;">string</span><span style="color: #000000;"> word) {
        </span><span style="color: #0000ff;">return</span> searchWord(word, root, <span style="color: #800080;">0</span><span style="color: #000000;">);
    }
    
    </span><span style="color: #0000ff;">bool</span> searchWord(<span style="color: #0000ff;">string</span> &amp;word, TrieNode *p, <span style="color: #0000ff;">int</span><span style="color: #000000;"> i) {
        </span><span style="color: #0000ff;">if</span> (i == word.size()) <span style="color: #0000ff;">return</span> p-&gt;<span style="color: #000000;">isWord;
        </span><span style="color: #0000ff;">if</span> (word[i] == <span style="color: #800000;">'</span><span style="color: #800000;">.</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">for</span> (auto &amp;a : p-&gt;<span style="color: #000000;">child) {
                </span><span style="color: #0000ff;">if</span> (a &amp;&amp; searchWord(word, a, i + <span style="color: #800080;">1</span>)) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
            }
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            </span><span style="color: #0000ff;">return</span> p-&gt;child[word[i] - <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span>] &amp;&amp; searchWord(word, p-&gt;child[word[i] - <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span>], i + <span style="color: #800080;">1</span><span style="color: #000000;">);
        }
    }
    
</span><span style="color: #0000ff;">private</span><span style="color: #000000;">:
    TrieNode </span>*<span style="color: #000000;">root;
};

</span><span style="color: #008000;">//</span><span style="color: #008000;"> Your WordDictionary object will be instantiated and called as such:
</span><span style="color: #008000;">//</span><span style="color: #008000;"> WordDictionary wordDictionary;
</span><span style="color: #008000;">//</span><span style="color: #008000;"> wordDictionary.addWord("word");
</span><span style="color: #008000;">//</span><span style="color: #008000;"> wordDictionary.search("pattern");</span></pre>
</div>
<p> </p>
<p>讨论：这道题有个很好的Follow up，就是当搜索的单词中存在星号怎么搞，星号的定义和<a href="http://www.cnblogs.com/grandyang/p/4401196.html" target="_blank">Wildcard Matching</a>中一样，可以代表任意的字符串，包括空字符串，请参见评论区1楼。</p>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4491665.html" target="_blank">Implement Trie (Prefix Tree)</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4401196.html" target="_blank">Wildcard Matching</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://leetcode.com/discuss/36246/my-java-trie-based-solution" target="_blank">https://leetcode.com/discuss/36246/my-java-trie-based-solution</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-05-16 05:59</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4507286" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4507286);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4504793.html" id="cb_post_title_url">[LeetCode] Course Schedule II 课程清单之二</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>There are a total of <em>n</em> courses you have to take, labeled from <code>0</code> to <code>n - 1</code>.</p>
<p>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: <code>[0,1]</code></p>
<p>Given the total number of courses and a list of prerequisite <strong>pairs</strong>, return the ordering of courses you should take to finish all courses.</p>
<p>There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array.</p>
<p>For example:</p>
<pre>2, [[1,0]]</pre>
<p>There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is <code>[0,1]</code></p>
<pre>4, [[1,0],[2,0],[3,1],[3,2]]</pre>
<p>There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. So one correct course order is <code>[0,1,2,3]</code>. Another correct ordering is<code>[0,2,1,3]</code>.</p>
<p><strong>Note:</strong><br/>
The input prerequisites is a graph represented by <strong>a list of edges</strong>, not adjacency matrices. Read more about <a href="https://www.khanacademy.org/computing/computer-science/algorithms/graph-representation/a/representing-graphs" target="_blank">how a graph is represented</a>.
</p>
<div class="spoilers" style="display: block;"><strong>Hints:</strong><ol>
<li>This problem is equivalent to finding the topological order in a 
directed graph. If a cycle exists, no topological ordering exists and 
therefore it will be impossible to take all courses.</li>
<li><a href="https://class.coursera.org/algo-003/lecture/52" target="_blank">Topological Sort via DFS</a> - A great video tutorial (21 minutes) on Coursera explaining the basic concepts of Topological Sort.</li>
<li>Topological sort could also be done via <a href="http://en.wikipedia.org/wiki/Topological_sorting#Algorithms" target="_blank">BFS</a>.</li>
</ol>
</div>
<p> </p>
<p>这题是之前那道<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4484571.html" id="cb_post_title_url"> Course Schedule 课程清单</a>的扩展，那道题只让我们判断是否能完成所有课程，即检测有向图中是否有环，而这道题我们得找出要上的课程的顺序，即有向图的拓扑排序，这样一来，难度就增加了，但是由于我们有之前那道的基础，而此题正是基于之前解法的基础上稍加修改，我们从queue中每取出一个数组就将其存在结果中，最终若有向图中有环，则结果中元素的个数不等于总课程数，那我们将结果清空即可。代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; findOrder(<span style="color: #0000ff;">int</span> numCourses, vector&lt;pair&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> prerequisites) {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> res;
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt; &gt; graph(numCourses, vector&lt;<span style="color: #0000ff;">int</span>&gt;(<span style="color: #800080;">0</span><span style="color: #000000;">));
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; <span style="color: #0000ff;">in</span>(numCourses, <span style="color: #800080;">0</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">for</span> (auto &amp;<span style="color: #000000;">a : prerequisites) {
            graph[a.second].push_back(a.first);
            </span>++<span style="color: #0000ff;">in</span><span style="color: #000000;">[a.first];
        }
        queue</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> q;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; numCourses; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">in</span>[i] == <span style="color: #800080;">0</span><span style="color: #000000;">) q.push(i);
        }
        </span><span style="color: #0000ff;">while</span> (!<span style="color: #000000;">q.empty()) {
            </span><span style="color: #0000ff;">int</span> t =<span style="color: #000000;"> q.front();
            res.push_back(t);
            q.pop();
            </span><span style="color: #0000ff;">for</span> (auto &amp;<span style="color: #000000;">a : graph[t]) {
                </span>--<span style="color: #0000ff;">in</span><span style="color: #000000;">[a];
                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">in</span>[a] == <span style="color: #800080;">0</span><span style="color: #000000;">) q.push(a);
            }
        }
        </span><span style="color: #0000ff;">if</span> (res.size() !=<span style="color: #000000;"> numCourses) res.clear();
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/5000291.html" id="homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0">Minimum Height Trees</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4484571.html" target="_blank">Course Schedule</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-05-14 23:19</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4504793" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4504793);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4501934.html" id="cb_post_title_url">[LeetCode] Minimum Size Subarray Sum 最短子数组之和</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given an array of n positive integers and a positive integer s, find the minimal length of a subarray of which the sum ≥ s. If there isn't one, return 0 instead.</p>
<p>For example, given the array <code>[2,3,1,2,4,3]</code> and <code>s = 7</code>,<br/>the subarray <code>[4,3]</code> has the minimal length under the problem constraint.</p>
<div class="spoilers">More practice:
<p>If you have figured out the <em>O</em>(<em>n</em>) solution, try coding another solution of which the time complexity is <em>O</em>(<em>n</em> log <em>n</em>).</p>
</div>
<p>Credits:<br/>Special thanks to <a href="https://oj.leetcode.com/discuss/user/Freezen">@Freezen</a> for adding this problem and creating all test cases.</p>
<p> </p>
<p>这道题给定了我们一个数字，让我们求子数组之和大于等于给定值的最小长度，跟之前那道<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4377150.html" id="cb_post_title_url"> Maximum Subarray 最大子数组</a>有些类似，并且题目中要求我们实现O(n)和O(nlgn)两种解法，那么我们先来看O(n)的解法，我们需要定义两个指针left和right，分别记录子数组的左右的边界位置，然后我们让right向右移，直到子数组和大于等于给定值或者right达到数组末尾，此时我们更新最短距离，并且将left像右移一位，然后再sum中减去移去的值，然后重复上面的步骤，直到right到达末尾，且left到达临界位置，即要么到达边界，要么再往右移动，和就会小于给定值。代码如下：</p>
<p> </p>
<p>解法一</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> O(n)</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> minSubArrayLen(<span style="color: #0000ff;">int</span> s, vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        </span><span style="color: #0000ff;">if</span> (nums.empty()) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> left = <span style="color: #800080;">0</span>, right = <span style="color: #800080;">0</span>, sum = <span style="color: #800080;">0</span>, len = nums.size(), res = len + <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (right &lt;<span style="color: #000000;"> len) {
            </span><span style="color: #0000ff;">while</span> (sum &lt; s &amp;&amp; right &lt;<span style="color: #000000;"> len) {
                sum </span>+= nums[right++<span style="color: #000000;">];
            }
            </span><span style="color: #0000ff;">while</span> (sum &gt;=<span style="color: #000000;"> s) {
                res </span>= min(res, right -<span style="color: #000000;"> left);
                sum </span>-= nums[left++<span style="color: #000000;">];
            }
        }
        </span><span style="color: #0000ff;">return</span> res == len + <span style="color: #800080;">1</span> ? <span style="color: #800080;">0</span><span style="color: #000000;"> : res;
    }
};</span></pre>
</div>
<p> </p>
<p>同样的思路，我们也可以换一种写法，参考代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> minSubArrayLen(<span style="color: #0000ff;">int</span> s, vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        </span><span style="color: #0000ff;">int</span> res = INT_MAX, left = <span style="color: #800080;">0</span>, sum = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; nums.size(); ++<span style="color: #000000;">i) {
            sum </span>+=<span style="color: #000000;"> nums[i];
            </span><span style="color: #0000ff;">while</span> (left &lt;= i &amp;&amp; sum &gt;=<span style="color: #000000;"> s) {
                res </span>= min(res, i - left + <span style="color: #800080;">1</span><span style="color: #000000;">);
                sum </span>-= nums[left++<span style="color: #000000;">];
            }
        }
        </span><span style="color: #0000ff;">return</span> res == INT_MAX ? <span style="color: #800080;">0</span><span style="color: #000000;"> : res;
    }
};</span></pre>
</div>
<p> </p>
<p>下面我们再来看看O(nlgn)的解法，这个解法要用到二分查找法，思路是，我们建立一个比原数组长一位的sums数组，其中sums[i]表示nums数组中[0, i - 1]的和，然后我们对于sums中每一个值sums[i]，用二分查找法找到子数组的右边界位置，使该子数组之和大于sums[i] + s，然后我们更新最短长度的距离即可。代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> O(nlgn)</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> minSubArrayLen(<span style="color: #0000ff;">int</span> s, vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        </span><span style="color: #0000ff;">int</span> len = nums.size(), sums[len + <span style="color: #800080;">1</span>] = {<span style="color: #800080;">0</span>}, res = len + <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt; len + <span style="color: #800080;">1</span>; ++i) sums[i] = sums[i - <span style="color: #800080;">1</span>] + nums[i - <span style="color: #800080;">1</span><span style="color: #000000;">];
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; len + <span style="color: #800080;">1</span>; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">int</span> right = searchRight(i + <span style="color: #800080;">1</span>, len, sums[i] +<span style="color: #000000;"> s, sums);
            </span><span style="color: #0000ff;">if</span> (right == len + <span style="color: #800080;">1</span>) <span style="color: #0000ff;">break</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> (res &gt; right - i) res = right -<span style="color: #000000;"> i;
        }
        </span><span style="color: #0000ff;">return</span> res == len + <span style="color: #800080;">1</span> ? <span style="color: #800080;">0</span><span style="color: #000000;"> : res;
    }
    </span><span style="color: #0000ff;">int</span> searchRight(<span style="color: #0000ff;">int</span> left, <span style="color: #0000ff;">int</span> right, <span style="color: #0000ff;">int</span> key, <span style="color: #0000ff;">int</span><span style="color: #000000;"> sums[]) {
        </span><span style="color: #0000ff;">while</span> (left &lt;=<span style="color: #000000;"> right) {
            </span><span style="color: #0000ff;">int</span> mid = (left + right) / <span style="color: #800080;">2</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> (sums[mid] &gt;= key) right = mid - <span style="color: #800080;">1</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">else</span> left = mid + <span style="color: #800080;">1</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> left;
    }
};</span></pre>
</div>
<p> </p>
<p>我们也可以不用为二分查找法专门写一个函数，直接嵌套在for循环中即可，参加代码如下：</p>
<p> </p>
<p>解法四：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> minSubArrayLen(<span style="color: #0000ff;">int</span> s, vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        </span><span style="color: #0000ff;">int</span> res = INT_MAX, n =<span style="color: #000000;"> nums.size();
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; sums(n + <span style="color: #800080;">1</span>, <span style="color: #800080;">0</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt; n + <span style="color: #800080;">1</span>; ++i) sums[i] = sums[i - <span style="color: #800080;">1</span>] + nums[i - <span style="color: #800080;">1</span><span style="color: #000000;">];
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">int</span> left = i + <span style="color: #800080;">1</span>, right = n, t = sums[i] +<span style="color: #000000;"> s;
            </span><span style="color: #0000ff;">while</span> (left &lt;=<span style="color: #000000;"> right) {
                </span><span style="color: #0000ff;">int</span> mid = left + (right - left) / <span style="color: #800080;">2</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">if</span> (sums[mid] &lt; t) left = mid + <span style="color: #800080;">1</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">else</span> right = mid - <span style="color: #800080;">1</span><span style="color: #000000;">;
            }
            </span><span style="color: #0000ff;">if</span> (left == n + <span style="color: #800080;">1</span>) <span style="color: #0000ff;">break</span><span style="color: #000000;">;
            res </span>= min(res, left -<span style="color: #000000;"> i);
        }
        </span><span style="color: #0000ff;">return</span> res == INT_MAX ? <span style="color: #800080;">0</span><span style="color: #000000;"> : res;
    }
};</span></pre>
</div>
<p> </p>
<p>讨论：本题有一个很好的Follow up，就是去掉所有数字是正数的限制条件，而去掉这个条件会使得累加数组不一定会是递增的了，那么就不能使用二分法，同时双指针的方法也会失效，只能另辟蹊径了。其实博主觉得同时应该去掉大于s的条件，只保留sum=s这个要求，因为这样我们可以再建立累加数组后用2sum的思路，快速查找s-sum是否存在，如果有了大于的条件，还得继续遍历所有大于s-sum的值，效率提高不了多少。</p>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4340948.html" target="_blank">Minimum Window Substring</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/6810361.html">Subarray Sum Equals K</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/7801533.html">Maximum Length of Repeated Subarray</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/17063/4ms-o-n-8ms-o-nlogn-c">https://discuss.leetcode.com/topic/17063/4ms-o-n-8ms-o-nlogn-c</a></p>
<p><a href="https://discuss.leetcode.com/topic/18583/accepted-clean-java-o-n-solution-two-pointers">https://discuss.leetcode.com/topic/18583/accepted-clean-java-o-n-solution-two-pointers</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-05-13 22:37</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4501934" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4501934);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4491665.html" id="cb_post_title_url">[LeetCode] Implement Trie (Prefix Tree) 实现字典树(前缀树)</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Implement a trie with <code>insert</code>, <code>search</code>, and <code>startsWith</code> methods.</p>
<p>Note:<br/>You may assume that all inputs are consist of lowercase letters <code>a-z</code>.</p>
<p> </p>
<p>这道题让我们实现一个重要但又有些复杂的数据结构-<a href="http://zh.wikipedia.org/wiki/Trie" target="_blank">字典树</a>， 又称前缀树或单词查找树，详细介绍可以参见<a href="http://dongxicheng.org/structure/trietree/" target="_blank">网友董的博客</a>，例如，一个保存了8个键的trie结构，"A", "to", "tea", "ted", "ten", "i", "in", and "inn".如下图所示：</p>
<p> </p>
<p><img alt="" class="thumbimage" data-file-height="375" data-file-width="400" height="234" src="http://upload.wikimedia.org/wikipedia/commons/thumb/b/be/Trie_example.svg/375px-Trie_example.svg.png" width="250"/></p>
<p> </p>
<p>字典树主要有如下三点性质：</p>
<p>1. 根节点不包含字符，除根节点意外每个节点只包含一个字符。</p>
<p>2. 从根节点到某一个节点，路径上经过的字符连接起来，为该节点对应的字符串。</p>
<p>3. 每个节点的所有子节点包含的字符串不相同。</p>
<p> </p>
<p>字母树的插入（Insert）、删除（ Delete）和查找（Find）都非常简单，用一个一重循环即可，即第i 次循环找到前i 个字母所对应的子树，然后进行相应的操作。实现这棵字母树，我们用最常见的数组保存（静态开辟内存）即可，当然也可以开动态的指针类型（动态开辟内存）。至于结点对儿子的指向，一般有三种方法：</p>
<p>1、对每个结点开一个字母集大小的数组，对应的下标是儿子所表示的字母，内容则是这个儿子对应在大数组上的位置，即标号；</p>
<p>2、对每个结点挂一个链表，按一定顺序记录每个儿子是谁；</p>
<p>3、使用左儿子右兄弟表示法记录这棵树。</p>
<p>三种方法，各有特点。第一种易实现，但实际的空间要求较大；第二种，较易实现，空间要求相对较小，但比较费时；第三种，空间要求最小，但相对费时且不易写。</p>
<p> </p>
<p>我们先来看第一种实现方法，这种方法实现起来简单直观，字母的字典树每个节点要定义一个大小为26的子节点指针数组，然后用一个标志符用来记录到当前位置为止是否为一个词，初始化的时候讲26个子节点都赋为空。那么insert操作只需要对于要插入的字符串的每一个字符算出其的位置，然后找是否存在这个子节点，若不存在则新建一个，然后再查找下一个。查找词和找前缀操作跟insert操作都很类似，不同点在于若不存在子节点，则返回false。查找次最后还要看标识位，而找前缀直接返回true即可。代码如下：</p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> TrieNode {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> Initialize your data structure here.</span>
    TrieNode *child[<span style="color: #800080;">26</span><span style="color: #000000;">];
    </span><span style="color: #0000ff;">bool</span><span style="color: #000000;"> isWord;
    TrieNode() : isWord(</span><span style="color: #0000ff;">false</span><span style="color: #000000;">){
        </span><span style="color: #0000ff;">for</span> (auto &amp;a : child) a =<span style="color: #000000;"> NULL;
    }
};

</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> Trie {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    Trie() {
        root </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> TrieNode();
    }

    </span><span style="color: #008000;">//</span><span style="color: #008000;"> Inserts a word into the trie.</span>
    <span style="color: #0000ff;">void</span> insert(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        TrieNode </span>*p =<span style="color: #000000;"> root;
        </span><span style="color: #0000ff;">for</span> (auto &amp;<span style="color: #000000;">a : s) {
            </span><span style="color: #0000ff;">int</span> i = a - <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> (!p-&gt;child[i]) p-&gt;child[i] = <span style="color: #0000ff;">new</span><span style="color: #000000;"> TrieNode();
            p </span>= p-&gt;<span style="color: #000000;">child[i];
        }
        p</span>-&gt;isWord = <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }

    </span><span style="color: #008000;">//</span><span style="color: #008000;"> Returns if the word is in the trie.</span>
    <span style="color: #0000ff;">bool</span> search(<span style="color: #0000ff;">string</span><span style="color: #000000;"> key) {
        TrieNode </span>*p =<span style="color: #000000;"> root;
        </span><span style="color: #0000ff;">for</span> (auto &amp;<span style="color: #000000;">a : key) {
            </span><span style="color: #0000ff;">int</span> i = a - <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> (!p-&gt;child[i]) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            p </span>= p-&gt;<span style="color: #000000;">child[i];
        }
        </span><span style="color: #0000ff;">return</span> p-&gt;<span style="color: #000000;">isWord;
    }

    </span><span style="color: #008000;">//</span><span style="color: #008000;"> Returns if there is any word in the trie
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> that starts with the given prefix.</span>
    <span style="color: #0000ff;">bool</span> startsWith(<span style="color: #0000ff;">string</span><span style="color: #000000;"> prefix) {
        TrieNode </span>*p =<span style="color: #000000;"> root;
        </span><span style="color: #0000ff;">for</span> (auto &amp;<span style="color: #000000;">a : prefix) {
            </span><span style="color: #0000ff;">int</span> i = a - <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> (!p-&gt;child[i]) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            p </span>= p-&gt;<span style="color: #000000;">child[i];
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }

</span><span style="color: #0000ff;">private</span><span style="color: #000000;">:
    TrieNode</span>*<span style="color: #000000;"> root;
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="http://dongxicheng.org/structure/trietree/" target="_blank">http://dongxicheng.org/structure/trietree/</a></p>
<p><a href="http://pisxw.com/algorithm/Implement-Trie-(Prefix%20Tree).html" target="_blank">http://pisxw.com/algorithm/Implement-Trie-(Prefix%20Tree).html</a></p>
<p><a href="https://leetcode.com/discuss/35048/share-my-java-solution" target="_blank">https://leetcode.com/discuss/35048/share-my-java-solution</a></p>
<p><a href="http://www.cnblogs.com/easonliu/p/4488522.html" target="_blank">http://www.cnblogs.com/easonliu/p/4488522.html</a></p>
<p><a href="https://leetcode.com/discuss/35014/ac-c-solution-using-unordered_map-for-next" target="_blank">https://leetcode.com/discuss/35014/ac-c-solution-using-unordered_map-for-next</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-05-10 06:32</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4491665" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4491665);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4484571.html" id="cb_post_title_url">[LeetCode] Course Schedule 课程清单</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>There are a total of <em>n</em> courses you have to take, labeled from <code>0</code> to <code>n - 1</code>.</p>
<p>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: <code>[0,1]</code></p>
<p>Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?</p>
<p>For example:</p>
<pre>2, [[1,0]]</pre>
<p>There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible.</p>
<pre>2, [[1,0],[0,1]]</pre>
<p>There are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.</p>
<div class="spoilers">Hints:<ol>
<li>This problem is equivalent to finding if a cycle exists in a directed graph. If a cycle exists, no topological ordering exists and therefore it will be impossible to take all courses.</li>
<li>There are <a href="https://www.khanacademy.org/computing/computer-science/algorithms/graph-representation/a/representing-graphs" target="_blank">several ways to represent a graph</a>. For example, the input prerequisites is a graph represented by a list of edges. Is this graph representation appropriate?</li>
<li><a href="https://class.coursera.org/algo-003/lecture/52" target="_blank">Topological Sort via DFS</a> - A great video tutorial (21 minutes) on Coursera explaining the basic concepts of Topological Sort.</li>
<li>Topological sort could also be done via <a href="http://en.wikipedia.org/wiki/Topological_sorting#Algorithms" target="_blank">BFS</a>.</li>
</ol></div>
<p> </p>
<p>这道课程清单的问题对于我们学生来说应该不陌生，因为我们在选课的时候经常会遇到想选某一门课程，发现选它之前必须先上了哪些课程，这道题给了很多提示，第一条就告诉我们了这道题的本质就是在有向图中检测环。 LeetCode中关于图的题很少，有向图的仅此一道，还有一道关于无向图的题是<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4267628.html" id="cb_post_title_url"> Clone Graph 无向图的复制</a>。个人认为图这种数据结构相比于树啊，链表啊什么的要更为复杂一些，尤其是有向图，很麻烦。第二条提示是在讲如何来表示一个有向图，可以用边来表示，边是由两个端点组成的，用两个点来表示边。第三第四条提示揭示了此题有两种解法，DFS和BFS都可以解此题。我们先来看BFS的解法，我们定义二维数组graph来表示这个有向图，一位数组in来表示每个顶点的<a href="http://en.wikipedia.org/wiki/Directed_graph#Indegree_and_outdegree" target="_blank">入度</a>。我们开始先根据输入来建立这个有向图，并将入度数组也初始化好。然后我们定义一个queue变量，将所有入度为0的点放入队列中，然后开始遍历队列，从graph里遍历其连接的点，每到达一个新节点，将其入度减一，如果此时该点入度为0，则放入队列末尾。直到遍历完队列中所有的值，若此时还有节点的入度不为0，则说明环存在，返回false，反之则返回true。代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> canFinish(<span style="color: #0000ff;">int</span> numCourses, vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> prerequisites) {
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt; &gt; graph(numCourses, vector&lt;<span style="color: #0000ff;">int</span>&gt;(<span style="color: #800080;">0</span><span style="color: #000000;">));
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; <span style="color: #0000ff;">in</span>(numCourses, <span style="color: #800080;">0</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto a : prerequisites) {
            graph[a[</span><span style="color: #800080;">1</span>]].push_back(a[<span style="color: #800080;">0</span><span style="color: #000000;">]);
            </span>++<span style="color: #0000ff;">in</span>[a[<span style="color: #800080;">0</span><span style="color: #000000;">]];
        }
        queue</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> q;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; numCourses; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">in</span>[i] == <span style="color: #800080;">0</span><span style="color: #000000;">) q.push(i);
        }
        </span><span style="color: #0000ff;">while</span> (!<span style="color: #000000;">q.empty()) {
            </span><span style="color: #0000ff;">int</span> t =<span style="color: #000000;"> q.front();
            q.pop();
            </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto a : graph[t]) {
                </span>--<span style="color: #0000ff;">in</span><span style="color: #000000;">[a];
                </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">in</span>[a] == <span style="color: #800080;">0</span><span style="color: #000000;">) q.push(a);
            }
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; numCourses; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">in</span>[i] != <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>下面我们来看DFS的解法，也需要建立有向图，还是用二维数组来建立，和BFS不同的是，我们像现在需要一个一维数组visit来记录访问状态，这里有三种状态，0表示还未访问过，1表示已经访问了，-1表示有冲突。大体思路是，先建立好有向图，然后从第一个门课开始，找其可构成哪门课，暂时将当前课程标记为已访问，然后对新得到的课程调用DFS递归，直到出现新的课程已经访问过了，则返回false，没有冲突的话返回true，然后把标记为已访问的课程改为未访问。代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> canFinish(<span style="color: #0000ff;">int</span> numCourses, vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt; &gt;&amp;<span style="color: #000000;"> prerequisites) {
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt; &gt; graph(numCourses, vector&lt;<span style="color: #0000ff;">int</span>&gt;(<span style="color: #800080;">0</span><span style="color: #000000;">));
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; visit(numCourses, <span style="color: #800080;">0</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto a : prerequisites) {
            graph[a[</span><span style="color: #800080;">1</span>]].push_back(a[<span style="color: #800080;">0</span><span style="color: #000000;">]);
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; numCourses; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (!canFinishDFS(graph, visit, i)) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
    </span><span style="color: #0000ff;">bool</span> canFinishDFS(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt; &gt; &amp;graph, vector&lt;<span style="color: #0000ff;">int</span>&gt; &amp;visit, <span style="color: #0000ff;">int</span><span style="color: #000000;"> i) {
        </span><span style="color: #0000ff;">if</span> (visit[i] == -<span style="color: #800080;">1</span>) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (visit[i] == <span style="color: #800080;">1</span>) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        visit[i] </span>= -<span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto a : graph[i]) {
            </span><span style="color: #0000ff;">if</span> (!canFinishDFS(graph, visit, a)) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        }
        visit[i] </span>= <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/5000291.html" id="homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0">Minimum Height Trees</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4504793.html" target="_blank">Course Schedule II</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="http://www.cnblogs.com/easonliu/p/4483437.html" target="_blank">http://www.cnblogs.com/easonliu/p/4483437.html</a></p>
<p><a href="https://leetcode.com/discuss/34741/python-20-lines-dfs-solution-sharing-with-explanation" target="_blank">https://leetcode.com/discuss/34741/python-20-lines-dfs-solution-sharing-with-explanation</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-05-07 13:01</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4484571" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4484571);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4478820.html" id="cb_post_title_url">[LeetCode] Reverse Linked List 倒置链表</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Reverse a singly linked list.</p>
<div class="spoilers">Hint:
<p>A linked list can be reversed either iteratively or recursively. Could you implement both?</p>
<p> </p>
<p>之前做到<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4306611.html" id="cb_post_title_url"> Reverse Linked List II 倒置链表之二</a>的时候我还纳闷怎么只有二没有一呢，原来真是忘了啊，现在才加上，这道题跟之前那道比起来简单不少，题目为了增加些许难度，让我们分别用迭代和递归来实现，但难度还是不大。我们先来看迭代的解法，思路是在原链表之前建立一个dummy node，因为首节点会变，然后从head开始，将之后的一个节点移到dummy node之后，重复此操作知道head成为末节点为止，代码如下：</p>
</div>
<p>解法一</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> Iterative</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    ListNode</span>* reverseList(ListNode*<span style="color: #000000;"> head) {
        </span><span style="color: #0000ff;">if</span> (!head) <span style="color: #0000ff;">return</span><span style="color: #000000;"> head;
        ListNode </span>*dummy = <span style="color: #0000ff;">new</span> ListNode(-<span style="color: #800080;">1</span><span style="color: #000000;">);
        dummy</span>-&gt;next =<span style="color: #000000;"> head;
        ListNode </span>*cur =<span style="color: #000000;"> head;
        </span><span style="color: #0000ff;">while</span> (cur-&gt;<span style="color: #000000;">next) {
            ListNode </span>*tmp = cur-&gt;<span style="color: #000000;">next;
            cur</span>-&gt;next = tmp-&gt;<span style="color: #000000;">next;
            tmp</span>-&gt;next = dummy-&gt;<span style="color: #000000;">next;
            dummy</span>-&gt;next =<span style="color: #000000;"> tmp;
        }
        </span><span style="color: #0000ff;">return</span> dummy-&gt;<span style="color: #000000;">next;
    }
};</span></pre>
</div>
<p> </p>
<p>下面我们来看递归解法，代码量更少，递归解法的思路是，不断的进入递归函数，直到head指向最后一个节点，p指向之前一个节点，然后调换head和p的位置，再返回上一层递归函数，再交换p和head的位置，每次交换后，head节点后面都是交换好的顺序，直到p为首节点，然后再交换，首节点就成了为节点，此时整个链表也完成了翻转，代码如下：</p>
<p>解法二</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> Recursive</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    ListNode</span>* reverseList(ListNode*<span style="color: #000000;"> head) {
        </span><span style="color: #0000ff;">if</span> (!head || !head-&gt;next) <span style="color: #0000ff;">return</span><span style="color: #000000;"> head;
        ListNode </span>*p =<span style="color: #000000;"> head;
        head </span>= reverseList(p-&gt;<span style="color: #000000;">next);
        p</span>-&gt;next-&gt;next =<span style="color: #000000;"> p;
        p</span>-&gt;next =<span style="color: #000000;"> NULL;
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> head;
    }
};</span></pre>
</div>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-05-05 12:45</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4478820" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4478820);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4465779.html" id="cb_post_title_url">[LeetCode] Isomorphic Strings  同构字符串</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given two strings <em>s</em> and <em>t</em>, determine if they are isomorphic.</p>
<p>Two strings are isomorphic if the characters in <em>s</em> can be replaced to get <em>t</em>.</p>
<p>All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.</p>
<p>For example,<br/>Given <code>"egg"</code>, <code>"add"</code>, return true.</p>
<p>Given <code>"foo"</code>, <code>"bar"</code>, return false.</p>
<p>Given <code>"paper"</code>, <code>"title"</code>, return true.</p>
<p>Note:<br/>You may assume both <em>s</em> and <em>t</em> have the same length.</p>
<p> </p>
<p>这道题让我们求同构字符串，就是说原字符串中的每个字符可由另外一个字符替代，可以被其本身替代，相同的字符一定要被同一个字符替代，且一个字符不能被多个字符替代，即不能出现一对多的映射。根据一对一映射的特点，我们需要用两个哈希表分别来记录原字符串和目标字符串中字符出现情况，由于ASCII码只有256个字符，所以我们可以用一个256大小的数组来代替哈希表，并初始化为0，我们遍历原字符串，分别从源字符串和目标字符串取出一个字符，然后分别在两个哈希表中查找其值，若不相等，则返回false，若相等，将其值更新为i + 1，因为默认的值是0，所以我们更新值为i + 1，这样当 i=0 时，则映射为1，如果不加1的话，那么就无法区分是否更新了，代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> isIsomorphic(<span style="color: #0000ff;">string</span> s, <span style="color: #0000ff;">string</span><span style="color: #000000;"> t) {
        </span><span style="color: #0000ff;">int</span> m1[<span style="color: #800080;">256</span>] = {<span style="color: #800080;">0</span>}, m2[<span style="color: #800080;">256</span>] = {<span style="color: #800080;">0</span>}, n =<span style="color: #000000;"> s.size();
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (m1[s[i]] != m2[t[i]]) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            m1[s[i]] </span>= i + <span style="color: #800080;">1</span><span style="color: #000000;">;
            m2[t[i]] </span>= i + <span style="color: #800080;">1</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4857022.html">Word Pattern</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-04-29 13:49</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4465779" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4465779);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4462810.html" id="cb_post_title_url">[LeetCode] Count Primes 质数的个数</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Description:</p>
<p>Count the number of prime numbers less than a non-negative number, n</p>
<div class="spoilers">References:
<p><a href="https://primes.utm.edu/howmany.html" target="_blank">How Many Primes Are There?</a></p>
<p><a href="http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes" target="_blank">Sieve of Eratosthenes</a></p>
</div>
<p>Credits:<br/>Special thanks to <a href="https://leetcode.com/discuss/user/mithmatt">@mithmatt</a> for adding this problem and creating all test cases.</p>
<p> </p>
<p>这道题给定一个非负数n，让我们求小于n的质数的个数，题目中给了充足的提示，解题方法就在第二个提示<a href="http://zh.wikipedia.org/wiki/%E5%9F%83%E6%8B%89%E6%89%98%E6%96%AF%E7%89%B9%E5%B0%BC%E7%AD%9B%E6%B3%95" target="_blank">埃拉托斯特尼筛法Sieve of Eratosthenes</a>中，这个算法的过程如下图所示，我们从2开始遍历到根号n，先找到第一个质数2，然后将其所有的倍数全部标记出来，然后到下一个质数3，标记其所有倍数，一次类推，直到根号n，此时数组中未被标记的数字就是质数。我们需要一个n-1长度的bool型数组来记录每个数字是否被标记，长度为n-1的原因是题目说是小于n的质数个数，并不包括n。 然后我们用两个for循环来实现埃拉托斯特尼筛法，难度并不是很大，代码如下所示：</p>
<p> </p>
<p><img alt="埃拉托斯特尼筛法" data-file-height="369" data-file-width="445" height="369" src="http://upload.wikimedia.org/wikipedia/commons/b/b9/Sieve_of_Eratosthenes_animation.gif" width="445"/></p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> countPrimes(<span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        vector</span>&lt;<span style="color: #0000ff;">bool</span>&gt; num(n - <span style="color: #800080;">1</span>, <span style="color: #0000ff;">true</span><span style="color: #000000;">);
        num[</span><span style="color: #800080;">0</span>] = <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, limit =<span style="color: #000000;"> sqrt(n);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">2</span>; i &lt;= limit; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (num[i - <span style="color: #800080;">1</span><span style="color: #000000;">]) {
                </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = i * i; j &lt; n; j +=<span style="color: #000000;"> i) {
                    num[j </span>- <span style="color: #800080;">1</span>] = <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                }
            }
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; n - <span style="color: #800080;">1</span>; ++<span style="color: #000000;">j) {
            </span><span style="color: #0000ff;">if</span> (num[j]) ++<span style="color: #000000;">res;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-04-28 13:40</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4462810" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4462810);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4452252.html" id="cb_post_title_url">[LeetCode] Remove Linked List Elements 移除链表元素</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Remove all elements from a linked list of integers that have value <strong><em>val</em></strong>.</p>
<p> <strong>Example</strong><br/>
<em><strong>Given:</strong></em> 1 --&gt; 2 --&gt; 6 --&gt; 3 --&gt; 4 --&gt; 5 --&gt; 6,  <strong><em>val</em></strong> = 6<br/>
<em><strong>Return:</strong></em> 1 --&gt; 2 --&gt; 3 --&gt; 4 --&gt; 5
</p>
<p><strong>Credits:</strong><br/>Special thanks to <a href="https://leetcode.com/discuss/user/mithmatt">@mithmatt</a> for adding this problem and creating all test cases.</p>
<p> </p>
<p>这道移除链表元素是链表的基本操作之一，没有太大的难度，就是考察了基本的链表遍历和设置指针的知识点，我们只需定义几个辅助指针，然后遍历原链表，遇到与给定值相同的元素，将该元素的前后连个节点连接起来，然后删除该元素即可，要注意的是还是需要在链表开头加上一个dummy node，具体实现参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    ListNode</span>* removeElements(ListNode* head, <span style="color: #0000ff;">int</span><span style="color: #000000;"> val) {
        ListNode </span>*dummy = <span style="color: #0000ff;">new</span> ListNode(-<span style="color: #800080;">1</span>), *pre =<span style="color: #000000;"> dummy;
        dummy</span>-&gt;next =<span style="color: #000000;"> head;
        </span><span style="color: #0000ff;">while</span> (pre-&gt;<span style="color: #000000;">next) {
            </span><span style="color: #0000ff;">if</span> (pre-&gt;next-&gt;val ==<span style="color: #000000;"> val) {
                ListNode </span>*t = pre-&gt;<span style="color: #000000;">next;
                pre</span>-&gt;next = t-&gt;<span style="color: #000000;">next;
                t</span>-&gt;next =<span style="color: #000000;"> NULL;
                </span><span style="color: #0000ff;">delete</span><span style="color: #000000;"> t;
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                pre </span>= pre-&gt;<span style="color: #000000;">next;
            }
        }
        </span><span style="color: #0000ff;">return</span> dummy-&gt;<span style="color: #000000;">next;
    }
};</span></pre>
</div>
<p> </p>
<p>我们也可以用递归来解，写法很简洁，通过递归调用到链表末尾，然后回来，需要要删的元素，将链表next指针指向下一个元素即可：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    ListNode</span>* removeElements(ListNode* head, <span style="color: #0000ff;">int</span><span style="color: #000000;"> val) {
        </span><span style="color: #0000ff;">if</span> (!head) <span style="color: #0000ff;">return</span><span style="color: #000000;"> NULL;
        head</span>-&gt;next = removeElements(head-&gt;<span style="color: #000000;">next, val);
        </span><span style="color: #0000ff;">return</span> head-&gt;val == val ? head-&gt;<span style="color: #000000;">next : head;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/12580/3-line-recursive-solution" target="_blank">https://discuss.leetcode.com/topic/12580/3-line-recursive-solution</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-04-24 00:29</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4452252" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4452252);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4447233.html" id="cb_post_title_url">[LeetCode] Happy Number 快乐数</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Write an algorithm to determine if a number is "happy".</p>
<p>A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.</p>
<p>Example: 19 is a happy number</p>
<ul>
<li>1^2 + 9^2 = 82</li>
<li>8^2 + 2^2 = 68</li>
<li>6^2 + 8^2 = 100</li>
<li>1^2 + 0^2 + 0^2 = 1</li>
</ul>
<p>Credits:<br/>Special thanks to <a href="https://leetcode.com/discuss/user/mithmatt">@mithmatt</a> and <a href="https://leetcode.com/discuss/user/ts">@ts</a> for adding this problem and creating all test cases.</p>
<p> </p>
<p>这道题定义了一种快乐数，就是说对于某一个正整数，如果对其各个位上的数字分别平方，然后再加起来得到一个新的数字，再进行同样的操作，如果最终结果变成了1，则说明是快乐数，如果一直循环但不是1的话，就不是快乐数，那么现在任意给我们一个正整数，让我们判断这个数是不是快乐数，题目中给的例子19是快乐数，那么我们来看一个不是快乐数的情况，比如数字11有如下的计算过程：</p>
<p>1^2 + 1^2 = 2<br/>2^2 = 4<br/>4^2 = 16<br/>1^2 + 6^2 = 37<br/>3^2 + 7^2 = 58<br/>5^2 + 8^2 = 89<br/>8^2 + 9^2 = 145<br/>1^2 + 4^2 + 5^2 = 42<br/>4^2 + 2^2 = 20<br/>2^2 + 0^2 = <span style="color: #ff0000;">4</span></p>
<p>我们发现在算到最后时数字4又出现了，那么之后的数字又都会重复之前的顺序，这个循环中不包含1，那么数字11不是一个快乐数，发现了规律后就要考虑怎么用代码来实现，我们可以用set来记录所有出现过的数字，然后每出现一个新数字，在set中查找看是否存在，若不存在则加入表中，若存在则跳出循环，并且判断此数是否为1，若为1返回true，不为1返回false，代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> isHappy(<span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        </span><span style="color: #0000ff;">set</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> s;
        </span><span style="color: #0000ff;">while</span> (n != <span style="color: #800080;">1</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">int</span> t = <span style="color: #800080;">0</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> (n) {
                t </span>+= (n % <span style="color: #800080;">10</span>) * (n % <span style="color: #800080;">10</span><span style="color: #000000;">);
                n </span>/= <span style="color: #800080;">10</span><span style="color: #000000;">;
            }
            n </span>=<span style="color: #000000;"> t;
            </span><span style="color: #0000ff;">if</span> (s.count(n)) <span style="color: #0000ff;">break</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> s.insert(n);
        }
        </span><span style="color: #0000ff;">return</span> n == <span style="color: #800080;">1</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>其实这道题也可以不用set来做，我们并不需要太多的额外空间，关于非快乐数有个特点，循环的数字中必定会有4，这里就不做证明了，我也不会证明，就是利用这个性质，就可以不用set了，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> isHappy(<span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        </span><span style="color: #0000ff;">while</span> (n != <span style="color: #800080;">1</span> &amp;&amp; n != <span style="color: #800080;">4</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">int</span> t = <span style="color: #800080;">0</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> (n) {
                t </span>+= (n % <span style="color: #800080;">10</span>) * (n % <span style="color: #800080;">10</span><span style="color: #000000;">);
                n </span>/= <span style="color: #800080;">10</span><span style="color: #000000;">;
            }
            n </span>=<span style="color: #000000;"> t;
        }
        </span><span style="color: #0000ff;">return</span> n == <span style="color: #800080;">1</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://leetcode.com/discuss/89535/0ms-solution-beats-97-perhaps-the-most-easy-one-to-understand" target="_blank">https://leetcode.com/discuss/89535/0ms-solution-beats-97-perhaps-the-most-easy-one-to-understand</a></p>
<p><a href="https://leetcode.com/discuss/33055/my-solution-in-c-o-1-space-and-no-magic-math-property-involved" target="_blank"><span style="line-height: 1.5;">https://leetcode.com/discuss/33055/my-solution-in-c-o-1-space-and-no-magic-math-property-involved<br/></span></a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-04-22 13:40</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4447233" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4447233);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4431646.html" id="cb_post_title_url">[LeetCode] Bitwise AND of Numbers Range 数字范围位相与</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a range [m, n] where 0 &lt;= m &lt;= n &lt;= 2147483647, return the bitwise AND of all numbers in this range, inclusive.</p>
<p>For example, given the range [5, 7], you should return 4.</p>
<p>Credits:<br/>Special thanks to <a href="https://leetcode.com/discuss/user/amrsaqr">@amrsaqr</a> for adding this problem and creating all test cases.</p>
<p> </p>
<p>又是一道考察位操作Bit Operation的题，相似的题目在LeetCode中还真不少，比如<a class="entrylistItemTitle" href="http://www.cnblogs.com/grandyang/p/4284205.html" id="CategoryEntryList1_EntryStoryList_ctl00_Entries_TitleUrl_24">Repeated DNA Sequences 求重复的DNA序列</a>，<a class="entrylistItemTitle" href="http://www.cnblogs.com/grandyang/p/4130577.html" id="CategoryEntryList1_EntryStoryList_ctl00_Entries_TitleUrl_57"> Single Number 单独的数字</a>,  <a class="entrylistItemTitle" href="http://www.cnblogs.com/grandyang/p/4263927.html" id="CategoryEntryList1_EntryStoryList_ctl00_Entries_TitleUrl_35"> Single Number II 单独的数字之二</a> ，<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4315649.html" id="cb_post_title_url"> Grey Code 格雷码</a>，和<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4321355.html" id="cb_post_title_url"> Reverse Bits 翻转位</a> 等等，那么这道题其实并不难，我们先从题目中给的例子来分析，[5, 7]里共有三个数字，分别写出它们的二进制为：</p>
<p>101　　110　　111</p>
<p>相与后的结果为100，仔细观察我们可以得出，最后的数是该数字范围内所有的数的左边共同的部分，如果上面那个例子不太明显，我们再来看一个范围[26, 30]，它们的二进制如下：</p>
<p><span style="color: #ff0000;">11</span>010　　<span style="color: #ff0000;">11</span>011　　<span style="color: #ff0000;">11</span>100　　<span style="color: #ff0000;">11</span>101　　<span style="color: #ff0000;">11</span>110</p>
<p>发现了规律后，我们只要写代码找到左边公共的部分即可，我们可以从建立一个32位都是1的mask，然后每次向左移一位，比较m和n是否相同，不同再继续左移一位，直至相同，然后把m和mask相与就是最终结果，代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> rangeBitwiseAnd(<span style="color: #0000ff;">int</span> m, <span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        </span><span style="color: #0000ff;">int</span> d =<span style="color: #000000;"> INT_MAX;
        </span><span style="color: #0000ff;">while</span> ((m &amp; d) != (n &amp;<span style="color: #000000;"> d)) {
            d </span>&lt;&lt;= <span style="color: #800080;">1</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> m &amp;<span style="color: #000000;"> d;
    }
};</span></pre>
</div>
<p> </p>
<p>此题还有另一种解法，不需要用mask，直接平移m和n，每次向右移一位，直到m和n相等，记录下所有平移的次数i，然后再把m左移i位即为最终结果，代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> rangeBitwiseAnd(<span style="color: #0000ff;">int</span> m, <span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        </span><span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (m !=<span style="color: #000000;"> n) {
            m </span>&gt;&gt;= <span style="color: #800080;">1</span><span style="color: #000000;">;
            n </span>&gt;&gt;= <span style="color: #800080;">1</span><span style="color: #000000;">;
            </span>++<span style="color: #000000;">i;
        }
        </span><span style="color: #0000ff;">return</span> (m &lt;&lt;<span style="color: #000000;"> i);
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种方法有点叼，就一行搞定了，通过递归来做的，如果n大于m，那么就对m和n分别除以2，并且调用递归函数，对结果再乘以2，一定要乘回来，不然就不对了，就举一个最简单的例子，m = 10, n = 11，注意这里是二进制表示的，然后各自除以2，都变成了1，调用递归返回1，这时候要乘以2，才能变回10，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> rangeBitwiseAnd(<span style="color: #0000ff;">int</span> m, <span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        </span><span style="color: #0000ff;">return</span> (n &gt; m) ? (rangeBitwiseAnd(m / <span style="color: #800080;">2</span>, n / <span style="color: #800080;">2</span>) &lt;&lt; <span style="color: #800080;">1</span><span style="color: #000000;">) : m;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种方法也不错，也很简单，如果m小于n就进行循环，n与上n-1，那么为什么要这样与呢，举个简单的例子呗，110与上(110-1)，得到100，这不就相当于去掉最低位的1么，n就这样每次去掉最低位的1，如果小于等于m了，返回此时的n即可，参见代码如下：</p>
<p> </p>
<p>解法四：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> rangeBitwiseAnd(<span style="color: #0000ff;">int</span> m, <span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        </span><span style="color: #0000ff;">while</span> (m &lt; n) n &amp;= (n - <span style="color: #800080;">1</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> n;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/13508/one-line-c-solution">https://discuss.leetcode.com/topic/13508/one-line-c-solution</a></p>
<p><a href="https://discuss.leetcode.com/topic/12133/bit-operation-solution-java">https://discuss.leetcode.com/topic/12133/bit-operation-solution-java</a></p>
<p><a href="https://discuss.leetcode.com/topic/20176/2-line-solution-with-detailed-explanation">https://discuss.leetcode.com/topic/20176/2-line-solution-with-detailed-explanation</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-04-16 11:53</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4431646" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4431646);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4402656.html" id="cb_post_title_url">[LeetCode] Number of Islands 岛屿的数量</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a 2d grid map of <code>'1'</code>s (land) and <code>'0'</code>s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p>
<p><em>Example 1:</em></p>
<pre>11110<br/>11010<br/>11000<br/>00000</pre>
<p>Answer: 1</p>
<p><em>Example 2:</em></p>
<pre>11000<br/>11000<br/>00100<br/>00011</pre>
<p>Answer: 3</p>
<p>Credits:<br/>Special thanks to <a href="https://leetcode.com/discuss/user/mithmatt">@mithmatt</a> for adding this problem and creating all test cases.</p>
<p> </p>
<p>这道求岛屿数量的题的本质是求矩阵中连续区域的个数，很容易想到需要用深度优先搜索DFS来解，我们需要建立一个visited数组用来记录某个位置是否被访问过，对于一个为‘1’且未被访问过的位置，我们递归进入其上下左右位置上为‘1’的数，将其visited对应值赋为true，继续进入其所有相连的邻位置，这样可以将这个连通区域所有的数找出来，并将其对应的visited中的值赋true，找完次区域后，我们将结果res自增1，然后我们在继续找下一个为‘1’且未被访问过的位置，以此类推直至遍历完整个原数组即可得到最终结果，代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> numIslands(vector&lt;vector&lt;<span style="color: #0000ff;">char</span>&gt; &gt; &amp;<span style="color: #000000;">grid) {
        </span><span style="color: #0000ff;">if</span> (grid.empty() || grid[<span style="color: #800080;">0</span>].empty()) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> m = grid.size(), n = grid[<span style="color: #800080;">0</span>].size(), res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">bool</span>&gt; &gt; visited(m, vector&lt;<span style="color: #0000ff;">bool</span>&gt;(n, <span style="color: #0000ff;">false</span><span style="color: #000000;">));
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; m; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; n; ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> (grid[i][j] == <span style="color: #800000;">'</span><span style="color: #800000;">1</span><span style="color: #800000;">'</span> &amp;&amp; !<span style="color: #000000;">visited[i][j]) {
                    numIslandsDFS(grid, visited, i, j);
                    </span>++<span style="color: #000000;">res;
                }
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">void</span> numIslandsDFS(vector&lt;vector&lt;<span style="color: #0000ff;">char</span>&gt; &gt; &amp;grid, vector&lt;vector&lt;<span style="color: #0000ff;">bool</span>&gt; &gt; &amp;visited, <span style="color: #0000ff;">int</span> x, <span style="color: #0000ff;">int</span><span style="color: #000000;"> y) {
        </span><span style="color: #0000ff;">if</span> (x &lt; <span style="color: #800080;">0</span> || x &gt;= grid.size()) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (y &lt; <span style="color: #800080;">0</span> || y &gt;= grid[<span style="color: #800080;">0</span>].size()) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (grid[x][y] != <span style="color: #800000;">'</span><span style="color: #800000;">1</span><span style="color: #800000;">'</span> || visited[x][y]) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
        visited[x][y] </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        numIslandsDFS(grid, visited, x </span>- <span style="color: #800080;">1</span><span style="color: #000000;">, y);
        numIslandsDFS(grid, visited, x </span>+ <span style="color: #800080;">1</span><span style="color: #000000;">, y);
        numIslandsDFS(grid, visited, x, y </span>- <span style="color: #800080;">1</span><span style="color: #000000;">);
        numIslandsDFS(grid, visited, x, y </span>+ <span style="color: #800080;">1</span><span style="color: #000000;">);
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/5190419.html" target="_blank">Number of Islands II</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/14595/c-with-union-find" target="_blank">https://discuss.leetcode.com/topic/14595/c-with-union-find</a></p>
<p><a href="https://discuss.leetcode.com/topic/13248/very-concise-java-ac-solution" target="_blank">https://discuss.leetcode.com/topic/13248/very-concise-java-ac-solution</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-04-08 15:56</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4402656" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4402656);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4392254.html" id="cb_post_title_url">[LeetCode] Binary Tree Right Side View 二叉树的右侧视图</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a binary tree, imagine yourself standing on the <em>right</em> side of it, return the values of the nodes you can see ordered from top to bottom.</p>
<p>For example:<br/>Given the following binary tree,</p>
<pre>   1            &lt;---
 /   \
2     3         &lt;---
 \     \
  5     4       &lt;---
</pre>
<p> </p>
<p>You should return <code>[1, 3, 4]</code>.</p>
<p>Credits:<br/>Special thanks to <a href="https://leetcode.com/discuss/user/amrsaqr">@amrsaqr</a> for adding this problem and creating all test cases.</p>
<p> </p>
<p>这道题要求我们打印出二叉树每一行最右边的一个数字，实际上是求二叉树层序遍历的一种变形，我们只需要保存每一层最右边的数字即可，可以参考我之前的博客<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4051321.html" id="cb_post_title_url"> Binary Tree Level Order Traversal 二叉树层序遍历</a>，这道题只要在之前那道题上稍加修改即可得到结果，还是需要用到数据结构队列queue，遍历每层的节点时，把下一层的节点都存入到queue中，每当开始新一层节点的遍历之前，先把新一层最后一个节点值存到结果中，代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">/*</span><span style="color: #008000;">*
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; rightSideView(TreeNode *<span style="color: #000000;">root) {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">if</span> (!root) <span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
        queue</span>&lt;TreeNode*&gt;<span style="color: #000000;"> q;
        q.push(root);
        </span><span style="color: #0000ff;">while</span> (!<span style="color: #000000;">q.empty()) {
            res.push_back(q.back()</span>-&gt;<span style="color: #000000;">val);
            </span><span style="color: #0000ff;">int</span> size =<span style="color: #000000;"> q.size();
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; size; ++<span style="color: #000000;">i) {
                TreeNode </span>*node =<span style="color: #000000;"> q.front();
                q.pop();
                </span><span style="color: #0000ff;">if</span> (node-&gt;left) q.push(node-&gt;<span style="color: #000000;">left);
                </span><span style="color: #0000ff;">if</span> (node-&gt;right) q.push(node-&gt;<span style="color: #000000;">right);
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-04-04 15:06</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4392254" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4392254);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4383632.html" id="cb_post_title_url">[LeetCode] House Robber 打家劫舍</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.</p>
<p>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.</p>
<p>Credits:<br/>Special thanks to <a href="https://oj.leetcode.com/discuss/user/ifanchu">@ifanchu</a> for adding this problem and creating all test cases. Also thanks to <a href="https://oj.leetcode.com/discuss/user/ts">@ts</a> for adding additional test cases.</p>
<p> </p>
<p>这道题的本质相当于在一列数组中取出一个或多个不相邻数，使其和最大。那么我们对于这类求极值的问题首先考虑动态规划Dynamic Programming来解，我们维护一个一位数组dp，其中dp[i]表示到i位置时不相邻数能形成的最大和，那么状态转移方程怎么写呢，我们先拿一个简单的例子来分析一下，比如说nums为{3, 2, 1, 5}，那么我们来看我们的dp数组应该是什么样的，首先dp[0]=3没啥疑问，再看dp[1]是多少呢，由于3比2大，所以我们抢第一个房子的3，当前房子的2不抢，所以dp[1]=3，那么再来看dp[2]，由于不能抢相邻的，所以我们可以用再前面的一个的dp值加上当前的房间值，和当前房间的前面一个dp值比较，取较大值当做当前dp值，所以我们可以得到状态转移方程dp[i] = max(num[i] + dp[i - 2], dp[i - 1]), 由此看出我们需要初始化dp[0]和dp[1]，其中dp[0]即为num[0]，dp[1]此时应该为max(num[0], num[1])，代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> DP</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> rob(vector&lt;<span style="color: #0000ff;">int</span>&gt; &amp;<span style="color: #000000;">num) {
        </span><span style="color: #0000ff;">if</span> (num.size() &lt;= <span style="color: #800080;">1</span>) <span style="color: #0000ff;">return</span> num.empty() ? <span style="color: #800080;">0</span> : num[<span style="color: #800080;">0</span><span style="color: #000000;">];
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; dp = {num[<span style="color: #800080;">0</span>], max(num[<span style="color: #800080;">0</span>], num[<span style="color: #800080;">1</span><span style="color: #000000;">])};
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">2</span>; i &lt; num.size(); ++<span style="color: #000000;">i) {
            dp.push_back(max(num[i] </span>+ dp[i - <span style="color: #800080;">2</span>], dp[i - <span style="color: #800080;">1</span><span style="color: #000000;">]));
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> dp.back();
    }
};</span></pre>
</div>
<p> </p>
<p>还有一种解法，核心思想还是用DP，分别维护两个变量a和b，然后按奇偶分别来更新a和b，这样就可以保证组成最大和的数字不相邻，代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> rob(vector&lt;<span style="color: #0000ff;">int</span>&gt; &amp;<span style="color: #000000;">nums) {
        </span><span style="color: #0000ff;">int</span> a = <span style="color: #800080;">0</span>, b = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; nums.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (i % <span style="color: #800080;">2</span> == <span style="color: #800080;">0</span><span style="color: #000000;">) {
                a </span>= max(a +<span style="color: #000000;"> nums[i], b);
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                b </span>= max(a, b +<span style="color: #000000;"> nums[i]);
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> max(a, b);
    }
};</span></pre>
</div>
<p> </p>
<p>上述方法还可以进一步简洁如下:</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> rob(vector&lt;<span style="color: #0000ff;">int</span>&gt; &amp;<span style="color: #000000;">nums) {
        </span><span style="color: #0000ff;">int</span> a = <span style="color: #800080;">0</span>, b = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; nums.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">int</span> m = a, n =<span style="color: #000000;"> b;
            a </span>= n +<span style="color: #000000;"> nums[i];
            b </span>=<span style="color: #000000;"> max(m, n);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> max(a, b);
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4518674.html" target="_blank">House Robber II</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/5275096.html" target="_blank">House Robber III</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4028713.html" target="_blank">Maximum Product Subarray</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/5319384.html" target="_blank">Paint House</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/5231220.html" target="_blank">Paint Fence</a></p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/8183477.html" id="homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0">Coin Path</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/6959585.html" target="_blank">Non-negative Integers without Consecutive Ones</a></p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/8176933.html" id="homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0">Delete and Earn</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/11082/java-o-n-solution-space-o-1">https://discuss.leetcode.com/topic/11082/java-o-n-solution-space-o-1</a></p>
<p><a href="https://discuss.leetcode.com/topic/11110/c-1ms-o-1-space-very-simple-solution">https://discuss.leetcode.com/topic/11110/c-1ms-o-1-space-very-simple-solution</a></p>
<p><a href="https://discuss.leetcode.com/topic/12024/java-dp-solution-o-n-runtime-and-o-1-space-with-inline-comment">https://discuss.leetcode.com/topic/12024/java-dp-solution-o-n-runtime-and-o-1-space-with-inline-comment</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-04-01 13:41</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4383632" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4383632);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5371438.html" id="cb_post_title_url">[LeetCode] Rising Temperature 上升温度</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a <code>Weather</code> table, write a SQL query to find all dates' Ids with higher temperature compared to its previous (yesterday's) dates.</p>
<pre>+---------+------------+------------------+
| Id(INT) | Date(DATE) | Temperature(INT) |
+---------+------------+------------------+
|       1 | 2015-01-01 |               10 |
|       2 | 2015-01-02 |               25 |
|       3 | 2015-01-03 |               20 |
|       4 | 2015-01-04 |               30 |
+---------+------------+------------------+
</pre>
<p>For example, return the following Ids for the above Weather table:</p>
<pre>+----+
| Id |
+----+
|  2 |
|  4 |
+----+</pre>
<p> </p>
<p>这道题给了我们一个Weather表，让我们找出比前一天温度高的Id，由于Id的排列未必是按顺序的，所以我们要找前一天就得根据日期来找，我们可以使用MySQL的函数Datadiff来计算两个日期的差值，我们的限制条件是温度高且日期差1，参见代码如下： </p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">SELECT</span> w1.Id <span style="color: #0000ff;">FROM</span><span style="color: #000000;"> Weather w1, Weather w2
</span><span style="color: #0000ff;">WHERE</span> w1.Temperature <span style="color: #808080;">&gt;</span> w2.Temperature <span style="color: #808080;">AND</span> <span style="color: #ff00ff;">DATEDIFF</span>(w1.Date, w2.Date) <span style="color: #808080;">=</span> <span style="color: #800000; font-weight: bold;">1</span>;</pre>
</div>
<p> </p>
<p>下面这种解法我们使用了MySQL的TO_DAYS函数，用来将日期换算成天数，其余跟上面相同：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">SELECT</span> w1.Id <span style="color: #0000ff;">FROM</span><span style="color: #000000;"> Weather w1, Weather w2
</span><span style="color: #0000ff;">WHERE</span> w1.Temperature <span style="color: #808080;">&gt;</span> w2.Temperature <span style="color: #808080;">AND</span> TO_DAYS(w1.Date) <span style="color: #808080;">=</span> TO_DAYS(w2.Date) <span style="color: #808080;">+</span> <span style="color: #800000; font-weight: bold;">1</span>;</pre>
</div>
<p> </p>
<p>我们也可以使用Subdate函数，来实现日期减1，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">SELECT</span> w1.Id <span style="color: #0000ff;">FROM</span><span style="color: #000000;"> Weather w1, Weather w2
</span><span style="color: #0000ff;">WHERE</span> w1.Temperature <span style="color: #808080;">&gt;</span> w2.Temperature <span style="color: #808080;">AND</span> SUBDATE(w1.Date, <span style="color: #800000; font-weight: bold;">1</span>) <span style="color: #808080;">=</span> w2.Date;</pre>
</div>
<p> </p>
<p>最后来一种完全不一样的解法，使用了两个变量pre_t和pre_d分别表示上一个温度和上一个日期，然后当前温度要大于上一温度，且日期差为1，满足上述两条件的话选出来为Id，否则为NULL，然后更新pre_t和pre_d为当前的值，最后选出的Id不为空即可：</p>
<p> </p>
<p>解法四：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">SELECT</span> Id <span style="color: #0000ff;">FROM</span><span style="color: #000000;"> (
</span><span style="color: #0000ff;">SELECT</span> <span style="color: #ff00ff;">CASE</span> <span style="color: #0000ff;">WHEN</span> Temperature <span style="color: #808080;">&gt;</span> <span style="color: #008000;">@pre_t</span> <span style="color: #808080;">AND</span> <span style="color: #ff00ff;">DATEDIFF</span>(Date, <span style="color: #008000;">@pre_d</span>) <span style="color: #808080;">=</span> <span style="color: #800000; font-weight: bold;">1</span> <span style="color: #0000ff;">THEN</span> Id <span style="color: #0000ff;">ELSE</span> <span style="color: #0000ff;">NULL</span> <span style="color: #0000ff;">END</span> <span style="color: #0000ff;">AS</span><span style="color: #000000;"> Id,
</span><span style="color: #008000;">@pre_t</span> :<span style="color: #808080;">=</span> Temperature, <span style="color: #008000;">@pre_d</span> :<span style="color: #808080;">=</span><span style="color: #000000;"> Date 
</span><span style="color: #0000ff;">FROM</span> Weather, (<span style="color: #0000ff;">SELECT</span> <span style="color: #008000;">@pre_t</span> :<span style="color: #808080;">=</span> <span style="color: #0000ff;">NULL</span>, <span style="color: #008000;">@pre_d</span> :<span style="color: #808080;">=</span> <span style="color: #0000ff;">NULL</span>) <span style="color: #0000ff;">AS</span> init <span style="color: #0000ff;">ORDER</span> <span style="color: #0000ff;">BY</span> Date <span style="color: #0000ff;">ASC</span><span style="color: #000000;">
) id </span><span style="color: #0000ff;">WHERE</span> Id <span style="color: #0000ff;">IS</span> <span style="color: #808080;">NOT</span> <span style="color: #0000ff;">NULL</span>;</pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://leetcode.com/discuss/33641/two-solutions" target="_blank">https://leetcode.com/discuss/33641/two-solutions</a></p>
<p><a href="https://leetcode.com/discuss/52370/my-simple-solution-using-inner-join" target="_blank">https://leetcode.com/discuss/52370/my-simple-solution-using-inner-join</a></p>
<p><a href="https://leetcode.com/discuss/86435/a-simple-straightforward-solution-and-its-very-fast" target="_blank">https://leetcode.com/discuss/86435/a-simple-straightforward-solution-and-its-very-fast</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-04-09 13:08</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5371438" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5371438);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5371227.html" id="cb_post_title_url">[LeetCode] Delete Duplicate Emails 删除重复邮箱</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Write a SQL query to delete all duplicate email entries in a table named <code>Person</code>, keeping only unique emails based on its <em>smallest</em> Id.</p>
<pre>+----+------------------+
| Id | Email            |
+----+------------------+
| 1  | john@example.com |
| 2  | bob@example.com  |
| 3  | john@example.com |
+----+------------------+
Id is the primary key column for this table.
</pre>
<p>For example, after running your query, the above <code>Person</code> table should have the following rows:</p>
<pre>+----+------------------+
| Id | Email            |
+----+------------------+
| 1  | john@example.com |
| 2  | bob@example.com  |
+----+------------------+</pre>
<p> </p>
<p>这道题让我们删除重复邮箱，那我们可以首先找出所有不重复的邮箱，然后取个反就是重复的邮箱，都删掉即可，那么我们如何找出所有不重复的邮箱呢，我们可以按照邮箱群组起来，然后用Min关键字挑出较小的，然后取补集删除即可：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">DELETE</span> <span style="color: #0000ff;">FROM</span> Person <span style="color: #0000ff;">WHERE</span> Id <span style="color: #808080;">NOT</span> <span style="color: #808080;">IN</span><span style="color: #000000;">
(</span><span style="color: #0000ff;">SELECT</span> Id <span style="color: #0000ff;">FROM</span> (<span style="color: #0000ff;">SELECT</span> <span style="color: #ff00ff;">MIN</span>(Id) Id <span style="color: #0000ff;">FROM</span> Person <span style="color: #0000ff;">GROUP</span> <span style="color: #0000ff;">BY</span> Email) p);</pre>
</div>
<p> </p>
<p>我们也可以使用内交让两个表以邮箱关联起来，然后把相同邮箱且Id大的删除掉，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">DELETE</span> p2 <span style="color: #0000ff;">FROM</span> Person p1 <span style="color: #808080;">JOIN</span><span style="color: #000000;"> Person p2 
</span><span style="color: #0000ff;">ON</span> p2.Email <span style="color: #808080;">=</span> p1.Email <span style="color: #0000ff;">WHERE</span> p2.Id <span style="color: #808080;">&gt;</span> p1.Id;</pre>
</div>
<p> </p>
<p>我们也可以不用Join，而直接用where将两表关联起来也行：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">DELETE</span> p2 <span style="color: #0000ff;">FROM</span><span style="color: #000000;"> Person p1, Person p2
</span><span style="color: #0000ff;">WHERE</span> p1.Email <span style="color: #808080;">=</span> p2.Email <span style="color: #808080;">AND</span> p2.Id <span style="color: #808080;">&gt;</span> p1.Id;</pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/5361967.html" id="homepage1_HomePageDays_DaysList_ctl01_DayList_TitleUrl_3">Duplicate Emails</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://leetcode.com/discuss/61176/simple-solution-using-a-self-join" target="_blank"><span style="line-height: 1.5;">https://leetcode.com/discuss/61176/simple-solution-using-a-self-join</span></a></p>
<p><a href="https://leetcode.com/discuss/48403/my-answer-delete-duplicate-emails-with-double-nested-query" target="_blank">https://leetcode.com/discuss/48403/my-answer-delete-duplicate-emails-with-double-nested-query</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-04-09 11:35</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5371227" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5371227);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5376902.html" id="cb_post_title_url">[LeetCode] Tenth Line 第十行</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>How would you print just the 10th line of a file?</p>
<p>For example, assume that <code>file.txt</code> has the following content:</p>
<pre>Line 1
Line 2
Line 3
Line 4
Line 5
Line 6
Line 7
Line 8
Line 9
Line 10
</pre>
<p>Your script should output the tenth line, which is:</p>
<pre>Line 10
</pre>
<div class="spoilers" style="display: block;"><strong>Hint:</strong><br/>
1. If the file contains less than 10 lines, what should you output?<br/>
2. There's at least three different solutions. Try to explore all possibilities.
</div>
<p> </p>
<p>这道题让我们用Bash脚本来打印一个txt文件的第十行，可以用很多种方法来实现，我们先来看一种是用awk来实现的方法，awk是强大的文本分析工具，具有流控制、数学运算、进程控制、内置的变量和函数、循环和判断的功能，具体可以参见<a href="http://tanxin.blog.51cto.com/6114226/1222140" target="_blank">这个帖子</a>。其中NR表示行数，$0表示当前记录，所以我们可以用if来判断行数为第十行时，将内容打印出来即可：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">awk</span> <span style="color: #800000;">'</span><span style="color: #800000;">{if(NR == 10) print $0}</span><span style="color: #800000;">'</span> <span style="color: #0000ff;">file</span>.txt</pre>
</div>
<p> </p>
<p>我们也可以用更简洁的写法来打印出第十行如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">awk</span> <span style="color: #800000;">'</span><span style="color: #800000;">NR == 10</span><span style="color: #800000;">'</span> <span style="color: #0000ff;">file</span>.txt</pre>
</div>
<p> </p>
<p>我们也可以使用流编辑工具sed来做，关于sed的讲解可以参见<a href="http://tanxin.blog.51cto.com/6114226/1208944" target="_blank">这个帖子</a>。-n默认表示打印所有行，p限定了具体打印的行数：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">sed</span> -n 10p <span style="color: #0000ff;">file</span>.txt</pre>
</div>
<p> </p>
<p>我们也可以使用tail和head关键字来打印，关于tail和head的用法详解请参见<a href="http://www.it610.com/article/1196291.htm" target="_blank">这个帖子</a>。其中head表示从头开始打印，tail表示从结尾开始打印，-你表示根据文件行数进行打印，一些区别与联系请见下列例子：</p>
<p>tail -n 3 file.txt: 打印file文件的最后三行内容　　　　　　</p>
<p>tail -n +3 file.txt： 从file文件第三行开始打印所有内容</p>
<p>head -n 3 file.txt： 打印file文件的前三行</p>
<p>head -n -3 file.txt： 打印file文件除了最后三行的所有内容</p>
<p>至于竖杠|为管道命令，讲解参见<a href="http://www.programgo.com/article/6462705832/;jsessionid=01A7179C41368EACBD963D21018878B2" target="_blank">这个帖子</a>，用法: command 1 | command 2 他的功能是把第一个命令command1执行的结果作为command 2的输入传给command 2。了解了这些知识，那么下面一行命令就很好理解了，首先输入file文件从第十行开始的所有内容，然后将输出内容的第一行打印出来即为第十行：</p>
<p> </p>
<p>解法四：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">tail</span> -n +<span style="color: #800080;">10</span> <span style="color: #0000ff;">file</span>.txt | <span style="color: #0000ff;">head</span> -n <span style="color: #800080;">1</span></pre>
</div>
<p> </p>
<p>下面这种方法跟上面刚好相反，先输出file文件的前十行，然后从输出的第十行开始打印，那么也能正好打印第十行的内容：</p>
<p> </p>
<p>解法五：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">head</span> -n <span style="color: #800080;">10</span> <span style="color: #0000ff;">file</span>.txt | <span style="color: #0000ff;">tail</span> -n +<span style="color: #800080;">10</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://leetcode.com/discuss/29526/super-simple-solution" target="_blank">https://leetcode.com/discuss/29526/super-simple-solution</a></p>
<p><a href="https://leetcode.com/discuss/29591/simple-solution-using-awk" target="_blank">https://leetcode.com/discuss/29591/simple-solution-using-awk</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-04-11 06:12</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5376902" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5376902);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5382166.html" id="cb_post_title_url">[LeetCode] Transpose File 转置文件</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a text file <code>file.txt</code>, transpose its content.</p>
<p>You may assume that each row has the same number of columns and each field is separated by the <code>' '</code> character.</p>
<p>For example, if <code>file.txt</code> has the following content:</p>
<pre>name age
alice 21
ryan 30
</pre>
<p> </p>
<p>Output the following:</p>
<pre>name alice ryan
age 21 30</pre>
<p> </p>
<p>这道题让我们转置一个文件，其实感觉就是把文本内容当做了一个矩阵，每个单词空格隔开看做是矩阵中的一个元素，然后将转置后的内容打印出来。那么我们先来看使用awk关键字的做法，关于awk的介绍可以参见<a href="http://tanxin.blog.51cto.com/6114226/1222140" target="_blank">这个帖子</a>。其中NF表示当前记录中的字段个数，就是有多少列，NR表示已经读出的记录数，就是行号，从1开始。那么在这里NF是2，因为文本只有两列，这里面这个for循环还跟我们通常所熟悉for循环不太一样，通常我们以为i只能是1和2，然后循环就结束了，而这里的i实际上遍历的数字为1,2,1,2,1,2，我们可能看到实际上循环了3遍1和2，而行数正好是3，可能人家就是这个机制吧。知道了上面这些，那么下面的代码就不难理解了，遍历过程如下：</p>
<p>i = 1, s = [name]</p>
<p>i = 2, s = [name; age]</p>
<p>i = 1, s = [name alice; age]</p>
<p>i = 2, s = [name alice; age 21]</p>
<p>i = 1, s = [name alice ryan; age 21]</p>
<p>i = 2, s = [name alice ryan; age 21 30]</p>
<p>然后我们再将s中的各行打印出来即可，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">awk</span> <span style="color: #800000;">'</span><span style="color: #800000;">{</span>
    <span style="color: #0000ff;">for</span> (i = <span style="color: #800080;">1</span>; i &lt;= NF; ++<span style="color: #000000;">i) {
        </span><span style="color: #0000ff;">if</span> (NR == <span style="color: #800080;">1</span>) s[i] =<span style="color: #000000;"> $i;
        </span><span style="color: #0000ff;">else</span> s[i] = s[i] <span style="color: #800000;">"</span> <span style="color: #800000;">"</span><span style="color: #000000;"> $i;
    }
} END {
    </span><span style="color: #0000ff;">for</span> (i = <span style="color: #800080;">1</span>; s[i] != <span style="color: #800000;">""</span>; ++<span style="color: #000000;">i) {
        print s[i];
    }
}</span><span style="color: #800000;">'</span><span style="color: #800000;"> file.txt</span></pre>
</div>
<p> </p>
<p>下面这种方法和上面的思路完全一样，但是代码风格不一样，上面是C语言风格，而这个完全就是Bash脚本的风格了，我们用read关键字，我们可以查看read的用法read: usage: read [-ers] [-u fd] [-t timeout] [-p prompt] [-a array] [-n nchars] [-d delim] [name ...]。那么我们知道-a表示数组，将读出的每行内容存入数组line中，那么下一行for中的一堆特殊字符肯定让你头晕眼花，关于shell中的特殊变量可以参见<a href="http://c.biancheng.net/cpp/view/2739.html" target="_blank">这个帖子</a>，其实我也不能算特别理解下面的代码，大概觉得跟上面的思路一样，求大神来具体给讲解下哈：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">while</span> read -a line; <span style="color: #0000ff;">do</span>
    <span style="color: #0000ff;">for</span> ((i = <span style="color: #800080;">0</span>; i &lt; <span style="color: #800000;">"</span><span style="color: #800000;">${#line[@]}</span><span style="color: #800000;">"</span>; ++i)); <span style="color: #0000ff;">do</span><span style="color: #000000;">
        a[$i]</span>=<span style="color: #800000;">"</span><span style="color: #800000;">${a[$i]} ${line[$i]}</span><span style="color: #800000;">"</span>
    <span style="color: #0000ff;">done</span>
<span style="color: #0000ff;">done</span> &lt; <span style="color: #0000ff;">file</span><span style="color: #000000;">.txt
</span><span style="color: #0000ff;">for</span> ((i = <span style="color: #800080;">0</span>; i &lt; ${#a[@]}; ++i)); <span style="color: #0000ff;">do</span>
    <span style="color: #0000ff;">echo</span><span style="color: #000000;"> ${a[i]}
</span><span style="color: #0000ff;">done</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://leetcode.com/discuss/38238/ac-solution-8-lines-only-in-pure-bash" target="_blank">https://leetcode.com/discuss/38238/ac-solution-8-lines-only-in-pure-bash</a></p>
<p><a href="https://leetcode.com/discuss/29462/ac-solution-using-awk-and-statement-just-like-c" target="_blank">https://leetcode.com/discuss/29462/ac-solution-using-awk-and-statement-just-like-c</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-04-12 12:26</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5382166" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5382166);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5389375.html" id="cb_post_title_url">[LeetCode] Valid Phone Numbers 验证电话号码</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a text file <code>file.txt</code> that contains list of phone numbers (one per line), write a one liner bash script to print all valid phone numbers.</p>
<p>You may assume that a valid phone number must appear in one of the following two formats: (xxx) xxx-xxxx or xxx-xxx-xxxx. (x means a digit)</p>
<p>You may also assume each line in the text file must not contain leading or trailing white spaces.</p>
<p>For example, assume that <code>file.txt</code> has the following content:</p>
<pre>987-123-4567
123 456 7890
(123) 456-7890
</pre>
<p>Your script should output the following valid phone numbers:</p>
<pre>987-123-4567
(123) 456-7890
</pre>
<p> </p>
<p>这道题让我们验证数字串是否为正确的电话号码的格式，而且规定了正确的格式只有两种(xxx) xxx-xxxx or xxx-xxx-xxxx，那么我们可以看出来区别就是在前几个字符，而后八个字符都相同。这题有多种解法，我们首先来看使用awk命令的解法，关于awk的介绍可以参见<a href="http://tanxin.blog.51cto.com/6114226/1222140" target="_blank">这个帖子</a>。这道题是难点是如何写匹配的正则表达式，关于Bash脚本的正则表达式讲解请参见<a href="http://blog.sina.com.cn/s/blog_43c625f10101f5cp.html" target="_blank">这个贴子</a>。那么首先来看‘/.../'表示中间的是要匹配的正则表达式，然后脱字符^<span style="text-align: left; line-height: 21px; font-family: Tahoma, 'Microsoft Yahei', simsun; color: #444444;">匹配一行的开头</span>，美元符$<span style="text-align: left; line-height: 21px; font-family: Tahoma, 'Microsoft Yahei', simsun; color: #444444;">在正则表达式中匹配行尾，然后再看中间的部分，[0-9]{3}表示匹配三个数字，圆括号<span style="text-align: left; line-height: 21px; font-family: Tahoma, 'Microsoft Yahei', simsun; color: #444444;">括起一组正则表达式. 它和"|"操作符或在用expr进行子字<span style="text-align: left; line-height: 21px; font-family: Tahoma, 'Microsoft Yahei', simsun; color: #444444;">符串提取(substring extraction)一起使用很有用。那么([0-9]{3}-|\([0-9]{3}\) )就可以理解了，它匹配了xxx-和(xxx) 这两种形式的字符串，然后后面的就好理解了，匹配xxx-xxxx这样的字符串，参见代码如下：</span></span></span></p>
<p> </p>
<p>解法一:</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">awk</span> <span style="color: #800000;">'</span><span style="color: #800000;">/^([0-9]{3}-|\([0-9]{3}\) )[0-9]{3}-[0-9]{4}$/</span><span style="color: #800000;">'</span> <span style="color: #0000ff;">file</span>.txt</pre>
</div>
<p> </p>
<p>下面来看使用sed命令的解法，关于sed的讲解可以参见<a href="http://tanxin.blog.51cto.com/6114226/1208944" target="_blank">这个帖子</a>。那么我们先来看后面的两个参数，-n表示关闭默认输出，默认将自动打印所有行，这样就不会打印出不符合要求的数字串了。-r表示支持扩展正则+ ? () {} |。后面的正则表达式和上面都相同，就是后面多了一个p，在用sed时，p和-n合用，表示打印某一行，这样才能把符合要求的行打印出来：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">sed</span> -n -r <span style="color: #800000;">'</span><span style="color: #800000;">/^([0-9]{3}-|\([0-9]{3}\) )[0-9]{3}-[0-9]{4}$/p</span><span style="color: #800000;">'</span> <span style="color: #0000ff;">file</span>.txt</pre>
</div>
<p> </p>
<p>再来看使用grep命令的做法，关于grep的讲解可以参见<a href="http://www.cnblogs.com/peida/archive/2012/12/17/2821195.html" target="_blank">这个帖子</a>。我没有查到那个-P参数的用法，有没有大神来点拨一下，后面的正则表达式思路根上面的相同，只不过用d{3}来表示[0-9]{3}，道理都一样，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span> <span style="color: #0000ff;">grep</span> -P <span style="color: #800000;">'</span><span style="color: #800000;">^(\d{3}-|\(\d{3}\) )\d{3}-\d{4}$</span><span style="color: #800000;">'</span> <span style="color: #0000ff;">file</span>.txt</pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://leetcode.com/discuss/29282/this-is-my-simple-solution" target="_blank">https://leetcode.com/discuss/29282/this-is-my-simple-solution</a></p>
<p><a href="https://leetcode.com/discuss/29476/three-different-solutions-using-grep-sed-and-awk" target="_blank">https://leetcode.com/discuss/29476/three-different-solutions-using-grep-sed-and-awk</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-04-13 23:43</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5389375" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5389375);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5386475.html" id="cb_post_title_url">[LeetCode] Word Frequency 单词频率</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Write a bash script to calculate the frequency of each word in a text file <code>words.txt</code>.</p>
<p>For simplicity sake, you may assume:</p>
<ul>
<li><code>words.txt</code> contains only lowercase characters and space <code>' '</code> characters.</li>
<li>Each word must consist of lowercase characters only.</li>
<li>Words are separated by one or more whitespace characters.</li>
</ul>
<p>For example, assume that <code>words.txt</code> has the following content:</p>
<pre>the day is sunny the the
the sunny is is
</pre>
<p>Your script should output the following, sorted by descending frequency:</p>
<pre>the 4
is 3
sunny 2
day 1
</pre>
<p> <strong>Note:</strong><br/>
Don't worry about handling ties, it is guaranteed that each word's frequency count is unique.
</p>
<div class="spoilers" style="display: block;"><strong>Hint:</strong><br/>
Could you write it in one-line using <a href="http://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO-4.html">Unix pipes</a>?
</div>
<p> </p>
<p>这道题给了我们一个文本文件，让我们统计里面单词出现的个数，提示中让我们用管道Pipes来做，在之前那道<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/5376902.html" id="homepage1_HomePageDays_DaysList_ctl02_DayList_TitleUrl_0">Tenth Line</a>中，我们使用过管道命令，管道命令的讲解请参见<a href="http://www.programgo.com/article/6462705832/;jsessionid=01A7179C41368EACBD963D21018878B2" target="_blank">这个帖子</a>。提示中让我们用管道连接各种命令，然后一行搞定，那么我们先来看第一种解法，乍一看啥都不明白，咋办？没关系，容我慢慢来讲解。首先用的关键字是grep命令，该命令一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来，详解请参见<a href="http://www.cnblogs.com/peida/archive/2012/12/17/2821195.html" target="_blank">这个帖子</a>。后面紧跟的-oE '[a-z]+'参数表示原文本内容变成一个单词一行的存储方式，于是此时文本的内容就变成了：</p>
<p>the<br/>day<br/>is<br/>sunny<br/>the<br/>the<br/>the<br/>sunny<br/>is</p>
<p>下面的sort命令就是用来排序的，参见<a href="http://blog.csdn.net/monkeyduck/article/details/10097829" target="_blank">这个帖子</a>。排完序的结果为：</p>
<p>day<br/>is<br/>is<br/>is<br/>sunny<br/>sunny<br/>the<br/>the<br/>the<br/>the</p>
<p>后面的uniq命令是表示去除重复行命令(参见<a href="http://blog.51yip.com/shell/1022.html" target="_blank">这个帖子</a>)，后面的参数-c表示在每行前加上表示相应行目出现次数的前缀编号，得到结果如下： </p>
<p>   1 day<br/>   3 is<br/>   2 sunny<br/>   4 the</p>
<p>然后我们再sort一下，后面的参数-nr表示按数值进行降序排列，得到结果：</p>
<p>   4 the<br/>   3 is<br/>   2 sunny<br/>   1 day  </p>
<p>而最后的awk命令就是将结果输出，两列颠倒位置即可：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">grep</span> -oE <span style="color: #800000;">'</span><span style="color: #800000;">[a-z]+</span><span style="color: #800000;">'</span> words.txt | <span style="color: #0000ff;">sort</span> | <span style="color: #0000ff;">uniq</span> -c | <span style="color: #0000ff;">sort</span> -nr | <span style="color: #0000ff;">awk</span> <span style="color: #800000;">'</span><span style="color: #800000;">{print $2" "$1}</span><span style="color: #800000;">'</span> </pre>
</div>
<p> </p>
<p> </p>
<p><span style="color: #333333;">下面这种方法用的关键字是tr命令，该命令主要用来进行字符替换或者大小写替换，详解请参见<a href="http://www.cnblogs.com/leaven/archive/2011/01/05/1926194.html" target="_blank"><span style="color: #333333;">这个帖子</span></a>。后面紧跟的-s参数表示如果发现连续的字符，就把它们缩减为1个，而后面的‘ ’和‘\n'就是空格和回车，意思是把所有的空格都换成回车，那么第一段命令tr -s ' ' '\n' &lt; words.txt 就好理解了，将单词之间的空格都换成回车，跟上面的第一段实现的作用相同，后面就完全一样了，参见上面的讲解：</span></p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">tr</span> -s <span style="color: #800000;">'</span> <span style="color: #800000;">'</span> <span style="color: #800000;">'</span><span style="color: #800000;">\n</span><span style="color: #800000;">'</span> &lt; words.txt | <span style="color: #0000ff;">sort</span> | <span style="color: #0000ff;">uniq</span> -c | <span style="color: #0000ff;">sort</span> -nr | <span style="color: #0000ff;">awk</span> <span style="color: #800000;">'</span><span style="color: #800000;">{print $2, $1}</span><span style="color: #800000;">'</span></pre>
</div>
<p> </p>
<p> </p>
<p>下面这种方法就没有用管道命令进行一行写法了，而是使用了强大的文本分析工具awk进行写类C的代码来实现，这种写法在之前的那道<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/5382166.html" id="homepage1_HomePageDays_DaysList_ctl01_DayList_TitleUrl_0">Transpose File</a><span class="postTitle2">已经讲解过了，这里就不多说了，最后要注意的是sort命令的参数-nr -k 2表示按第二列的降序数值排列：</span></p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">awk</span> <span style="color: #800000;">'</span><span style="color: #800000;">{</span>
    <span style="color: #0000ff;">for</span> (i = <span style="color: #800080;">1</span>; i &lt;= NF; ++i) ++<span style="color: #000000;">s[$i];
} END {
    </span><span style="color: #0000ff;">for</span> (i <span style="color: #0000ff;">in</span><span style="color: #000000;"> s) print i, s[i];
}</span><span style="color: #800000;">'</span><span style="color: #800000;"> words.txt | sort -nr -k 2</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://leetcode.com/discuss/33353/my-accepted-answer-using-tr-sort-uniq-and-awk" target="_blank">https://leetcode.com/discuss/33353/my-accepted-answer-using-tr-sort-uniq-and-awk</a></p>
<p><a href="https://leetcode.com/discuss/46976/my-ac-solution-one-pipe-command-but-cost-20ms" target="_blank">https://leetcode.com/discuss/46976/my-ac-solution-one-pipe-command-but-cost-20ms</a></p>
<p><a href="https://leetcode.com/discuss/29001/solution-using-awk-and-pipes-with-explaination" target="_blank">https://leetcode.com/discuss/29001/solution-using-awk-and-pipes-with-explaination</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-04-13 11:33</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5386475" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5386475);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4325432.html" id="cb_post_title_url">[LeetCode] Number of 1 Bits 位1的个数</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p> </p>
<p>Write a function that takes an unsigned integer and returns the number of ’1' bits it has (also known as the <a href="http://en.wikipedia.org/wiki/Hamming_weight">Hamming weight</a>).</p>
<p>For example, the 32-bit integer ’11' has binary representation <code>00000000000000000000000000001011</code>, so the function should return 3.</p>
<p> </p>
<p>很简单的一道位操作Bit Manipulation的题，最近新出的三道题都没有啥难度啊，这样会误导新人的，做了这三道得出个LeetCode没啥难度的结论，其实里面好题真的不少，难题也很多，经典题也多，反正就是赞赞赞，32个赞。</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> hammingWeight(uint32_t n) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; <span style="color: #800080;">32</span>; ++<span style="color: #000000;">i) {
            res </span>+= (n &amp; <span style="color: #800080;">1</span><span style="color: #000000;">);
            n </span>= n &gt;&gt; <span style="color: #800080;">1</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-03-10 11:11</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4325432" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4325432);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4321355.html" id="cb_post_title_url">[LeetCode] Reverse Bits  翻转位</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Reverse bits of a given 32 bits unsigned integer.</p>
<p>For example, given input 43261596 (represented in binary as 00000010100101000001111010011100), return 964176192 (represented in binary as00111001011110000010100101000000).</p>
<p>Follow up:<br/>If this function is called many times, how would you optimize it?</p>
<p>Credits:<br/>Special thanks to <a href="https://oj.leetcode.com/discuss/user/ts">@ts</a> for adding this problem and creating all test cases.</p>
<p> </p>
<p>这道题又是在考察位操作Bit Operation，LeetCode中有关位操作的题也有不少，比如 <a class="entrylistItemTitle" href="http://www.cnblogs.com/grandyang/p/4284205.html" id="CategoryEntryList1_EntryStoryList_ctl00_Entries_TitleUrl_24">Repeated DNA Sequences</a>，<a class="entrylistItemTitle" href="http://www.cnblogs.com/grandyang/p/4130577.html" id="CategoryEntryList1_EntryStoryList_ctl00_Entries_TitleUrl_57">Single Number</a>,  <a class="entrylistItemTitle" href="http://www.cnblogs.com/grandyang/p/4263927.html" id="CategoryEntryList1_EntryStoryList_ctl00_Entries_TitleUrl_35"> Single Number II</a> ，和<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4315649.html" id="cb_post_title_url"> Grey Code</a> 等等。跟上面那些题比起来，这道题简直不能再简单了。那么对于这道题，我们只需要把要翻转的数从右向左一位位的取出来，如果取出来的是1，我们将结果res左移一位并且加上1；如果取出来的是0，我们将结果res左移一位，然后将n右移一位即可，代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    uint32_t reverseBits(uint32_t n) {
        uint32_t res </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; <span style="color: #800080;">32</span>; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (n &amp; <span style="color: #800080;">1</span> == <span style="color: #800080;">1</span><span style="color: #000000;">) {
                res </span>= (res &lt;&lt; <span style="color: #800080;">1</span>) + <span style="color: #800080;">1</span><span style="color: #000000;">;
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                res </span>= res &lt;&lt; <span style="color: #800080;">1</span><span style="color: #000000;">;
            }
            n </span>= n &gt;&gt; <span style="color: #800080;">1</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>我们可以简化上面的代码，去掉if...else...结构，可以结果res左移一位，然后再判断n的最低位是否为1，是的话那么结果res加上1，然后将n右移一位即可，代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    uint32_t reverseBits(uint32_t n) {
        uint32_t res </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; <span style="color: #800080;">32</span>; ++<span style="color: #000000;">i) {
            res </span>&lt;&lt;= <span style="color: #800080;">1</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> ((n &amp; <span style="color: #800080;">1</span>) == <span style="color: #800080;">1</span>) ++<span style="color: #000000;">res;
            n </span>&gt;&gt;= <span style="color: #800080;">1</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>我们继续简化上面的解法，将if判断句直接揉进去，通过‘或’上一个n的最低位即可，用n‘与’1提取最低位，然后将n右移一位即可，代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    uint32_t reverseBits(uint32_t n) {
        uint32_t res </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; <span style="color: #800080;">32</span>; ++<span style="color: #000000;">i) {
            res </span>= (res &lt;&lt; <span style="color: #800080;">1</span>) | (n &amp; <span style="color: #800080;">1</span><span style="color: #000000;">);
            n </span>&gt;&gt;= <span style="color: #800080;">1</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>博主还能进一步简化，这里我们不更新n的值，而是直接将n右移i位，然后通过‘与’1来提取出该位，加到左移一位后的结果res中即可，参加代码如下：</p>
<p> </p>
<p>解法四：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    uint32_t reverseBits(uint32_t n) {
        uint32_t res </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; <span style="color: #800080;">32</span>; ++<span style="color: #000000;">i) {
            res </span>= (res &lt;&lt; <span style="color: #800080;">1</span>) + (n &gt;&gt; i &amp; <span style="color: #800080;">1</span><span style="color: #000000;">);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>我们也可以换一种角度来做，首先将n右移i位，然后通过‘与’1来提取出该位，然后将其左移 (32 - i) 位，然后‘或’上结果res，就是其翻转后应该在的位置，参见代码如下： </p>
<p> </p>
<p>解法五：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    uint32_t reverseBits(uint32_t n) {
        uint32_t res </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; <span style="color: #800080;">32</span>; ++<span style="color: #000000;">i) {
            res </span>|= ((n &gt;&gt; i) &amp; <span style="color: #800080;">1</span>) &lt;&lt; (<span style="color: #800080;">31</span> -<span style="color: #000000;"> i);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4325432.html" target="_blank">Number of 1 Bits</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-03-08 10:15</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4321355" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4321355);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4298711.html" id="cb_post_title_url">[LeetCode] Rotate Array 旋转数组</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Rotate an array of <em>n</em> elements to the right by <em>k</em> steps.</p>
<p>For example, with <em>n</em> = 7 and <em>k</em> = 3, the array <code>[1,2,3,4,5,6,7]</code> is rotated to <code>[5,6,7,1,2,3,4]</code>.</p>
<p>Note:<br/>Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.</p>
<div class="spoilers">Hint:<br/>Could you do it in-place with O(1) extra space?</div>
<p>Credits:<br/>Special thanks to <a href="https://oj.leetcode.com/discuss/user/Freezen">@Freezen</a> for adding this problem and creating all test cases.</p>
<p> </p>
<p>新题抢先刷，这道题标为Easy，应该不是很难，我们先来看一种O(n)的空间复杂度的方法，我们复制一个和nums一样的数组，然后利用映射关系i -&gt; (i+k)%n来交换数字。代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">void</span> rotate(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; nums, <span style="color: #0000ff;">int</span><span style="color: #000000;"> k) {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; t =<span style="color: #000000;"> nums;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; nums.size(); ++<span style="color: #000000;">i) {
            nums[(i </span>+ k) % nums.size()] =<span style="color: #000000;"> t[i];
        }
    }
};</span></pre>
</div>
<p> </p>
<p>由于提示中要求我们空间复杂度为O(1)，所以我们不能用辅助数组，上面的思想还是可以使用的，但是写法就复杂的多，而且需要用到很多的辅助变量，我们用题目中的例子来展示下面这种算法的nums的变化过程：</p>
<p>1 2 3 4 5 6 7 <br/>1 2 3 <span style="color: #ff0000;">1</span> 5 6 7<br/>1 2 3 1 5 6 <span style="color: #ff0000;">4</span><br/>1 2 <span style="color: #ff0000;">7</span> 1 5 6 4<br/>1 2 7 1 5 <span style="color: #ff0000;">3</span> 4<br/>1 <span style="color: #ff0000;">6</span> 7 1 5 3 4<br/>1 6 7 1 <span style="color: #ff0000;">2</span> 3 4<br/><span style="color: #ff0000;">5</span> 6 7 1 2 3 4</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">void</span> rotate(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; nums, <span style="color: #0000ff;">int</span><span style="color: #000000;"> k) {
        </span><span style="color: #0000ff;">if</span> (nums.empty() || (k %= nums.size()) == <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> n = nums.size(), start = <span style="color: #800080;">0</span>, i = <span style="color: #800080;">0</span>, cur = nums[i], cnt = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (cnt++ &lt;<span style="color: #000000;"> n) {
            i </span>= (i + k) %<span style="color: #000000;"> n;
            </span><span style="color: #0000ff;">int</span> t =<span style="color: #000000;"> nums[i];
            nums[i] </span>=<span style="color: #000000;"> cur;
            </span><span style="color: #0000ff;">if</span> (i ==<span style="color: #000000;"> start) {
                </span>++start; ++<span style="color: #000000;">i;
                cur </span>=<span style="color: #000000;"> nums[i];
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                cur </span>=<span style="color: #000000;"> t;
            }
        }
    }
};</span></pre>
</div>
<p> </p>
<p>根据热心网友<a href="http://www.cnblogs.com/waruzhi/" id="a_comment_author_3489589" target="_blank">waruzhi</a>的留言，这道题其实还有种类似翻转字符的方法，思路是先把前n-k个数字翻转一下，再把后k个数字翻转一下，最后再把整个数组翻转一下：</p>
<p>1 2 3 4 5 6 7 <br/><span style="color: #ff0000;">4 3 2 1</span> 5 6 7 <br/>4 3 2 1 <span style="color: #ff0000;">7 6 5</span><br/><span style="color: #ff0000;">5 6 7 1 2 3 4</span></p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">void</span> rotate(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; nums, <span style="color: #0000ff;">int</span><span style="color: #000000;"> k) {
        </span><span style="color: #0000ff;">if</span> (nums.empty() || (k %= nums.size()) == <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> n =<span style="color: #000000;"> nums.size();
        reverse(nums.begin(), nums.begin() </span>+ n -<span style="color: #000000;"> k);
        reverse(nums.begin() </span>+ n -<span style="color: #000000;"> k, nums.end());
        reverse(nums.begin(), nums.end());
    }
};</span></pre>
</div>
<p> </p>
<p>由于旋转数组的操作也可以看做从数组的末尾取k个数组放入数组的开头，所以我们用STL的push_back和erase可以很容易的实现这些操作。</p>
<p> </p>
<p>解法四：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">void</span> rotate(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; nums, <span style="color: #0000ff;">int</span><span style="color: #000000;"> k) {
        </span><span style="color: #0000ff;">if</span> (nums.empty() || (k %= nums.size()) == <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> n =<span style="color: #000000;"> nums.size();
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n - k; ++<span style="color: #000000;">i) {
            nums.push_back(nums[</span><span style="color: #800080;">0</span><span style="color: #000000;">]);
            nums.erase(nums.begin());
        }
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种方法其实还蛮独特的，通过不停的交换某两个数字的位置来实现旋转，根据<a href="https://discuss.leetcode.com/topic/9406/3-lines-of-c-in-one-pass-using-swap" target="_blank">网上这个帖子</a>的思路改写而来，数组改变过程如下：</p>
<p>1 2 3 4 5 6 7 <br/><span style="color: #ff0000;">5</span> 2 3 4 <span style="color: #ff0000;">1</span> 6 7 <br/>5 <span style="color: #ff0000;">6</span> 3 4 1 <span style="color: #ff0000;">2</span> 7<br/>5 6 <span style="color: #ff0000;">7</span> 4 1 2 <span style="color: #ff0000;">3</span><br/>5 6 7 <span style="color: #ff0000;">1 4</span> 2 3<br/>5 6 7 1 <span style="color: #ff0000;">2 4</span> 3<br/>5 6 7 1 2 <span style="color: #ff0000;">3 4</span></p>
<p> </p>
<p>解法五：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">void</span> rotate(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; nums, <span style="color: #0000ff;">int</span><span style="color: #000000;"> k) {
        </span><span style="color: #0000ff;">if</span> (nums.empty()) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> n = nums.size(), start = <span style="color: #800080;">0</span><span style="color: #000000;">;   
        </span><span style="color: #0000ff;">while</span> (n &amp;&amp; (k %=<span style="color: #000000;"> n)) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; k; ++<span style="color: #000000;">i) {
                swap(nums[i </span>+ start], nums[n - k + i +<span style="color: #000000;"> start]);
            }
            n </span>-=<span style="color: #000000;"> k;
            start </span>+=<span style="color: #000000;"> k;
        }
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/9801/summary-of-c-solutions/2" target="_blank">https://discuss.leetcode.com/topic/9801/summary-of-c-solutions/2</a></p>
<p><a href="https://discuss.leetcode.com/topic/24283/a-7-line-time-o-n-in-place-solution-no-reversing/2" target="_blank">https://discuss.leetcode.com/topic/24283/a-7-line-time-o-n-in-place-solution-no-reversing/2</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-02-24 15:13</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4298711" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4298711);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4295761.html" id="cb_post_title_url">[LeetCode] Best Time to Buy and Sell Stock IV 买卖股票的最佳时间之四</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Say you have an array for which the <em>i</em>th element is the price of a given stock on day <em>i</em>.</p>
<p>Design an algorithm to find the maximum profit. You may complete at most k transactions.</p>
<p>Note:<br/>You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p>
<p>Credits:<br/>Special thanks to <a href="https://oj.leetcode.com/discuss/user/Freezen">@Freezen</a> for adding this problem and creating all test cases.</p>
<p> </p>
<p>这道题实际上是之前那道<a class="entrylistItemTitle" href="http://www.cnblogs.com/grandyang/p/4281975.html" id="CategoryEntryList1_EntryStoryList_ctl00_Entries_TitleUrl_8"> Best Time to Buy and Sell Stock III 买股票的最佳时间之三</a>的一般情况的推广，还是需要用动态规划Dynamic programming来解决，具体思路如下：</p>
<p>这里我们需要两个递推公式来分别更新两个变量local和global，参见网友<a href="http://blog.csdn.net/linhuanmars/article/details/23236995" target="_blank">Code Ganker的博客</a>，我们其实可以求至少k次交易的最大利润。我们定义local[i][j]为在到达第i天时最多可进行j次交易并且最后一次交易在最后一天卖出的最大利润，此为局部最优。然后我们定义global[i][j]为在到达第i天时最多可进行j次交易的最大利润，此为全局最优。它们的递推式为：</p>
<p>local[i][j] = max(global[i - 1][j - 1] + max(diff, 0), local[i - 1][j] + diff)</p>
<p>global[i][j] = max(local[i][j], global[i - 1][j])，</p>
<p>其中局部最优值是比较前一天并少交易一次的全局最优加上大于0的差值，和前一天的局部最优加上差值后相比，两者之中取较大值，而全局最优比较局部最优和前一天的全局最优。</p>
<p>但这道题还有个坑，就是如果k的值远大于prices的天数，比如k是好几百万，而prices的天数就为若干天的话，上面的DP解法就非常的没有效率，应该直接用<a class="entrylistItemTitle" href="http://www.cnblogs.com/grandyang/p/4280803.html" id="CategoryEntryList1_EntryStoryList_ctl00_Entries_TitleUrl_9">Best Time to Buy and Sell Stock II 买股票的最佳时间之二</a>的方法来求解，所以实际上这道题是之前的二和三的综合体，代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> maxProfit(<span style="color: #0000ff;">int</span> k, vector&lt;<span style="color: #0000ff;">int</span>&gt; &amp;<span style="color: #000000;">prices) {
        </span><span style="color: #0000ff;">if</span> (prices.empty()) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (k &gt;= prices.size()) <span style="color: #0000ff;">return</span><span style="color: #000000;"> solveMaxProfit(prices);
        </span><span style="color: #0000ff;">int</span> g[k + <span style="color: #800080;">1</span>] = {<span style="color: #800080;">0</span><span style="color: #000000;">};
        </span><span style="color: #0000ff;">int</span> l[k + <span style="color: #800080;">1</span>] = {<span style="color: #800080;">0</span><span style="color: #000000;">};
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; prices.size() - <span style="color: #800080;">1</span>; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">int</span> diff = prices[i + <span style="color: #800080;">1</span>] -<span style="color: #000000;"> prices[i];
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = k; j &gt;= <span style="color: #800080;">1</span>; --<span style="color: #000000;">j) {
                l[j] </span>= max(g[j - <span style="color: #800080;">1</span>] + max(diff, <span style="color: #800080;">0</span>), l[j] +<span style="color: #000000;"> diff);
                g[j] </span>=<span style="color: #000000;"> max(g[j], l[j]);
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> g[k];
    }
    </span><span style="color: #0000ff;">int</span> solveMaxProfit(vector&lt;<span style="color: #0000ff;">int</span>&gt; &amp;<span style="color: #000000;">prices) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt; prices.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (prices[i] - prices[i - <span style="color: #800080;">1</span>] &gt; <span style="color: #800080;">0</span><span style="color: #000000;">) {
                res </span>+= prices[i] - prices[i - <span style="color: #800080;">1</span><span style="color: #000000;">];
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4997417.html">Best Time to Buy and Sell Stock with Cooldown</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4281975.html" style="line-height: 1.5;" target="_blank">Best Time to Buy and Sell Stock III</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4280803.html" target="_blank">Best Time to Buy and Sell Stock II</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4280131.html" target="_blank">Best Time to Buy and Sell Stock</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-02-18 14:36</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4295761" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4295761);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4284205.html" id="cb_post_title_url">[LeetCode] Repeated DNA Sequences 求重复的DNA序列</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: "ACGAATTCCG". When studying DNA, it is sometimes useful to identify repeated sequences within the DNA.</p>
<p>Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule.</p>
<p>For example,</p>
<pre>Given s = "AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT",

Return:
["AAAAACCCCC", "CCCCCAAAAA"].</pre>
<p>看到这道题想到这应该属于CS的一个重要分支生物信息Bioinformatics研究的内容，研究DNA序列特征的重要意义自然不用多说，但是对于我们广大码农来说，还是专注于算法吧，此题还是用位操作Bit Manipulation来求解，计算机由于其二进制存储的特点可以很巧妙的解决一些问题，像之前的<a class="entrylistItemTitle" href="http://www.cnblogs.com/grandyang/p/4130577.html" id="CategoryEntryList1_EntryStoryList_ctl00_Entries_TitleUrl_32">Single Number 单独的数字</a>和<a class="entrylistItemTitle" href="http://www.cnblogs.com/grandyang/p/4263927.html" id="CategoryEntryList1_EntryStoryList_ctl00_Entries_TitleUrl_10">Single Number II 单独的数字之二</a>都是很巧妙利用位操作来求解。此题由于构成输入字符串的字符只有四种，分别是A, C, G, T，下面我们来看下它们的ASCII码用二进制来表示：</p>
<p>A: 0100 0<strong>001</strong>　　C: 0100 0<strong>011</strong>　　G: 0100 0<strong>111</strong>　　T: 0101 0<strong>100</strong></p>
<p>由于我们的目的是利用位来区分字符，当然是越少位越好，通过观察发现，每个字符的后三位都不相同，故而我们可以用末尾三位来区分这四个字符。而题目要求是10个字符长度的串，每个字符用三位来区分，10个字符需要30位，在32位机上也OK。为了提取出后30位，我们还需要用个mask，取值为0x7ffffff，用此mask可取出后27位，再向左平移三位即可。算法的思想是，当取出第十个字符时，将其存在哈希表里，和该字符串出现频率映射，之后每向左移三位替换一个字符，查找新字符串在哈希表里出现次数，如果之前刚好出现过一次，则将当前字符串存入返回值的数组并将其出现次数加一，如果从未出现过，则将其映射到1。为了能更清楚的阐述整个过程，我们用题目中给的例子来分析整个过程：</p>
<p>首先我们取出前九个字符AAAAACCCC，根据上面的分析，我们用三位来表示一个字符，所以这九个字符可以用二进制表示为001001001001011011011，然后我们继续遍历字符串，下一个进来的是C，则当前字符为AAAAACCCCC，二进制表示为001001001001011011011011，然后我们将其存入哈希表中，用二进制的好处是可以用一个int变量来表示任意十个字符序列，比起直接存入字符串大大的节省了内存空间，然后再读入下一个字符C，则此时字符串为AAAACCCCCA，我们还是存入其二进制的表示形式，以此类推，当某个序列之前已经出现过了，我们将其存入结果res中即可，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; findRepeatedDnaSequences(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        vector</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">if</span> (s.size() &lt;= <span style="color: #800080;">10</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">int</span> mask = <span style="color: #800080;">0x7ffffff</span><span style="color: #000000;">;
        unordered_map</span>&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> m;
        </span><span style="color: #0000ff;">int</span> cur = <span style="color: #800080;">0</span>, i = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (i &lt; <span style="color: #800080;">9</span><span style="color: #000000;">) {
            cur </span>= (cur &lt;&lt; <span style="color: #800080;">3</span>) | (s[i++] &amp; <span style="color: #800080;">7</span><span style="color: #000000;">);
        }
        </span><span style="color: #0000ff;">while</span> (i &lt;<span style="color: #000000;"> s.size()) {
            cur </span>= ((cur &amp; mask) &lt;&lt; <span style="color: #800080;">3</span>) | (s[i++] &amp; <span style="color: #800080;">7</span><span style="color: #000000;">);
            </span><span style="color: #0000ff;">if</span> (m.find(cur) !=<span style="color: #000000;"> m.end()) {
                </span><span style="color: #0000ff;">if</span> (m[cur] == <span style="color: #800080;">1</span>) res.push_back(s.substr(i - <span style="color: #800080;">10</span>, <span style="color: #800080;">10</span><span style="color: #000000;">));
                </span>++<span style="color: #000000;">m[cur]; 
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                m[cur] </span>= <span style="color: #800080;">1</span><span style="color: #000000;">;
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>上面的方法可以写的更简洁一些，这里我们可以用set来代替哈希表，只要当前的数已经在哈希表中存在了，我们就将其加入res中，这里我们res也定义成set，这样就可以利用set的不能有重复项的特点，从而得到正确的答案，最后我们将set转为vector即可，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; findRepeatedDnaSequences(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        unordered_set</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> res;
        unordered_set</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> st;
        </span><span style="color: #0000ff;">int</span> cur = <span style="color: #800080;">0</span>, i = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (i &lt; <span style="color: #800080;">9</span>) cur = cur &lt;&lt; <span style="color: #800080;">3</span> | (s[i++] &amp; <span style="color: #800080;">7</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">while</span> (i &lt;<span style="color: #000000;"> s.size()) {
            cur </span>= ((cur &amp; <span style="color: #800080;">0x7ffffff</span>) &lt;&lt; <span style="color: #800080;">3</span>) | (s[i++] &amp; <span style="color: #800080;">7</span><span style="color: #000000;">);
            </span><span style="color: #0000ff;">if</span> (st.count(cur)) res.insert(s.substr(i - <span style="color: #800080;">10</span>, <span style="color: #800080;">10</span><span style="color: #000000;">));
            </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> st.insert(cur);
        }
        </span><span style="color: #0000ff;">return</span> vector&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;">(res.begin(), res.end());
    }
};</span></pre>
</div>
<p> </p>
<p>上面的方法都是用三位来表示一个字符，这里我们可以用两位来表示一个字符，00表示A，01表示C，10表示G，11表示T，那么我们总共需要20位就可以表示十个字符流，其余的思路跟上面的方法完全相同，注意这里的mask只需要表示18位，所以变成了0x3ffff，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; findRepeatedDnaSequences(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        unordered_set</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> res;
        unordered_set</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> st;
        unordered_map</span>&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt; m{{<span style="color: #800000;">'</span><span style="color: #800000;">A</span><span style="color: #800000;">'</span>, <span style="color: #800080;">0</span>}, {<span style="color: #800000;">'</span><span style="color: #800000;">C</span><span style="color: #800000;">'</span>, <span style="color: #800080;">1</span>}, {<span style="color: #800000;">'</span><span style="color: #800000;">G</span><span style="color: #800000;">'</span>, <span style="color: #800080;">2</span>}, {<span style="color: #800000;">'</span><span style="color: #800000;">T</span><span style="color: #800000;">'</span>, <span style="color: #800080;">3</span><span style="color: #000000;">}};
        </span><span style="color: #0000ff;">int</span> cur = <span style="color: #800080;">0</span>, i = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (i &lt; <span style="color: #800080;">9</span>) cur = cur &lt;&lt; <span style="color: #800080;">2</span> | m[s[i++<span style="color: #000000;">]];
        </span><span style="color: #0000ff;">while</span> (i &lt;<span style="color: #000000;"> s.size()) {
            cur </span>= ((cur &amp; <span style="color: #800080;">0x3ffff</span>) &lt;&lt; <span style="color: #800080;">2</span>) | (m[s[i++<span style="color: #000000;">]]);
            </span><span style="color: #0000ff;">if</span> (st.count(cur)) res.insert(s.substr(i - <span style="color: #800080;">10</span>, <span style="color: #800080;">10</span><span style="color: #000000;">));
            </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> st.insert(cur);
        }
        </span><span style="color: #0000ff;">return</span> vector&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;">(res.begin(), res.end());
    }
};</span></pre>
</div>
<p> </p>
<p>如果我们不需要考虑节省内存空间，那我们可以直接将10个字符组成字符串存入set中，那么也就不需要mask啥的了，但是思路还是跟上面的方法相同:</p>
<p> </p>
<p>解法四：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; findRepeatedDnaSequences(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        </span><span style="color: #0000ff;">set</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> res, st;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i + <span style="color: #800080;">9</span> &lt; s.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">string</span> t = s.substr(i, <span style="color: #800080;">10</span><span style="color: #000000;">);
            </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (st.count(t)) res.insert(t);
            </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> st.insert(t);
        }
        </span><span style="color: #0000ff;">return</span> vector&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;">{res.begin(), res.end()};
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/27517/7-lines-simple-java-o-n" target="_blank">https://discuss.leetcode.com/topic/27517/7-lines-simple-java-o-n</a></p>
<p><a href="https://discuss.leetcode.com/topic/8487/i-did-it-in-10-lines-of-c/2" target="_blank">https://discuss.leetcode.com/topic/8487/i-did-it-in-10-lines-of-c/2</a></p>
<p><a href="https://discuss.leetcode.com/topic/8894/clean-java-solution-hashmap-bits-manipulation" target="_blank">https://discuss.leetcode.com/topic/8894/clean-java-solution-hashmap-bits-manipulation</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-02-10 16:11</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4284205" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4284205);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5186294.html" id="cb_post_title_url">[LeetCode] Reverse Words in a String II 翻转字符串中的单词之二</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p><br/>Given an input string, reverse the string word by word. A word is defined as a sequence of non-space characters.<br/>The input string does not contain leading or trailing spaces and the words are always separated by a single space.<br/>For example,<br/>Given s = "the sky is blue",<br/>return "blue is sky the".<br/>Could you do it in-place without allocating extra space? </p>
<p> </p>
<p>这道题让我们翻转一个字符串中的单词，跟之前那题<a href="http://www.cnblogs.com/grandyang/p/4606676.html" target="_blank">Reverse Words in a String</a>没有区别，由于之前那道题我们就是用in-place的方法做的，而这道题反而更简化了题目，因为不考虑首尾空格了和单词之间的多空格了，方法还是很简单，先把每个单词翻转一遍，再把整个字符串翻转一遍，或者也可以调换个顺序，先翻转整个字符串，再翻转每个单词，参见代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">void</span> reverseWords(<span style="color: #0000ff;">string</span> &amp;<span style="color: #000000;">s) {
        </span><span style="color: #0000ff;">int</span> left = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt;= s.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (i == s.size() || s[i] == <span style="color: #800000;">'</span> <span style="color: #800000;">'</span><span style="color: #000000;">) {
                reverse(s, left, i </span>- <span style="color: #800080;">1</span><span style="color: #000000;">);
                left </span>= i + <span style="color: #800080;">1</span><span style="color: #000000;">;
            }
        }
        reverse(s, </span><span style="color: #800080;">0</span>, s.size() - <span style="color: #800080;">1</span><span style="color: #000000;">);
    }
    </span><span style="color: #0000ff;">void</span> reverse(<span style="color: #0000ff;">string</span> &amp;s, <span style="color: #0000ff;">int</span> left, <span style="color: #0000ff;">int</span><span style="color: #000000;"> right) {
        </span><span style="color: #0000ff;">while</span> (left &lt;<span style="color: #000000;"> right) {
            </span><span style="color: #0000ff;">char</span> t =<span style="color: #000000;"> s[left];
            s[left] </span>=<span style="color: #000000;"> s[right];
            s[right] </span>=<span style="color: #000000;"> t;
            </span>++left; --<span style="color: #000000;">right;
        }
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4606676.html" target="_blank">Reverse Words in a String</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p>
<p> </p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-02-11 07:48</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5186294" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5186294);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5367670.html" id="cb_post_title_url">[LeetCode] Department Top Three Salaries 系里前三高薪水</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>The <code>Employee</code> table holds all employees. Every employee has an Id, and there is also a column for the department Id.</p>
<pre>+----+-------+--------+--------------+
| Id | Name  | Salary | DepartmentId |
+----+-------+--------+--------------+
| 1  | Joe   | 70000  | 1            |
| 2  | Henry | 80000  | 2            |
| 3  | Sam   | 60000  | 2            |
| 4  | Max   | 90000  | 1            |
| 5  | Janet | 69000  | 1            |
| 6  | Randy | 85000  | 1            |
+----+-------+--------+--------------+
</pre>
<p>The <code>Department</code> table holds all departments of the company.</p>
<pre>+----+----------+
| Id | Name     |
+----+----------+
| 1  | IT       |
| 2  | Sales    |
+----+----------+
</pre>
<p>Write a SQL query to find employees who earn the top three salaries in each of the department. For the above tables, your SQL query should return the following rows.</p>
<pre>+------------+----------+--------+
| Department | Employee | Salary |
+------------+----------+--------+
| IT         | Max      | 90000  |
| IT         | Randy    | 85000  |
| IT         | Joe      | 70000  |
| Sales      | Henry    | 80000  |
| Sales      | Sam      | 60000  |
+------------+----------+--------+</pre>
<p> </p>
<p>这道题是之前那道<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/5366412.html" id="homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0">Department Highest Salary</a>的拓展，难度标记为Hard，还是蛮有难度的一道题，综合了前面很多题的知识点，首先看使用Select Count(Distinct)的方法，我们内交Employee和Department两张表，然后我们找出比当前薪水高的最多只能有两个，那么前三高的都能被取出来了，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">SELECT</span> d.Name <span style="color: #0000ff;">AS</span> Department, e.Name <span style="color: #0000ff;">AS</span> Employee, e.Salary <span style="color: #0000ff;">FROM</span><span style="color: #000000;"> Employee e
</span><span style="color: #808080;">JOIN</span> Department d <span style="color: #0000ff;">on</span> e.DepartmentId <span style="color: #808080;">=</span><span style="color: #000000;"> d.Id
</span><span style="color: #0000ff;">WHERE</span> (<span style="color: #0000ff;">SELECT</span> <span style="color: #ff00ff;">COUNT</span>(<span style="color: #0000ff;">DISTINCT</span> Salary) <span style="color: #0000ff;">FROM</span> Employee <span style="color: #0000ff;">WHERE</span> Salary <span style="color: #808080;">&gt;</span><span style="color: #000000;"> e.Salary
</span><span style="color: #808080;">AND</span> DepartmentId <span style="color: #808080;">=</span> d.Id) <span style="color: #808080;">&lt;</span> <span style="color: #800000; font-weight: bold;">3</span> <span style="color: #0000ff;">ORDER</span> <span style="color: #0000ff;">BY</span> d.Name, e.Salary <span style="color: #0000ff;">DESC</span>;</pre>
</div>
<p> </p>
<p>下面这种方法将上面方法中的&lt;3换成了IN (0, 1, 2)，是一样的效果：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">SELECT</span> d.Name <span style="color: #0000ff;">AS</span> Department, e.Name <span style="color: #0000ff;">AS</span> Employee, e.Salary <span style="color: #0000ff;">FROM</span><span style="color: #000000;"> Employee e, Department d
</span><span style="color: #0000ff;">WHERE</span> (<span style="color: #0000ff;">SELECT</span> <span style="color: #ff00ff;">COUNT</span>(<span style="color: #0000ff;">DISTINCT</span> Salary) <span style="color: #0000ff;">FROM</span> Employee <span style="color: #0000ff;">WHERE</span> Salary <span style="color: #808080;">&gt;</span><span style="color: #000000;"> e.Salary
</span><span style="color: #808080;">AND</span> DepartmentId <span style="color: #808080;">=</span> d.Id) <span style="color: #808080;">IN</span> (<span style="color: #800000; font-weight: bold;">0</span>, <span style="color: #800000; font-weight: bold;">1</span>, <span style="color: #800000; font-weight: bold;">2</span>) <span style="color: #808080;">AND</span> e.DepartmentId <span style="color: #808080;">=</span> d.Id <span style="color: #0000ff;">ORDER</span> <span style="color: #0000ff;">BY</span> d.Name, e.Salary <span style="color: #0000ff;">DESC</span>;</pre>
</div>
<p> </p>
<p>或者我们也可以使用Group by Having Count(Distinct ..) 关键字来做：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">SELECT</span> d.Name <span style="color: #0000ff;">AS</span> Department, e.Name <span style="color: #0000ff;">AS</span> Employee, e.Salary <span style="color: #0000ff;">FROM</span><span style="color: #000000;"> 
(</span><span style="color: #0000ff;">SELECT</span> e1.Name, e1.Salary, e1.DepartmentId <span style="color: #0000ff;">FROM</span> Employee e1 <span style="color: #808080;">JOIN</span><span style="color: #000000;"> Employee e2 
</span><span style="color: #0000ff;">ON</span> e1.DepartmentId <span style="color: #808080;">=</span> e2.DepartmentId <span style="color: #808080;">AND</span> e1.Salary <span style="color: #808080;">&lt;=</span> e2.Salary <span style="color: #0000ff;">GROUP</span> <span style="color: #0000ff;">BY</span><span style="color: #000000;"> e1.Id 
</span><span style="color: #0000ff;">HAVING</span> <span style="color: #ff00ff;">COUNT</span>(<span style="color: #0000ff;">DISTINCT</span> e2.Salary) <span style="color: #808080;">&lt;=</span> <span style="color: #800000; font-weight: bold;">3</span>) e <span style="color: #808080;">JOIN</span> Department d <span style="color: #0000ff;">ON</span> e.DepartmentId <span style="color: #808080;">=</span><span style="color: #000000;"> d.Id 
</span><span style="color: #0000ff;">ORDER</span> <span style="color: #0000ff;">BY</span> d.Name, e.Salary <span style="color: #0000ff;">DESC</span>;</pre>
</div>
<p> </p>
<p>下面这种方法略微复杂一些，用到了变量，跟<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/5354173.html" id="homepage1_HomePageDays_DaysList_ctl03_DayList_TitleUrl_2">Consecutive Numbers</a>中的解法三使用的方法一样，目的是为了给每个人都按照薪水的高低增加一个rank，最后返回rank值小于等于3的项即可，参见代码如下：</p>
<p> </p>
<p>解法四：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">SELECT</span> d.Name <span style="color: #0000ff;">AS</span> Department, e.Name <span style="color: #0000ff;">AS</span> Employee, e.Salary <span style="color: #0000ff;">FROM</span><span style="color: #000000;"> 
(</span><span style="color: #0000ff;">SELECT</span><span style="color: #000000;"> Name, Salary, DepartmentId,
</span><span style="color: #008000;">@rank</span> :<span style="color: #808080;">=</span> <span style="color: #0000ff;">IF</span>(<span style="color: #008000;">@pre_d</span> <span style="color: #808080;">=</span> DepartmentId, <span style="color: #008000;">@rank</span> <span style="color: #808080;">+</span> (<span style="color: #008000;">@pre_s</span> <span style="color: #808080;">&lt;&gt;</span> Salary), <span style="color: #800000; font-weight: bold;">1</span>) <span style="color: #0000ff;">AS</span><span style="color: #000000;"> rank,
</span><span style="color: #008000;">@pre_d</span> :<span style="color: #808080;">=</span> DepartmentId, <span style="color: #008000;">@pre_s</span> :<span style="color: #808080;">=</span><span style="color: #000000;"> Salary 
</span><span style="color: #0000ff;">FROM</span> Employee, (<span style="color: #0000ff;">SELECT</span> <span style="color: #008000;">@pre_d</span> :<span style="color: #808080;">=</span> <span style="color: #808080;">-</span><span style="color: #800000; font-weight: bold;">1</span>, <span style="color: #008000;">@pre_s</span> :<span style="color: #808080;">=</span> <span style="color: #808080;">-</span><span style="color: #800000; font-weight: bold;">1</span>, <span style="color: #008000;">@rank</span> :<span style="color: #808080;">=</span> <span style="color: #800000; font-weight: bold;">1</span>) <span style="color: #0000ff;">AS</span><span style="color: #000000;"> init
</span><span style="color: #0000ff;">ORDER</span> <span style="color: #0000ff;">BY</span> DepartmentId, Salary <span style="color: #0000ff;">DESC</span>) e <span style="color: #808080;">JOIN</span> Department d <span style="color: #0000ff;">ON</span> e.DepartmentId <span style="color: #808080;">=</span><span style="color: #000000;"> d.Id
</span><span style="color: #0000ff;">WHERE</span> e.rank <span style="color: #808080;">&lt;=</span> <span style="color: #800000; font-weight: bold;">3</span> <span style="color: #0000ff;">ORDER</span> <span style="color: #0000ff;">BY</span> d.Name, e.Salary <span style="color: #0000ff;">DESC</span>;</pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/5366412.html" id="homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0">Department Highest Salary</a></p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/5348961.html" id="homepage1_HomePageDays_DaysList_ctl04_DayList_TitleUrl_2">Second Highest Salary</a></p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/5348900.html" id="homepage1_HomePageDays_DaysList_ctl04_DayList_TitleUrl_3">Combine Two Tables</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://leetcode.com/discuss/23002/my-tidy-solution" target="_blank">https://leetcode.com/discuss/23002/my-tidy-solution</a></p>
<p><a href="https://leetcode.com/discuss/91087/yet-another-solution-using-having-count-distinct" target="_blank">https://leetcode.com/discuss/91087/yet-another-solution-using-having-count-distinct</a></p>
<p><a href="https://leetcode.com/discuss/69880/two-solutions-1-count-join-2-three-variables-join" target="_blank">https://leetcode.com/discuss/69880/two-solutions-1-count-join-2-three-variables-join</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-04-08 13:21</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5367670" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5367670);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5366412.html" id="cb_post_title_url">[LeetCode] Department Highest Salary 系里最高薪水</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>The <code>Employee</code> table holds all employees. Every employee has an Id, a salary, and there is also a column for the department Id.</p>
<pre>+----+-------+--------+--------------+
| Id | Name  | Salary | DepartmentId |
+----+-------+--------+--------------+
| 1  | Joe   | 70000  | 1            |
| 2  | Henry | 80000  | 2            |
| 3  | Sam   | 60000  | 2            |
| 4  | Max   | 90000  | 1            |
+----+-------+--------+--------------+
</pre>
<p>The <code>Department</code> table holds all departments of the company.</p>
<pre>+----+----------+
| Id | Name     |
+----+----------+
| 1  | IT       |
| 2  | Sales    |
+----+----------+
</pre>
<p>Write a SQL query to find employees who have the highest salary in each of the departments. For the above tables, Max has the highest salary in the IT department and Henry has the highest salary in the Sales department.</p>
<pre>+------------+----------+--------+
| Department | Employee | Salary |
+------------+----------+--------+
| IT         | Max      | 90000  |
| Sales      | Henry    | 80000  |
+------------+----------+--------+
</pre>
<p> </p>
<p>这道题让给了我们两张表，Employee表和Department表，让我们找系里面薪水最高的人的，实际上这题是<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/5348961.html" id="homepage1_HomePageDays_DaysList_ctl04_DayList_TitleUrl_2">Second Highest Salary</a><span class="postTitle2">和</span><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/5348900.html" id="homepage1_HomePageDays_DaysList_ctl04_DayList_TitleUrl_3">Combine Two Tables</a><span class="postTitle2">的结合题，我们既需要联合两表，又要找到最高薪水，那么我们首先让两个表内交起来，然后将结果表需要的列都标明，然后就是要找最高的薪水，我们用Max关键字来实现，参见代码如下：</span></p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">SELECT</span> d.Name <span style="color: #0000ff;">AS</span> Department, e1.Name <span style="color: #0000ff;">AS</span> Employee, e1.Salary <span style="color: #0000ff;">FROM</span><span style="color: #000000;"> Employee e1
</span><span style="color: #808080;">JOIN</span> Department d <span style="color: #0000ff;">ON</span> e1.DepartmentId <span style="color: #808080;">=</span> d.Id <span style="color: #0000ff;">WHERE</span> Salary <span style="color: #808080;">IN</span><span style="color: #000000;"> 
(</span><span style="color: #0000ff;">SELECT</span> <span style="color: #ff00ff;">MAX</span>(Salary) <span style="color: #0000ff;">FROM</span> Employee e2 <span style="color: #0000ff;">WHERE</span> e1.DepartmentId <span style="color: #808080;">=</span> e2.DepartmentId);</pre>
</div>
<p> </p>
<p>我们也可以不用Join关键字，直接用Where将两表连起来，然后找最高薪水的方法和上面相同：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">SELECT</span> d.Name <span style="color: #0000ff;">AS</span> Department, e.Name <span style="color: #0000ff;">AS</span> Employee, e.Salary <span style="color: #0000ff;">FROM</span><span style="color: #000000;"> Employee e, Department d
</span><span style="color: #0000ff;">WHERE</span> e.DepartmentId <span style="color: #808080;">=</span> d.Id <span style="color: #808080;">AND</span> e.Salary <span style="color: #808080;">=</span> (<span style="color: #0000ff;">SELECT</span> <span style="color: #ff00ff;">MAX</span>(Salary) <span style="color: #0000ff;">FROM</span> Employee e2 <span style="color: #0000ff;">WHERE</span> e2.DepartmentId <span style="color: #808080;">=</span> d.Id);</pre>
</div>
<p> </p>
<p>下面这种方法没用用到Max关键字，而是用了&gt;=符号，实现的效果跟Max关键字相同，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">SELECT</span> d.Name <span style="color: #0000ff;">AS</span> Department, e.Name <span style="color: #0000ff;">AS</span> Employee, e.Salary <span style="color: #0000ff;">FROM</span><span style="color: #000000;"> Employee e, Department d
</span><span style="color: #0000ff;">WHERE</span> e.DepartmentId <span style="color: #808080;">=</span> d.Id <span style="color: #808080;">AND</span> e.Salary <span style="color: #808080;">&gt;=</span> <span style="color: #808080;">ALL</span> (<span style="color: #0000ff;">SELECT</span> Salary <span style="color: #0000ff;">FROM</span> Employee e2 <span style="color: #0000ff;">WHERE</span> e2.DepartmentId <span style="color: #808080;">=</span> d.Id);</pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/5348961.html" id="homepage1_HomePageDays_DaysList_ctl04_DayList_TitleUrl_2">Second Highest Salary</a></p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/5348900.html" id="homepage1_HomePageDays_DaysList_ctl04_DayList_TitleUrl_3">Combine Two Tables</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-04-08 07:24</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5366412" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5366412);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5361992.html" id="cb_post_title_url">[LeetCode] Customers Who Never Order 从未下单订购的顾客</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Suppose that a website contains two tables, the <code>Customers</code> table and the <code>Orders</code> table. Write a SQL query to find all customers who never order anything.</p>
<p>Table: <code>Customers</code>.</p>
<pre>+----+-------+
| Id | Name  |
+----+-------+
| 1  | Joe   |
| 2  | Henry |
| 3  | Sam   |
| 4  | Max   |
+----+-------+
</pre>
<p>Table: <code>Orders</code>.</p>
<pre>+----+------------+
| Id | CustomerId |
+----+------------+
| 1  | 3          |
| 2  | 1          |
+----+------------+
</pre>
<p>Using the above tables as example, return the following:</p>
<pre>+-----------+
| Customers |
+-----------+
| Henry     |
| Max       |
+-----------+
</pre>
<p> </p>
<p>这道题让我们给了我们一个Customers表和一个Orders表，让我们找到从来没有下单的顾客，那么我们最直接的方法就是找没有在Orders表中出现的顾客Id就行了，用Not in关键字，如下所示：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">SELECT</span> Name <span style="color: #0000ff;">AS</span> Customers <span style="color: #0000ff;">FROM</span><span style="color: #000000;"> Customers 
</span><span style="color: #0000ff;">WHERE</span> Id <span style="color: #808080;">NOT</span> <span style="color: #808080;">IN</span> (<span style="color: #0000ff;">SELECT</span> CustomerId <span style="color: #0000ff;">FROM</span> Orders);</pre>
</div>
<p> </p>
<p>或者我们也可以用左交来联合两个表，只要找出右边的CustomerId为Null的顾客就是木有下单的：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">SELECT</span> Name <span style="color: #0000ff;">AS</span> Customers <span style="color: #0000ff;">FROM</span><span style="color: #000000;"> Customers
</span><span style="color: #808080;">LEFT</span> <span style="color: #808080;">JOIN</span> Orders <span style="color: #0000ff;">ON</span> Customers.Id <span style="color: #808080;">=</span><span style="color: #000000;"> Orders.CustomerId
</span><span style="color: #0000ff;">WHERE</span> Orders.CustomerId <span style="color: #0000ff;">IS</span> <span style="color: #0000ff;">NULL</span>;</pre>
</div>
<p> </p>
<p>我们还可以用Not exists关键字来做，原理和Not in很像，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">SELECT</span> Name <span style="color: #0000ff;">AS</span> Customers <span style="color: #0000ff;">FROM</span><span style="color: #000000;"> Customers c
</span><span style="color: #0000ff;">WHERE</span> <span style="color: #808080;">NOT</span> <span style="color: #808080;">EXISTS</span> (<span style="color: #0000ff;">SELECT</span> <span style="color: #808080;">*</span> <span style="color: #0000ff;">FROM</span> Orders o <span style="color: #0000ff;">WHERE</span> o.CustomerId <span style="color: #808080;">=</span> c.Id);</pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://leetcode.com/discuss/22624/three-accepted-solutions" target="_blank">https://leetcode.com/discuss/22624/three-accepted-solutions</a></p>
<p><a href="https://leetcode.com/discuss/53213/a-solution-using-not-in-and-another-one-using-left-join" target="_blank">https://leetcode.com/discuss/53213/a-solution-using-not-in-and-another-one-using-left-join</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-04-07 06:41</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5361992" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5361992);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5361967.html" id="cb_post_title_url">[LeetCode] Duplicate Emails 重复的邮箱</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Write a SQL query to find all duplicate emails in a table named <code>Person</code>.</p>
<pre>+----+---------+
| Id | Email   |
+----+---------+
| 1  | a@b.com |
| 2  | c@d.com |
| 3  | a@b.com |
+----+---------+
</pre>
<p>For example, your query should return the following for the above table:</p>
<pre>+---------+
| Email   |
+---------+
| a@b.com |
+---------+
</pre>
<p><strong>Note</strong>: All emails are in lowercase.</p>
<p> </p>
<p>这道题让我们求重复的邮箱，那么最直接的方法就是用Group by...Having Count(*)...的固定搭配来做，代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">SELECT</span> Email <span style="color: #0000ff;">FROM</span> Person <span style="color: #0000ff;">GROUP</span> <span style="color: #0000ff;">BY</span><span style="color: #000000;"> Email
</span><span style="color: #0000ff;">HAVING</span> <span style="color: #ff00ff;">COUNT</span>(<span style="color: #808080;">*</span>) <span style="color: #808080;">&gt;</span> <span style="color: #800000; font-weight: bold;">1</span>;</pre>
</div>
<p> </p>
<p>我们还可以用内交来做，用Email来内交两个表，然后返回Id不同的行，则说明两个不同的人使用了相同的邮箱：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">SELECT</span> <span style="color: #0000ff;">DISTINCT</span> p1.Email <span style="color: #0000ff;">FROM</span><span style="color: #000000;"> Person p1
</span><span style="color: #808080;">JOIN</span> Person p2 <span style="color: #0000ff;">ON</span> p1.Email <span style="color: #808080;">=</span><span style="color: #000000;"> p2.Email
</span><span style="color: #0000ff;">WHERE</span> p1.Id <span style="color: #808080;">&lt;&gt;</span> p2.Id;</pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://leetcode.com/discuss/53206/a-solution-using-a-group-by-and-another-one-using-a-self-join" target="_blank">https://leetcode.com/discuss/53206/a-solution-using-a-group-by-and-another-one-using-a-self-join</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-04-07 06:09</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5361967" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5361967);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5354306.html" id="cb_post_title_url">[LeetCode] Employees Earning More Than Their Managers 员工挣得比经理多</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>The <code>Employee</code> table holds all employees including their managers. Every employee has an Id, and there is also a column for the manager Id.</p>
<pre>+----+-------+--------+-----------+
| Id | Name  | Salary | ManagerId |
+----+-------+--------+-----------+
| 1  | Joe   | 70000  | 3         |
| 2  | Henry | 80000  | 4         |
| 3  | Sam   | 60000  | NULL      |
| 4  | Max   | 90000  | NULL      |
+----+-------+--------+-----------+
</pre>
<p>Given the <code>Employee</code> table, write a SQL query that finds out employees who earn more than their managers. For the above table, Joe is the only employee who earns more than his manager.</p>
<pre>+----------+
| Employee |
+----------+
| Joe      |
+----------+</pre>
<p> </p>
<p>这道题给我们了一个Employee表，里面有员工的薪水信息和其经理的信息，经理也属于员工，其经理Id为空，让我们找出薪水比其经理高的员工，那么就是一个很简单的比较问题了，我们可以生成两个实例对象进行内交通过ManagerId和Id，然后限制条件是一个Salary大于另一个即可：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">SELECT</span> e1.Name <span style="color: #0000ff;">FROM</span><span style="color: #000000;"> Employee e1
</span><span style="color: #808080;">JOIN</span> Employee e2 <span style="color: #0000ff;">ON</span> e1.ManagerId <span style="color: #808080;">=</span><span style="color: #000000;"> e2.Id
</span><span style="color: #0000ff;">WHERE</span> e1.Salary <span style="color: #808080;">&gt;</span> e2.Salary;</pre>
</div>
<p> </p>
<p>我们也可以不用Join，直接把条件都写到where里也行：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">SELECT</span> e1.Name <span style="color: #0000ff;">FROM</span><span style="color: #000000;"> Employee e1, Employee e2
</span><span style="color: #0000ff;">WHERE</span> e1.ManagerId <span style="color: #808080;">=</span> e2.Id <span style="color: #808080;">AND</span> e1.Salary <span style="color: #808080;">&gt;</span> e2.Salary;</pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://leetcode.com/discuss/88189/two-straightforward-way-using-where-and-join%20" target="_blank">https://leetcode.com/discuss/88189/two-straightforward-way-using-where-and-join</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-04-05 11:21</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5354306" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5354306);return false;">收藏</a></div>
</div>
</html>