<html lang="zh-cn">
<head>
<meta charset="utf-8"/>
<div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5354173.html" id="cb_post_title_url">[LeetCode] Consecutive Numbers 连续的数字</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Write a SQL query to find all numbers that appear at least three times consecutively.</p>
<pre>+----+-----+
| Id | Num |
+----+-----+
| 1  |  1  |
| 2  |  1  |
| 3  |  1  |
| 4  |  2  |
| 5  |  1  |
| 6  |  2  |
| 7  |  2  |
+----+-----+
</pre>
<p>For example, given the above <code>Logs</code> table, <code>1</code> is the only number that appears consecutively for at least three times.</p>
<p> </p>
<p>这道题给了我们一个Logs表，让我们找Num列中连续出现相同数字三次的数字，那么由于需要找三次相同数字，所以我们需要建立三个表的实例，我们可以用l1分别和l2, l3内交，l1和l2的Id下一个位置比，l1和l3的下两个位置比，然后将Num都相同的数字返回即可：</p>
<p> </p>
<p>解法一:</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">SELECT</span> <span style="color: #0000ff;">DISTINCT</span> l1.Num <span style="color: #0000ff;">FROM</span><span style="color: #000000;"> Logs l1
</span><span style="color: #808080;">JOIN</span> Logs l2 <span style="color: #0000ff;">ON</span> l1.Id <span style="color: #808080;">=</span> l2.Id <span style="color: #808080;">-</span> <span style="color: #800000; font-weight: bold;">1</span>
<span style="color: #808080;">JOIN</span> Logs l3 <span style="color: #0000ff;">ON</span> l1.Id <span style="color: #808080;">=</span> l3.Id <span style="color: #808080;">-</span> <span style="color: #800000; font-weight: bold;">2</span>
<span style="color: #0000ff;">WHERE</span> l1.Num <span style="color: #808080;">=</span> l2.Num <span style="color: #808080;">AND</span> l2.Num <span style="color: #808080;">=</span> l3.Num;</pre>
</div>
<p> </p>
<p>下面这种方法没用用到Join，而是直接在三个表的实例中查找，然后把四个条件限定上，就可以返回正确结果了：</p>
<p> </p>
<p>解法二:</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">SELECT</span> <span style="color: #0000ff;">DISTINCT</span> l1.Num <span style="color: #0000ff;">FROM</span><span style="color: #000000;"> Logs l1, Logs l2, Logs l3
</span><span style="color: #0000ff;">WHERE</span> l1.Id <span style="color: #808080;">=</span> l2.Id <span style="color: #808080;">-</span> <span style="color: #800000; font-weight: bold;">1</span> <span style="color: #808080;">AND</span> l2.Id <span style="color: #808080;">=</span> l3.Id <span style="color: #808080;">-</span> <span style="color: #800000; font-weight: bold;">1</span>
<span style="color: #808080;">AND</span> l1.Num <span style="color: #808080;">=</span> l2.Num <span style="color: #808080;">AND</span> l2.Num <span style="color: #808080;">=</span> l3.Num;</pre>
</div>
<p> </p>
<p>再来看一种画风截然不同的方法，用到了变量count和pre，分别初始化为0和-1，然后需要注意的是用到了IF语句，MySQL里的IF语句和我们所熟知的其他语言的if不太一样，相当于我们所熟悉的三元操作符a?b:c，若a真返回b，否则返回c，具体可看<a href="http://outofmemory.cn/code-snippet/1149/MySQL-if-case-statement-usage-summary" target="_blank">这个帖子</a>。那么我们先来看对于Num列的第一个数字1，pre由于初始化是-1，和当前Num不同，所以此时count赋1，此时给pre赋为1，然后Num列的第二个1进来，此时的pre和Num相同了，count自增1，到Num列的第三个1进来，count增加到了3，此时满足了where条件，t.n &gt;= 3，所以1就被select出来了，以此类推遍历完整个Num就可以得到最终结果：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">SELECT</span> <span style="color: #0000ff;">DISTINCT</span> Num <span style="color: #0000ff;">FROM</span><span style="color: #000000;"> (
</span><span style="color: #0000ff;">SELECT</span> Num, <span style="color: #008000;">@count</span> :<span style="color: #808080;">=</span> <span style="color: #0000ff;">IF</span>(<span style="color: #008000;">@pre</span> <span style="color: #808080;">=</span> Num, <span style="color: #008000;">@count</span> <span style="color: #808080;">+</span> <span style="color: #800000; font-weight: bold;">1</span>, <span style="color: #800000; font-weight: bold;">1</span>) <span style="color: #0000ff;">AS</span> n, <span style="color: #008000;">@pre</span> :<span style="color: #808080;">=</span><span style="color: #000000;"> Num
</span><span style="color: #0000ff;">FROM</span> Logs, (<span style="color: #0000ff;">SELECT</span> <span style="color: #008000;">@count</span> :<span style="color: #808080;">=</span> <span style="color: #800000; font-weight: bold;">0</span>, <span style="color: #008000;">@pre</span> :<span style="color: #808080;">=</span> <span style="color: #808080;">-</span><span style="color: #800000; font-weight: bold;">1</span>) <span style="color: #0000ff;">AS</span><span style="color: #000000;"> init
) </span><span style="color: #0000ff;">AS</span> t <span style="color: #0000ff;">WHERE</span> t.n <span style="color: #808080;">&gt;=</span> <span style="color: #800000; font-weight: bold;">3</span>;</pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://leetcode.com/discuss/54463/simple-solution" target="_blank">https://leetcode.com/discuss/54463/simple-solution</a></p>
<p><a href="https://leetcode.com/discuss/87854/simple-sql-with-join-1484-ms%20" target="_blank">https://leetcode.com/discuss/87854/simple-sql-with-join-1484-ms</a></p>
<p><a href="https://leetcode.com/discuss/69767/two-solutions-inner-join-and-two-variables" target="_blank">https://leetcode.com/discuss/69767/two-solutions-inner-join-and-two-variables</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-04-05 10:51</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5354173" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5354173);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4225047.html" id="cb_post_title_url">[LeetCode] Largest Number 最大组合数</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a list of non negative integers, arrange them such that they form the largest number.</p>
<p>For example, given <code>[3, 30, 34, 5, 9]</code>, the largest formed number is <code>9534330</code>.</p>
<p>Note: The result may be very large, so you need to return a string instead of an integer.</p>
<p>Credits:<br/>Special thanks to <a href="https://oj.leetcode.com/discuss/user/ts">@ts</a> for adding this problem and creating all test cases.</p>
<p> </p>
<p>这道题给了我们一个数组，让我们将其拼接成最大的数，那么根据题目中给的例子来看，主要就是要给给定数组进行排序，但是排序方法不是普通的升序或者降序，因为9要排在最前面，而9既不是数组中最大的也不是最小的，所以我们要自定义排序方法。如果不参考网友的解法，我估计是无法想出来的。这种解法对于两个数字a和b来说，如果将其都转为字符串，如果ab &gt; ba，则a排在前面，比如9和34，由于934&gt;349，所以9排在前面，再比如说30和3，由于303&lt;330，所以3排在30的前面。按照这种规则对原数组进行排序后，将每个数字转化为字符串再连接起来就是最终结果。代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> largestNumber(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        </span><span style="color: #0000ff;">string</span><span style="color: #000000;"> res;
        sort(nums.begin(), nums.end(), [](</span><span style="color: #0000ff;">int</span> a, <span style="color: #0000ff;">int</span><span style="color: #000000;"> b) {
           </span><span style="color: #0000ff;">return</span> to_string(a) + to_string(b) &gt; to_string(b) +<span style="color: #000000;"> to_string(a); 
        });
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; nums.size(); ++<span style="color: #000000;">i) {
            res </span>+=<span style="color: #000000;"> to_string(nums[i]);
        }
        </span><span style="color: #0000ff;">return</span> res[<span style="color: #800080;">0</span>] == <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span> ? <span style="color: #800000;">"</span><span style="color: #800000;">0</span><span style="color: #800000;">"</span><span style="color: #000000;"> : res;
    }
};</span></pre>
</div>
<p><span style="font-size: 14px; line-height: 1.5;"> </span></p>
<p>参考资料：</p>
<p><a href="http://leetcodesolution.blogspot.com/2015/01/leetcode-largest-number.html" target="_blank">http://leetcodesolution.blogspot.com/2015/01/leetcode-largest-number.html</a><br/><a href="https://leetcode.com/discuss/32431/simple-10-line-c-solution" target="_blank">https://leetcode.com/discuss/32431/simple-10-line-c-solution</a><br/><a href="https://leetcode.com/discuss/29699/share-a-short-code-in-c" target="_blank">https://leetcode.com/discuss/29699/share-a-short-code-in-c</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-01-14 22:37</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4225047" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4225047);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5351611.html" id="cb_post_title_url">[LeetCode] Rank Scores 分数排行</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Write a SQL query to rank scores. If there is a tie between two scores, both should have the same ranking. Note that after a tie, the next ranking number should be the next consecutive integer value. In other words, there should be no "holes" between ranks.</p>
<pre>+----+-------+
| Id | Score |
+----+-------+
| 1  | 3.50  |
| 2  | 3.65  |
| 3  | 4.00  |
| 4  | 3.85  |
| 5  | 4.00  |
| 6  | 3.65  |
+----+-------+
</pre>
<p>For example, given the above <code>Scores</code> table, your query should generate the following report (order by highest score):</p>
<pre>+-------+------+
| Score | Rank |
+-------+------+
| 4.00  | 1    |
| 4.00  | 1    |
| 3.85  | 2    |
| 3.65  | 3    |
| 3.65  | 3    |
| 3.50  | 4    |
+-------+------+
</pre>
<p> </p>
<p>这道题给了我们一个分数表，让我们给分数排序，要求是相同的分数在相同的名次，下一个分数在相连的下一个名次，中间不能有空缺数字，这道题我是完全照着<a href="https://leetcode.com/discuss/40116/simple-short-fast" target="_blank">史蒂芬大神的帖子</a>来写的，膜拜大神中...大神总结了四种方法，那么我们一个一个的来膜拜学习，首先看第一种解法，解题的思路是对于每一个分数，找出表中有多少个大于或等于该分数的不同的分数，然后按降序排列即可，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">SELECT</span><span style="color: #000000;"> Score, 
(</span><span style="color: #0000ff;">SELECT</span> <span style="color: #ff00ff;">COUNT</span>(<span style="color: #0000ff;">DISTINCT</span> Score) <span style="color: #0000ff;">FROM</span> Scores <span style="color: #0000ff;">WHERE</span> Score <span style="color: #808080;">&gt;=</span><span style="color: #000000;"> s.Score) Rank 
</span><span style="color: #0000ff;">FROM</span> Scores s <span style="color: #0000ff;">ORDER</span> <span style="color: #0000ff;">BY</span> Score <span style="color: #0000ff;">DESC</span>;</pre>
</div>
<p> </p>
<p>跟上面的解法思想相同，就是写法上略有不同：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">SELECT</span><span style="color: #000000;"> Score,
(</span><span style="color: #0000ff;">SELECT</span> <span style="color: #ff00ff;">COUNT</span>(<span style="color: #808080;">*</span>) <span style="color: #0000ff;">FROM</span> (<span style="color: #0000ff;">SELECT</span> <span style="color: #0000ff;">DISTINCT</span> Score s <span style="color: #0000ff;">FROM</span> Scores) t <span style="color: #0000ff;">WHERE</span> s <span style="color: #808080;">&gt;=</span><span style="color: #000000;"> Score) Rank
</span><span style="color: #0000ff;">FROM</span> Scores <span style="color: #0000ff;">ORDER</span> <span style="color: #0000ff;">BY</span> Score <span style="color: #0000ff;">DESC</span>;</pre>
</div>
<p> </p>
<p>下面这种解法使用了内交，Join是Inner Join的简写形式，自己和自己内交，条件是右表的分数大于等于左表，然后群组起来根据分数的降序排列，十分巧妙的解法：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">SELECT</span> s.Score, <span style="color: #ff00ff;">COUNT</span>(<span style="color: #0000ff;">DISTINCT</span><span style="color: #000000;"> t.Score) Rank
</span><span style="color: #0000ff;">FROM</span> Scores s <span style="color: #808080;">JOIN</span> Scores t <span style="color: #0000ff;">ON</span> s.Score <span style="color: #808080;">&lt;=</span><span style="color: #000000;"> t.Score
</span><span style="color: #0000ff;">GROUP</span> <span style="color: #0000ff;">BY</span> s.Id <span style="color: #0000ff;">ORDER</span> <span style="color: #0000ff;">BY</span> s.Score <span style="color: #0000ff;">DESC</span>;</pre>
</div>
<p> </p>
<p>下面这种解法跟上面三种的画风就不太一样了，这里用了两个变量，变量使用时其前面需要加@，这里的：= 是赋值的意思，如果前面有Set关键字，则可以直接用=号来赋值，如果没有，则必须要使用:=来赋值，两个变量rank和pre，其中rank表示当前的排名，pre表示之前的分数，下面代码中的&lt;&gt;表示不等于，如果左右两边不相等，则返回true或1，若相等，则返回false或0。初始化rank为0，pre为-1，然后按降序排列分数，对于分数4来说，pre赋为4，和之前的pre值-1不同，所以rank要加1，那么分数4的rank就为1，下面一个分数还是4，那么pre赋值为4和之前的4相同，所以rank要加0，所以这个分数4的rank也是1，以此类推就可以计算出所有分数的rank了。</p>
<p> </p>
<p>解法四：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">SELECT</span><span style="color: #000000;"> Score,
</span><span style="color: #008000;">@rank</span> :<span style="color: #808080;">=</span> <span style="color: #008000;">@rank</span> <span style="color: #808080;">+</span> (<span style="color: #008000;">@pre</span> <span style="color: #808080;">&lt;&gt;</span> (<span style="color: #008000;">@pre</span> :<span style="color: #808080;">=</span><span style="color: #000000;"> Score)) Rank
</span><span style="color: #0000ff;">FROM</span> Scores, (<span style="color: #0000ff;">SELECT</span> <span style="color: #008000;">@rank</span> :<span style="color: #808080;">=</span> <span style="color: #800000; font-weight: bold;">0</span>, <span style="color: #008000;">@pre</span> :<span style="color: #808080;">=</span> <span style="color: #808080;">-</span><span style="color: #800000; font-weight: bold;">1</span><span style="color: #000000;">) INIT 
</span><span style="color: #0000ff;">ORDER</span> <span style="color: #0000ff;">BY</span> Score <span style="color: #0000ff;">DESC</span>;</pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://leetcode.com/discuss/40116/simple-short-fast" target="_blank">https://leetcode.com/discuss/40116/simple-short-fast</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-04-04 11:20</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5351611" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5351611);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5348976.html" id="cb_post_title_url">[LeetCode] Nth Highest Salary 第N高薪水</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Write a SQL query to get the <em>n</em>th highest salary from the <code>Employee</code> table.</p>
<pre>+----+--------+
| Id | Salary |
+----+--------+
| 1  | 100    |
| 2  | 200    |
| 3  | 300    |
+----+--------+
</pre>
<p>For example, given the above Employee table, the <em>n</em>th highest salary where <em>n</em> = 2 is <code>200</code>. If there is no <em>n</em>th highest salary, then the query should return <code>null</code>.</p>
<p> </p>
<p>这道题是之前那道<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/5348961.html" id="homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0">Second Highest Salary</a>的拓展，根据之前那道题的做法，我们可以很容易的将其推展为N，根据对<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/5348961.html" id="homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0">Second Highest Salary</a>中解法一的分析，我们只需要将OFFSET后面的1改为N-1就行了，但是这样MySQL会报错，估计不支持运算，那么我们可以在前面加一个SET N = N - 1，将N先变成N-1再做也是一样的：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">CREATE</span> <span style="color: #0000ff;">FUNCTION</span> getNthHighestSalary(N <span style="color: #0000ff;">INT</span>) <span style="color: #0000ff;">RETURNS</span> <span style="color: #0000ff;">INT</span>
<span style="color: #0000ff;">BEGIN</span>
  <span style="color: #0000ff;">SET</span> N <span style="color: #808080;">=</span> N <span style="color: #808080;">-</span> <span style="color: #800000; font-weight: bold;">1</span><span style="color: #000000;">;
  </span><span style="color: #0000ff;">RETURN</span><span style="color: #000000;"> (
      </span><span style="color: #0000ff;">SELECT</span> <span style="color: #0000ff;">DISTINCT</span> Salary <span style="color: #0000ff;">FROM</span> Employee <span style="color: #0000ff;">GROUP</span> <span style="color: #0000ff;">BY</span><span style="color: #000000;"> Salary
      </span><span style="color: #0000ff;">ORDER</span> <span style="color: #0000ff;">BY</span> Salary <span style="color: #0000ff;">DESC</span> LIMIT <span style="color: #800000; font-weight: bold;">1</span><span style="color: #000000;"> OFFSET N
  );
</span><span style="color: #0000ff;">END</span></pre>
</div>
<p> </p>
<p>根据对<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/5348961.html" id="homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0">Second Highest Salary</a>中解法四的分析，我们只需要将其1改为N-1即可，这里却支持N-1的计算，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">CREATE</span> <span style="color: #0000ff;">FUNCTION</span> getNthHighestSalary(N <span style="color: #0000ff;">INT</span>) <span style="color: #0000ff;">RETURNS</span> <span style="color: #0000ff;">INT</span>
<span style="color: #0000ff;">BEGIN</span>
  <span style="color: #0000ff;">RETURN</span><span style="color: #000000;"> (
      </span><span style="color: #0000ff;">SELECT</span> <span style="color: #ff00ff;">MAX</span>(Salary) <span style="color: #0000ff;">FROM</span><span style="color: #000000;"> Employee E1
      </span><span style="color: #0000ff;">WHERE</span> N <span style="color: #808080;">-</span> <span style="color: #800000; font-weight: bold;">1</span> <span style="color: #808080;">=</span><span style="color: #000000;">
      (</span><span style="color: #0000ff;">SELECT</span> <span style="color: #ff00ff;">COUNT</span>(<span style="color: #0000ff;">DISTINCT</span>(E2.Salary)) <span style="color: #0000ff;">FROM</span><span style="color: #000000;"> Employee E2
      </span><span style="color: #0000ff;">WHERE</span> E2.Salary <span style="color: #808080;">&gt;</span><span style="color: #000000;"> E1.Salary)
  );
</span><span style="color: #0000ff;">END</span></pre>
</div>
<p> </p>
<p>当然我们也可以通过将最后的&gt;改为&gt;=，这样我们就可以将N-1换成N了：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">CREATE</span> <span style="color: #0000ff;">FUNCTION</span> getNthHighestSalary(N <span style="color: #0000ff;">INT</span>) <span style="color: #0000ff;">RETURNS</span> <span style="color: #0000ff;">INT</span>
<span style="color: #0000ff;">BEGIN</span>
  <span style="color: #0000ff;">RETURN</span><span style="color: #000000;"> (
      </span><span style="color: #0000ff;">SELECT</span> <span style="color: #ff00ff;">MAX</span>(Salary) <span style="color: #0000ff;">FROM</span><span style="color: #000000;"> Employee E1
      </span><span style="color: #0000ff;">WHERE</span> N <span style="color: #808080;">=</span><span style="color: #000000;">
      (</span><span style="color: #0000ff;">SELECT</span> <span style="color: #ff00ff;">COUNT</span>(<span style="color: #0000ff;">DISTINCT</span>(E2.Salary)) <span style="color: #0000ff;">FROM</span><span style="color: #000000;"> Employee E2
      </span><span style="color: #0000ff;">WHERE</span> E2.Salary <span style="color: #808080;">&gt;=</span><span style="color: #000000;"> E1.Salary)
  );
</span><span style="color: #0000ff;">END</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/5348961.html" id="homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0">Second Highest Salary</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://leetcode.com/discuss/88875/simple-answer-with-limit-and-offset" target="_blank">https://leetcode.com/discuss/88875/simple-answer-with-limit-and-offset</a></p>
<p><a href="https://leetcode.com/discuss/63183/fastest-solution-without-using-order-declaring-variables" target="_blank">https://leetcode.com/discuss/63183/fastest-solution-without-using-order-declaring-variables</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-04-03 05:43</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5348976" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5348976);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5348961.html" id="cb_post_title_url">[LeetCode] Second Highest Salary 第二高薪水</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Write a SQL query to get the second highest salary from the <code>Employee</code> table.</p>
<pre>+----+--------+
| Id | Salary |
+----+--------+
| 1  | 100    |
| 2  | 200    |
| 3  | 300    |
+----+--------+
</pre>
<p>For example, given the above Employee table, the second highest salary is <code>200</code>. If there is no second highest salary, then the query should return <code>null</code>.</p>
<p> </p>
<p>这道题让我们找表中某列第二大的数，这道题有很多种解法，先来看一种使用Limit和Offset两个关键字的解法，MySQL中Limit后面的数字限制了我们返回数据的个数，Offset是偏移量，那么如果我们想找第二高薪水，我们首先可以先对薪水进行降序排列，然后我们将Offset设为1，那么就是从第二个开始，也就是第二高薪水，然后我们将Limit设为1，就是只取出第二高薪水，如果将Limit设为2，那么就将第二高和第三高薪水都取出来：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">SELECT</span> Salary <span style="color: #0000ff;">FROM</span> Employee <span style="color: #0000ff;">GROUP</span> <span style="color: #0000ff;">BY</span><span style="color: #000000;"> Salary
</span><span style="color: #0000ff;">UNION</span> <span style="color: #808080;">ALL</span> (<span style="color: #0000ff;">SELECT</span> <span style="color: #0000ff;">NULL</span> <span style="color: #0000ff;">AS</span><span style="color: #000000;"> Salary)
</span><span style="color: #0000ff;">ORDER</span> <span style="color: #0000ff;">BY</span> Salary <span style="color: #0000ff;">DESC</span> LIMIT <span style="color: #800000; font-weight: bold;">1</span> OFFSET <span style="color: #800000; font-weight: bold;">1</span>;</pre>
</div>
<p> </p>
<p>我们也可以使用Max函数来做，这个返回最大值，逻辑是我们取出的不包含最大值的数字中的最大值，即为第二大值：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">SELECT</span> <span style="color: #ff00ff;">MAX</span>(Salary) <span style="color: #0000ff;">FROM</span><span style="color: #000000;"> Employee 
</span><span style="color: #0000ff;">WHERE</span> Salary <span style="color: #808080;">NOT</span> <span style="color: #808080;">IN</span><span style="color: #000000;">
(</span><span style="color: #0000ff;">SELECT</span> <span style="color: #ff00ff;">MAX</span>(Salary) <span style="color: #0000ff;">FROM</span> Employee);</pre>
</div>
<p> </p>
<p>下面这种方法和上面基本一样，就是用小于号&lt;代替了Not in关键字，效果相同：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">SELECT</span> <span style="color: #ff00ff;">MAX</span>(Salary) <span style="color: #0000ff;">FROM</span><span style="color: #000000;"> Employee
</span><span style="color: #0000ff;">Where</span> Salary <span style="color: #808080;">&lt;</span><span style="color: #000000;">
(</span><span style="color: #0000ff;">SELECT</span> <span style="color: #ff00ff;">MAX</span>(Salary) <span style="color: #0000ff;">FROM</span> Employee);</pre>
</div>
<p> </p>
<p>最后来看一种可以扩展到找到第N高的薪水的方法，只要将下面语句中的1改为N-1即可，第二高的薪水带入N-1就是1，下面语句的逻辑是，假如我们要找第二高的薪水，那么我们允许其中一个最大值存在，然后在其余的数字中找出最大的，即为整个的第二大的值；</p>
<p> </p>
<p>解法四：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">SELECT</span> <span style="color: #ff00ff;">MAX</span>(Salary) <span style="color: #0000ff;">FROM</span><span style="color: #000000;"> Employee E1
</span><span style="color: #0000ff;">WHERE</span> <span style="color: #800000; font-weight: bold;">1</span> <span style="color: #808080;">=</span><span style="color: #000000;">
(</span><span style="color: #0000ff;">SELECT</span> <span style="color: #ff00ff;">COUNT</span>(<span style="color: #0000ff;">DISTINCT</span>(E2.Salary)) <span style="color: #0000ff;">FROM</span><span style="color: #000000;"> Employee E2
</span><span style="color: #0000ff;">WHERE</span> E2.Salary <span style="color: #808080;">&gt;</span> E1.Salary);</pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://leetcode.com/discuss/47041/very-very-simple-solution" target="_blank">https://leetcode.com/discuss/47041/very-very-simple-solution</a></p>
<p><a href="https://leetcode.com/discuss/42849/general-solution-not-using-max" target="_blank">https://leetcode.com/discuss/42849/general-solution-not-using-max</a></p>
<p><a href="https://leetcode.com/discuss/21751/simple-query-which-handles-the-null-situation" target="_blank">https://leetcode.com/discuss/21751/simple-query-which-handles-the-null-situation</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-04-03 05:00</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5348961" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5348961);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5348900.html" id="cb_post_title_url">[LeetCode] Combine Two Tables 联合两表</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Table: <code>Person</code></p>
<pre>+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| PersonId    | int     |
| FirstName   | varchar |
| LastName    | varchar |
+-------------+---------+
PersonId is the primary key column for this table.
</pre>
<p>Table: <code>Address</code></p>
<pre>+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| AddressId   | int     |
| PersonId    | int     |
| City        | varchar |
| State       | varchar |
+-------------+---------+
AddressId is the primary key column for this table.
</pre>
<p> </p>
<p>Write a SQL query for a report that provides the following information for each person in the Person table, regardless if there is an address for each of those people:</p>
<pre>FirstName, LastName, City, State</pre>
<p> </p>
<p>LeetCode还出了是来到数据库的题，来那么也来做做吧，这道题是第一道，相对来说比较简单，是一道两表联合查找的问题，我们需要用到Join操作，关于一些Join操作可以看我之前的博客<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/5346963.html" id="homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0">SQL Left Join, Right Join, Inner Join, and Natural Join 各种Join小结</a>，最直接的方法就是用Left Join来做，根据PersonId这项来把两个表联合起来：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">SELECT</span> Person.FirstName, Person.LastName, Address.City, Address.State <span style="color: #0000ff;">FROM</span> Person <span style="color: #808080;">LEFT</span> <span style="color: #808080;">JOIN</span> Address <span style="color: #0000ff;">ON</span> Person.PersonId <span style="color: #808080;">=</span> Address.PersonId;</pre>
</div>
<p> </p>
<p>在使用Left Join时，我们也可以使用关键Using来声明我们相用哪个列名来进行联合：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">SELECT</span> Person.FirstName, Person.LastName, Address.City, Address.State <span style="color: #0000ff;">FROM</span> Person <span style="color: #808080;">LEFT</span> <span style="color: #808080;">JOIN</span> Address USING(PersonId);</pre>
</div>
<p> </p>
<p>或者我们可以加上Natural关键字，这样我们就不用声明具体的列，MySQL可以自行搜索相同的列：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">SELECT</span> Person.FirstName, Person.LastName, Address.City, Address.State <span style="color: #0000ff;">FROM</span> Person NATURAL <span style="color: #808080;">LEFT</span> <span style="color: #808080;">JOIN</span> Address;</pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://leetcode.com/discuss/21216/its-a-simple-question-of-left-join-my-solution-attached" target="_blank">https://leetcode.com/discuss/21216/its-a-simple-question-of-left-join-my-solution-attached</a></p>
<p><a href="https://leetcode.com/discuss/53001/comparative-solution-between-left-using-natural-left-join" target="_blank">https://leetcode.com/discuss/53001/comparative-solution-between-left-using-natural-left-join</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p>
<p> </p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-04-03 04:09</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5348900" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5348900);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4233035.html" id="cb_post_title_url">[LeetCode] Dungeon Game 地牢游戏</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p>　　</p>
<p>The demons had captured the princess (P) and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of M x N rooms laid out in a 2D grid. Our valiant knight (K) was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess.</p>
<p>The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.</p>
<p>Some of the rooms are guarded by demons, so the knight loses health (<em>negative</em> integers) upon entering these rooms; other rooms are either empty (<em>0's</em>) or contain magic orbs that increase the knight's health (<em>positive</em> integers).</p>
<p>In order to reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step.</p>
<p> </p>
<p>Write a function to determine the knight's minimum initial health so that he is able to rescue the princess.</p>
<p>For example, given the dungeon below, the initial health of the knight must be at least 7 if he follows the optimal path <code>RIGHT-&gt; RIGHT -&gt; DOWN -&gt; DOWN</code>.</p>
<table class="dungeon">
<tbody>
<tr>
<td>-2 (K)</td>
<td>-3</td>
<td>3</td>
</tr>
<tr>
<td>-5</td>
<td>-10</td>
<td>1</td>
</tr>
<tr>
<td>10</td>
<td>30</td>
<td>-5 (P)</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Notes:</p>
<ul>
<li>The knight's health has no upper bound.</li>
<li>Any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.</li>
</ul>
<p> </p>
<p>Credits:<br/>Special thanks to <a href="https://oj.leetcode.com/discuss/user/stellari">@stellari</a> for adding this problem and creating all test cases.</p>
<p> </p>
<p>这道王子救公主的题还是蛮新颖的，我最开始的想法是比较右边和下边的数字的大小，去大的那个，但是这个算法对某些情况不成立，比如下面的情况：</p>
<table class="dungeon">
<tbody>
<tr>
<td>1 (K)</td>
<td>-3</td>
<td>3</td>
</tr>
<tr>
<td>0</td>
<td>-2</td>
<td>0</td>
</tr>
<tr>
<td>-3</td>
<td>-3</td>
<td>-3 (P)<br/><br/></td>
</tr>
</tbody>
</table>
<p>如果按我的那种算法走的路径为 1 -&gt; 0 -&gt; -2 -&gt; 0 -&gt; -3, 这样的话骑士的起始血量要为5，而正确的路径应为 1 -&gt; -3 -&gt; 3 -&gt; 0 -&gt; -3, 这样骑士的骑士血量只需为3。无奈只好上网看大神的解法，发现统一都是用<a href="http://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92" target="_blank">动态规划Dynamic Programming</a>来做，建立一个二维数组dp，其中dp[i][j]用来表示当前位置 (i, j) 出发的起始血量，最先处理的是公主所在的房间的起始生命值，然后慢慢向第一个房间扩散，不断的得到各个位置的最优的生命值。逆向推正是本题的精髓所在啊，仔细想想也是，如果从起始位置开始遍历，我们并不知道初始时应该初始化的血量，但是到达公主房间后，我们知道血量至少不能小于1，如果公主房间还需要掉血的话，那么掉血后剩1才能保证起始位置的血量最小。那么下面来推导状态转移方程，首先考虑每个位置的血量是由什么决定的，骑士会挂主要是因为去了下一个房间时，掉血量大于本身的血值，而能去的房间只有右边和下边，所以当前位置的血量是由右边和下边房间的可生存血量决定的，进一步来说，应该是由较小的可生存血量决定的，因为较我们需要起始血量尽可能的少，所以用较小的可生存血量减去当前房间的数字，如果是非正数的话，说明当前当前的房间数字是整数，那么当前房间的生存血量可以是1，所以我们的状态转移方程是dp[i][j] = max(1, min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j])。为了更好的处理边界情况，我们的二维dp数组比原数组的行数列数均多1个，先都初始化为整型数最大值INT_MAX，由于我们知道到达公主房间后，骑士火拼完的血量至少为1，那么此时公主房间的右边和下边房间里的数字我们就都设置为1，这样到达公主房间的生存血量就是1减去公主房间的数字和1相比较，取较大值，就没有问题了，代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> calculateMinimumHP(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> dungeon) {
        </span><span style="color: #0000ff;">int</span> m = dungeon.size(), n = dungeon[<span style="color: #800080;">0</span><span style="color: #000000;">].size();
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; dp(m + <span style="color: #800080;">1</span>, vector&lt;<span style="color: #0000ff;">int</span>&gt;(n + <span style="color: #800080;">1</span><span style="color: #000000;">, INT_MAX));
        dp[m][n </span>- <span style="color: #800080;">1</span>] = <span style="color: #800080;">1</span>; dp[m - <span style="color: #800080;">1</span>][n] = <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = m - <span style="color: #800080;">1</span>; i &gt;= <span style="color: #800080;">0</span>; --<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = n - <span style="color: #800080;">1</span>; j &gt;= <span style="color: #800080;">0</span>; --<span style="color: #000000;">j) {
                dp[i][j] </span>= max(<span style="color: #800080;">1</span>, min(dp[i + <span style="color: #800080;">1</span>][j], dp[i][j + <span style="color: #800080;">1</span>]) -<span style="color: #000000;"> dungeon[i][j]);
            }
        }
        </span><span style="color: #0000ff;">return</span> dp[<span style="color: #800080;">0</span>][<span style="color: #800080;">0</span><span style="color: #000000;">];
    }
};</span></pre>
</div>
<p> </p>
<p>我们可以对空间进行优化，使用一个一维的dp数组，并且不停的覆盖原有的值，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> calculateMinimumHP(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> dungeon) {
        </span><span style="color: #0000ff;">int</span> m = dungeon.size(), n = dungeon[<span style="color: #800080;">0</span><span style="color: #000000;">].size();
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; dp(n + <span style="color: #800080;">1</span><span style="color: #000000;">, INT_MAX);
        dp[n </span>- <span style="color: #800080;">1</span>] = <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = m - <span style="color: #800080;">1</span>; i &gt;= <span style="color: #800080;">0</span>; --<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = n - <span style="color: #800080;">1</span>; j &gt;= <span style="color: #800080;">0</span>; --<span style="color: #000000;">j) {
                dp[j] </span>= max(<span style="color: #800080;">1</span>, min(dp[j], dp[j + <span style="color: #800080;">1</span>]) -<span style="color: #000000;"> dungeon[i][j]);
            }
        }
        </span><span style="color: #0000ff;">return</span> dp[<span style="color: #800080;">0</span><span style="color: #000000;">];
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4353555.html" target="_blank">Unique Paths</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4353255.html" target="_blank">Minimum Path Sum</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/8215787.html">Cherry Pickup</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-01-19 09:40</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4233035" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4233035);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4231455.html" id="cb_post_title_url">[LeetCode] Binary Search Tree Iterator 二叉搜索树迭代器</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p>Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.</p>
<p>Calling <code>next()</code> will return the next smallest number in the BST.</p>
<p>Note: <code>next()</code> and <code>hasNext()</code> should run in average O(1) time and uses O(<em>h</em>) memory, where <em>h</em> is the height of the tree.</p>
<p>Credits:<br/>Special thanks to <a href="https://oj.leetcode.com/discuss/user/ts">@ts</a> for adding this problem and creating all test cases.</p>
<p> </p>
<p>这道题主要就是考二叉树的中序遍历的非递归形式，需要额外定义一个栈来辅助，二叉搜索树的建树规则就是左&lt;根&lt;右，用中序遍历即可从小到大取出所有节点。代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">/*</span><span style="color: #008000;">*
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> BSTIterator {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    BSTIterator(TreeNode </span>*<span style="color: #000000;">root) {
        </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> (root) {
            s.push(root);
            root </span>= root-&gt;<span style="color: #000000;">left;
        }
    }

    </span><span style="color: #008000;">/*</span><span style="color: #008000;">* @return whether we have a next smallest number </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">bool</span><span style="color: #000000;"> hasNext() {
        </span><span style="color: #0000ff;">return</span> !<span style="color: #000000;">s.empty();
    }

    </span><span style="color: #008000;">/*</span><span style="color: #008000;">* @return the next smallest number </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">int</span><span style="color: #000000;"> next() {
        TreeNode </span>*n =<span style="color: #000000;"> s.top();
        s.pop();
        </span><span style="color: #0000ff;">int</span> res = n-&gt;<span style="color: #000000;">val;
        </span><span style="color: #0000ff;">if</span> (n-&gt;<span style="color: #000000;">right) {
            n </span>= n-&gt;<span style="color: #000000;">right;
            </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> (n) {
                s.push(n);
                n </span>= n-&gt;<span style="color: #000000;">left;
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
</span><span style="color: #0000ff;">private</span><span style="color: #000000;">:
    stack</span>&lt;TreeNode*&gt;<span style="color: #000000;"> s;
};

</span><span style="color: #008000;">/*</span><span style="color: #008000;">*
 * Your BSTIterator will be called like this:
 * BSTIterator i = BSTIterator(root);
 * while (i.hasNext()) cout &lt;&lt; i.next();
 </span><span style="color: #008000;">*/</span></pre>
</div>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-01-18 08:33</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4231455" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4231455);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4219878.html" id="cb_post_title_url">[LeetCode] Factorial Trailing Zeroes 求阶乘末尾零的个数</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given an integer <em>n</em>, return the number of trailing zeroes in <em>n</em>!.</p>
<p>Note: Your solution should be in logarithmic time complexity.</p>
<p>Credits:<br/>Special thanks to <a href="https://oj.leetcode.com/discuss/user/ts">@ts</a> for adding this problem and creating all test cases.</p>
<p> </p>
<p>这道题并没有什么难度，是让求一个数的阶乘末尾0的个数，也就是要找乘数中10的个数，而10可分解为2和5，而我们可知2的数量又远大于5的数量，那么此题即便为找出5的个数。仍需注意的一点就是，像25,125，这样的不只含有一个5的数字需要考虑进去。代码如下：</p>
<p> </p>
<p>C++ 解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> trailingZeroes(<span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> (n) {
            res </span>+= n / <span style="color: #800080;">5</span><span style="color: #000000;">;
            n </span>/= <span style="color: #800080;">5</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>Java 解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public <span style="color: #0000ff;">class<span style="color: #000000;"> Solution {
    <span style="color: #0000ff;">public <span style="color: #0000ff;">int trailingZeroes(<span style="color: #0000ff;">int<span style="color: #000000;"> n) {
        <span style="color: #0000ff;">int res = 0<span style="color: #000000;">;
        <span style="color: #0000ff;">while (n &gt; 0<span style="color: #000000;">) {
            res += n / 5<span style="color: #000000;">;
            n /= 5<span style="color: #000000;">;
        }
        <span style="color: #0000ff;">return<span style="color: #000000;"> res;
    }
}</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre>
</div>
<p> </p>
<p>这题还有递归的解法，思路和上面完全一样，写法更简洁了，一行搞定碉堡了。</p>
<p> </p>
<p>C++ 解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> trailingZeroes(<span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        </span><span style="color: #0000ff;">return</span> n == <span style="color: #800080;">0</span> ? <span style="color: #800080;">0</span> : n / <span style="color: #800080;">5</span> + trailingZeroes(n / <span style="color: #800080;">5</span><span style="color: #000000;">);
    }
};</span></pre>
</div>
<p> </p>
<p>Java 解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span> trailingZeroes(<span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        </span><span style="color: #0000ff;">return</span> n == 0 ? 0 : n / 5 + trailingZeroes(n / 5<span style="color: #000000;">);
    }
}</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://leetcode.com/discuss/19855/my-one-line-solutions-in-3-languages" target="_blank">https://leetcode.com/discuss/19855/my-one-line-solutions-in-3-languages</a></p>
<p><a href="https://leetcode.com/discuss/44524/a-4ms-c-solution-using-method-in-wikipedia" target="_blank">https://leetcode.com/discuss/44524/a-4ms-c-solution-using-method-in-wikipedia</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-01-12 21:33</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4219878" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4219878);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4225316.html" id="cb_post_title_url">[LeetCode] Excel Sheet Column Number 求Excel表列序号</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<p>Given a column title as appear in an Excel sheet, return its corresponding column number.</p>
<p>For example:</p>
<pre>    A -&gt; 1
    B -&gt; 2
    C -&gt; 3
    ...
    Z -&gt; 26
    AA -&gt; 27
    AB -&gt; 28 </pre>
<p><strong>Credits:</strong><br/>Special thanks to <a href="https://oj.leetcode.com/discuss/user/ts">@ts</a> for adding this problem and creating all test cases.</p>
<p> </p>
<p>这题实际上相当于一种二十六进制转十进制的问题，并不难，只要一位一位的转换即可。代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> titleToNumber(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        </span><span style="color: #0000ff;">int</span> n =<span style="color: #000000;"> s.size();
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> tmp = <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = n; i &gt;= <span style="color: #800080;">1</span>; --<span style="color: #000000;">i) {
            res </span>+= (s[i - <span style="color: #800080;">1</span>] - <span style="color: #800000;">'</span><span style="color: #800000;">A</span><span style="color: #800000;">'</span> + <span style="color: #800080;">1</span>) *<span style="color: #000000;"> tmp; 
            tmp </span>*= <span style="color: #800080;">26</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-01-15 00:33</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4225316" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4225316);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5184143.html" id="cb_post_title_url">[LeetCode] Two Sum III - Data structure design 两数之和之三 - 数据结构设计</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Design and implement a TwoSum class. It should support the following operations:add and find.</p>
<p>add - Add the number to an internal data structure.<br/>find - Find if there exists any pair of numbers which sum is equal to the value.</p>
<p>For example,<br/>add(1); add(3); add(5);<br/>find(4) -&gt; true<br/>find(7) -&gt; false </p>
<p> </p>
<p>这道题让我们设计一个Two Sum的数据结构，跟LeetCode的第一道题<a href="http://www.cnblogs.com/grandyang/p/4130379.html" target="_blank">Two Sum</a>没有什么太大的不一样，作为LeetCode的首题，Two Sum的名气不小啊，正所谓平生不会TwoSum，刷尽LeetCode也枉然。记得原来在背单词的时候，总是记得第一个单词是abandon，结果有些人背来背去还在abandon，有时候想想刷题其实跟背GRE红宝书没啥太大的区别，都是一个熟练功夫，并不需要有多高的天赋，只要下足功夫，都能达到一个很不错的水平，套用一句鸡汤问来激励下吧，“有些时候我们的努力程度根本达不到需要拼天赋的地步”，好了，不闲扯了，来看题吧。不过这题也没啥可讲的，会做Two Sum的这题就很简单了，我们先来看用哈希表的解法，我们把每个数字和其出现的次数建立映射，然后我们遍历哈希表，对于每个值，我们先求出此值和目标值之间的差值t，然后我们需要分两种情况来看，如果当前值不等于差值t，那么只要哈希表中有差值t就返回True，或者是当差值t等于当前值时，如果此时哈希表的映射次数大于1，则表示哈希表中还有另一个和当前值相等的数字，二者相加就是目标值，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> TwoSum {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">void</span> add(<span style="color: #0000ff;">int</span><span style="color: #000000;"> number) {
        </span>++<span style="color: #000000;">m[number];
    }
    </span><span style="color: #0000ff;">bool</span> find(<span style="color: #0000ff;">int</span><span style="color: #000000;"> value) {
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto a : m) {
            </span><span style="color: #0000ff;">int</span> t = value -<span style="color: #000000;"> a.first;
            </span><span style="color: #0000ff;">if</span> ((t != a.first &amp;&amp; m.count(t)) || (t == a.first &amp;&amp; a.second &gt; <span style="color: #800080;">1</span><span style="color: #000000;">)) {
                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
            }
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
    }
</span><span style="color: #0000ff;">private</span><span style="color: #000000;">:
    unordered_map</span>&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> m;
};</span></pre>
</div>
<p> </p>
<p>另一种解法不用哈希表，而是unordered_multiset来做，但是原理和上面一样，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> TwoSum {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">void</span> add(<span style="color: #0000ff;">int</span><span style="color: #000000;"> number) {
        s.insert(number);
    }
    </span><span style="color: #0000ff;">bool</span> find(<span style="color: #0000ff;">int</span><span style="color: #000000;"> value) {
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto a : s) {
            </span><span style="color: #0000ff;">int</span> cnt = a == value - a ? <span style="color: #800080;">1</span> : <span style="color: #800080;">0</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> (s.count(value - a) &gt;<span style="color: #000000;"> cnt) {
                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
            }
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
    }
</span><span style="color: #0000ff;">private</span><span style="color: #000000;">:
    unordered_multiset</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> s;
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4130379.html" target="_blank">Two Sum</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://leetcode.com/discuss/59376/fast-and-concise-c-multiset-solution" target="_blank">https://leetcode.com/discuss/59376/fast-and-concise-c-multiset-solution</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-02-06 15:46</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5184143" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5184143);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4233501.html" id="cb_post_title_url">[LeetCode] Majority Element 求众数</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given an array of size <em>n</em>, find the majority element. The majority element is the element that appears more than <code>⌊ n/2 ⌋</code> times.</p>
<p>You may assume that the array is non-empty and the majority element always exist in the array.</p>
<p>Example 1:</p>
<pre>Input: [3,2,3]
Output: 3</pre>
<p>Example 2:</p>
<pre>Input: [2,2,1,1,1,2,2]
Output: 2</pre>
<p> </p>
<p>这是到求众数的问题，有很多种解法，其中我感觉比较好的有两种，一种是用哈希表，这种方法需要O(n)的时间和空间，另一种是用一种叫摩尔投票法 Moore Voting，需要O(n)的时间和O(1)的空间，比前一种方法更好。这种投票法先将第一个数字假设为众数，然后把计数器设为1，比较下一个数和此数是否相等，若相等则计数器加一，反之减一。然后看此时计数器的值，若为零，则将下一个值设为候选众数。以此类推直到遍历完整个数组，当前候选众数即为该数组的众数。不仔细弄懂摩尔投票法的精髓的话，过一阵子还是会忘记的，首先要明确的是这个叼炸天的方法是有前提的，就是数组中一定要有众数的存在才能使用，下面我们来看本算法的思路，这是一种先假设候选者，然后再进行验证的算法。我们现将数组中的第一个数假设为众数，然后进行统计其出现的次数，如果遇到同样的数，则计数器自增1，否则计数器自减1，如果计数器减到了0，则更换下一个数字为候选者。这是一个很巧妙的设定，也是本算法的精髓所在，为啥遇到不同的要计数器减1呢，为啥减到0了又要更换候选者呢？首先是有那个强大的前提存在，一定会有一个出现超过半数的数字存在，那么如果计数器减到0了话，说明目前不是候选者数字的个数已经跟候选者的出现个数相同了，那么这个候选者已经很weak，不一定能出现超过半数，我们选择更换当前的候选者。那有可能你会有疑问，那万一后面又大量的出现了之前的候选者怎么办，不需要担心，如果之前的候选者在后面大量出现的话，其又会重新变为候选者，直到最终验证成为正确的众数，佩服算法的提出者啊，代码如下：</p>
<p> </p>
<p>C++ 解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> majorityElement(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, cnt = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span><span style="color: #000000;"> num : nums) {
            </span><span style="color: #0000ff;">if</span> (cnt == <span style="color: #800080;">0</span>) {res = num; ++<span style="color: #000000;">cnt;}
            </span><span style="color: #0000ff;">else</span> (num == res) ? ++cnt : --<span style="color: #000000;">cnt;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>Java 解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span> majorityElement(<span style="color: #0000ff;">int</span><span style="color: #000000;">[] nums) {
        </span><span style="color: #0000ff;">int</span> res = 0, cnt = 0<span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span><span style="color: #000000;"> num : nums) {
            </span><span style="color: #0000ff;">if</span> (cnt == 0) {res = num; ++<span style="color: #000000;">cnt;}
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (num == res) ++<span style="color: #000000;">cnt;
            </span><span style="color: #0000ff;">else</span> --<span style="color: #000000;">cnt;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
}</span></pre>
</div>
<p> </p>
<p>下面这种解法利用到了位操作Bit Manipulation来解，将中位数按位来建立，从0到31位，每次统计下数组中该位上0和1的个数，如果1多，那么我们将结果res中该位变为1，最后累加出来的res就是中位数了，相当赞的方法，这种思路尤其在这道题的延伸<a href="http://www.cnblogs.com/grandyang/p/4606822.html" target="_blank">Majority Element II</a>中有重要的应用，参见代码如下：</p>
<p> </p>
<p>C++ 解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> majorityElement(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, n =<span style="color: #000000;"> nums.size();
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; <span style="color: #800080;">32</span>; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">int</span> ones = <span style="color: #800080;">0</span>, zeros = <span style="color: #800080;">0</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span><span style="color: #000000;"> num : nums) {
                </span><span style="color: #0000ff;">if</span> (ones &gt; n / <span style="color: #800080;">2</span> || zeros &gt; n / <span style="color: #800080;">2</span>) <span style="color: #0000ff;">break</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">if</span> ((num &amp; (<span style="color: #800080;">1</span> &lt;&lt; i)) != <span style="color: #800080;">0</span>) ++<span style="color: #000000;">ones;
                </span><span style="color: #0000ff;">else</span> ++<span style="color: #000000;">zeros;
            }
            </span><span style="color: #0000ff;">if</span> (ones &gt; zeros) res |= (<span style="color: #800080;">1</span> &lt;&lt;<span style="color: #000000;"> i);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>Java 解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span> majorityElement(<span style="color: #0000ff;">int</span><span style="color: #000000;">[] nums) {
        </span><span style="color: #0000ff;">int</span> res = 0, n =<span style="color: #000000;"> nums.length;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = 0; i &lt; 32; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">int</span> ones = 0, zeros = 0<span style="color: #000000;">;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span><span style="color: #000000;"> num : nums) {
                </span><span style="color: #0000ff;">if</span> (ones &gt; n / 2 || zeros &gt; n / 2) <span style="color: #0000ff;">break</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">if</span> ((num &amp; (1 &lt;&lt; i)) != 0) ++<span style="color: #000000;">ones;
                </span><span style="color: #0000ff;">else</span> ++<span style="color: #000000;">zeros;
            }
            </span><span style="color: #0000ff;">if</span> (ones &gt; zeros) res |= (1 &lt;&lt;<span style="color: #000000;"> i);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
}</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4606822.html" target="_blank">Majority Element II</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-01-19 12:54</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4233501" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4233501);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4227618.html" id="cb_post_title_url">[LeetCode] Excel Sheet Column Title 求Excel表列名称</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p>Given a positive integer, return its corresponding column title as appear in an Excel sheet.</p>
<p>For example:</p>
<pre>    1 -&gt; A
    2 -&gt; B
    3 -&gt; C
    ...
    26 -&gt; Z
    27 -&gt; AA
    28 -&gt; AB </pre>
<p><strong>Credits:</strong><br/>Special thanks to <a href="https://oj.leetcode.com/discuss/user/ifanchu">@ifanchu</a> for adding this problem and creating all test cases.</p>
<p> </p>
<p>此题和<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4225316.html" id="cb_post_title_url">Excel Sheet Column Number 求Excel表列序号</a><span class="postTitle2">是一起的，</span>但是我在这题上花的时间远比上面一道多，起始原理都一样，就是一位一位的求，此题从低位往高位求，每进一位，则把原数缩小26倍，再对26取余，之后减去余数，再缩小26倍，以此类推，可以求出各个位置上的字母。最后只需将整个字符串翻转一下即可。 代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> convertToTitle(<span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        </span><span style="color: #0000ff;">string</span> res = <span style="color: #800000;">""</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> (n) {
            </span><span style="color: #0000ff;">if</span> (n % <span style="color: #800080;">26</span> == <span style="color: #800080;">0</span><span style="color: #000000;">) {
                res </span>+= <span style="color: #800000;">'</span><span style="color: #800000;">Z</span><span style="color: #800000;">'</span><span style="color: #000000;">;
                n </span>-= <span style="color: #800080;">26</span><span style="color: #000000;">;
            }
            </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                res </span>+= n%<span style="color: #800080;">26</span> - <span style="color: #800080;">1</span> + <span style="color: #800000;">'</span><span style="color: #800000;">A</span><span style="color: #800000;">'</span><span style="color: #000000;">;
                n </span>-= n%<span style="color: #800080;">26</span><span style="color: #000000;">;
            }
            n </span>/= <span style="color: #800080;">26</span><span style="color: #000000;">;
        }
        reverse(res.begin(), res.end());
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>然后我们可以写的更简洁一些：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> Non-recursion</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> convertToTitle(<span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        </span><span style="color: #0000ff;">string</span><span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> (n) {
            res </span>+= --n % <span style="color: #800080;">26</span> + <span style="color: #800000;">'</span><span style="color: #800000;">A</span><span style="color: #800000;">'</span><span style="color: #000000;">;
            n </span>/= <span style="color: #800080;">26</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">string</span><span style="color: #000000;">(res.rbegin(), res.rend());
    }
};</span></pre>
</div>
<p> </p>
<p>这道题还可以用递归来解，而且可以丧心病狂的压缩到一行代码来解：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> convertToTitle(<span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        </span><span style="color: #0000ff;">return</span> n == <span style="color: #800080;">0</span> ? <span style="color: #800000;">""</span> : convertToTitle(n / <span style="color: #800080;">26</span>) + (<span style="color: #0000ff;">char</span>)(--n % <span style="color: #800080;">26</span> + <span style="color: #800000;">'</span><span style="color: #800000;">A</span><span style="color: #800000;">'</span><span style="color: #000000;">);
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4225316.html" id="cb_post_title_url">Excel Sheet Column Number</a></p>
<p> </p>
<p>参考资料：</p>
<p class="p1"><span class="s1"><a href="https://leetcode.com/discuss/19024/simple-c-code">https://leetcode.com/discuss/19024/simple-c-code</a></span></p>
<p class="p1"><span class="s1"><a href="https://leetcode.com/discuss/19047/my-1-lines-code-in-java-c-and-python">https://leetcode.com/discuss/19047/my-1-lines-code-in-java-c-and-python</a></span></p>
<p class="p1"> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-01-16 07:22</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4227618" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4227618);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5185815.html" id="cb_post_title_url">[LeetCode] Two Sum II - Input array is sorted 两数之和之二 - 输入数组有序</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number.<br/>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.<br/>You may assume that each input would have exactly one solution.<br/>Input: numbers={2, 7, 11, 15}, target=9<br/>Output: index1=1, index2=2 </p>
<p> </p>
<p>这又是一道<a href="http://www.cnblogs.com/grandyang/p/4130379.html" target="_blank">Two Sum</a>的衍生题，作为LeetCode开山之题，我们务必要把Two Sum及其所有的衍生题都拿下，这道题其实应该更容易一些，因为给定的数组是有序的，而且题目中限定了一定会有解，我最开始想到的方法是二分法来搜索，因为一定有解，而且数组是有序的，那么第一个数字肯定要小于目标值target，那么我们每次用二分法来搜索target - numbers[i]即可，代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> O(nlgn)</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; twoSum(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; numbers, <span style="color: #0000ff;">int</span><span style="color: #000000;"> target) {
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; numbers.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">int</span> t = target - numbers[i], left = i + <span style="color: #800080;">1</span>, right = numbers.size()<span style="color: #000000;">;
            </span><span style="color: #0000ff;">while</span> (left &lt;<span style="color: #000000;"> right) {
                </span><span style="color: #0000ff;">int</span> mid = left + (right - left) / <span style="color: #800080;">2</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">if</span> (numbers[mid] == t) <span style="color: #0000ff;">return</span> {i + <span style="color: #800080;">1</span>, mid + <span style="color: #800080;">1</span><span style="color: #000000;">};
                </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (numbers[mid] &lt; t) left = mid + <span style="color: #800080;">1</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">else</span> right =<span style="color: #000000;"> mid;
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> {};
    }
};</span></pre>
</div>
<p> </p>
<p>但是上面那种方法并不efficient，时间复杂度是O(nlgn)，我们再来看一种O(n)的解法，我们只需要两个指针，一个指向开头，一个指向末尾，然后向中间遍历，如果指向的两个数相加正好等于target的话，直接返回两个指针的位置即可，若小于target，左指针右移一位，若大于target，右指针左移一位，以此类推直至两个指针相遇停止，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> O(n)</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; twoSum(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; numbers, <span style="color: #0000ff;">int</span><span style="color: #000000;"> target) {
        </span><span style="color: #0000ff;">int</span> l = <span style="color: #800080;">0</span>, r = numbers.size() - <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (l &lt;<span style="color: #000000;"> r) {
            </span><span style="color: #0000ff;">int</span> sum = numbers[l] +<span style="color: #000000;"> numbers[r];
            </span><span style="color: #0000ff;">if</span> (sum == target) <span style="color: #0000ff;">return</span> {l + <span style="color: #800080;">1</span>, r + <span style="color: #800080;">1</span><span style="color: #000000;">};
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (sum &lt; target) ++<span style="color: #000000;">l;
            </span><span style="color: #0000ff;">else</span> --<span style="color: #000000;">r;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> {};
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/5184143.html" id="homepage1_HomePageDays_DaysList_ctl03_DayList_TitleUrl_0">Two Sum III - Data structure design</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4130379.html" target="_blank">Two Sum</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-02-10 00:33</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5185815" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5185815);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4238577.html" id="cb_post_title_url">[LeetCode] Fraction to Recurring Decimal 分数转循环小数</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given two integers representing the numerator and denominator of a fraction, return the fraction in string format.</p>
<p>If the fractional part is repeating, enclose the repeating part in parentheses.</p>
<p>For example,</p>
<ul>
<li>Given numerator = 1, denominator = 2, return "0.5".</li>
<li>Given numerator = 2, denominator = 1, return "2".</li>
<li>Given numerator = 2, denominator = 3, return "0.(6)".</li>
</ul>
<p><strong>Credits:</strong><br/>Special thanks to <a href="https://oj.leetcode.com/discuss/user/Shangrila">@Shangrila</a> for adding this problem and creating all test cases.</p>
<p> </p>
<p>这道题还是比较有意思的，开始还担心万一结果是无限不循环小数怎么办，百度之后才发现原来可以写成分数的都是有理数，而有理数要么是有限的，要么是无限循环小数，无限不循环的叫无理数，例如圆周率pi或自然数e等，小学数学没学好，汗！由于还存在正负情况，处理方式是按正数处理，符号最后在判断，那么我们需要把除数和被除数取绝对值，那么问题就来了：由于整型数INT的取值范围是-2147483648～2147483647，而对-2147483648取绝对值就会超出范围，所以我们需要先转为long long型再取绝对值。那么怎么样找循环呢，肯定是再得到一个数字后要看看之前有没有出现这个数。为了节省搜索时间，我们采用哈希表来存数每个小数位上的数字。还有一个小技巧，由于我们要算出小数每一位，采取的方法是每次把余数乘10，再除以除数，得到的商即为小数的下一位数字。等到新算出来的数字在之前出现过，则在循环开始出加左括号，结束处加右括号。代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> fractionToDecimal(<span style="color: #0000ff;">int</span> numerator, <span style="color: #0000ff;">int</span><span style="color: #000000;"> denominator) {
        </span><span style="color: #0000ff;">int</span> s1 = numerator &gt;= <span style="color: #800080;">0</span> ? <span style="color: #800080;">1</span> : -<span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> s2 = denominator &gt;= <span style="color: #800080;">0</span> ? <span style="color: #800080;">1</span> : -<span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">long</span> <span style="color: #0000ff;">long</span> num = abs( (<span style="color: #0000ff;">long</span> <span style="color: #0000ff;">long</span><span style="color: #000000;">)numerator );
        </span><span style="color: #0000ff;">long</span> <span style="color: #0000ff;">long</span> den = abs( (<span style="color: #0000ff;">long</span> <span style="color: #0000ff;">long</span><span style="color: #000000;">)denominator );
        </span><span style="color: #0000ff;">long</span> <span style="color: #0000ff;">long</span> <span style="color: #0000ff;">out</span> = num /<span style="color: #000000;"> den;
        </span><span style="color: #0000ff;">long</span> <span style="color: #0000ff;">long</span> rem = num %<span style="color: #000000;"> den;
        unordered_map</span>&lt;<span style="color: #0000ff;">long</span> <span style="color: #0000ff;">long</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> m;
        </span><span style="color: #0000ff;">string</span> res = to_string(<span style="color: #0000ff;">out</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">if</span> (s1 * s2 == -<span style="color: #800080;">1</span> &amp;&amp; (<span style="color: #0000ff;">out</span> &gt; <span style="color: #800080;">0</span> || rem &gt; <span style="color: #800080;">0</span>)) res = <span style="color: #800000;">"</span><span style="color: #800000;">-</span><span style="color: #800000;">"</span> +<span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">if</span> (rem == <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
        res </span>+= <span style="color: #800000;">"</span><span style="color: #800000;">.</span><span style="color: #800000;">"</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">string</span> s = <span style="color: #800000;">""</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> pos = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (rem != <span style="color: #800080;">0</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">if</span> (m.find(rem) !=<span style="color: #000000;"> m.end()) {
                s.insert(m[rem], </span><span style="color: #800000;">"</span><span style="color: #800000;">(</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                s </span>+= <span style="color: #800000;">"</span><span style="color: #800000;">)</span><span style="color: #800000;">"</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">return</span> res +<span style="color: #000000;"> s;
            }
            m[rem] </span>=<span style="color: #000000;"> pos;
            s </span>+= to_string((rem * <span style="color: #800080;">10</span>) /<span style="color: #000000;"> den);
            rem </span>= (rem * <span style="color: #800080;">10</span>) %<span style="color: #000000;"> den;
            </span>++<span style="color: #000000;">pos;
        }
        </span><span style="color: #0000ff;">return</span> res +<span style="color: #000000;"> s;
    }
};</span></pre>
</div>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-01-21 12:49</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4238577" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4238577);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4244123.html" id="cb_post_title_url">[LeetCode] Compare Version Numbers 版本比较</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p>Compare two version numbers <em>version1</em> and <em>version1</em>.<br/>If <em>version1</em> &gt; <em>version2</em> return 1, if <em>version1</em> &lt; <em>version2</em> return -1, otherwise return 0.</p>
<p>You may assume that the version strings are non-empty and contain only digits and the <code>.</code> character.<br/>The <code>.</code> character does not represent a decimal point and is used to separate number sequences.<br/>For instance, <code>2.5</code> is not "two and a half" or "half way to version three", it is the fifth second-level revision of the second first-level revision.</p>
<p>Here is an example of version numbers ordering:</p>
<pre>0.1 &lt; 1.1 &lt; 1.2 &lt; 13.37</pre>
<p>Credits:<br/>Special thanks to <a href="https://oj.leetcode.com/discuss/user/ts">@ts</a> for adding this problem and creating all test cases.</p>
<p> </p>
<p>这道题调试了好久，一直不想上网搜别人的解法，因为感觉自己可以做出来，改来改去最后终于通过了，再上网一搜，发现果然和别人的方法不同，小有成就感。我的思路是：由于两个版本号所含的小数点个数不同，有可能是1和1.1.1比较，还有可能开头有无效0，比如01和1就是相同版本，还有可能末尾无效0，比如1.0和1也是同一版本。对于没有小数点的数字，可以默认为最后一位是小数点，而版本号比较的核心思想是相同位置的数字比较，比如题目给的例子，1.2和13.37比较，我们都知道应该显示1和13比较，13比1大，所以后面的不用再比了，再比如1.1和1.2比较，前面都是1，则比较小数点后面的数字。那么算法就是每次对应取出相同位置的小数点之前所有的字符，把他们转为数字比较，若不同则可直接得到答案，若相同，再对应往下取。如果一个数字已经没有小数点了，则默认取出为0，和另一个比较，这样也解决了末尾无效0的情况。代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> compareVersion(<span style="color: #0000ff;">string</span> version1, <span style="color: #0000ff;">string</span><span style="color: #000000;"> version2) {
        </span><span style="color: #0000ff;">int</span> n1 = version1.size(), n2 =<span style="color: #000000;"> version2.size();
        </span><span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>, j = <span style="color: #800080;">0</span>, d1 = <span style="color: #800080;">0</span>, d2 = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">string</span><span style="color: #000000;"> v1, v2;
        </span><span style="color: #0000ff;">while</span> (i &lt; n1 || j &lt;<span style="color: #000000;"> n2) {
            </span><span style="color: #0000ff;">while</span> (i &lt; n1 &amp;&amp; version1[i] != <span style="color: #800000;">'</span><span style="color: #800000;">.</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                v1.push_back(version1[i</span>++<span style="color: #000000;">]);
            }
            d1 </span>=<span style="color: #000000;"> atoi(v1.c_str());
            </span><span style="color: #0000ff;">while</span> (j &lt; n2 &amp;&amp; version2[j] != <span style="color: #800000;">'</span><span style="color: #800000;">.</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                v2.push_back(version2[j</span>++<span style="color: #000000;">]);
            }
            d2 </span>=<span style="color: #000000;"> atoi(v2.c_str());
            </span><span style="color: #0000ff;">if</span> (d1 &gt; d2) <span style="color: #0000ff;">return</span> <span style="color: #800080;">1</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (d1 &lt; d2) <span style="color: #0000ff;">return</span> -<span style="color: #800080;">1</span><span style="color: #000000;">;
            v1.clear(); v2.clear();
            </span>++i; ++<span style="color: #000000;">j;
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p><br/>当然我们也可以不使用将字符串转为整型的atoi函数，我们可以一位一位的累加，参加如下代码：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> compareVersion(<span style="color: #0000ff;">string</span> version1, <span style="color: #0000ff;">string</span><span style="color: #000000;"> version2) {
        </span><span style="color: #0000ff;">int</span> n1 = version1.size(), n2 =<span style="color: #000000;"> version2.size();
        </span><span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>, j = <span style="color: #800080;">0</span>, d1 = <span style="color: #800080;">0</span>, d2 = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (i &lt; n1 || j &lt;<span style="color: #000000;"> n2) {
            </span><span style="color: #0000ff;">while</span> (i &lt; n1 &amp;&amp; version1[i] != <span style="color: #800000;">'</span><span style="color: #800000;">.</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                d1 </span>= d1 * <span style="color: #800080;">10</span> + version1[i++] - <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span><span style="color: #000000;">;
            }
            </span><span style="color: #0000ff;">while</span> (j &lt; n2 &amp;&amp; version2[j] != <span style="color: #800000;">'</span><span style="color: #800000;">.</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                d2 </span>= d2 * <span style="color: #800080;">10</span> + version2[j++] - <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span><span style="color: #000000;">;
            }
            </span><span style="color: #0000ff;">if</span> (d1 &gt; d2) <span style="color: #0000ff;">return</span> <span style="color: #800080;">1</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (d1 &lt; d2) <span style="color: #0000ff;">return</span> -<span style="color: #800080;">1</span><span style="color: #000000;">;
            d1 </span>= d2 = <span style="color: #800080;">0</span><span style="color: #000000;">;
            </span>++i; ++<span style="color: #000000;">j;
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>由于这道题我们需要将版本号以’.'分开，那么我们可以借用强大的字符串流stringstream的功能来实现分段和转为整数，使用这种方法写的代码很简洁，如下所示：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> compareVersion(<span style="color: #0000ff;">string</span> version1, <span style="color: #0000ff;">string</span><span style="color: #000000;"> version2) {
        istringstream v1(version1 </span>+ <span style="color: #800000;">"</span><span style="color: #800000;">.</span><span style="color: #800000;">"</span>), v2(version2 + <span style="color: #800000;">"</span><span style="color: #800000;">.</span><span style="color: #800000;">"</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">int</span> d1 = <span style="color: #800080;">0</span>, d2 = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">char</span> dot = <span style="color: #800000;">'</span><span style="color: #800000;">.</span><span style="color: #800000;">'</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (v1.good() ||<span style="color: #000000;"> v2.good()) {
            </span><span style="color: #0000ff;">if</span> (v1.good()) v1 &gt;&gt; d1 &gt;&gt;<span style="color: #000000;"> dot;
            </span><span style="color: #0000ff;">if</span> (v2.good()) v2 &gt;&gt; d2 &gt;&gt;<span style="color: #000000;"> dot;
            </span><span style="color: #0000ff;">if</span> (d1 &gt; d2) <span style="color: #0000ff;">return</span> <span style="color: #800080;">1</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (d1 &lt; d2) <span style="color: #0000ff;">return</span> -<span style="color: #800080;">1</span><span style="color: #000000;">;
            d1 </span>= d2 = <span style="color: #800080;">0</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>最后我们来看一种用C语言的字符串指针来实现的方法，这个方法的关键是用到将字符串转为长整型的strtol函数，关于此函数的用法可以参见我的另一篇博客<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4966132.html" id="homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0">strtol 函数用法</a>。参见代码如下：</p>
<p> </p>
<p>解法四：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> compareVersion(<span style="color: #0000ff;">string</span> version1, <span style="color: #0000ff;">string</span><span style="color: #000000;"> version2) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">char</span> *v1 = (<span style="color: #0000ff;">char</span>*)version1.c_str(), *v2 = (<span style="color: #0000ff;">char</span>*<span style="color: #000000;">)version2.c_str();
        </span><span style="color: #0000ff;">while</span> (res == <span style="color: #800080;">0</span> &amp;&amp; (*v1 != <span style="color: #800000;">'</span><span style="color: #800000;">\0</span><span style="color: #800000;">'</span> || *v2 != <span style="color: #800000;">'</span><span style="color: #800000;">\0</span><span style="color: #800000;">'</span><span style="color: #000000;">)) {
            </span><span style="color: #0000ff;">long</span> d1 = *v1 == <span style="color: #800000;">'</span><span style="color: #800000;">\0</span><span style="color: #800000;">'</span> ? <span style="color: #800080;">0</span> : strtol(v1, &amp;v1, <span style="color: #800080;">10</span><span style="color: #000000;">);
            </span><span style="color: #0000ff;">long</span> d2 = *v2 == <span style="color: #800000;">'</span><span style="color: #800000;">\0</span><span style="color: #800000;">'</span> ? <span style="color: #800080;">0</span> : strtol(v2, &amp;v2, <span style="color: #800080;">10</span><span style="color: #000000;">);
            </span><span style="color: #0000ff;">if</span> (d1 &gt; d2) <span style="color: #0000ff;">return</span> <span style="color: #800080;">1</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (d1 &lt; d2) <span style="color: #0000ff;">return</span> -<span style="color: #800080;">1</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                </span><span style="color: #0000ff;">if</span> (*v1 != <span style="color: #800000;">'</span><span style="color: #800000;">\0</span><span style="color: #800000;">'</span>) ++<span style="color: #000000;">v1;
                </span><span style="color: #0000ff;">if</span> (*v2 != <span style="color: #800000;">'</span><span style="color: #800000;">\0</span><span style="color: #800000;">'</span>) ++<span style="color: #000000;">v2;
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4790469.html" target="_blank">First Bad Version</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://leetcode.com/discuss/30652/my-2ms-easy-solution-with-c-c" target="_blank">https://leetcode.com/discuss/30652/my-2ms-easy-solution-with-c-c</a></p>
<p><a href="https://leetcode.com/discuss/32731/java-solution-with-fewer-if-logic" target="_blank">https://leetcode.com/discuss/32731/java-solution-with-fewer-if-logic</a></p>
<p><a href="https://leetcode.com/discuss/56653/solution-lines-clean-coding-using-istringstream-read-input" target="_blank">https://leetcode.com/discuss/56653/solution-lines-clean-coding-using-istringstream-read-input</a></p>
<p><a href="https://leetcode.com/discuss/18756/runtime-easy-understand-solution-with-algorithm-description" target="_blank">https://leetcode.com/discuss/18756/runtime-easy-understand-solution-with-algorithm-description</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-01-23 14:22</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4244123" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4244123);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4234970.html" id="cb_post_title_url">[LeetCode] Maximum Gap 求最大间距</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given an unsorted array, find the maximum difference between the successive elements in its sorted form.</p>
<p>Return 0 if the array contains less than 2 elements.</p>
<p>Example 1:</p>
<pre>Input: [3,6,9,1]
Output: 3
Explanation: The sorted form of the array is [1,3,6,9], either
             (3,6) or (6,9) has the maximum difference 3.</pre>
<p>Example 2:</p>
<pre>Input: [10]
Output: 0
Explanation: The array contains less than 2 elements, therefore return 0.</pre>
<p>Note:</p>
<ul>
<li>You may assume all elements in the array are non-negative integers and fit in the 32-bit signed integer range.</li>
<li>Try to solve it in linear time/space.</li>
</ul>
<p> </p>
<p>遇到这类问题肯定先想到的是要给数组排序，但是题目要求是要线性的时间和空间，那么只能用桶排序或者基排序。这里我用桶排序Bucket Sort来做，首先找出数组的最大值和最小值，然后要确定每个桶的容量，即为(最大值 - 最小值) / 个数 + 1，在确定桶的个数，即为(最大值 - 最小值) / 桶的容量 + 1，然后需要在每个桶中找出局部最大值和最小值，而最大间距的两个数不会在同一个桶中，而是一个桶的最小值和另一个桶的最大值之间的间距。代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> maximumGap(vector&lt;<span style="color: #0000ff;">int</span>&gt; &amp;<span style="color: #000000;">numss) {
        </span><span style="color: #0000ff;">if</span> (numss.empty()) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> mx = INT_MIN, mn = INT_MAX, n =<span style="color: #000000;"> numss.size();
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span><span style="color: #000000;"> d : numss) {
            mx </span>=<span style="color: #000000;"> max(mx, d);
            mn </span>=<span style="color: #000000;"> min(mn, d);
        }
        </span><span style="color: #0000ff;">int</span> size = (mx - mn) / n + <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> bucket_nums = (mx - mn) / size + <span style="color: #800080;">1</span><span style="color: #000000;">;
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> bucket_min(bucket_nums, INT_MAX);
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> bucket_max(bucket_nums, INT_MIN);
        </span><span style="color: #0000ff;">set</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> s;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span><span style="color: #000000;"> d : numss) {
            </span><span style="color: #0000ff;">int</span> idx = (d - mn) /<span style="color: #000000;"> size;
            bucket_min[idx] </span>=<span style="color: #000000;"> min(bucket_min[idx], d);
            bucket_max[idx] </span>=<span style="color: #000000;"> max(bucket_max[idx], d);
            s.insert(idx);
        }
        </span><span style="color: #0000ff;">int</span> pre = <span style="color: #800080;">0</span>, res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (!s.count(i)) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
            res </span>= max(res, bucket_min[i] -<span style="color: #000000;"> bucket_max[pre]);
            pre </span>=<span style="color: #000000;"> i;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="http://blog.csdn.net/u011345136/article/details/41963051" target="_blank">http://blog.csdn.net/u011345136/article/details/41963051</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-01-19 22:49</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4234970" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4234970);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5184890.html" id="cb_post_title_url">[LeetCode] Missing Ranges 缺失区间</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a sorted integer array where the range of elements are [0, 99] inclusive, return its missing ranges.<br/>For example, given [0, 1, 3, 50, 75], return [“2”, “4-&gt;49”, “51-&gt;74”, “76-&gt;99”] </p>
<p> </p>
<p>这道题让我们求缺失区间，跟之前那道<a href="http://www.cnblogs.com/grandyang/p/4603555.html" target="_blank">Summary Ranges</a>很类似，这道题让我们求缺失的空间，给了一个空间的范围[lower upper]，缺失的空间的范围需要在给定的空间范围内。我们首先将lower赋给l，然后开始遍历nums数组，如果i小于nums长度且当前数字小于等于upper，我们让r等于当前数字，否则如果<span style="line-height: 1.5;">当i等于nums的长度时或者当前数字大于upper时，将r赋为upper+1。然后判断l和r的值，若相同，l自增1，否则当r大于l时，说明缺失空间存在，我们看l和r是否差1，如果是，说明只缺失了一个数字，若不是，则说明缺失了一个区间，我们分别加上数字或者区间即可，参见代码如下：</span></p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; findMissingRanges(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; nums, <span style="color: #0000ff;">int</span> lower, <span style="color: #0000ff;">int</span><span style="color: #000000;"> upper) {
        vector</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">int</span> l =<span style="color: #000000;"> lower;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt;= nums.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">int</span> r = (i &lt; nums.size() &amp;&amp; nums[i] &lt;= upper) ? nums[i] : upper + <span style="color: #800080;">1</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> (l == r) ++<span style="color: #000000;">l;
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (r &gt;<span style="color: #000000;"> l) {
                res.push_back(r </span>- l == <span style="color: #800080;">1</span> ? to_string(l) : to_string(l) + <span style="color: #800000;">"</span><span style="color: #800000;">-&gt;</span><span style="color: #800000;">"</span> + to_string(r - <span style="color: #800080;">1</span><span style="color: #000000;">));
                l </span>= r + <span style="color: #800080;">1</span><span style="color: #000000;">;
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4603555.html" target="_blank">Summary Ranges</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://leetcode.com/discuss/29206/my-concise-java-accepted-solution" target="_blank">https://leetcode.com/discuss/29206/my-concise-java-accepted-solution</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p>
<p> </p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-02-08 07:21</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5184890" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5184890);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4217175.html" id="cb_post_title_url">[LeetCode] Find Peak Element 求数组的局部峰值</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>A peak element is an element that is greater than its neighbors.</p>
<p>Given an input array <code>nums</code>, where <code>nums[i] ≠ nums[i+1]</code>, find a peak element and return its index.</p>
<p>The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.</p>
<p>You may imagine that <code>nums[-1] = nums[n] = -∞</code>.</p>
<p>Example 1:</p>
<pre>Input: nums = <code>[1,2,3,1]</code>
Output: 2
Explanation: 3 is a peak element and your function should return the index number 2.</pre>
<p>Example 2:</p>
<pre>Input: nums = <code>[</code>1,2,1,3,5,6,4]
Output: 1 or 5 
Explanation: Your function can return either index number 1 where the peak element is 2, 
             or index number 5 where the peak element is 6.
</pre>
<p>Note:</p>
<p>Your solution should be in logarithmic complexity.</p>
<p> </p>
<p>这道题是求数组的一个峰值，如果这里用遍历整个数组找最大值肯定会出现Time Limit Exceeded，但题目中说了这个峰值可以是局部的最大值，所以我们只需要找到第一个局部峰值就可以了。所谓峰值就是比周围两个数字都大的数字，那么只需要跟周围两个数字比较就可以了。既然要跟左右的数字比较，就得考虑越界的问题，题目中给了nums[-1] = nums[n] = -∞，那么我们其实可以把这两个整型最小值直接加入到数组中，然后从第二个数字遍历到倒数第二个数字，这样就不会存在越界的可能了。由于题目中说了峰值一定存在，那么有一个很重要的corner case我们要注意，就是当原数组中只有一个数字，且是整型最小值的时候，我们如果还要首尾垫数字，就会形成一条水平线，从而没有峰值了，所以我们对于数组中只有一个数字的情况在开头直接判断一下即可，参见代码如下：</p>
<p> </p>
<p>C++ 解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> findPeakElement(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        </span><span style="color: #0000ff;">if</span> (nums.size() == <span style="color: #800080;">1</span>) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        nums.insert(nums.begin(), INT_MIN);
        nums.push_back(INT_MIN);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt; (<span style="color: #0000ff;">int</span>)nums.size() - <span style="color: #800080;">1</span>; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (nums[i] &gt; nums[i - <span style="color: #800080;">1</span>] &amp;&amp; nums[i] &gt; nums[i + <span style="color: #800080;">1</span>]) <span style="color: #0000ff;">return</span> i - <span style="color: #800080;">1</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> -<span style="color: #800080;">1</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p><span style="line-height: 1.5;"> </span></p>
<p>Java 解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span> findPeakElement(<span style="color: #0000ff;">int</span><span style="color: #000000;">[] nums) {
        </span><span style="color: #0000ff;">if</span> (nums.length == 1) <span style="color: #0000ff;">return</span> 0<span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span>[] newNums = <span style="color: #0000ff;">new</span> <span style="color: #0000ff;">int</span>[nums.length + 2<span style="color: #000000;">];
        System.arraycopy(nums, </span>0, newNums, 1<span style="color: #000000;">, nums.length);
        newNums[</span>0] =<span style="color: #000000;"> Integer.MIN_VALUE;
        newNums[newNums.length </span>- 1] =<span style="color: #000000;"> Integer.MIN_VALUE;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = 1; i &lt; newNums.length - 1; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (newNums[i] &gt; newNums[i - 1] &amp;&amp; newNums[i] &gt; newNums[i + 1]) <span style="color: #0000ff;">return</span> i - 1<span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> -1<span style="color: #000000;">;
    }
}</span></pre>
</div>
<p> </p>
<p>我们可以对上面的线性扫描的方法进行一些优化，可以省去首尾垫值的步骤。由于题目中说明了局部峰值一定存在，那么实际上可以从第二个数字开始往后遍历，如果第二个数字比第一个数字小，说明此时第一个数字就是一个局部峰值；否则就往后继续遍历，现在是个递增趋势，如果此时某个数字小于前面那个数字，说明前面数字就是一个局部峰值，返回位置即可。如果循环结束了，说明原数组是个递增数组，返回最后一个位置即可，参见代码如下：</p>
<p> </p>
<p><span style="line-height: 1.5;">C++ 解法二：</span></p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> findPeakElement(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt; nums.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (nums[i] &lt; nums[i - <span style="color: #800080;">1</span>]) <span style="color: #0000ff;">return</span> i - <span style="color: #800080;">1</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> nums.size() - <span style="color: #800080;">1</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p>   </p>
<p>Java 解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span> findPeakElement(<span style="color: #0000ff;">int</span><span style="color: #000000;">[] nums) {
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = 1; i &lt; nums.length; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (nums[i] &lt; nums[i - 1]) <span style="color: #0000ff;">return</span> i - 1<span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> nums.length - 1<span style="color: #000000;">;
    }
}</span></pre>
</div>
<p> </p>
<p>由于题目中提示了要用对数级的时间复杂度，那么我们就要考虑使用类似于二分查找法来缩短时间，由于只是需要找到任意一个峰值，那么我们在确定二分查找折半后中间那个元素后，和紧跟的那个元素比较下大小，如果大于，则说明峰值在前面，如果小于则在后面。这样就可以找到一个峰值了，代码如下：</p>
<p> </p>
<p>C++ 解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> findPeakElement(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        </span><span style="color: #0000ff;">int</span> left = <span style="color: #800080;">0</span>, right = nums.size() - <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (left &lt;<span style="color: #000000;"> right) {
            </span><span style="color: #0000ff;">int</span> mid = left + (right - left) / <span style="color: #800080;">2</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> (nums[mid] &lt; nums[mid + <span style="color: #800080;">1</span>]) left = mid + <span style="color: #800080;">1</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">else</span> right =<span style="color: #000000;"> mid;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> right;
    }
};</span></pre>
</div>
<p> </p>
<p>Java 解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span> findPeakElement(<span style="color: #0000ff;">int</span><span style="color: #000000;">[] nums) {
        </span><span style="color: #0000ff;">int</span> left = <span style="color: #800080;">0</span>, right = nums.length - <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (left &lt;<span style="color: #000000;"> right) {
            </span><span style="color: #0000ff;">int</span> mid = left + (right - left) / <span style="color: #800080;">2</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> (nums[mid] &lt; nums[mid + <span style="color: #800080;">1</span>]) left = mid + <span style="color: #800080;">1</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">else</span> right =<span style="color: #000000;"> mid;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> right;
    }
}</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p>Peak Index in a Mountain Array</p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-01-11 21:53</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4217175" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4217175);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5184698.html" id="cb_post_title_url">[LeetCode] One Edit Distance 一个编辑距离</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given two strings S and T, determine if they are both one edit distance apart.</p>
<p> </p>
<p>这道题是之前那道<a href="http://www.cnblogs.com/grandyang/p/4344107.html" target="_blank">Edit Distance</a>的拓展，然而这道题并没有那道题难，这道题只让我们判断两个字符串的编辑距离是否为1，那么我们只需分下列三种情况来考虑就行了：<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url"><br/></a></p>
<p>1. 两个字符串的长度之差大于1，那么直接返回False</p>
<p>2. 两个字符串的长度之差等于1，那么长的那个字符串去掉一个字符，剩下的应该和短的字符串相同</p>
<p>3. 两个字符串的长度之差等于0，那么两个字符串对应位置的字符只能有一处不同。</p>
<p>分析清楚了所有的情况，代码就很好写了，参见如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> isOneEditDistance(<span style="color: #0000ff;">string</span> s, <span style="color: #0000ff;">string</span><span style="color: #000000;"> t) {
        </span><span style="color: #0000ff;">if</span> (s.size() &lt;<span style="color: #000000;"> t.size()) swap(s, t);
        </span><span style="color: #0000ff;">int</span> m = s.size(), n = t.size(), diff = m -<span style="color: #000000;"> n;
        </span><span style="color: #0000ff;">if</span> (diff &gt;= <span style="color: #800080;">2</span>) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (diff == <span style="color: #800080;">1</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
                </span><span style="color: #0000ff;">if</span> (s[i] !=<span style="color: #000000;"> t[i]) {
                    </span><span style="color: #0000ff;">return</span> s.substr(i + <span style="color: #800080;">1</span>) ==<span style="color: #000000;"> t.substr(i);
                }
            }
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            </span><span style="color: #0000ff;">int</span> cnt = <span style="color: #800080;">0</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; m; ++<span style="color: #000000;">i) {
                </span><span style="color: #0000ff;">if</span> (s[i] != t[i]) ++<span style="color: #000000;">cnt;
            }
            </span><span style="color: #0000ff;">return</span> cnt == <span style="color: #800080;">1</span><span style="color: #000000;">;
        }
    }
};</span></pre>
</div>
<p> </p>
<p>我们实际上可以让代码写的更加简洁，只需要对比两个字符串对应位置上的字符，如果遇到不同的时候，这时我们看两个字符串的长度关系，如果相等，那么我们比较当前位置后的字串是否相同，如果s的长度大，那么我们比较s的下一个位置开始的子串，和t的当前位置开始的子串是否相同，反之如果t的长度大，那么我们比较t的下一个位置开始的子串，和s的当前位置开始的子串是否相同。如果循环结束，都没有找到不同的字符，那么此时我们看两个字符串的长度是否相差1，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> isOneEditDistance(<span style="color: #0000ff;">string</span> s, <span style="color: #0000ff;">string</span><span style="color: #000000;"> t) {
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; min(s.size(), t.size()); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (s[i] !=<span style="color: #000000;"> t[i]) {
                </span><span style="color: #0000ff;">if</span> (s.size() == t.size()) <span style="color: #0000ff;">return</span> s.substr(i + <span style="color: #800080;">1</span>) == t.substr(i + <span style="color: #800080;">1</span><span style="color: #000000;">);
                </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (s.size() &lt; t.size()) <span style="color: #0000ff;">return</span> s.substr(i) == t.substr(i + <span style="color: #800080;">1</span><span style="color: #000000;">);
                </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">return</span> s.substr(i + <span style="color: #800080;">1</span>) ==<span style="color: #000000;"> t.substr(i);
            }
        }
        </span><span style="color: #0000ff;">return</span> abs((<span style="color: #0000ff;">int</span>)s.size() - (<span style="color: #0000ff;">int</span>)t.size()) == <span style="color: #800080;">1</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4344107.html" target="_blank">Edit Distance</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/30308/my-clear-java-solution-with-explanation">https://discuss.leetcode.com/topic/30308/my-clear-java-solution-with-explanation</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p>
<p> </p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-02-07 14:34</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5184698" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5184698);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4128461.html" id="cb_post_title_url">[LeetCode] Intersection of Two Linked Lists  求两个链表的交点</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Write a program to find the node at which the intersection of two singly linked lists begins.</p>
<p> </p>
<p>For example, the following two linked lists:</p>
<pre>A:          a1 → a2
                      ↘
                        c1 → c2 → c3
                      ↗            
B:     b1 → b2 → b3
</pre>
<p>begin to intersect at node c1.</p>
<p> </p>
<p>Notes:</p>
<ul>
<li>If the two linked lists have no intersection at all, return <code>null</code>.</li>
<li>The linked lists must retain their original structure after the function returns.</li>
<li>You may assume there are no cycles anywhere in the entire linked structure.</li>
<li>Your code should preferably run in O(n) time and use only O(1) memory.</li>
</ul>
<p> </p>
<p>Credits:<br/>Special thanks to <a href="https://oj.leetcode.com/discuss/user/stellari">@stellari</a> for adding this problem and creating all test cases.</p>
<p> </p>
<p>我还以为以后在不能免费做OJ的题了呢，想不到OJ又放出了不需要买书就能做的题，业界良心啊，哈哈^_^。这道求两个链表的交点题要求执行时间为O(n)，则不能利用类似冒泡法原理去暴力查找相同点，事实证明如果链表很长的话，那样的方法效率很低。我也想到会不会是像之前删除重复元素的题一样需要用两个指针来遍历，可是想了好久也没想出来怎么弄。无奈上网搜大神们的解法，发觉其实解法很简单，因为如果两个链长度相同的话，那么对应的一个个比下去就能找到，所以只需要把长链表变短即可。具体算法为：分别遍历两个链表，得到分别对应的长度。然后求长度的差值，把较长的那个链表向后移动这个差值的个数，然后一一比较即可。代码如下： </p>
<p> </p>
<p>C++ 解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    ListNode </span>*getIntersectionNode(ListNode *headA, ListNode *<span style="color: #000000;">headB) {
        </span><span style="color: #0000ff;">if</span> (!headA || !headB) <span style="color: #0000ff;">return</span><span style="color: #000000;"> NULL;
        </span><span style="color: #0000ff;">int</span> lenA = getLength(headA), lenB =<span style="color: #000000;"> getLength(headB);
        </span><span style="color: #0000ff;">if</span> (lenA &lt;<span style="color: #000000;"> lenB) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; lenB - lenA; ++i) headB = headB-&gt;<span style="color: #000000;">next;
        } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; lenA - lenB; ++i) headA = headA-&gt;<span style="color: #000000;">next;
        }
        </span><span style="color: #0000ff;">while</span> (headA &amp;&amp; headB &amp;&amp; headA !=<span style="color: #000000;"> headB) {
            headA </span>= headA-&gt;<span style="color: #000000;">next;
            headB </span>= headB-&gt;<span style="color: #000000;">next;
        }
        </span><span style="color: #0000ff;">return</span> (headA &amp;&amp; headB) ?<span style="color: #000000;"> headA : NULL;
    }
    </span><span style="color: #0000ff;">int</span> getLength(ListNode*<span style="color: #000000;"> head) {
        </span><span style="color: #0000ff;">int</span> cnt = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> (head) {
            </span>++<span style="color: #000000;">cnt;
            head </span>= head-&gt;<span style="color: #000000;">next;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> cnt;
    }
};</span></pre>
</div>
<p> </p>
<p>Java 解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        </span><span style="color: #0000ff;">if</span> (headA == <span style="color: #0000ff;">null</span> || headB == <span style="color: #0000ff;">null</span>) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">null</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> lenA = getLength(headA), lenB =<span style="color: #000000;"> getLength(headB);
        </span><span style="color: #0000ff;">if</span> (lenA &gt;<span style="color: #000000;"> lenB) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = 0; i &lt; lenA - lenB; ++i) headA =<span style="color: #000000;"> headA.next;
        } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = 0; i &lt; lenB - lenA; ++i) headB =<span style="color: #000000;"> headB.next;
        }
        </span><span style="color: #0000ff;">while</span> (headA != <span style="color: #0000ff;">null</span> &amp;&amp; headB != <span style="color: #0000ff;">null</span> &amp;&amp; headA !=<span style="color: #000000;"> headB) {
            headA </span>=<span style="color: #000000;"> headA.next;
            headB </span>=<span style="color: #000000;"> headB.next;
        }
        </span><span style="color: #0000ff;">return</span> (headA != <span style="color: #0000ff;">null</span> &amp;&amp; headB != <span style="color: #0000ff;">null</span>) ? headA : <span style="color: #0000ff;">null</span><span style="color: #000000;">;
    }
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> getLength(ListNode head) {
        </span><span style="color: #0000ff;">int</span> cnt = 0<span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (head != <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
            </span>++<span style="color: #000000;">cnt;
            head </span>=<span style="color: #000000;"> head.next;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> cnt;
    }
}</span></pre>
</div>
<p> </p>
<p>这道题还有一种特别巧妙的方法，虽然题目中强调了链表中不存在环，但是我们可以用环的思想来做，我们让两条链表分别从各自的开头开始往后遍历，当其中一条遍历到末尾时，我们跳到另一个条链表的开头继续遍历。两个指针最终会相等，而且只有两种情况，一种情况是在交点处相遇，另一种情况是在各自的末尾的空节点处相等。为什么一定会相等呢，因为两个指针走过的路程相同，是两个链表的长度之和，所以一定会相等。这个思路真的很巧妙，而且更重要的是代码写起来特别的简洁，参见代码如下：</p>
<p> </p>
<p>C++ 解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    ListNode </span>*getIntersectionNode(ListNode *headA, ListNode *<span style="color: #000000;">headB) {
        </span><span style="color: #0000ff;">if</span> (!headA || !headB) <span style="color: #0000ff;">return</span><span style="color: #000000;"> NULL;
        ListNode </span>*a = headA, *b =<span style="color: #000000;"> headB;
        </span><span style="color: #0000ff;">while</span> (a !=<span style="color: #000000;"> b) {
            a </span>= a ? a-&gt;<span style="color: #000000;">next : headB;
            b </span>= b ? b-&gt;<span style="color: #000000;">next : headA;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> a;
    }
};</span></pre>
</div>
<p> </p>
<p>Java 解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        </span><span style="color: #0000ff;">if</span> (headA == <span style="color: #0000ff;">null</span> || headB == <span style="color: #0000ff;">null</span>) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">null</span><span style="color: #000000;">;
        ListNode a </span>= headA, b =<span style="color: #000000;"> headB;
        </span><span style="color: #0000ff;">while</span> (a !=<span style="color: #000000;"> b) {
            a </span>= (a != <span style="color: #0000ff;">null</span>) ?<span style="color: #000000;"> a.next : headB;
            b </span>= (b != <span style="color: #0000ff;">null</span>) ?<span style="color: #000000;"> b.next : headA;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> a;
    }
}</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2014-11-28 14:40</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4128461" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4128461);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5185561.html" id="cb_post_title_url">[LeetCode] Longest Substring with At Most Two Distinct Characters 最多有两个不同字符的最长子串</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a string S, find the length of the longest substring T that contains at most two distinct characters.<br/>For example,<br/>Given S = “eceba”,<br/>T is “ece” which its length is 3. </p>
<p> </p>
<p>这道题给我们一个字符串，让我们求最多有两个不同字符的最长子串。那么我们首先想到的是用哈希表来做，哈希表记录每个字符的出现次数，然后如果哈希表中的映射数量超过两个的时候，我们需要删掉一个映射，比如此时哈希表中e有2个，c有1个，此时把b也存入了哈希表，那么就有三对映射了，这时我们的left是0，先从e开始，映射值减1，此时e还有1个，不删除，left自增1。这是哈希表里还有三对映射，此时left是1，那么到c了，映射值减1，此时e映射为0，将e从哈希表中删除，left自增1，然后我们更新结果为i - left + 1，以此类推直至遍历完整个字符串，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> lengthOfLongestSubstringTwoDistinct(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, left = <span style="color: #800080;">0</span><span style="color: #000000;">;
        unordered_map</span>&lt;<span style="color: #0000ff;">char</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> m;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; s.size(); ++<span style="color: #000000;">i) {
            </span>++<span style="color: #000000;">m[s[i]];
            </span><span style="color: #0000ff;">while</span> (m.size() &gt; <span style="color: #800080;">2</span><span style="color: #000000;">) {
                </span><span style="color: #0000ff;">if</span> (--m[s[left]] == <span style="color: #800080;">0</span><span style="color: #000000;">) m.erase(s[left]);
                </span>++<span style="color: #000000;">left;
            }
            res </span>= max(res, i - left + <span style="color: #800080;">1</span><span style="color: #000000;">);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>我们除了用哈希表来映射字符出现的个数，我们还可以映射每个字符最新的坐标，比如题目中的例子"eceba"，遇到第一个e，映射其坐标0，遇到c，映射其坐标1，遇到第二个e时，映射其坐标2，当遇到b时，映射其坐标3，每次我们都判断当前哈希表中的映射数，如果大于2的时候，那么我们需要删掉一个映射，我们还是从left=0时开始向右找，我们看每个字符在哈希表中的映射值是否等于当前坐标left，比如第一个e，哈希表此时映射值为2，不等于left的0，那么left自增1，遇到c的时候，哈希表中c的映射值是1，和此时的left相同，那么我们把c删掉，left自增1，再更新结果，以此类推直至遍历完整个字符串，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> lengthOfLongestSubstringTwoDistinct(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, left = <span style="color: #800080;">0</span><span style="color: #000000;">;
        unordered_map</span>&lt;<span style="color: #0000ff;">char</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> m;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; s.size(); ++<span style="color: #000000;">i) {
            m[s[i]] </span>=<span style="color: #000000;"> i;
            </span><span style="color: #0000ff;">while</span> (m.size() &gt; <span style="color: #800080;">2</span><span style="color: #000000;">) {
                </span><span style="color: #0000ff;">if</span> (m[s[left]] ==<span style="color: #000000;"> left) m.erase(s[left]);
                </span>++<span style="color: #000000;">left;
            }
            res </span>= max(res, i - left + <span style="color: #800080;">1</span><span style="color: #000000;">);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>后来又在网上看到了一种解法，这种解法是维护一个sliding window，指针left指向起始位置，right指向window的最后一个位置，用于定位left的下一个跳转位置，思路如下：</p>
<p>1. 若当前字符和前一个字符相同，继续循环。</p>
<p>2. 若不同，看当前字符和right指的字符是否相同</p>
<p>    (1) 若相同，left不变，右边跳到i - 1</p>
<p>    (2) 若不同，更新结果，left变为right+1，right变为i - 1</p>
<p>最后需要注意在循环结束后，我们还要比较res和s.size() - left的大小，返回大的，这是由于如果字符串是"ecebaaa"，那么当left=3时，i=5,6的时候，都是继续循环，当i加到7时，跳出了循环，而此时正确答案应为"baaa"这4个字符，而我们的res只更新到了"ece"这3个字符，所以我们最后要判断s.size() - left和res的大小。</p>
<p>另外需要说明的是这种解法仅适用于于不同字符数为2个的情况，如果为k个的话，还是需要用上面两种解法。</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> lengthOfLongestSubstringTwoDistinct(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        </span><span style="color: #0000ff;">int</span> left = <span style="color: #800080;">0</span>, right = -<span style="color: #800080;">1</span>, res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt; s.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (s[i] == s[i - <span style="color: #800080;">1</span>]) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> (right &gt;= <span style="color: #800080;">0</span> &amp;&amp; s[right] !=<span style="color: #000000;"> s[i]) {
                res </span>= max(res, i -<span style="color: #000000;"> left);
                left </span>= right + <span style="color: #800080;">1</span><span style="color: #000000;">;
            }
            right </span>= i - <span style="color: #800080;">1</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> max(s.size() -<span style="color: #000000;"> left, res);
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4480780.html" target="_blank">Longest Substring Without Repeating Characters</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4656517.html">Sliding Window Maximum</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/5351347.html" target="_blank">Longest Substring with At Most K Distinct Characters</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/21645/c-one-scan-solution-easy-understanding">https://discuss.leetcode.com/topic/21645/c-one-scan-solution-easy-understanding</a></p>
<p> </p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-02-09 15:20</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5185561" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5185561);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5181672.html" id="cb_post_title_url">[LeetCode] Read N Characters Given Read4 II - Call multiple times 用Read4来读取N个字符之二 - 多次调用</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>The API: int read4(char *buf) reads 4 characters at a time from a file.</p>
<p>The return value is the actual number of characters read. For example, it returns 3 if there is only 3 characters left in the file.</p>
<p>By using the read4 API, implement the function int read(char *buf, int n) that reads n characters from the file.</p>
<p>Note:<br/>The read function may be called multiple times. </p>
<p> </p>
<p>这道题是之前那道<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/5174322.html" id="homepage1_HomePageDays_DaysList_ctl05_DayList_TitleUrl_1">Read N Characters Given Read4</a>的拓展，那道题说read函数只能调用一次，而这道题说read函数可以调用多次，那么难度就增加了，为了更简单直观的说明问题，我们举个简单的例子吧，比如：</p>
<p>buf = "ab", <span class="testcase-info text-default ng-binding" id="result_wa_testcase_input">[read(1),read(2)]，返回 <span class="testcase-info text-success ng-binding" id="result_wa_testcase_expected">["a","b"]</span></span></p>
<p>那么第一次调用<span class="testcase-info text-default ng-binding" id="result_wa_testcase_input">read(1)</span>后，从buf中读出一个字符，那么就是第一个字符a，然后又调用了一个<span class="testcase-info text-default ng-binding" id="result_wa_testcase_input">read(2)</span>，想取出两个字符，但是buf中只剩一个b了，所以就把取出的结果就是b。再来看一个例子：</p>
<p><span class="testcase-info text-default ng-binding" id="result_wa_testcase_input">buf = "a", [read(0),read(1),read(2)]<span class="testcase-info text-default ng-binding" id="result_wa_testcase_input">，返回 <span class="testcase-info text-success ng-binding" id="result_wa_testcase_expected"><span class="testcase-info text-success ng-binding" id="result_wa_testcase_expected">["","a",""]</span></span></span></span></p>
<p>第一次调用<span class="testcase-info text-default ng-binding" id="result_wa_testcase_input">read(0)</span>，不取任何字符，返回空，第二次调用<span class="testcase-info text-default ng-binding" id="result_wa_testcase_input">read(1)，取一个字符，buf中只有一个字符，取出为a，然后再调用<span class="testcase-info text-default ng-binding" id="result_wa_testcase_input">read(2)，想取出两个字符，但是buf中没有字符了，所以取出为空。</span></span><span class="testcase-info text-default ng-binding"><span class="testcase-info text-default ng-binding"><br/></span></span></p>
<p><span class="testcase-info text-default ng-binding"><span class="testcase-info text-default ng-binding">但是这道题我不太懂的地方是明明函数返回的是int类型啊，为啥OJ的output都是vector&lt;char&gt;类的，然后我就在网上找了下面两种能通过OJ的解法，大概看了看，也是看的个一知半解，貌似是用两个变量readPos和writePos来记录读取和写的位置，i从0到n开始循环，如果此时读和写的位置相同，那么我们调用read4函数，将结果赋给writePos，把readPos置零，如果writePos为零的话，说明buf中没有东西了，返回当前的坐标i。然后我们用内置的buff变量的readPos位置覆盖输入字符串buf的i位置，如果完成遍历，返回n，参见代码如下：</span></span></p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> read(<span style="color: #0000ff;">char</span> *buf, <span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (readPos ==<span style="color: #000000;"> writePos) {
                writePos </span>=<span style="color: #000000;"> read4(buff);
                readPos </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">if</span> (writePos == <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;"> i;
            }
            buf[i] </span>= buff[readPos++<span style="color: #000000;">];
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> n;
    }
</span><span style="color: #0000ff;">private</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> readPos = <span style="color: #800080;">0</span>, writePos = <span style="color: #800080;">0</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">char</span> buff[<span style="color: #800080;">4</span><span style="color: #000000;">];
};</span></pre>
</div>
<p> </p>
<p>下面这种方法和上面的方法基本相同，稍稍改变了些解法，使得看起来更加简洁一些：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> read(<span style="color: #0000ff;">char</span> *buf, <span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        </span><span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (i &lt; n &amp;&amp; (readPos &lt; writePos || (readPos = <span style="color: #800080;">0</span>) &lt; (writePos =<span style="color: #000000;"> read4(buff))))
            buf[i</span>++] = buff[readPos++<span style="color: #000000;">];
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> i;
    }
    </span><span style="color: #0000ff;">char</span> buff[<span style="color: #800080;">4</span><span style="color: #000000;">];
    </span><span style="color: #0000ff;">int</span> readPos = <span style="color: #800080;">0</span>, writePos = <span style="color: #800080;">0</span><span style="color: #000000;">;
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/5174322.html" id="homepage1_HomePageDays_DaysList_ctl05_DayList_TitleUrl_1">Read N Characters Given Read4</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://leetcode.com/discuss/21219/a-simple-java-code" target="_blank">https://leetcode.com/discuss/21219/a-simple-java-code</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url" style="line-height: 1.5;">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-02-04 15:09</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5181672" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5181672);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5174322.html" id="cb_post_title_url">[LeetCode] Read N Characters Given Read4 用Read4来读取N个字符</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>The API: int read4(char *buf) reads 4 characters at a time from a file.<br/>The return value is the actual number of characters read. For example, it returns 3 if there is only 3 characters left in the file.<br/>By using the read4 API, implement the function int read(char *buf, int n) that reads n characters from the file.<br/>Note:<br/>The read function will only be called once for each test case.</p>
<p> </p>
<p>这道题给了我们一个Read4函数，每次可以从一个文件中最多读出4个字符，如果文件中的字符不足4个字符时，返回准确的当前剩余的字符数。现在让我们实现一个最多能读取n个字符的函数。这题有迭代和递归的两种解法，我们先来看迭代的方法，思路是我们每4个读一次，然后把读出的结果判断一下，如果为0的话，说明此时的buf已经被读完，跳出循环，直接返回res和n之中的较小值。否则一直读入，直到读完n个字符，循环结束，最后再返回res和n之中的较小值，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> Forward declaration of the read4 API.</span>
<span style="color: #0000ff;">int</span> read4(<span style="color: #0000ff;">char</span> *<span style="color: #000000;">buf);

</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> read(<span style="color: #0000ff;">char</span> *buf, <span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt;= n / <span style="color: #800080;">4</span>; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">int</span> cur = read4(buf +<span style="color: #000000;"> res);
            </span><span style="color: #0000ff;">if</span> (cur == <span style="color: #800080;">0</span>) <span style="color: #0000ff;">break</span><span style="color: #000000;">;
            res </span>+=<span style="color: #000000;"> cur;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> min(res, n);
    }
};</span></pre>
</div>
<p> </p>
<p>下面来看递归的解法，这个也不难，我们对buf调用read4函数，然后判断返回值t，如果返回值t大于等于n，说明此时n不大于4，直接返回n即可，如果此返回值t小于4，直接返回t即可，如果都不是，则直接返回调用递归函数加上4，其中递归函数的buf应往后推4个字符，此时n变成n-4即可，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> Forward declaration of the read4 API.</span>
<span style="color: #0000ff;">int</span> read4(<span style="color: #0000ff;">char</span> *<span style="color: #000000;">buf);

</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> read(<span style="color: #0000ff;">char</span> *buf, <span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        </span><span style="color: #0000ff;">int</span> t =<span style="color: #000000;"> read4(buf);
        </span><span style="color: #0000ff;">if</span> (t &gt;= n) <span style="color: #0000ff;">return</span><span style="color: #000000;"> n;
        </span><span style="color: #0000ff;">if</span> (t &lt; <span style="color: #800080;">4</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;"> t;
        </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">4</span> + read(&amp;buf[<span style="color: #800080;">4</span>], n - <span style="color: #800080;">4</span><span style="color: #000000;">);
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/5181672.html" target="_blank">Read N Characters Given Read4 II - Call multiple times</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://leetcode.com/discuss/61941/ap-solution-c-0ms-4lines" target="_blank">https://leetcode.com/discuss/61941/ap-solution-c-0ms-4lines</a></p>
<p><a href="https://leetcode.com/discuss/65714/my-solution-using-recursion" target="_blank">https://leetcode.com/discuss/65714/my-solution-using-recursion</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-02-01 02:54</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5174322" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5174322);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/5172838.html" id="cb_post_title_url">[LeetCode] Binary Tree Upside Down 二叉树的上下颠倒</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a binary tree where all the right nodes are either leaf nodes with a sibling (a left node that shares the same parent node) or empty, flip it upside down and turn it into a tree where the original right nodes turned into left leaf nodes. Return the new root.</p>
<p>For example:</p>
<p>Given a binary tree {1,2,3,4,5},</p>
<p>    1</p>
<p>   / \</p>
<p>  2   3</p>
<p> / \</p>
<p>4   5</p>
<p>return the root of the binary tree [4,5,2,#,#,3,1].</p>
<p>   4</p>
<p>  / \</p>
<p> 5   2</p>
<p>    / \</p>
<p>   3   1  </p>
<p> </p>
<p>这道题让我们把一棵二叉树上下颠倒一下，而且限制了右节点要么为空要么一定会有对应的左节点。上下颠倒后原来二叉树的最左子节点变成了根节点，其对应的右节点变成了其左子节点，其父节点变成了其右子节点，相当于顺时针旋转了一下。对于一般树的题都会有迭代和递归两种解法，这道题也不例外，那么我们先来看看递归的解法。对于一个根节点来说，我们的目标是将其左子节点变为根节点，右子节点变为左子节点，原根节点变为右子节点，那么我们首先判断这个根节点是否存在，且其有没有左子节点，如果不满足这两个条件的话，直接返回即可，不需要翻转操作。那么我们不停的对左子节点调用递归函数，直到到达最左子节点开始翻转，翻转好最左子节点后，开始回到上一个左子节点继续翻转即可，直至翻转完整棵树，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> Recursion</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    TreeNode </span>*upsideDownBinaryTree(TreeNode *<span style="color: #000000;">root) {
        </span><span style="color: #0000ff;">if</span> (!root || !root-&gt;left) <span style="color: #0000ff;">return</span><span style="color: #000000;"> root;
        TreeNode </span>*l = root-&gt;left, *r = root-&gt;<span style="color: #000000;">right;
        TreeNode </span>*res =<span style="color: #000000;"> upsideDownBinaryTree(l);
        l</span>-&gt;left =<span style="color: #000000;"> r;
        l</span>-&gt;right =<span style="color: #000000;"> root;
        root</span>-&gt;left =<span style="color: #000000;"> NULL;
        root</span>-&gt;right =<span style="color: #000000;"> NULL;
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>下面我们来看迭代的方法，和递归方法相反的时，这个是从上往下开始翻转，直至翻转到最左子节点，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> Iterative</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    TreeNode </span>*upsideDownBinaryTree(TreeNode *<span style="color: #000000;">root) {
        TreeNode </span>*cur = root, *pre = NULL, *next = NULL, *tmp =<span style="color: #000000;"> NULL;
        </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> (cur) {
            next </span>= cur-&gt;<span style="color: #000000;">left;
            cur</span>-&gt;left =<span style="color: #000000;"> tmp;
            tmp </span>= cur-&gt;<span style="color: #000000;">right;
            cur</span>-&gt;right =<span style="color: #000000;"> pre;
            pre </span>=<span style="color: #000000;"> cur;
            cur </span>=<span style="color: #000000;"> next;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> pre;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a href="https://discuss.leetcode.com/topic/5961/easy-o-n-iteration-solution-java">https://discuss.leetcode.com/topic/5961/easy-o-n-iteration-solution-java</a></p>
<p><a href="https://discuss.leetcode.com/topic/40924/java-recursive-o-logn-space-and-iterative-solutions-o-1-space-with-explanation-and-figure">https://discuss.leetcode.com/topic/40924/java-recursive-o-logn-space-and-iterative-solutions-o-1-space-with-explanation-and-figure</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2016-01-31 08:59</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=5172838" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(5172838);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4091064.html" id="cb_post_title_url">[LeetCode] Min Stack 最小栈</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</p>
<ul>
<li>push(x) -- Push element x onto stack.</li>
<li>pop() -- Removes the element on top of the stack.</li>
<li>top() -- Get the top element.</li>
<li>getMin() -- Retrieve the minimum element in the stack.</li>
</ul>
<p> </p>
<p>这道最小栈跟原来的栈相比就是多了一个功能，可以返回该栈的最小值。使用两个栈来实现，一个栈来按顺序存储push进来的数据，另一个用来存出现过的最小值。代码如下:</p>
<p> </p>
<p>C++ 解法一： </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> MinStack {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">* initialize your data structure here. </span><span style="color: #008000;">*/</span><span style="color: #000000;">
    MinStack() {}
    
    </span><span style="color: #0000ff;">void</span> push(<span style="color: #0000ff;">int</span><span style="color: #000000;"> x) {
        s1.push(x);
        </span><span style="color: #0000ff;">if</span> (s2.empty() || x &lt;=<span style="color: #000000;"> s2.top()) s2.push(x);
    }
    
    </span><span style="color: #0000ff;">void</span><span style="color: #000000;"> pop() {
        </span><span style="color: #0000ff;">if</span> (s1.top() ==<span style="color: #000000;"> s2.top()) s2.pop();
        s1.pop();
    }
    
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> top() {
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> s1.top();
    }
    
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> getMin() {
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> s2.top();
    }
    
</span><span style="color: #0000ff;">private</span><span style="color: #000000;">:
    stack</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> s1, s2;
};</span></pre>
</div>
<p> </p>
<p>Java 解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> MinStack {
    </span><span style="color: #0000ff;">private</span> Stack&lt;Integer&gt; s1 = <span style="color: #0000ff;">new</span> Stack&lt;&gt;<span style="color: #000000;">();
    </span><span style="color: #0000ff;">private</span> Stack&lt;Integer&gt; s2 = <span style="color: #0000ff;">new</span> Stack&lt;&gt;<span style="color: #000000;">();
    
    </span><span style="color: #008000;">/**</span><span style="color: #008000;"> initialize your data structure here. </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span><span style="color: #000000;"> MinStack() {}
    
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> push(<span style="color: #0000ff;">int</span><span style="color: #000000;"> x) {
        s1.push(x);
        </span><span style="color: #0000ff;">if</span> (s2.isEmpty() || s2.peek() &gt;=<span style="color: #000000;"> x) s2.push(x);
    }
    
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> pop() {
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> Cannot write like the following:
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> if (s2.peek() == s1.peek()) s2.pop();
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> s1.pop();</span>
        <span style="color: #0000ff;">int</span> x =<span style="color: #000000;"> s1.pop();
        </span><span style="color: #0000ff;">if</span> (s2.peek() ==<span style="color: #000000;"> x) s2.pop();
    }
    
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> top() {
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> s1.peek();
    }
    
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> getMin() {
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> s2.peek();
    }
}</span></pre>
</div>
<p> </p>
<p>需要注意的是上面的Java解法中的pop()中，为什么不能用注释掉那两行的写法，我之前也不太明白为啥不能对两个stack同时调用peek()函数来比较，如果是这种写法，那么不管s1和s2对栈顶元素是否相等，永远返回false。这是为什么呢，这我们就要到Java的对于peek的定义了，对于peek()函数的返回值并不是int类型，而是一个Object类型，这是一个基本的对象类型，如果我们直接用==来比较的话，那么肯定不会返回true，因为是两个不同的对象，所以我们一定要先将一个转为int型，然后再和另一个进行比较，这样才能得到我们想要的答案，这也是Java和C++的一个重要的不同点吧。</p>
<p>那么下面我们再来看另一种解法，这种解法只用到了一个栈，还需要一个整型变量min_val来记录当前最小值，初始化为整型最小值，然后如果需要进栈的数字小于等于当前最小值min_val，那么将min_val压入栈，并且将min_val更新为当前数字。在出栈操作时，先将栈顶元素移出栈，再判断该元素是否和min_val相等，相等的话我们将min_val更新为新栈顶元素，再将新栈顶元素移出栈即可，参见代码如下：</p>
<p> </p>
<p>C++ 解法二： </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> MinStack {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #008000;">/*</span><span style="color: #008000;">* initialize your data structure here. </span><span style="color: #008000;">*/</span><span style="color: #000000;">
    MinStack() {
        min_val </span>=<span style="color: #000000;"> INT_MAX;
    }
    
    </span><span style="color: #0000ff;">void</span> push(<span style="color: #0000ff;">int</span><span style="color: #000000;"> x) {
        </span><span style="color: #0000ff;">if</span> (x &lt;=<span style="color: #000000;"> min_val) {
            st.push(min_val);
            min_val </span>=<span style="color: #000000;"> x;
        }
        st.push(x);
    }
    
    </span><span style="color: #0000ff;">void</span><span style="color: #000000;"> pop() {
        </span><span style="color: #0000ff;">int</span> t =<span style="color: #000000;"> st.top(); st.pop();
        </span><span style="color: #0000ff;">if</span> (t ==<span style="color: #000000;"> min_val) {
            min_val </span>=<span style="color: #000000;"> st.top(); st.pop();
        }
    }
    
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> top() {
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> st.top();
    }
    
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> getMin() {
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> min_val;
    }
</span><span style="color: #0000ff;">private</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> min_val;
    stack</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> st;
};</span></pre>
</div>
<p> </p>
<p>Java 解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> MinStack {
    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">int</span> min_val =<span style="color: #000000;"> Integer.MAX_VALUE;
    </span><span style="color: #0000ff;">private</span> Stack&lt;Integer&gt; s = <span style="color: #0000ff;">new</span> Stack&lt;&gt;<span style="color: #000000;">();
    
    </span><span style="color: #008000;">/**</span><span style="color: #008000;"> initialize your data structure here. </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span><span style="color: #000000;"> MinStack() {}
    
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> push(<span style="color: #0000ff;">int</span><span style="color: #000000;"> x) {
        </span><span style="color: #0000ff;">if</span> (x &lt;=<span style="color: #000000;"> min_val) {
            s.push(min_val);
            min_val </span>=<span style="color: #000000;"> x;
        }
        s.push(x);
    }
    
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> pop() {
        </span><span style="color: #0000ff;">if</span> (s.pop() == min_val) min_val =<span style="color: #000000;"> s.pop();
    }
    
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> top() {
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> s.peek();
    }
    
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> getMin() {
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> min_val;
    }
}</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/7020/java-accepted-solution-using-one-stack" target="_blank">https://discuss.leetcode.com/topic/7020/java-accepted-solution-using-one-stack</a></p>
<p><a href="https://discuss.leetcode.com/topic/18556/c-using-two-stacks-quite-short-and-easy-to-understand" target="_blank">https://discuss.leetcode.com/topic/18556/c-using-two-stacks-quite-short-and-easy-to-understand</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2014-11-12 08:33</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4091064" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4091064);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4040438.html" id="cb_post_title_url">[LeetCode] Find Minimum in Rotated Sorted Array II 寻找旋转有序数组的最小值之二</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><blockquote>
<p><em>Follow up</em> for "Find Minimum in Rotated Sorted Array":<br/>What if <em>duplicates</em> are allowed?</p>
<p>Would this affect the run-time complexity? How and why?</p>
</blockquote>
<p>Suppose a sorted array is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e., <code>0 1 2 4 5 6 7</code> might become <code>4 5 6 7 0 1 2</code>).</p>
<p>Find the minimum element.</p>
<p>The array may contain duplicates.</p>
<p> </p>
<p>寻找旋转有序重复数组的最小值是对之前问题的延伸(<a href="http://www.cnblogs.com/grandyang/p/4032934.html" target="_blank">http://www.cnblogs.com/grandyang/p/4032934.html</a>)，当数组中存在大量的重复数字时，就会破坏二分查找法的机制，我们无法取得O(lgn)的时间复杂度，又将会回到简单粗暴的O(n)，比如如下两种情况：</p>
<p>{2, 2, 2, 2, 2, 2, 2, 2, 0, 1, 1, 2} 和 {2, 2, 2, 0, 2, 2, 2, 2, 2, 2, 2, 2}， 我们发现，当第一个数字和最后一个数字，还有中间那个数字全部相等的时候，二分查找法就崩溃了，因为它无法判断到底该去左半边还是右半边。这种情况下，我们将左指针右移一位，略过一个相同数字，这对结果不会产生影响，因为我们只是去掉了一个相同的，然后对剩余的部分继续用二分查找法，在最坏的情况下，比如数组所有元素都相同，时间复杂度会升到O(n)，参见代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> findMin(vector&lt;<span style="color: #0000ff;">int</span>&gt; &amp;<span style="color: #000000;">nums) {
        </span><span style="color: #0000ff;">if</span> (nums.empty()) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> left = <span style="color: #800080;">0</span>, right = nums.size() - <span style="color: #800080;">1</span>, res = nums[<span style="color: #800080;">0</span><span style="color: #000000;">];
        </span><span style="color: #0000ff;">while</span> (left &lt; right - <span style="color: #800080;">1</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">int</span> mid = left + (right - left) / <span style="color: #800080;">2</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> (nums[left] &lt;<span style="color: #000000;"> nums[mid]) {
                res </span>=<span style="color: #000000;"> min(res, nums[left]);
                left </span>= mid + <span style="color: #800080;">1</span><span style="color: #000000;">;
            } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (nums[left] &gt;<span style="color: #000000;"> nums[mid]) {
                res </span>=<span style="color: #000000;"> min(res, nums[right]);
                right </span>=<span style="color: #000000;"> mid;
            } </span><span style="color: #0000ff;">else</span> ++<span style="color: #000000;">left;
        }
        res </span>=<span style="color: #000000;"> min(res, nums[left]);
        res </span>=<span style="color: #000000;"> min(res, nums[right]);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="http://blog.csdn.net/linhuanmars/article/details/40449299" target="_blank">http://blog.csdn.net/linhuanmars/article/details/40449299</a> </p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2014-10-21 15:15</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4040438" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4040438);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4032934.html" id="cb_post_title_url">[LeetCode] Find Minimum in Rotated Sorted Array  寻找旋转有序数组的最小值</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Suppose a sorted array is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e., <code>0 1 2 4 5 6 7</code> might become <code>4 5 6 7 0 1 2</code>).</p>
<p>Find the minimum element.</p>
<p>You may assume no duplicate exists in the array.</p>
<p> </p>
<p>这道寻找旋转有序数组的最小值肯定不能通过直接遍历整个数组来寻找，这个方法过于简单粗暴，这样的话，旋不旋转就没有意义。应该考虑将时间复杂度从简单粗暴的O(n)缩小到O(lgn)，这时候二分查找法就浮现在脑海。</p>
<p> </p>
<p>首先要判断这个有序数组是否旋转了，通过比较第一个和最后一个数的大小，如果第一个数小，则没有旋转，直接返回这个数。如果第一个数大，就要进一步搜索。我们定义left和right两个指针分别指向开头和结尾，还要找到中间那个数，然后和left指的数比较，如果中间的数大，则继续二分查找右半段数组，反之查找左半段。终止条件是当左右两个指针相邻，返回小的那个。代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> findMin(vector&lt;<span style="color: #0000ff;">int</span>&gt; &amp;<span style="color: #000000;">num) {
        </span><span style="color: #0000ff;">int</span> left = <span style="color: #800080;">0</span>, right = num.size() - <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (num[left] &gt;<span style="color: #000000;"> num[right]) {
            </span><span style="color: #0000ff;">while</span> (left != (right - <span style="color: #800080;">1</span><span style="color: #000000;">)) {
                </span><span style="color: #0000ff;">int</span> mid = (left + right) / <span style="color: #800080;">2</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">if</span> (num[left] &lt; num[mid]) left =<span style="color: #000000;"> mid;
                </span><span style="color: #0000ff;">else</span> right =<span style="color: #000000;"> mid;
            }
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> min(num[left], num[right]);
        }
        </span><span style="color: #0000ff;">return</span> num[<span style="color: #800080;">0</span><span style="color: #000000;">];
    }
};</span></pre>
</div>
<p> </p>
<p>对于数组中有重复数字的情况，请参见我的另一篇博文：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4040438.html" target="_blank">http://www.cnblogs.com/grandyang/p/4040438.html</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2014-10-18 13:05</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4032934" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4032934);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4028713.html" id="cb_post_title_url">[LeetCode] Maximum Product Subarray 求最大子数组乘积</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Find the contiguous subarray within an array (containing at least one number) which has the largest product.</p>
<p>For example, given the array <code>[2,3,-2,4]</code>,<br/>the contiguous subarray <code>[2,3]</code> has the largest product = <code>6</code>.</p>
<p> </p>
<p>这个求最大子数组乘积问题是由最大子数组之和问题演变而来，但是却比求最大子数组之和要复杂，因为在求和的时候，遇到0，不会改变最大值，遇到负数，也只是会减小最大值而已。而在求最大子数组乘积的问题中，遇到0会使整个乘积为0，而遇到负数，则会使最大乘积变成最小乘积，正因为有负数和0的存在，使问题变得复杂了不少。。</p>
<p>比如，我们现在有一个数组[2, 3, -2, 4]，我们可以很容易的找出所有的连续子数组，[2], [3], [-2], [4], [2, 3], [3, -2], [-2, 4], [2, 3, -2], [3, -2, 4], [2, 3, -2, 4], 然后可以很轻松的算出最大的子数组乘积为6，来自子数组[2, 3].</p>
<p>那么我们如何写代码来实现自动找出最大子数组乘积呢，我最先想到的方比较简单粗暴，就是找出所有的子数组，然后算出每一个子数组的乘积，然后比较找出最大的一个，需要两个for循环，第一个for遍历整个数组，第二个for遍历含有当前数字的子数组，就是按以下顺序找出子数组: [2], [2, 3], [2, 3, -2], [2, 3, -2, 4],    [3], [3, -2], [3, -2, 4],    [-2], [-2, 4],    [4], <span style="font-size: 14px;">我在本地测试的一些数组全部通过，于是兴高采烈的拿到OJ上测试，结果丧心病狂的OJ用一个有15000个数字的数组来测试，然后说我程序的运行时间超过了要求值，我一看我的代码，果然如此，时间复杂度O(n2), 得想办法只用一次循环搞定。我想来想去想不出好方法，于是到网上搜各位大神的解决方法。其实这道题最直接的方法就是用DP来做，而且要用两个dp数组，其中f[i]表示子数组[0, i]范围内的最大子数组乘积，g[i]表示子数组[0, i]范围内的最小子数组乘积，初始化时f[0]和g[0]都初始化为nums[0]，其余都初始化为0。那么从数组的第二个数字开始遍历，那么此时的最大值和最小值只会在这三个数字之间产生，即f[i-1]*nums[i]，g[i-1]*nums[i]，和nums[i]。所以我们用三者中的最大值来更新f[i]，用最小值来更新g[i]，然后用f[i]来更新结果res即可，参见代码如下：</span></p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> maxProduct(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        </span><span style="color: #0000ff;">int</span> res = nums[<span style="color: #800080;">0</span>], n =<span style="color: #000000;"> nums.size();
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; f(n, <span style="color: #800080;">0</span>), g(n, <span style="color: #800080;">0</span><span style="color: #000000;">);
        f[</span><span style="color: #800080;">0</span>] = nums[<span style="color: #800080;">0</span><span style="color: #000000;">];
        g[</span><span style="color: #800080;">0</span>] = nums[<span style="color: #800080;">0</span><span style="color: #000000;">];
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt; n; ++<span style="color: #000000;">i) {
            f[i] </span>= max(max(f[i - <span style="color: #800080;">1</span>] * nums[i], g[i - <span style="color: #800080;">1</span>] *<span style="color: #000000;"> nums[i]), nums[i]);
            g[i] </span>= min(min(f[i - <span style="color: #800080;">1</span>] * nums[i], g[i - <span style="color: #800080;">1</span>] *<span style="color: #000000;"> nums[i]), nums[i]);
            res </span>=<span style="color: #000000;"> max(res, f[i]);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>我们可以对上面的解法进行空间上的优化，以下摘自OJ官方解答，大体思路相同，写法更加简洁：</p>
<p>Besides keeping track of the largest product, we also need to keep track of the smallest product. Why? The smallest product, which is the largest in the negative sense could become the maximum when being multiplied by a negative number.</p>
<p>Let us denote that:</p>
<div class="cnblogs_code">
<pre>f(k) = Largest product subarray, <span style="color: #0000ff;">from</span> index <span style="color: #800080;">0</span> up to k.</pre>
</div>
<p> </p>
<p>Similarly,</p>
<div class="cnblogs_code">
<pre>g(k) = Smallest product subarray, <span style="color: #0000ff;">from</span> index <span style="color: #800080;">0</span> up to k.</pre>
</div>
<p> </p>
<p>Then,</p>
<div class="cnblogs_code">
<pre>f(k) = max( f(k-<span style="color: #800080;">1</span>) * A[k], A[k], g(k-<span style="color: #800080;">1</span>) *<span style="color: #000000;"> A[k] )
g(k) </span>= min( g(k-<span style="color: #800080;">1</span>) * A[k], A[k], f(k-<span style="color: #800080;">1</span>) * A[k] )</pre>
</div>
<p> </p>
<p>There we have a dynamic programming formula. Using two arrays of size <em>n</em>, we could deduce the final answer as f(<em>n</em>-1). Since we only need to access its previous elements at each step, two variables are sufficient.</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span> maxProduct(<span style="color: #0000ff;">int</span><span style="color: #000000;">[] A) {
   assert A.length </span>&gt; <span style="color: #800080;">0</span><span style="color: #000000;">;
   </span><span style="color: #0000ff;">int</span> max = A[<span style="color: #800080;">0</span>], min = A[<span style="color: #800080;">0</span>], maxAns = A[<span style="color: #800080;">0</span><span style="color: #000000;">];
   </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt; A.length; i++<span style="color: #000000;">) {
      </span><span style="color: #0000ff;">int</span> mx = max, mn =<span style="color: #000000;"> min;
      max </span>= Math.max(Math.max(A[i], mx * A[i]), mn *<span style="color: #000000;"> A[i]);
      min </span>= Math.min(Math.min(A[i], mx * A[i]), mn *<span style="color: #000000;"> A[i]);
      maxAns </span>=<span style="color: #000000;"> Math.max(max, maxAns);
   }
   </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> maxAns;
}</span></pre>
</div>
<p> </p>
<p>根据上述描述可以写出代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> maxProduct(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        </span><span style="color: #0000ff;">if</span> (nums.empty()) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> res = nums[<span style="color: #800080;">0</span>], mn = nums[<span style="color: #800080;">0</span>], mx = nums[<span style="color: #800080;">0</span><span style="color: #000000;">];
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt; nums.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">int</span> tmax = mx, tmin =<span style="color: #000000;"> mn;
            mx </span>= max(max(nums[i], tmax * nums[i]), tmin *<span style="color: #000000;"> nums[i]);
            mn </span>= min(min(nums[i], tmax * nums[i]), tmin *<span style="color: #000000;"> nums[i]);
            res </span>=<span style="color: #000000;"> max(res, mx);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种方法也是用两个变量来表示当前最大值和最小值的，但是没有无脑比较三个数，而是对于当前的nums[i]值进行了正负情况的讨论：</p>
<div>1. 当遍历到一个正数时，此时的最大值等于之前的最大值乘以这个正数和当前正数中的较大值，此时的最小值等于之前的最小值乘以这个正数和当前正数中的较小值。</div>
<p>2. 当遍历到一个负数时，我们先用一个变量t保存之前的最大值mx，然后此时的最大值等于之前最小值乘以这个负数和当前负数中的较大值，此时的最小值等于之前保存的最大值t乘以这个负数和当前负数中的较小值。</p>
<p>3. 在每遍历完一个数时，都要更新最终的最大值。</p>
<div>P.S. 如果这里改成求最小值的话，就是求最小子数组乘积，并且时间复杂度是醉人的O(n)，是不是很强大呢，参见代码如下：</div>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> maxProduct(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        </span><span style="color: #0000ff;">int</span> res = nums[<span style="color: #800080;">0</span>], mx = res, mn =<span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt; nums.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (nums[i] &gt; <span style="color: #800080;">0</span><span style="color: #000000;">) {
                mx </span>= max(mx *<span style="color: #000000;"> nums[i], nums[i]);
                mn </span>= min(mn *<span style="color: #000000;"> nums[i], nums[i]);
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                </span><span style="color: #0000ff;">int</span> t =<span style="color: #000000;"> mx;
                mx </span>= max(mn *<span style="color: #000000;"> nums[i], nums[i]);
                mn </span>= min(t *<span style="color: #000000;"> nums[i], nums[i]);
            }
            res </span>=<span style="color: #000000;"> max(res, mx);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这道题使用了一个trick来将上面解法的分情况讨论合成了一种，在上面的解法中我们分析了当nums[i]为正数时，最大值和最小值的更新情况，为负数时，稍有不同的就是最小值更新时要用到之前的最大值，而不是更新后的最大值，所以我们才要用变量t来保存之前的结果。而下面这种方法的巧妙处在于先判断一个当前数字是否是负数，是的话就交换最大值和最小值。那么此时的mx就是之前的mn，所以mx的更新还是跟上面的方法是统一的，而在在更新mn的时候，之前的mx已经保存到mn中了，而且并没有改变，所以可以直接拿来用，不得不说，确实叼啊，参见代码如下：</p>
<p> </p>
<p>解法四：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> maxProduct(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        </span><span style="color: #0000ff;">int</span> res = nums[<span style="color: #800080;">0</span>], mx = res, mn =<span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt; nums.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (nums[i] &lt; <span style="color: #800080;">0</span><span style="color: #000000;">) swap(mx, mn);
            mx </span>= max(nums[i], mx *<span style="color: #000000;"> nums[i]);
            mn </span>= min(nums[i], mn *<span style="color: #000000;"> nums[i]);
            res </span>=<span style="color: #000000;"> max(res, mx);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>再来看一种画风不太一样的解法，这种解法遍历了两次，一次是正向遍历，一次是反向遍历，相当于正向建立一个累加积数组，每次用出现的最大值更新结果res，然后再反响建立一个累加积数组，再用出现的最大值更新结果res，注意当遇到0的时候，prod要重置为1，参见代码如下：</p>
<p> </p>
<p>解法五：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> maxProduct(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        </span><span style="color: #0000ff;">int</span> res = nums[<span style="color: #800080;">0</span>], prod = <span style="color: #800080;">1</span>, n =<span style="color: #000000;"> nums.size();
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            res </span>= max(res, prod *=<span style="color: #000000;"> nums[i]);
            </span><span style="color: #0000ff;">if</span> (nums[i] == <span style="color: #800080;">0</span>) prod = <span style="color: #800080;">1</span><span style="color: #000000;">;
        }
        prod </span>= <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = n - <span style="color: #800080;">1</span>; i &gt;= <span style="color: #800080;">0</span>; --<span style="color: #000000;">i) {
            res </span>= max(res, prod *=<span style="color: #000000;"> nums[i]);
            </span><span style="color: #0000ff;">if</span> (nums[i] == <span style="color: #800080;">0</span>) prod = <span style="color: #800080;">1</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4377150.html" target="_blank">Maximum Subarray</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4383632.html" target="_blank">House Robber</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4650187.html">Product of Array Except Self</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/7084957.html" target="_blank">Maximum Product of Three Numbers</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/7753959.html">Subarray Product Less Than K</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/51712/2-passes-scan-beats-99">https://discuss.leetcode.com/topic/51712/2-passes-scan-beats-99</a></p>
<p><a href="https://discuss.leetcode.com/topic/3581/share-my-dp-code-that-got-ac">https://discuss.leetcode.com/topic/3581/share-my-dp-code-that-got-ac</a></p>
<p><a href="https://discuss.leetcode.com/topic/3607/sharing-my-solution-o-1-space-o-n-running-time">https://discuss.leetcode.com/topic/3607/sharing-my-solution-o-1-space-o-n-running-time</a></p>
<p><a href="https://discuss.leetcode.com/topic/4417/possibly-simplest-solution-with-o-n-time-complexity">https://discuss.leetcode.com/topic/4417/possibly-simplest-solution-with-o-n-time-complexity</a></p>
<p><a href="https://discuss.leetcode.com/topic/27155/my-concise-dp-o-n-java-solution-with-o-1-extra-space">https://discuss.leetcode.com/topic/27155/my-concise-dp-o-n-java-solution-with-o-1-extra-space</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2014-10-16 14:24</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4028713" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4028713);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4606676.html" id="cb_post_title_url">[LeetCode] Reverse Words in a String 翻转字符串中的单词</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given an input string, reverse the string word by word.</p>
<p> For example,<br/>
Given s = "<code>the sky is blue</code>",<br/>
return "<code>blue is sky the</code>".
</p>
<p>
<strong><span style="color: red;">Update (2015-02-12):</span></strong><br/>
For C programmers: Try to solve it <em>in-place</em> in <em>O</em>(1) space.
</p>
<p>
<strong>Clarification:</strong></p>
<ul>
<li>What constitutes a word?<br/>
A sequence of non-space characters constitutes a word.</li>
<li>Could the input string contain leading or trailing spaces?<br/>
Yes. However, your reversed string should not contain leading or trailing spaces.</li>
<li>How about multiple spaces between two words?<br/>
Reduce them to a single space in the reversed string.</li>
</ul>
<p> </p>
<p>这道题让我们翻转字符串中的单词，题目中给了我们写特别说明，如果单词之间遇到多个空格，只能返回一个，而且首尾不能有单词，并且对C语言程序员要求空间复杂度为O(1)，所以我们只能对原字符串s之间做修改，而不能声明新的字符串。那么我们如何翻转字符串中的单词呢，我们的做法是，先整个字符串整体翻转一次，然后再分别翻转每一个单词（或者先分别翻转每一个单词，然后再整个字符串整体翻转一次），此时就能得到我们需要的结果了。那么这里我们需要定义一些变量来辅助我们解题，storeIndex表示当前存储到的位置，n为字符串的长度。我们先给整个字符串反转一下，然后我们开始循环，遇到空格直接跳过，如果是非空格字符，我们此时看storeIndex是否为0，为0的话表示第一个单词，不用增加空格；如果不为0，说明不是第一个单词，需要在单词中间加一个空格，然后我们要找到下一个单词的结束位置我们用一个while循环来找下一个为空格的位置，在此过程中继续覆盖原字符串，找到结束位置了，下面就来翻转这个单词，然后更新i为结尾位置，最后遍历结束，我们剪裁原字符串到storeIndex位置，就可以得到我们需要的结果，代码如下：</p>
<p> </p>
<p>C++ 解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">void</span> reverseWords(<span style="color: #0000ff;">string</span> &amp;<span style="color: #000000;">s) {
        </span><span style="color: #0000ff;">int</span> storeIndex = <span style="color: #800080;">0</span>, n =<span style="color: #000000;"> s.size();
        reverse(s.begin(), s.end());
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (s[i] != <span style="color: #800000;">'</span> <span style="color: #800000;">'</span><span style="color: #000000;">) {
                </span><span style="color: #0000ff;">if</span> (storeIndex != <span style="color: #800080;">0</span>) s[storeIndex++] = <span style="color: #800000;">'</span> <span style="color: #800000;">'</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">int</span> j =<span style="color: #000000;"> i;
                </span><span style="color: #0000ff;">while</span> (j &lt; n &amp;&amp; s[j] != <span style="color: #800000;">'</span> <span style="color: #800000;">'</span>) s[storeIndex++] = s[j++<span style="color: #000000;">];
                reverse(s.begin() </span>+ storeIndex - (j - i), s.begin() +<span style="color: #000000;"> storeIndex);
                i </span>=<span style="color: #000000;"> j;
            }
        }
        s.resize(storeIndex);
    }
};</span></pre>
</div>
<p> </p>
<p>Java解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> String reverseWords(String s) {
        </span><span style="color: #0000ff;">int</span> storeIndex = 0, n =<span style="color: #000000;"> s.length();
        StringBuilder sb </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> StringBuilder(s).reverse();
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = 0; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (sb.charAt(i) != ' '<span style="color: #000000;">) {
                </span><span style="color: #0000ff;">if</span> (storeIndex != 0) sb.setCharAt(storeIndex++, ' '<span style="color: #000000;">);
                </span><span style="color: #0000ff;">int</span> j =<span style="color: #000000;"> i;
                </span><span style="color: #0000ff;">while</span> (j &lt; n &amp;&amp; sb.charAt(j) != ' ') sb.setCharAt(storeIndex++, sb.charAt(j++<span style="color: #000000;">));
                String t </span>= <span style="color: #0000ff;">new</span> StringBuilder(sb.substring(storeIndex - (j -<span style="color: #000000;"> i), storeIndex)).reverse().toString();
                sb.replace(storeIndex </span>- (j -<span style="color: #000000;"> i), storeIndex, t);
                i </span>=<span style="color: #000000;"> j;
            }
        }
        sb.setLength(storeIndex);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> sb.toString();
    }
}</span></pre>
</div>
<p> </p>
<p>下面我们来看使用字符串流类stringstream的解法，我们先把字符串装载入字符串流中，然后定义一个临时变量tmp，然后把第一个单词赋给s，这里需要注意的是，如果含有非空格字符，那么每次&gt;&gt;操作就会提取连在一起的非空格字符，那么我们每次将其加在s前面即可；如果原字符串为空，那么就不会进入while循环；如果原字符串为许多空格字符连在一起，那么第一个&gt;&gt;操作就会提取出这些空格字符放入s中，然后不进入while循环，这时候我们只要判断一下s的首字符是否为空格字符，是的话就将s清空即可，参见代码如下：</p>
<p> </p>
<p>C++ 解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">void</span> reverseWords(<span style="color: #0000ff;">string</span> &amp;<span style="color: #000000;">s) {
        istringstream </span><span style="color: #0000ff;">is</span><span style="color: #000000;">(s);
        </span><span style="color: #0000ff;">string</span><span style="color: #000000;"> tmp;
        </span><span style="color: #0000ff;">is</span> &gt;&gt;<span style="color: #000000;"> s;
        </span><span style="color: #0000ff;">while</span>(<span style="color: #0000ff;">is</span> &gt;&gt; tmp) s = tmp + <span style="color: #800000;">"</span> <span style="color: #800000;">"</span> +<span style="color: #000000;"> s;
        </span><span style="color: #0000ff;">if</span>(!s.empty() &amp;&amp; s[<span style="color: #800080;">0</span>] == <span style="color: #800000;">'</span> <span style="color: #800000;">'</span>) s = <span style="color: #800000;">""</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种方法也是使用stringstream来做，但是我们使用了getline来做，第三个参数是设定分隔字符，我们用空格字符来分隔，这个跟上面的&gt;&gt;操作是有不同的，每次只能过一个空格字符，如果有多个空格字符连在一起，那么t会赋值为空字符串，所以我们在处理t的时候首先要判断其是否为空，是的话直接跳过，参见代码如下：</p>
<p> </p>
<p>C++ 解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">void</span> reverseWords(<span style="color: #0000ff;">string</span> &amp;<span style="color: #000000;">s) {
        istringstream </span><span style="color: #0000ff;">is</span><span style="color: #000000;">(s);
        s </span>= <span style="color: #800000;">""</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">string</span> t = <span style="color: #800000;">""</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (getline(<span style="color: #0000ff;">is</span>, t, <span style="color: #800000;">'</span> <span style="color: #800000;">'</span><span style="color: #000000;">)) {
            </span><span style="color: #0000ff;">if</span> (t.empty()) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
            s </span>= (s.empty() ? t : (t + <span style="color: #800000;">"</span> <span style="color: #800000;">"</span> +<span style="color: #000000;"> s));
        }
    }
};</span></pre>
</div>
<p> </p>
<p>而如果我们使用Java的String的split函数来做的话就非常简单了，没有那么多的幺蛾子，简单明了，我们首先将原字符串调用trim()来去除冗余空格，然后调用split()来分隔，分隔符设为"\\s+"，这其实是一个正则表达式，\\s表示空格字符，+表示可以有一个或多个空格字符，那么我们就可以把单词分隔开装入一个字符串数组中，然后我们从末尾开始，一个个把单词取出来加入结果res中，并且单词之间加上空格字符，注意我们把第一个单词留着不取，然后返回的时候再加上即可，参见代码如下：</p>
<p> </p>
<p>Java解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> String reverseWords(String s) {
        String res </span>= ""<span style="color: #000000;">;
        String[] words </span>= s.trim().split("\\s+"<span style="color: #000000;">);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = words.length - 1; i &gt; 0; --<span style="color: #000000;">i) {
            res </span>+= words[i] + " "<span style="color: #000000;">;   
        }
        </span><span style="color: #0000ff;">return</span> res + words[0<span style="color: #000000;">];
    }
}</span></pre>
</div>
<p> </p>
<p>下面这种方法就更加的简单了，疯狂的利用到了Java的内置函数，这也是Java的强大之处，注意这里的分隔符没有用正则表达式，而是直接放了个空格符进去，后面还是有+号，跟上面的写法得到的效果是一样的，然后我们对字符串数组进行翻转，然后调用join()函数来把字符串数组拼接成一个字符串，中间夹上空格符即可，参见代码如下：</p>
<p> </p>
<p>Java解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> String reverseWords(String s) {
        String[] words </span>= s.trim().split(" +"<span style="color: #000000;">);
        Collections.reverse(Arrays.asList(words));
        </span><span style="color: #0000ff;">return</span> String.join(" "<span style="color: #000000;">, words);
    }
}</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/5186294.html" target="_blank">Reverse Words in a String II</a> </p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/3298/in-place-simple-solution" target="_blank">https://discuss.leetcode.com/topic/3298/in-place-simple-solution</a></p>
<p><a href="%20https://discuss.leetcode.com/topic/2742/my-accepted-java-solution" target="_blank">https://discuss.leetcode.com/topic/2742/my-accepted-java-solution</a></p>
<p><a href="https://discuss.leetcode.com/topic/11785/java-3-line-builtin-solution" target="_blank">https://discuss.leetcode.com/topic/11785/java-3-line-builtin-solution</a></p>
<p><a href="https://discuss.leetcode.com/topic/10199/5-lines-c-using-stringstream" target="_blank">https://discuss.leetcode.com/topic/10199/5-lines-c-using-stringstream</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-06-29 08:14</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4606676" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4606676);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4247718.html" id="cb_post_title_url">[LeetCode] Evaluate Reverse Polish Notation 计算逆波兰表达式</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Evaluate the value of an arithmetic expression in <a href="http://en.wikipedia.org/wiki/Reverse_Polish_notation" target="_blank">Reverse Polish Notation</a>.</p>
<p>Valid operators are <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>. Each operand may be an integer or another expression.</p>
<p>Note:</p>
<ul>
<li>Division between two integers should truncate toward zero.</li>
<li>The given RPN expression is always valid. That means the expression would always evaluate to a result and there won't be any divide by zero operation.</li>
</ul>
<p>Example 1:</p>
<pre>Input: ["2", "1", "+", "3", "*"]
Output: 9
Explanation: ((2 + 1) * 3) = 9
</pre>
<p>Example 2:</p>
<pre>Input: ["4", "13", "5", "/", "+"]
Output: 6
Explanation: (4 + (13 / 5)) = 6
</pre>
<p>Example 3:</p>
<pre>Input: ["10", "6", "9", "3", "+", "-11", "*", "/", "*", "17", "+", "5", "+"]
Output: 22
Explanation: 
  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
= ((10 * (6 / (12 * -11))) + 17) + 5
= ((10 * (6 / -132)) + 17) + 5
= ((10 * 0) + 17) + 5
= (0 + 17) + 5
= 17 + 5
= 22</pre>
<p> </p>
<p><a href="http://zh.wikipedia.org/wiki/%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E7%A4%BA%E6%B3%95" target="_blank">逆波兰表达式</a>就是把操作数放前面，把操作符后置的一种写法，我们通过观察可以发现，第一个出现的运算符，其前面必有两个数字，当这个运算符和之前两个数字完成运算后从原数组中删去，把得到一个新的数字插入到原来的位置，继续做相同运算，直至整个数组变为一个数字。于是按这种思路写了代码如下，<span style="font-size: 14px;">但是拿到OJ上测试，发现会有Time Limit Exceeded的错误，无奈只好上网搜答案，发现大家都是用栈做的。仔细想想，这道题果然应该是栈的完美应用啊，从前往后遍历数组，遇到数字则压入栈中，遇到符号，则把栈顶的两个数字拿出来运算，把结果再压入栈中，直到遍历完整个数组，栈顶数字即为最终答案。代码如下:</span></p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> evalRPN(vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp;<span style="color: #000000;"> tokens) {
        </span><span style="color: #0000ff;">if</span> (tokens.size() == <span style="color: #800080;">1</span>) <span style="color: #0000ff;">return</span> stoi(tokens[<span style="color: #800080;">0</span><span style="color: #000000;">]);
        stack</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> st;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; tokens.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (tokens[i] != <span style="color: #800000;">"</span><span style="color: #800000;">+</span><span style="color: #800000;">"</span> &amp;&amp; tokens[i] != <span style="color: #800000;">"</span><span style="color: #800000;">-</span><span style="color: #800000;">"</span> &amp;&amp; tokens[i] != <span style="color: #800000;">"</span><span style="color: #800000;">*</span><span style="color: #800000;">"</span> &amp;&amp; tokens[i] != <span style="color: #800000;">"</span><span style="color: #800000;">/</span><span style="color: #800000;">"</span><span style="color: #000000;">) {
                st.push(stoi(tokens[i]));
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                </span><span style="color: #0000ff;">int</span> num1 =<span style="color: #000000;"> st.top(); st.pop();
                </span><span style="color: #0000ff;">int</span> num2 =<span style="color: #000000;"> st.top(); st.pop();
                </span><span style="color: #0000ff;">if</span> (tokens[i] == <span style="color: #800000;">"</span><span style="color: #800000;">+</span><span style="color: #800000;">"</span>) st.push(num2 +<span style="color: #000000;"> num1);
                </span><span style="color: #0000ff;">if</span> (tokens[i] == <span style="color: #800000;">"</span><span style="color: #800000;">-</span><span style="color: #800000;">"</span>) st.push(num2 -<span style="color: #000000;"> num1);
                </span><span style="color: #0000ff;">if</span> (tokens[i] == <span style="color: #800000;">"</span><span style="color: #800000;">*</span><span style="color: #800000;">"</span>) st.push(num2 *<span style="color: #000000;"> num1);
                </span><span style="color: #0000ff;">if</span> (tokens[i] == <span style="color: #800000;">"</span><span style="color: #800000;">/</span><span style="color: #800000;">"</span>) st.push(num2 /<span style="color: #000000;"> num1);
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> st.top();
    }
};</span></pre>
</div>
<p> </p>
<p>我们也可以用递归来做，由于一个有效的逆波兰表达式的末尾必定是操作符，所以我们可以从末尾开始处理，如果遇到操作符，向前两个位置调用递归函数，找出前面两个数字，然后进行操作将结果返回，如果遇到的是数字直接返回即可，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> evalRPN(vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp;<span style="color: #000000;"> tokens) {
        </span><span style="color: #0000ff;">int</span> op = (<span style="color: #0000ff;">int</span>)tokens.size() - <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> helper(tokens, op);
    }
    </span><span style="color: #0000ff;">int</span> helper(vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp; tokens, <span style="color: #0000ff;">int</span>&amp;<span style="color: #000000;"> op) {
        </span><span style="color: #0000ff;">string</span> str =<span style="color: #000000;"> tokens[op];
        </span><span style="color: #0000ff;">if</span> (str != <span style="color: #800000;">"</span><span style="color: #800000;">+</span><span style="color: #800000;">"</span> &amp;&amp; str != <span style="color: #800000;">"</span><span style="color: #800000;">-</span><span style="color: #800000;">"</span> &amp;&amp; str != <span style="color: #800000;">"</span><span style="color: #800000;">*</span><span style="color: #800000;">"</span> &amp;&amp; str != <span style="color: #800000;">"</span><span style="color: #800000;">/</span><span style="color: #800000;">"</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;"> stoi(str);
        </span><span style="color: #0000ff;">int</span> num1 = helper(tokens, --<span style="color: #000000;">op);
        </span><span style="color: #0000ff;">int</span> num2 = helper(tokens, --<span style="color: #000000;">op);
        </span><span style="color: #0000ff;">if</span> (str == <span style="color: #800000;">"</span><span style="color: #800000;">+</span><span style="color: #800000;">"</span>) <span style="color: #0000ff;">return</span> num2 +<span style="color: #000000;"> num1;
        </span><span style="color: #0000ff;">if</span> (str == <span style="color: #800000;">"</span><span style="color: #800000;">-</span><span style="color: #800000;">"</span>) <span style="color: #0000ff;">return</span> num2 -<span style="color: #000000;"> num1;
        </span><span style="color: #0000ff;">if</span> (str == <span style="color: #800000;">"</span><span style="color: #800000;">*</span><span style="color: #800000;">"</span>) <span style="color: #0000ff;">return</span> num2 *<span style="color: #000000;"> num1;
        </span><span style="color: #0000ff;">return</span> num2 /<span style="color: #000000;"> num1;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4570699.html" target="_blank">Basic Calculator</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4814506.html" target="_blank">Expression Add Operators</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-01-25 06:48</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4247718" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4247718);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4579693.html" id="cb_post_title_url">[LeetCode] Max Points on a Line 共线点个数</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given <em>n</em> points on a 2D plane, find the maximum number of points that lie on the same straight line.</p>
<p> </p>
<p>这道题给了我们一堆二维点，然后让我们求最大的共线点的个数，根据初中数学我们知道，两点确定一条直线，而且可以写成y = ax + b的形式，所有共线的点都满足这个公式。所以这些给定点两两之间都可以算一个斜率，每个斜率代表一条直线，对每一条直线，带入所有的点看是否共线并计算个数，这是整体的思路。但是还有两点特殊情况需要考虑，二是当两个点重合时，无法确定一条直线，但这也是共线的情况，需要特殊处理。二是斜率不存在的情况，由于两个点(x1, y1)和(x2, y2)的斜率k表示为(y2 - y1) / (x2 - x1)，那么当x1 = x2时斜率不存在，这种共线情况需要特殊处理。我们需要用到哈希表来记录斜率和共线点个数之间的映射，其中第一种重合点的情况我们假定其斜率为INT_MIN，第二种情况我们假定其斜率为INT_MAX，这样都可以用map映射了。我们还需要顶一个变量duplicate来记录重合点的个数，最后只需和哈希表中的数字相加即为共线点的总数，这种方法现在已经无法通过OJ了，贴出来权当纪念。代码如下：</p>
<p> </p>
<p>C++ 解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> Failed on case: [[0,0],[94911151,94911150],[94911152,94911151]]</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> maxPoints(vector&lt;Point&gt;&amp;<span style="color: #000000;"> points) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; points.size(); ++<span style="color: #000000;">i) {
            unordered_map</span>&lt;<span style="color: #0000ff;">float</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> m;
            </span><span style="color: #0000ff;">int</span> duplicate = <span style="color: #800080;">1</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = i + <span style="color: #800080;">1</span>; j &lt; points.size(); ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> (points[i].x == points[j].x &amp;&amp; points[i].y ==<span style="color: #000000;"> points[j].y) {
                    </span>++<span style="color: #000000;">duplicate;
                } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (points[i].x ==<span style="color: #000000;"> points[j].x) {
                    </span>++<span style="color: #000000;">m[INT_MAX];
                } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    </span><span style="color: #0000ff;">float</span> slope = (<span style="color: #0000ff;">float</span>)(points[j].y - points[i].y) / (points[j].x -<span style="color: #000000;"> points[i].x);
                    </span>++<span style="color: #000000;">m[slope];
                }
            }
            res </span>=<span style="color: #000000;"> max(res, duplicate);
            </span><span style="color: #0000ff;">for</span> (auto it = m.begin(); it != m.end(); ++<span style="color: #000000;">it) {
                res </span>= max(res, it-&gt;second +<span style="color: #000000;"> duplicate);
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>Java 解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> Failed on case: [[0,0],[94911151,94911150],[94911152,94911151]]</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> maxPoints(Point[] points) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; points.length; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">int</span> duplicate = <span style="color: #800080;">1</span>, vertical = <span style="color: #800080;">0</span><span style="color: #000000;">;
            Map</span>&lt;Double, Integer&gt; m = <span style="color: #0000ff;">new</span> HashMap&lt;&gt;<span style="color: #000000;">();
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = i + <span style="color: #800080;">1</span>; j &lt; points.length; ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> (points[i].x == points[j].x &amp;&amp; points[i].y ==<span style="color: #000000;"> points[j].y) {
                    </span>++<span style="color: #000000;">duplicate;
                } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (points[i].x ==<span style="color: #000000;"> points[j].x) {
                    m.put(Double.MAX_VALUE, m.getOrDefault(Double.MAX_VALUE, </span><span style="color: #800080;">0</span>) + <span style="color: #800080;">1</span><span style="color: #000000;">);
                } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (points[i].y ==<span style="color: #000000;"> points[j].y) {
                    m.put(</span><span style="color: #800080;">0.0</span>, m.getOrDefault(<span style="color: #800080;">0.0</span>, <span style="color: #800080;">0</span>) + <span style="color: #800080;">1</span><span style="color: #000000;">);
                } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    </span><span style="color: #0000ff;">double</span> slope = (<span style="color: #0000ff;">double</span>)(points[j].y - points[i].y) / (points[j].x -<span style="color: #000000;"> points[i].x);
                    m.put(slope, m.getOrDefault(slope, </span><span style="color: #800080;">0</span>) + <span style="color: #800080;">1</span><span style="color: #000000;">);
                }
            }
            res </span>=<span style="color: #000000;"> Math.max(res, duplicate);
            </span><span style="color: #0000ff;">for</span> (Map.Entry&lt;Double, Integer&gt;<span style="color: #000000;"> e : m.entrySet()) {
                res </span>= Math.max(res, e.getValue() +<span style="color: #000000;"> duplicate);
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
}</span></pre>
</div>
<p> </p>
<p>由于通过斜率来判断共线需要用到除法，而用double表示的双精度小数在有的系统里不一定准确，为了更加精确无误的计算共线，我们应当避免除法，从而避免无线不循环小数的出现，那么怎么办呢，我们把除数和被除数都保存下来，不做除法，但是我们要让这两数分别除以它们的最大公约数，这样例如8和4，4和2，2和1，这三组商相同的数就都会存到一个映射里面，同样也能实现我们的目标，而求GCD的函数如果用递归来写那么一行就搞定了，叼不叼，这个方法能很好的避免除法的出现，算是牺牲了空间来保证精度吧，参见代码如下：</p>
<p> </p>
<p>C++ 解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> maxPoints(vector&lt;Point&gt;&amp;<span style="color: #000000;"> points) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; points.size(); ++<span style="color: #000000;">i) {
            map</span>&lt;pair&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> m;
            </span><span style="color: #0000ff;">int</span> duplicate = <span style="color: #800080;">1</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = i + <span style="color: #800080;">1</span>; j &lt; points.size(); ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> (points[i].x == points[j].x &amp;&amp; points[i].y ==<span style="color: #000000;"> points[j].y) {
                    </span>++duplicate; <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                } 
                </span><span style="color: #0000ff;">int</span> dx = points[j].x -<span style="color: #000000;"> points[i].x;
                </span><span style="color: #0000ff;">int</span> dy = points[j].y -<span style="color: #000000;"> points[i].y;
                </span><span style="color: #0000ff;">int</span> d =<span style="color: #000000;"> gcd(dx, dy);
                </span>++m[{dx / d, dy /<span style="color: #000000;"> d}];
            }
            res </span>=<span style="color: #000000;"> max(res, duplicate);
            </span><span style="color: #0000ff;">for</span> (auto it = m.begin(); it != m.end(); ++<span style="color: #000000;">it) {
                res </span>= max(res, it-&gt;second +<span style="color: #000000;"> duplicate);
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">int</span> gcd(<span style="color: #0000ff;">int</span> a, <span style="color: #0000ff;">int</span><span style="color: #000000;"> b) {
        </span><span style="color: #0000ff;">return</span> (b == <span style="color: #800080;">0</span>) ? a : gcd(b, a %<span style="color: #000000;"> b);
    }
};</span></pre>
</div>
<p> </p>
<p>Java 解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> maxPoints(Point[] points) {
        </span><span style="color: #0000ff;">int</span> res = 0<span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = 0; i &lt; points.length; ++<span style="color: #000000;">i) {
            Map</span>&lt;Map&lt;Integer, Integer&gt;, Integer&gt; m = <span style="color: #0000ff;">new</span> HashMap&lt;&gt;<span style="color: #000000;">();
            </span><span style="color: #0000ff;">int</span> duplicate = 1<span style="color: #000000;">;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = i + 1; j &lt; points.length; ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> (points[i].x == points[j].x &amp;&amp; points[i].y ==<span style="color: #000000;"> points[j].y) {
                    </span>++duplicate; <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                }
                </span><span style="color: #0000ff;">int</span> dx = points[j].x -<span style="color: #000000;"> points[i].x;
                </span><span style="color: #0000ff;">int</span> dy = points[j].y -<span style="color: #000000;"> points[i].y;
                </span><span style="color: #0000ff;">int</span> d =<span style="color: #000000;"> gcd(dx, dy);
                Map</span>&lt;Integer, Integer&gt; t = <span style="color: #0000ff;">new</span> HashMap&lt;&gt;<span style="color: #000000;">();
                t.put(dx </span>/ d, dy /<span style="color: #000000;"> d);
                m.put(t, m.getOrDefault(t, </span>0) + 1<span style="color: #000000;">);
            }
            res </span>=<span style="color: #000000;"> Math.max(res, duplicate);
            </span><span style="color: #0000ff;">for</span> (Map.Entry&lt;Map&lt;Integer, Integer&gt;, Integer&gt;<span style="color: #000000;"> e : m.entrySet()) {
                res </span>= Math.max(res, e.getValue() +<span style="color: #000000;"> duplicate);
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span> gcd(<span style="color: #0000ff;">int</span> a, <span style="color: #0000ff;">int</span><span style="color: #000000;"> b) {
        </span><span style="color: #0000ff;">return</span> (b == 0) ? a : gcd(b, a %<span style="color: #000000;"> b);
    }
}</span></pre>
</div>
<p> </p>
<p>令我惊奇的是，这道题的OJ居然容忍brute force的方法通过，那么我感觉下面这种O(n<sup>3</sup>)的解法之所以能通过OJ，可能还有一个原因就是用了比较高效的判断三点共线的方法。一般来说判断三点共线有三种方法，斜率法，周长法，面积法(请参见<a href="http://yiminghe.iteye.com/blog/568666" target="_blank">这个帖子</a>)。而其中通过判断叉积为零的面积法是坠好的。比如说有三个点A(x1, y1)、B(x2, y2)、C(x3, y3)，那么判断三点共线就是判断下面这个等式是否成立：</p>
<p><img alt="" src="https://images2015.cnblogs.com/blog/391947/201701/391947-20170111141450088-1765227618.jpg"/></p>
<p>行列式的求法不用多说吧，不会的话回去翻线性代数，当初少打点刀塔不就好啦~</p>
<p> </p>
<p>C++ 解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> maxPoints(vector&lt;Point&gt;&amp;<span style="color: #000000;"> points) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; points.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">int</span> duplicate = <span style="color: #800080;">1</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = i + <span style="color: #800080;">1</span>; j &lt; points.size(); ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">int</span> cnt = <span style="color: #800080;">0</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">long</span> <span style="color: #0000ff;">long</span> x1 = points[i].x, y1 =<span style="color: #000000;"> points[i].y;
                </span><span style="color: #0000ff;">long</span> <span style="color: #0000ff;">long</span> x2 = points[j].x, y2 =<span style="color: #000000;"> points[j].y;
                </span><span style="color: #0000ff;">if</span> (x1 == x2 &amp;&amp; y1 == y2) {++duplicate; <span style="color: #0000ff;">continue</span><span style="color: #000000;">;}
                </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> k = <span style="color: #800080;">0</span>; k &lt; points.size(); ++<span style="color: #000000;">k) {
                    </span><span style="color: #0000ff;">int</span> x3 = points[k].x, y3 =<span style="color: #000000;"> points[k].y;
                    </span><span style="color: #0000ff;">if</span> (x1 * y2 + x2 * y3 + x3 * y1 - x3 * y2 - x2 * y1 - x1 * y3 == <span style="color: #800080;">0</span><span style="color: #000000;">) {
                        </span>++<span style="color: #000000;">cnt;
                    }
                }
                res </span>=<span style="color: #000000;"> max(res, cnt);
            }
            res </span>=<span style="color: #000000;"> max(res, duplicate);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p><span style="color: #0000ff;"> </span></p>
<p>Java 解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> maxPoints(Point[] points) {
        </span><span style="color: #0000ff;">int</span> res = 0, n =<span style="color: #000000;"> points.length;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = 0; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">int</span> duplicate = 1<span style="color: #000000;">;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = i + 1; j &lt; n; ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">int</span> cnt = 0<span style="color: #000000;">;
                </span><span style="color: #0000ff;">long</span> x1 = points[i].x, y1 =<span style="color: #000000;"> points[i].y;
                </span><span style="color: #0000ff;">long</span> x2 = points[j].x, y2 =<span style="color: #000000;"> points[j].y;
                </span><span style="color: #0000ff;">if</span> (x1 == x2 &amp;&amp; y1 == y2) {++duplicate;<span style="color: #0000ff;">continue</span><span style="color: #000000;">;}
                </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> k = 0; k &lt; n; ++<span style="color: #000000;">k) {
                    </span><span style="color: #0000ff;">int</span> x3 = points[k].x, y3 =<span style="color: #000000;"> points[k].y;
                    </span><span style="color: #0000ff;">if</span> (x1*y2 + x2*y3 + x3*y1 - x3*y2 - x2*y1 - x1 * y3 == 0<span style="color: #000000;">) {
                        </span>++<span style="color: #000000;">cnt;
                    }
                }
                res </span>=<span style="color: #000000;"> Math.max(res, cnt);
            }
            res </span>=<span style="color: #000000;"> Math.max(res, duplicate);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
}</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/2979/a-java-solution-with-notes/2" target="_blank">https://discuss.leetcode.com/topic/2979/a-java-solution-with-notes/2</a></p>
<p><a href="https://discuss.leetcode.com/topic/6028/sharing-my-simple-solution-with-explanation" target="_blank">https://discuss.leetcode.com/topic/6028/sharing-my-simple-solution-with-explanation</a></p>
<p><a href="https://discuss.leetcode.com/topic/18447/16ms-28ms-c-solutions-with-explanations/2" target="_blank">https://discuss.leetcode.com/topic/18447/16ms-28ms-c-solutions-with-explanations/2</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-06-16 04:37</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4579693" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4579693);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4249905.html" id="cb_post_title_url">[LeetCode] Sort List 链表排序</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Sort a linked list in <em>O</em>(<em>n</em> log <em>n</em>) time using constant space complexity.</p>
<p> </p>
<p>常见排序方法有很多，插入排序，选择排序，堆排序，快速排序，冒泡排序，归并排序，桶排序等等。。它们的时间复杂度不尽相同，而这里题目限定了时间必须为O(nlgn)，符合要求只有快速排序，归并排序，堆排序，而根据单链表的特点，最适于用归并排序。代码如下：</p>
<p> </p>
<p>C++ 解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    ListNode</span>* sortList(ListNode*<span style="color: #000000;"> head) {
        </span><span style="color: #0000ff;">if</span> (!head || !head-&gt;next) <span style="color: #0000ff;">return</span><span style="color: #000000;"> head;
        ListNode </span>*slow = head, *fast = head, *pre =<span style="color: #000000;"> head;
        </span><span style="color: #0000ff;">while</span> (fast &amp;&amp; fast-&gt;<span style="color: #000000;">next) {
            pre </span>=<span style="color: #000000;"> slow;
            slow </span>= slow-&gt;<span style="color: #000000;">next;
            fast </span>= fast-&gt;next-&gt;<span style="color: #000000;">next;
        }
        pre</span>-&gt;next =<span style="color: #000000;"> NULL;
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> merge(sortList(head), sortList(slow));
    }
    ListNode</span>* merge(ListNode* l1, ListNode*<span style="color: #000000;"> l2) {
        ListNode </span>*dummy = <span style="color: #0000ff;">new</span> ListNode(-<span style="color: #800080;">1</span><span style="color: #000000;">);
        ListNode </span>*cur =<span style="color: #000000;"> dummy;
        </span><span style="color: #0000ff;">while</span> (l1 &amp;&amp;<span style="color: #000000;"> l2) {
            </span><span style="color: #0000ff;">if</span> (l1-&gt;val &lt; l2-&gt;<span style="color: #000000;">val) {
                cur</span>-&gt;next =<span style="color: #000000;"> l1;
                l1 </span>= l1-&gt;<span style="color: #000000;">next;
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                cur</span>-&gt;next =<span style="color: #000000;"> l2;
                l2 </span>= l2-&gt;<span style="color: #000000;">next;
            }
            cur </span>= cur-&gt;<span style="color: #000000;">next;
        }
        </span><span style="color: #0000ff;">if</span> (l1) cur-&gt;next =<span style="color: #000000;"> l1;
        </span><span style="color: #0000ff;">if</span> (l2) cur-&gt;next =<span style="color: #000000;"> l2;
        </span><span style="color: #0000ff;">return</span> dummy-&gt;<span style="color: #000000;">next;
    }
};</span></pre>
</div>
<p> </p>
<p>Java 解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> ListNode sortList(ListNode head) {
        </span><span style="color: #0000ff;">if</span> (head == <span style="color: #0000ff;">null</span> || head.next == <span style="color: #0000ff;">null</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;"> head;
        ListNode slow </span>= head, fast = head, pre =<span style="color: #000000;"> head;
        </span><span style="color: #0000ff;">while</span> (fast != <span style="color: #0000ff;">null</span> &amp;&amp; fast.next != <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
            pre </span>=<span style="color: #000000;"> slow;
            slow </span>=<span style="color: #000000;"> slow.next;
            fast </span>=<span style="color: #000000;"> fast.next.next;
        }
        pre.next </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> merge(sortList(head), sortList(slow));
    }
    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> ListNode merge(ListNode l1, ListNode l2) {
        ListNode dummy </span>= <span style="color: #0000ff;">new</span> ListNode(-<span style="color: #800080;">1</span><span style="color: #000000;">);
        ListNode cur </span>=<span style="color: #000000;"> dummy;
        </span><span style="color: #0000ff;">while</span> (l1 != <span style="color: #0000ff;">null</span> &amp;&amp; l2 != <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">if</span> (l1.val &lt;<span style="color: #000000;"> l2.val) {
                cur.next </span>=<span style="color: #000000;"> l1;
                l1 </span>=<span style="color: #000000;"> l1.next;
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                cur.next </span>=<span style="color: #000000;"> l2;
                l2 </span>=<span style="color: #000000;"> l2.next;
            }
            cur </span>=<span style="color: #000000;"> cur.next;
        }
        </span><span style="color: #0000ff;">if</span> (l1 != <span style="color: #0000ff;">null</span>) cur.next =<span style="color: #000000;"> l1;
        </span><span style="color: #0000ff;">if</span> (l2 != <span style="color: #0000ff;">null</span>) cur.next =<span style="color: #000000;"> l2;
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> dummy.next;
    }
}</span></pre>
</div>
<p> </p>
<p>下面这种方法也是归并排序，而且在merge函数中也使用了递归，这样使代码更加简洁啦～</p>
<p> </p>
<p>C++ 解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    ListNode</span>* sortList(ListNode*<span style="color: #000000;"> head) {
        </span><span style="color: #0000ff;">if</span> (!head || !head-&gt;next) <span style="color: #0000ff;">return</span><span style="color: #000000;"> head;
        ListNode </span>*slow = head, *fast = head, *pre =<span style="color: #000000;"> head;
        </span><span style="color: #0000ff;">while</span> (fast &amp;&amp; fast-&gt;<span style="color: #000000;">next) {
            pre </span>=<span style="color: #000000;"> slow;
            slow </span>= slow-&gt;<span style="color: #000000;">next;
            fast </span>= fast-&gt;next-&gt;<span style="color: #000000;">next;
        }
        pre</span>-&gt;next =<span style="color: #000000;"> NULL;
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> merge(sortList(head), sortList(slow));
    }
    ListNode</span>* merge(ListNode* l1, ListNode*<span style="color: #000000;"> l2) {
        </span><span style="color: #0000ff;">if</span> (!l1) <span style="color: #0000ff;">return</span><span style="color: #000000;"> l2;
        </span><span style="color: #0000ff;">if</span> (!l2) <span style="color: #0000ff;">return</span><span style="color: #000000;"> l1;
        </span><span style="color: #0000ff;">if</span> (l1-&gt;val &lt; l2-&gt;<span style="color: #000000;">val) {
            l1</span>-&gt;next = merge(l1-&gt;<span style="color: #000000;">next, l2);
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> l1;
        } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            l2</span>-&gt;next = merge(l1, l2-&gt;<span style="color: #000000;">next);
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> l2;
        }
    }
};</span></pre>
</div>
<p> </p>
<p>Java 解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> ListNode sortList(ListNode head) {
        </span><span style="color: #0000ff;">if</span> (head == <span style="color: #0000ff;">null</span> || head.next == <span style="color: #0000ff;">null</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;"> head;
        ListNode slow </span>= head, fast = head, pre =<span style="color: #000000;"> head;
        </span><span style="color: #0000ff;">while</span> (fast != <span style="color: #0000ff;">null</span> &amp;&amp; fast.next != <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
            pre </span>=<span style="color: #000000;"> slow;
            slow </span>=<span style="color: #000000;"> slow.next;
            fast </span>=<span style="color: #000000;"> fast.next.next;
        }
        pre.next </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> merge(sortList(head), sortList(slow));
    }
    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> ListNode merge(ListNode l1, ListNode l2) {
        </span><span style="color: #0000ff;">if</span> (l1 == <span style="color: #0000ff;">null</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;"> l2;
        </span><span style="color: #0000ff;">if</span> (l2 == <span style="color: #0000ff;">null</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;"> l1;
        </span><span style="color: #0000ff;">if</span> (l1.val &lt;<span style="color: #000000;"> l2.val) {
            l1.next </span>=<span style="color: #000000;"> merge(l1.next, l2);
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> l1;
        } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            l2.next </span>=<span style="color: #000000;"> merge(l1, l2.next);
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> l2;
        }
    }
}</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/17150/clean-and-short-merge-sort-solution-in-c" target="_blank">https://discuss.leetcode.com/topic/17150/clean-and-short-merge-sort-solution-in-c</a></p>
<p><a href="https://discuss.leetcode.com/topic/15029/56ms-c-solutions-using-quicksort-with-explanations" target="_blank">https://discuss.leetcode.com/topic/15029/56ms-c-solutions-using-quicksort-with-explanations</a></p>
<p><a href="https://discuss.leetcode.com/topic/643/i-have-a-pretty-good-mergesort-method-can-anyone-speed-up-the-run-time-or-reduce-the-memory-usage/2" target="_blank">https://discuss.leetcode.com/topic/643/i-have-a-pretty-good-mergesort-method-can-anyone-speed-up-the-run-time-or-reduce-the-memory-usage/2</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-01-26 11:53</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4249905" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4249905);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4250107.html" id="cb_post_title_url">[LeetCode] Insertion Sort List 链表插入排序</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Sort a linked list using insertion sort.</p>
<p> </p>
<p>链表的插入排序实现原理很简单，就是一个元素一个元素的从原链表中取出来，然后按顺序插入到新链表中，时间复杂度为O(n2)，是一种效率并不是很高的算法，但是空间复杂度为O(1)，以高时间复杂度换取了低空间复杂度。代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    ListNode</span>* insertionSortList(ListNode*<span style="color: #000000;"> head) {
        ListNode </span>*dummy = <span style="color: #0000ff;">new</span> ListNode(-<span style="color: #800080;">1</span>), *cur =<span style="color: #000000;"> dummy;
        </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> (head) {
            ListNode </span>*t = head-&gt;<span style="color: #000000;">next;
            cur </span>=<span style="color: #000000;"> dummy;
            </span><span style="color: #0000ff;">while</span> (cur-&gt;next &amp;&amp; cur-&gt;next-&gt;val &lt;= head-&gt;<span style="color: #000000;">val) {
                cur </span>= cur-&gt;<span style="color: #000000;">next;
            }
            head</span>-&gt;next = cur-&gt;<span style="color: #000000;">next;
            cur</span>-&gt;next =<span style="color: #000000;"> head;
            head </span>=<span style="color: #000000;"> t;
        }
        </span><span style="color: #0000ff;">return</span> dummy-&gt;<span style="color: #000000;">next;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4249905.html" target="_blank">Sort List</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-01-26 13:38</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4250107" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4250107);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4587511.html" id="cb_post_title_url">[LeetCode] LRU Cache 最近最少使用页面置换缓存器</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: <code>get</code> and <code>set</code>.</p>
<p> <code>get(key)</code> - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.<br/>
<code>set(key, value)</code> - Set or insert the value if the key is not
 already present. When the cache reached its capacity, it should 
invalidate the least recently used item before inserting a new item.
</p>
<p> </p>
<p>这道题让我们实现一个LRU缓存器，LRU是Least Recently Used的简写，就是最近最少使用的意思。那么这个缓存器主要有两个成员函数，get和put，其中get函数是通过输入key来获得value，如果成功获得后，这对(key, value)升至缓存器中最常用的位置（顶部），如果key不存在，则返回-1。而put函数是插入一对新的(key, value)，如果原缓存器中有该key，则需要先删除掉原有的，将新的插入到缓存器的顶部。如果不存在，则直接插入到顶部。若加入新的值后缓存器超过了容量，则需要删掉一个最不常用的值，也就是底部的值。具体实现时我们需要三个私有变量，cap, l和m，其中cap是缓存器的容量大小，l是保存缓存器内容的列表，m是哈希表，保存关键值key和缓存器各项的迭代器之间映射，方便我们以O(1)的时间内找到目标项。</p>
<p>然后我们再来看get和put如何实现，get相对简单些，我们在m中查找给定的key，如果存在则将此项移到顶部，并返回value，若不存在返回-1。对于put，我们也是现在m中查找给定的key，如果存在就删掉原有项，并在顶部插入新来项，然后判断是否溢出，若溢出则删掉底部项(最不常用项)。代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> LRUCache{
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    LRUCache(</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> capacity) {
        cap </span>=<span style="color: #000000;"> capacity;
    }
    
    </span><span style="color: #0000ff;">int</span> <span style="color: #0000ff;">get</span>(<span style="color: #0000ff;">int</span><span style="color: #000000;"> key) {
        auto it </span>=<span style="color: #000000;"> m.find(key);
        </span><span style="color: #0000ff;">if</span> (it == m.end()) <span style="color: #0000ff;">return</span> -<span style="color: #800080;">1</span><span style="color: #000000;">;
        l.splice(l.begin(), l, it</span>-&gt;<span style="color: #000000;">second);
        </span><span style="color: #0000ff;">return</span> it-&gt;second-&gt;<span style="color: #000000;">second;
    }
    
    </span><span style="color: #0000ff;">void</span> put(<span style="color: #0000ff;">int</span> key, <span style="color: #0000ff;">int</span><span style="color: #000000;"> value) {
        auto it </span>=<span style="color: #000000;"> m.find(key);
        </span><span style="color: #0000ff;">if</span> (it != m.end()) l.erase(it-&gt;<span style="color: #000000;">second);
        l.push_front(make_pair(key, value));
        m[key] </span>=<span style="color: #000000;"> l.begin();
        </span><span style="color: #0000ff;">if</span> (m.size() &gt;<span style="color: #000000;"> cap) {
            </span><span style="color: #0000ff;">int</span> k = l.rbegin()-&gt;<span style="color: #000000;">first;
            l.pop_back();
            m.erase(k);
        }
    }
    
</span><span style="color: #0000ff;">private</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> cap;
    list</span>&lt;pair&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;&gt;<span style="color: #000000;"> l;
    unordered_map</span>&lt;<span style="color: #0000ff;">int</span>, list&lt;pair&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;&gt;::iterator&gt;<span style="color: #000000;"> m;
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/6258459.html" target="_blank">LFU Cache</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/6944331.html">Design In-Memory File System</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/7026999.html">Design Compressed String Iterator</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="http://www.cnblogs.com/TenosDoIt/p/3417157.html" target="_blank">http://www.cnblogs.com/TenosDoIt/p/3417157.html</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-06-19 03:10</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4587511" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4587511);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4251757.html" id="cb_post_title_url">[LeetCode] Binary Tree Postorder Traversal 二叉树的后序遍历</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a binary tree, return the <em>postorder</em> traversal of its nodes' values.</p>
<p> For example:<br/>
Given binary tree <code>{1,#,2,3}</code>,<br/>
</p>
<pre>   1
    \
     2
    /
   3
</pre>
<p>return <code>[3,2,1]</code>.</p>
<p><strong>Note:</strong> Recursive solution is trivial, could you do it iteratively?</p>
<p> </p>
<p>经典题目，求二叉树的后序遍历的非递归方法，跟前序，中序，层序一样都需要用到栈，后续的顺序是左-右-根，所以当一个节点值被取出来时，它的左右子节点要么不存在，要么已经被访问过了。我们先将根结点压入栈，然后定义一个辅助结点head，while循环的条件是栈不为空，在循环中，首先将栈顶结点t取出来，如果栈顶结点没有左右子结点，或者其左子结点是head，或者其右子结点是head的情况下。我们将栈顶结点值加入结果res中，并将栈顶元素移出栈，然后将head指向栈顶元素；否则的话就看如果右子结点不为空，将其加入栈，再看左子结点不为空的话，就加入栈，注意这里先右后左的顺序是因为栈的后入先出的特点，可以使得左子结点先被处理。下面来看为什么是这三个条件呢，首先如果栈顶元素如果没有左右子结点的话，说明其是叶结点，而且我们的入栈顺序保证了左子结点先被处理，所以此时的结点值就可以直接加入结果res了，然后移出栈，将head指向这个叶结点，这样的话head每次就是指向前一个处理过并且加入结果res的结点，那么如果栈顶结点的左子结点或者右子结点是head的话，说明其子结点已经加入结果res了，那么就可以处理当前结点了，代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; postorderTraversal(TreeNode*<span style="color: #000000;"> root) {
        </span><span style="color: #0000ff;">if</span> (!root) <span style="color: #0000ff;">return</span><span style="color: #000000;"> {};
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> res;
        stack</span>&lt;TreeNode*&gt;<span style="color: #000000;"> s{{root}};
        TreeNode </span>*head =<span style="color: #000000;"> root;
        </span><span style="color: #0000ff;">while</span> (!<span style="color: #000000;">s.empty()) {
            TreeNode </span>*t =<span style="color: #000000;"> s.top();
            </span><span style="color: #0000ff;">if</span> ((!t-&gt;left &amp;&amp; !t-&gt;right) || t-&gt;left == head || t-&gt;right ==<span style="color: #000000;"> head) {
                res.push_back(t</span>-&gt;<span style="color: #000000;">val);
                s.pop();
                head </span>=<span style="color: #000000;"> t;
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                </span><span style="color: #0000ff;">if</span> (t-&gt;right) s.push(t-&gt;<span style="color: #000000;">right);
                </span><span style="color: #0000ff;">if</span> (t-&gt;left) s.push(t-&gt;<span style="color: #000000;">left);
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>由于后序遍历的顺序是左-右-根，而先序遍历的顺序是根-左-右，二者其实还是很相近的，我们可以先在先序遍历的方法上做些小改动，使其遍历顺序变为根-右-左，然后翻转一下，就是左-右-根啦，翻转的方法我们使用反向Q，哦不，是反向加入结果res，每次都在结果res的开头加入结点值，而改变先序遍历的顺序就只要该遍历一下入栈顺序，先左后右，这样出栈处理的时候就是先右后左啦，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; postorderTraversal(TreeNode*<span style="color: #000000;"> root) {
        </span><span style="color: #0000ff;">if</span> (!root) <span style="color: #0000ff;">return</span><span style="color: #000000;"> {};
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> res;
        stack</span>&lt;TreeNode*&gt;<span style="color: #000000;"> s{{root}};
        </span><span style="color: #0000ff;">while</span> (!<span style="color: #000000;">s.empty()) {
            TreeNode </span>*t =<span style="color: #000000;"> s.top(); s.pop();
            res.insert(res.begin(), t</span>-&gt;<span style="color: #000000;">val);
            </span><span style="color: #0000ff;">if</span> (t-&gt;left) s.push(t-&gt;<span style="color: #000000;">left);
            </span><span style="color: #0000ff;">if</span> (t-&gt;right) s.push(t-&gt;<span style="color: #000000;">right);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>那么在<a href="http://www.cnblogs.com/grandyang/p/4146981.html" target="_blank">Binary Tree Preorder Traversal</a>中的解法二也可以改动一下变成后序遍历，改动的思路跟上面的解法一样，都是先将先序遍历的根-左-右顺序变为根-右-左，再翻转变为后序遍历的左-右-根，翻转还是改变结果res的加入顺序，然后把更新辅助结点p的左右顺序换一下即可，代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; postorderTraversal(TreeNode*<span style="color: #000000;"> root) {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> res;
        stack</span>&lt;TreeNode*&gt;<span style="color: #000000;"> s;
        TreeNode </span>*p =<span style="color: #000000;"> root;
        </span><span style="color: #0000ff;">while</span> (!s.empty() ||<span style="color: #000000;"> p) {
            </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (p) {
                s.push(p);
                res.insert(res.begin(), p</span>-&gt;<span style="color: #000000;">val);
                p </span>= p-&gt;<span style="color: #000000;">right;
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                TreeNode </span>*t =<span style="color: #000000;"> s.top(); s.pop();
                p </span>= t-&gt;<span style="color: #000000;">left;
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>论坛上还有一种双栈的解法，其实本质上跟解法二没什么区别，都是利用了改变先序遍历的顺序来实现后序遍历的，参见代码如下：</p>
<p> </p>
<p>解法四：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; postorderTraversal(TreeNode*<span style="color: #000000;"> root) {
        </span><span style="color: #0000ff;">if</span> (!root) <span style="color: #0000ff;">return</span><span style="color: #000000;"> {};
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> res;
        stack</span>&lt;TreeNode*&gt;<span style="color: #000000;"> s1, s2;
        s1.push(root);
        </span><span style="color: #0000ff;">while</span> (!<span style="color: #000000;">s1.empty()) {
            TreeNode </span>*t =<span style="color: #000000;"> s1.top(); s1.pop();
            s2.push(t);
            </span><span style="color: #0000ff;">if</span> (t-&gt;left) s1.push(t-&gt;<span style="color: #000000;">left);
            </span><span style="color: #0000ff;">if</span> (t-&gt;right) s1.push(t-&gt;<span style="color: #000000;">right);
        }
        </span><span style="color: #0000ff;">while</span> (!<span style="color: #000000;">s2.empty()) {
            res.push_back(s2.top()</span>-&gt;<span style="color: #000000;">val); s2.pop();
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4146981.html" target="_blank">Binary Tree Preorder Traversal</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4297300.html" target="_blank">Binary Tree Inorder Traversal</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4051321.html" target="_blank">Binary Tree Level Order Traversal</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/18094/java-solution-using-two-stacks">https://discuss.leetcode.com/topic/18094/java-solution-using-two-stacks</a></p>
<p><a href="https://discuss.leetcode.com/topic/30632/preorder-inorder-and-postorder-iteratively-summarization">https://discuss.leetcode.com/topic/30632/preorder-inorder-and-postorder-iteratively-summarization</a></p>
<p><a href="https://discuss.leetcode.com/topic/44231/preorder-inorder-and-postorder-traversal-iterative-java-solution">https://discuss.leetcode.com/topic/44231/preorder-inorder-and-postorder-traversal-iterative-java-solution</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-01-27 00:32</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4251757" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4251757);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4146981.html" id="cb_post_title_url">[LeetCode] Binary Tree Preorder Traversal 二叉树的先序遍历</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a binary tree, return the <em>preorder</em> traversal of its nodes' values.</p>
<p>For example:<br/>Given binary tree <code>{1,#,2,3}</code>,</p>
<pre>   1
    \
     2
    /
   3
</pre>
<p> </p>
<p>return <code>[1,2,3]</code>.</p>
<p>Note: Recursive solution is trivial, could you do it iteratively?</p>
<p> </p>
<p>一般我们提到<a href="http://zh.wikipedia.org/wiki/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86" target="_blank">树的遍历</a>，最常见的有先序遍历，中序遍历，后序遍历和层序遍历，它们用递归实现起来都非常的简单。而题目的要求是不能使用递归求解，于是只能考虑到用非递归的方法，这就要用到stack来辅助运算。由于先序遍历的顺序是"根-左-右", 算法为：</p>
<p>1. 把根节点push到栈中</p>
<p>2. 循环检测栈是否为空，若不空，则取出栈顶元素，保存其值，然后看其右子节点是否存在，若存在则push到栈中。再看其左子节点，若存在，则push到栈中。</p>
<p>代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; preorderTraversal(TreeNode*<span style="color: #000000;"> root) {
        </span><span style="color: #0000ff;">if</span> (!root) <span style="color: #0000ff;">return</span><span style="color: #000000;"> {};
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> res;
        stack</span>&lt;TreeNode*&gt;<span style="color: #000000;"> s{{root}};
        </span><span style="color: #0000ff;">while</span> (!<span style="color: #000000;">s.empty()) {
            TreeNode </span>*t =<span style="color: #000000;"> s.top(); s.pop();
            res.push_back(t</span>-&gt;<span style="color: #000000;">val);
            </span><span style="color: #0000ff;">if</span> (t-&gt;right) s.push(t-&gt;<span style="color: #000000;">right);
            </span><span style="color: #0000ff;">if</span> (t-&gt;left) s.push(t-&gt;<span style="color: #000000;">left);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种写法使用了一个辅助结点p，这种写法其实可以看作是一个模版，对应的还有中序和后序的模版写法，形式很统一，方便于记忆。辅助结点p初始化为根结点，while循环的条件是栈不为空或者辅助结点p不为空，在循环中首先判断如果辅助结点p存在，那么先将p加入栈中，然后将p的结点值加入结果res中，此时p指向其左子结点。否则如果p不存在的话，表明没有左子结点，我们取出栈顶结点，将p指向栈顶结点的右子结点，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; preorderTraversal(TreeNode*<span style="color: #000000;"> root) {</span><span style="color: #000000;">
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> res;
        stack</span>&lt;TreeNode*&gt;<span style="color: #000000;"> s;
        TreeNode </span>*p =<span style="color: #000000;"> root;
        </span><span style="color: #0000ff;">while</span> (!s.empty() ||<span style="color: #000000;"> p) {
            </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (p) {
                s.push(p);
                res.push_back(p</span>-&gt;<span style="color: #000000;">val);
                p </span>= p-&gt;<span style="color: #000000;">left;
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                TreeNode </span>*t =<span style="color: #000000;"> s.top(); s.pop();
                p </span>= t-&gt;<span style="color: #000000;">right;
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4297300.html" target="_blank">Binary Tree Inorder Traversal</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4251757.html" target="_blank">Binary Tree Postorder Traversal</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4051321.html" target="_blank">Binary Tree Level Order Traversal</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/5327635.html" target="_blank">Verify Preorder Sequence in Binary Search Tree</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/5174738.html" target="_blank">Verify Preorder Serialization of a Binary Tree</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/30632/preorder-inorder-and-postorder-iteratively-summarization">https://discuss.leetcode.com/topic/30632/preorder-inorder-and-postorder-iteratively-summarization</a></p>
<p><a href="https://discuss.leetcode.com/topic/44231/preorder-inorder-and-postorder-traversal-iterative-java-solution">https://discuss.leetcode.com/topic/44231/preorder-inorder-and-postorder-traversal-iterative-java-solution</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2014-12-05 16:29</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4146981" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4146981);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4254860.html" id="cb_post_title_url">[LeetCode] Reorder List 链表重排序</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p><span style="line-height: 1.5;"> </span></p>
<p>Given a singly linked list <em>L</em>: <em>L</em><sub>0</sub>→<em>L</em><sub>1</sub>→…→<em>L</em><sub><em>n</em>-1</sub>→<em>L</em><sub>n</sub>,<br/>
reorder it to: <em>L</em><sub>0</sub>→<em>L</em><sub><em>n</em></sub>→<em>L</em><sub>1</sub>→<em>L</em><sub><em>n</em>-1</sub>→<em>L</em><sub>2</sub>→<em>L</em><sub><em>n</em>-2</sub>→…
</p>
<p>You must do this in-place without altering the nodes' values.</p>
<p>
For example,<br/>
Given <code>{1,2,3,4}</code>, reorder it to <code>{1,4,2,3}</code>.
</p>
<p> </p>
<p>这道链表重排序问题可以拆分为以下三个小问题：</p>
<p>1. 使用快慢指针来找到链表的中点，并将链表从中点处断开，形成两个独立的链表。</p>
<p>2. 将第二个链翻转。</p>
<p>3. 将第二个链表的元素间隔地插入第一个链表中。</p>
<p> </p>
<p>代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">/*</span><span style="color: #008000;">*
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">void</span> reorderList(ListNode *<span style="color: #000000;">head) {
        </span><span style="color: #0000ff;">if</span> (!head || !head-&gt;next || !head-&gt;next-&gt;next) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
        ListNode </span>*fast =<span style="color: #000000;"> head;
        ListNode </span>*slow =<span style="color: #000000;"> head;
        </span><span style="color: #0000ff;">while</span> (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;<span style="color: #000000;">next) {
            slow </span>= slow-&gt;<span style="color: #000000;">next;
            fast </span>= fast-&gt;next-&gt;<span style="color: #000000;">next;
        }
        ListNode </span>*mid = slow-&gt;<span style="color: #000000;">next;
        slow</span>-&gt;next =<span style="color: #000000;"> NULL;
        ListNode </span>*last =<span style="color: #000000;"> mid;
        ListNode </span>*pre =<span style="color: #000000;"> NULL;
        </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> (last) {
            ListNode </span>*next = last-&gt;<span style="color: #000000;">next;
            last</span>-&gt;next =<span style="color: #000000;"> pre;
            pre </span>=<span style="color: #000000;"> last;
            last </span>=<span style="color: #000000;"> next;
        }
        </span><span style="color: #0000ff;">while</span> (head &amp;&amp;<span style="color: #000000;"> pre) {
            ListNode </span>*next = head-&gt;<span style="color: #000000;">next;
            head</span>-&gt;next =<span style="color: #000000;"> pre;
            pre </span>= pre-&gt;<span style="color: #000000;">next;
            head</span>-&gt;next-&gt;next =<span style="color: #000000;"> next;
            head </span>=<span style="color: #000000;"> next;
        }
    }
};</span></pre>
</div>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-01-28 07:16</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4254860" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4254860);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4137302.html" id="cb_post_title_url">[LeetCode] Linked List Cycle II 单链表中的环之二</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a linked list, return the node where the cycle begins. If there is no cycle, return <code>null</code>.</p>
<p> Follow up:<br/>
Can you solve it without using extra space?
</p>
<p> </p>
<p>这个求单链表中的环的起始点是之前那个判断单链表中是否有环的延伸，可参见我之前的一篇文章 (<a href="http://www.cnblogs.com/grandyang/p/4137187.html" target="_blank">http://www.cnblogs.com/grandyang/p/4137187.html</a>). 还是要设快慢指针，不过这次要记录两个指针相遇的位置，当两个指针相遇了后，让其一指针从链表头开始，一步两步，一步一步似爪牙，似魔鬼的步伐。。。哈哈，打住打住。。。此时再相遇的位置就是链表中环的起始位置。代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    ListNode </span>*detectCycle(ListNode *<span style="color: #000000;">head) {
        ListNode </span>*slow = head, *fast =<span style="color: #000000;"> head;
        </span><span style="color: #0000ff;">while</span> (fast &amp;&amp; fast-&gt;<span style="color: #000000;">next) {
            slow </span>= slow-&gt;<span style="color: #000000;">next;
            fast </span>= fast-&gt;next-&gt;<span style="color: #000000;">next;
            </span><span style="color: #0000ff;">if</span> (slow == fast) <span style="color: #0000ff;">break</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">if</span> (!fast || !fast-&gt;next) <span style="color: #0000ff;">return</span><span style="color: #000000;"> NULL;
        slow </span>=<span style="color: #000000;"> head;
        </span><span style="color: #0000ff;">while</span> (slow !=<span style="color: #000000;"> fast) {
            slow </span>= slow-&gt;<span style="color: #000000;">next;
            fast </span>= fast-&gt;<span style="color: #000000;">next;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> fast;
    }
};</span></pre>
</div>
<p><span style="line-height: 1.5;"> </span></p>
<p>单链表中的环的问题还有许多扩展，比如求环的长度，或者是如何解除环等等，可参见网上大神的总结 (<a href="http://www.cnblogs.com/hiddenfox/p/3408931.html" target="_blank">http://www.cnblogs.com/hiddenfox/p/3408931.html</a>).</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2014-12-02 14:10</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4137302" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4137302);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4137187.html" id="cb_post_title_url">[LeetCode] Linked List Cycle 单链表中的环</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p>Given a linked list, determine if it has a cycle in it.</p>
<p> Follow up:<br/>
Can you solve it without using extra space?
</p>
<p> </p>
<p>这道题是快慢指针的经典应用。只需要设两个指针，一个每次走一步的慢指针和一个每次走两步的快指针，如果链表里有环的话，两个指针最终肯定会相遇。实在是太巧妙了，要是我肯定想不出来。代码如下：</p>
<p> </p>
<p>C++ 解法：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> hasCycle(ListNode *<span style="color: #000000;">head) {
        ListNode </span>*slow = head, *fast =<span style="color: #000000;"> head;
        </span><span style="color: #0000ff;">while</span> (fast &amp;&amp; fast-&gt;<span style="color: #000000;">next) {
            slow </span>= slow-&gt;<span style="color: #000000;">next;
            fast </span>= fast-&gt;next-&gt;<span style="color: #000000;">next;
            </span><span style="color: #0000ff;">if</span> (slow == fast) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>Java 解法：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">boolean</span><span style="color: #000000;"> hasCycle(ListNode head) {
        ListNode slow </span>= head, fast =<span style="color: #000000;"> head;
        </span><span style="color: #0000ff;">while</span> (fast != <span style="color: #0000ff;">null</span> &amp;&amp; fast.next != <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
            slow </span>=<span style="color: #000000;"> slow.next;
            fast </span>=<span style="color: #000000;"> fast.next.next;
            </span><span style="color: #0000ff;">if</span> (slow == fast) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
    }
}</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4137302.html" id="cb_post_title_url">Linked List Cycle II 单链表中的环之二</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2014-12-02 13:23</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4137187" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4137187);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4576240.html" id="cb_post_title_url">[LeetCode] Word Break II 拆分词句之二</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a non-empty string <em>s</em> and a dictionary <em>wordDict</em> containing a list of non-empty words, add spaces in <em>s</em> to construct a sentence where each word is a valid dictionary word. Return all such possible sentences.</p>
<p>Note:</p>
<ul>
<li>The same word in the dictionary may be reused multiple times in the segmentation.</li>
<li>You may assume the dictionary does not contain duplicate words.</li>
</ul>
<p>Example 1:</p>
<pre>Input:
s = "<code>catsanddog</code>"
wordDict = <code>["cat", "cats", "and", "sand", "dog"]</code>
Output:
<code>[
  "cats and dog",
  "cat sand dog"
]</code>
</pre>
<p>Example 2:</p>
<pre>Input:
s = "pineapplepenapple"
wordDict = ["apple", "pen", "applepen", "pine", "pineapple"]
Output:
[
  "pine apple pen apple",
  "pineapple pen apple",
  "pine applepen apple"
]
Explanation: Note that you are allowed to reuse a dictionary word.
</pre>
<p>Example 3:</p>
<pre>Input:
s = "catsandog"
wordDict = ["cats", "dog", "sand", "and", "cat"]
Output:
[]</pre>
<p> </p>
<p>这道题是之前那道<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4257740.html" id="cb_post_title_url">Word Break 拆分词句</a>的拓展，那道题只让我们判断给定的字符串能否被拆分成字典中的词，而这道题加大了难度，让我们求出所有可以拆分成的情况，就像题目中给的例子所示。之前的版本中字典wordDict的数据类型是HashSet，现在的不知为何改成了数组vector，而且博主看到第二个例子就笑了，PPAP么，哈哈。</p>
<p>根据博主行走江湖多年的经验，像这种返回结果要列举所有情况的题，十有八九都是要用递归来做的。当我们一时半会没有啥思路的时候，先不要考虑代码如何实现，如果就给你一个s和wordDict，不看Output的内容，你会怎么找出结果。比如对于例子1，博主可能会先扫一遍wordDict数组，看有没有单词可以当s的开头，那么我们可以发现cat和cats都可以，比如我们先选了cat，那么此时s就变成了 "sanddog"，我们再在数组里找单词，发现了sand可以，最后剩一个dog，也在数组中，于是一个结果就出来了。然后回到开头选cats的话，那么此时s就变成了 "anddog"，我们再在数组里找单词，发现了and可以，最后剩一个dog，也在数组中，于是另一个结果也就出来了。那么这个查询的方法很适合用递归来实现，因为s改变后，查询的机制并不变，很适合调用递归函数。再者，我们要明确的是，如果不用记忆数组做减少重复计算的优化，那么递归方法跟brute force没什么区别，大概率无法通过OJ。所以我们要避免重复计算，如何避免呢，还是看上面的分析，如果当s变成 "sanddog"的时候，那么此时我们知道其可以拆分成sand和dog，当某个时候如果我们又遇到了这个 "sanddog"的时候，我们难道还需要再调用递归算一遍吗，当然不希望啦，所以我们要将这个中间结果保存起来，由于我们必须要同时保存s和其所有的拆分的字符串，那么可以使用一个HashMap，来建立二者之间的映射，那么在递归函数中，我们首先检测当前s是否已经有映射，有的话直接返回即可，如果s为空了，我们如何处理呢，题目中说了给定的s不会为空，但是我们递归函数处理时s是会变空的，这时候我们是直接返回空集吗，这里有个小trick，我们其实放一个空字符串返回，为啥要这么做呢？我们观察题目中的Output，发现单词之间是有空格，而最后一个单词后面没有空格，所以这个空字符串就起到了标记当前单词是最后一个，那么我们就不要再加空格了。接着往下看，我们遍历wordDict数组，如果某个单词是s字符串中的开头单词的话，我们对后面部分调用递归函数，将结果保存到rem中，然后遍历里面的所有字符串，和当前的单词拼接起来，这里就用到了我们前面说的trick。for循环结束后，记得返回结果res之前建立其和s之间的映射，方便下次使用，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; wordBreak(<span style="color: #0000ff;">string</span> s, vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp;<span style="color: #000000;"> wordDict) {
        unordered_map</span>&lt;<span style="color: #0000ff;">string</span>, vector&lt;<span style="color: #0000ff;">string</span>&gt;&gt;<span style="color: #000000;"> m;
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> helper(s, wordDict, m);
    }
    vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; helper(<span style="color: #0000ff;">string</span> s, vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp; wordDict, unordered_map&lt;<span style="color: #0000ff;">string</span>, vector&lt;<span style="color: #0000ff;">string</span>&gt;&gt;&amp;<span style="color: #000000;"> m) {
        </span><span style="color: #0000ff;">if</span> (m.count(s)) <span style="color: #0000ff;">return</span><span style="color: #000000;"> m[s];
        </span><span style="color: #0000ff;">if</span> (s.empty()) <span style="color: #0000ff;">return</span> {<span style="color: #800000;">""</span><span style="color: #000000;">};
        vector</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">string</span><span style="color: #000000;"> word : wordDict) {
            </span><span style="color: #0000ff;">if</span> (s.substr(<span style="color: #800080;">0</span>, word.size()) != word) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
            vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; rem =<span style="color: #000000;"> helper(s.substr(word.size()), wordDict, m);
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">string</span><span style="color: #000000;"> str : rem) {
                res.push_back(word </span>+ (str.empty() ? <span style="color: #800000;">""</span> : <span style="color: #800000;">"</span> <span style="color: #800000;">"</span>) +<span style="color: #000000;"> str);
            }
        }
        </span><span style="color: #0000ff;">return</span> m[s] =<span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>我们也可以将将主函数本身当作递归函数，这样就不用单独的使用一个递归函数了，不过我们的HashMap必须是全局了，写在外部就好了，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    unordered_map</span>&lt;<span style="color: #0000ff;">string</span>, vector&lt;<span style="color: #0000ff;">string</span>&gt;&gt;<span style="color: #000000;"> m;
    vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; wordBreak(<span style="color: #0000ff;">string</span> s, vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp;<span style="color: #000000;"> wordDict) {
        </span><span style="color: #0000ff;">if</span> (m.count(s)) <span style="color: #0000ff;">return</span><span style="color: #000000;"> m[s];
        </span><span style="color: #0000ff;">if</span> (s.empty()) <span style="color: #0000ff;">return</span> {<span style="color: #800000;">""</span><span style="color: #000000;">};
        vector</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">string</span><span style="color: #000000;"> word : wordDict) {
            </span><span style="color: #0000ff;">if</span> (s.substr(<span style="color: #800080;">0</span>, word.size()) != word) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
            vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; rem =<span style="color: #000000;"> wordBreak(s.substr(word.size()), wordDict);
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">string</span><span style="color: #000000;"> str : rem) {
                res.push_back(word </span>+ (str.empty() ? <span style="color: #800000;">""</span> : <span style="color: #800000;">"</span> <span style="color: #800000;">"</span>) +<span style="color: #000000;"> str);
            }
        }
        </span><span style="color: #0000ff;">return</span> m[s] =<span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4257740.html" target="_blank">Word Break</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/6254527.html" target="_blank">Concatenated Words</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-06-15 05:49</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4576240" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4576240);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4257740.html" id="cb_post_title_url">[LeetCode] Word Break 拆分词句</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a non-empty string <em>s</em> and a dictionary <em>wordDict</em> containing a list of non-empty words, determine if <em>s</em> can be segmented into a space-separated sequence of one or more dictionary words.</p>
<p>Note:</p>
<ul>
<li>The same word in the dictionary may be reused multiple times in the segmentation.</li>
<li>You may assume the dictionary does not contain duplicate words.</li>
</ul>
<p>Example 1:</p>
<pre>Input: s = "leetcode", wordDict = ["leet", "code"]
Output: true
Explanation: Return true because <code>"leetcode"</code> can be segmented as <code>"leet code"</code>.
</pre>
<p>Example 2:</p>
<pre>Input: s = "applepenapple", wordDict = ["apple", "pen"]
Output: true
Explanation: Return true because <code>"</code>applepenapple<code>"</code> can be segmented as <code>"</code>apple pen apple<code>"</code>.
             Note that you are allowed to reuse a dictionary word.
</pre>
<p>Example 3:</p>
<pre>Input: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
Output: false</pre>
<p> </p>
<p>这道拆分词句问题是看给定的词句能分被拆分成字典里面的内容，这是一道很经典的题目，解法不止一种，考察的范围很广，属于我们必须要熟练掌握的题目。那么先来想brute force的解法，就拿例子1来分析，如果字典中只有两个单词，我们怎么去判断，是不是可以将原字符串s分成任意两段，然后再看分成的单词是否在字典中。注意这道题说是单词可以重复使用，所以可以分成任意段，而且字典中的单词可以有很多个，这就增加了题目的难度，很多童鞋就在这里迷失了，毫无头绪。那么，就由博主来给各位指点迷津吧（此处应有掌声👏）。</p>
<p>既然要分段，看子字符串是否在字典中，由于给定的字典是数组（之前还是HashSet呢），那么我们肯定不希望每次查找都需要遍历一遍数组，费劲！还是把字典中的所有单词都存入HashSet中吧，这样我们就有了常数时间级的查找速度，perfect！好，我们得开始给字符串分段了，怎么分，只能一个一个分了，先看第一个字母是否在字典中，如果不在的话，好办，说明这种分法肯定是错的。问题是在的话，后面的那部分怎么处理，难道还用for循环？你也不知道还要分多少段，怎么用for循环。对于这种不知道怎么处理的情况，一个万能的做法是丢给递归函数，让其去递归求解，这里我们suppose递归函数会返回我们一个正确的值，如果返回的是true的话，表明我们现在分成的两段都在字典中，我们直接返回true即可，因为只要找出一种情况就行了。这种调用递归函数的方法就是brute force的解法，我们遍历了所有的情况，优点是写法简洁，思路清晰，缺点是存在大量的重复计算，被OJ啪啪打脸。所以我们需要进行优化，使用记忆数组memo来保存所有已经计算过的结果，再下次遇到的时候，直接从cache中取，而不是再次计算一遍。这种使用记忆数组memo的递归写法，和使用dp数组的迭代写法，乃解题的两大神器，凡事能用dp解的题，一般也有用记忆数组的递归解法，好似一对形影不离的好基友～关于dp解法，博主会在下文中讲解。这里我们的记忆数组memo[i]定义为范围为[0, i)的子字符串是否可以拆分，初始化为-1，表示没有计算过，如果可以拆分，则赋值为1，反之为0。在之前讲brute force解法时，博主提到的是讲分成两段的后半段的调用递归函数，我们也可以不取出子字符串，而是用一个start变量，来标记分段的位置，这样递归函数中只需要从start的位置往后遍历即可，在递归函数更新记忆数组memo即可，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> wordBreak(<span style="color: #0000ff;">string</span> s, vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp;<span style="color: #000000;"> wordDict) {
        unordered_set</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> wordSet(wordDict.begin(), wordDict.end());
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; memo(s.size(), -<span style="color: #800080;">1</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">return</span> check(s, wordSet, <span style="color: #800080;">0</span><span style="color: #000000;">, memo);
    }
    </span><span style="color: #0000ff;">bool</span> check(<span style="color: #0000ff;">string</span> s, unordered_set&lt;<span style="color: #0000ff;">string</span>&gt;&amp; wordSet, <span style="color: #0000ff;">int</span> start, vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> memo) {
        </span><span style="color: #0000ff;">if</span> (start &gt;= s.size()) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (memo[start] != -<span style="color: #800080;">1</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;"> memo[start];
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = start + <span style="color: #800080;">1</span>; i &lt;= s.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (wordSet.count(s.substr(start, i - start)) &amp;&amp;<span style="color: #000000;"> check(s, wordSet, i, memo)) {
                </span><span style="color: #0000ff;">return</span> memo[start] = <span style="color: #800080;">1</span><span style="color: #000000;">;
            }
        }
        </span><span style="color: #0000ff;">return</span> memo[start] = <span style="color: #800080;">0</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>这道题其实还是一道经典的DP题目，也就是动态规划Dynamic Programming。博主曾经说玩子数组或者子字符串且求极值的题，基本就是DP没差了，虽然这道题没有求极值，但是玩子字符串也符合DP的状态转移的特点。把一个人的温暖转移到另一个人的胸膛... 咳咳，跑错片场了，那是爱情转移～ 强行拉回，DP解法的两大难点，定义dp数组跟找出状态转移方程，先来看dp数组的定义，这里我们就用一个一维的dp数组，其中dp[i]表示范围[0, i)内的子串是否可以拆分，注意这里dp数组的长度比s串的长度大1，是因为我们要handle空串的情况，我们初始化dp[0]为true，然后开始遍历。注意这里我们需要两个for循环来遍历，因为此时已经没有递归函数了，所以我们必须要遍历所有的子串，我们用j把[0, i)范围内的子串分为了两部分，[0, j) 和 [j, i)，其中范围 [0, j) 就是dp[j]，范围 [j, i) 就是s.substr(j, i-j)，其中dp[j]是之前的状态，我们已经算出来了，可以直接取，只需要在字典中查找s.substr(j, i-j)是否存在了，如果二者均为true，将dp[i]赋为true，并且break掉，此时就不需要再用j去分[0, i)范围了，因为[0, i)范围已经可以拆分了。最终我们返回dp数组的最后一个值，就是整个数组是否可以拆分的布尔值了，代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> wordBreak(<span style="color: #0000ff;">string</span> s, vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp;<span style="color: #000000;"> wordDict) {
        unordered_set</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> wordSet(wordDict.begin(), wordDict.end());
        vector</span>&lt;<span style="color: #0000ff;">bool</span>&gt; dp(s.size() + <span style="color: #800080;">1</span><span style="color: #000000;">);
        dp[</span><span style="color: #800080;">0</span>] = <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; dp.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; i; ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> (dp[j] &amp;&amp; wordSet.count(s.substr(j, i -<span style="color: #000000;"> j))) {
                    dp[i] </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                }
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> dp.back();
    }
};</span></pre>
</div>
<p> </p>
<p>下面我们从题目中给的例子来分析：</p>
<p class="p1"><span class="s1">l </span></p>
<p class="p1"><span class="s1">le e </span></p>
<p class="p1"><span class="s1">lee ee e </span></p>
<p class="p1"><span class="s1"><strong>leet</strong> </span></p>
<p class="p1"><span class="s1">leetc eetc etc tc c </span></p>
<p class="p1"><span class="s1">leetco eetco etco tco co o </span></p>
<p class="p1"><span class="s1">leetcod eetcod etcod tcod cod od d </span></p>
<p class="p1"><span class="s1">leetcode eetcode etcode tcode <strong>code </strong></span></p>
<p class="p1"><span class="s1">T F F F T F F F T </span></p>
<p class="p1"><span class="s1">我们知道算法的核心思想是逐行扫描，每一行再逐个字符扫描，每次都在组合出一个新的字符串都要到字典里去找，如果有的话，则跳过此行，继续扫描下一行。</span></p>
<p class="p1"> </p>
<p>既然DFS都可以解题，那么BFS也就坐不住了，也要出来蹦跶一下。其实本质跟递归的解法没有太大的区别，递归解法在调用递归的时候，原先的状态被存入了栈中，这里BFS是存入了队列中，使用visited数组来标记已经算过的位置，作用跟memo数组一样，从队列中取出一个位置进行遍历，把可以拆分的新位置存入队列中，遍历完成后标记当前位置，然后再到队列中去取即可，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> wordBreak(<span style="color: #0000ff;">string</span> s, vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp;<span style="color: #000000;"> wordDict) {
        unordered_set</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> wordSet(wordDict.begin(), wordDict.end());
        vector</span>&lt;<span style="color: #0000ff;">bool</span>&gt;<span style="color: #000000;"> visited(s.size());
        queue</span>&lt;<span style="color: #0000ff;">int</span>&gt; q{{<span style="color: #800080;">0</span><span style="color: #000000;">}};
        </span><span style="color: #0000ff;">while</span> (!<span style="color: #000000;">q.empty()) {
            </span><span style="color: #0000ff;">int</span> start =<span style="color: #000000;"> q.front(); q.pop();
            </span><span style="color: #0000ff;">if</span> (!<span style="color: #000000;">visited[start]) {
                </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = start + <span style="color: #800080;">1</span>; i &lt;= s.size(); ++<span style="color: #000000;">i) {
                    </span><span style="color: #0000ff;">if</span> (wordSet.count(s.substr(start, i -<span style="color: #000000;"> start))) {
                        q.push(i);
                        </span><span style="color: #0000ff;">if</span> (i == s.size()) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                    }
                }
                visited[start] </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
            }
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p class="p1">类似题目：</p>
<p class="p1"><a href="http://www.cnblogs.com/grandyang/p/4576240.html" target="_blank">Word Break II</a></p>
<p class="p1"> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-01-29 04:59</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4257740" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4257740);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4261431.html" id="cb_post_title_url">[LeetCode] Copy List with Random Pointer 拷贝带有随机指针的链表</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.</p>
<p>Return a deep copy of the list.</p>
<p> </p>
<p>这道链表的深度拷贝题的难点就在于如何处理随机指针的问题，由于每一个节点都有一个随机指针，这个指针可以为空，也可以指向链表的任意一个节点，如果我们在每生成一个新节点给其随机指针赋值时，都要去遍历原链表的话，OJ上肯定会超时，所以我们可以考虑用Hash map来缩短查找时间，第一遍遍历生成所有新节点时同时建立一个原节点和新节点的哈希表，第二遍给随机指针赋值时，查找时间是常数级。代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    RandomListNode </span>*copyRandomList(RandomListNode *<span style="color: #000000;">head) {
        </span><span style="color: #0000ff;">if</span> (!head) <span style="color: #0000ff;">return</span><span style="color: #000000;"> NULL;
        RandomListNode </span>*res = <span style="color: #0000ff;">new</span> RandomListNode(head-&gt;<span style="color: #000000;">label);
        RandomListNode </span>*node =<span style="color: #000000;"> res;
        RandomListNode </span>*cur = head-&gt;<span style="color: #000000;">next;
        map</span>&lt;RandomListNode*, RandomListNode*&gt;<span style="color: #000000;"> m;
        m[head] </span>=<span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> (cur) {
            RandomListNode </span>*tmp = <span style="color: #0000ff;">new</span> RandomListNode(cur-&gt;<span style="color: #000000;">label);
            node</span>-&gt;next =<span style="color: #000000;"> tmp;
            m[cur] </span>=<span style="color: #000000;"> tmp;
            node </span>= node-&gt;<span style="color: #000000;">next;
            cur </span>= cur-&gt;<span style="color: #000000;">next;
        }
        node </span>=<span style="color: #000000;"> res;
        cur </span>=<span style="color: #000000;"> head;
        </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> (node) {
            node</span>-&gt;random = m[cur-&gt;<span style="color: #000000;">random];
            node </span>= node-&gt;<span style="color: #000000;">next;
            cur </span>= cur-&gt;<span style="color: #000000;">next;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>当然，如果使用哈希表占用额外的空间，如果这道题限制了空间的话，就要考虑别的方法。下面这个方法很巧妙，具体细节可参见神网友<a href="http://fisherlei.blogspot.com/2013/11/leetcode-copy-list-with-random-pointer.html" target="_blank">水中的鱼的博客</a>，该方法可以分为以下三个步骤：</p>
<p>1. 在原链表的每个节点后面拷贝出一个新的节点</p>
<p>2. 依次给新的节点的随机指针赋值，而且这个赋值非常容易 cur-&gt;next-&gt;random = cur-&gt;random-&gt;next</p>
<p>3. 断开链表可得到深度拷贝后的新链表</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    RandomListNode </span>*copyRandomList(RandomListNode *<span style="color: #000000;">head) {
        </span><span style="color: #0000ff;">if</span> (!head) <span style="color: #0000ff;">return</span><span style="color: #000000;"> NULL;
        RandomListNode </span>*cur =<span style="color: #000000;"> head;
        </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> (cur) {
            RandomListNode </span>*node = <span style="color: #0000ff;">new</span> RandomListNode(cur-&gt;<span style="color: #000000;">label);
            node</span>-&gt;next = cur-&gt;<span style="color: #000000;">next;
            cur</span>-&gt;next =<span style="color: #000000;"> node;
            cur </span>= node-&gt;<span style="color: #000000;">next;
        }
        cur </span>=<span style="color: #000000;"> head;
        </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> (cur) {
            </span><span style="color: #0000ff;">if</span> (cur-&gt;<span style="color: #000000;">random) {
                cur</span>-&gt;next-&gt;random = cur-&gt;random-&gt;<span style="color: #000000;">next;
            }
            cur </span>= cur-&gt;next-&gt;<span style="color: #000000;">next;
        }
        cur </span>=<span style="color: #000000;"> head;
        RandomListNode </span>*res = head-&gt;<span style="color: #000000;">next;
        </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> (cur) {
            RandomListNode </span>*tmp = cur-&gt;<span style="color: #000000;">next;
            cur</span>-&gt;next = tmp-&gt;<span style="color: #000000;">next;
            </span><span style="color: #0000ff;">if</span>(tmp-&gt;next) tmp-&gt;next = tmp-&gt;next-&gt;<span style="color: #000000;">next;
            cur </span>= cur-&gt;<span style="color: #000000;">next;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-01-30 05:34</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4261431" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4261431);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4263927.html" id="cb_post_title_url">[LeetCode] Single Number II 单独的数字之二</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given an array of integers, every element appears <em>three</em> times except for one. Find that single one.</p>
<p>Note:<br/>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p>
<p> </p>
<p>这道题是之前那道 <a href="http://www.cnblogs.com/Given%20an%20array%20of%20integers,%20every%20element%20appears%20three%20times%20except%20for%20one.%20Find%20that%20single%20one.%20%20Note:%20Your%20algorithm%20should%20have%20a%20linear%20runtime%20complexity.%20Could%20you%20implement%20it%20without%20using%20extra%20memory" target="_blank">Single Number 单独的数字 </a>的延伸，那道题的解法就比较独特，是利用计算机按位储存数字的特性来做的，这道题就是除了一个单独的数字之外，数组中其他的数字都出现了三次，那么还是要利用位操作 Bit Operation 来解此题。我们可以建立一个32位的数字，来统计每一位上1出现的个数，我们知道如果某一位上为1的话，那么如果该整数出现了三次，对3去余为0，我们把每个数的对应位都加起来对3取余，最终剩下来的那个数就是单独的数字。代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> singleNumber(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; <span style="color: #800080;">32</span>; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">int</span> sum = <span style="color: #800080;">0</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; nums.size(); ++<span style="color: #000000;">j) {
                sum </span>+= (nums[j] &gt;&gt; i) &amp; <span style="color: #800080;">1</span><span style="color: #000000;">;
            }
            res </span>|= (sum % <span style="color: #800080;">3</span>) &lt;&lt;<span style="color: #000000;"> i;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p><span style="line-height: 1.5;"> </span></p>
<p>还有一种解法，思路很相似，用3个整数来表示INT的各位的出现次数情况，one表示出现了1次，two表示出现了2次。当出现3次的时候该位清零。最后答案就是one的值。</p>
<ol>
<li><code>ones</code>   代表第i<sup>th</sup> 位只出现一次的掩码变量</li>
<li><code>twos</code>  代表第i<sup>th</sup> 位只出现两次次的掩码变量</li>
<li><code>threes</code>  代表第i<sup>th</sup> 位只出现三次的掩码变量</li>
</ol>
<p>假设现在有一个数字1，那么我们更新one的方法就是‘亦或’这个1，则one就变成了1，而two的更新方法是用上一个状态下的one去‘与’上数字1，然后‘或’上这个结果，这样假如之前one是1，那么此时two也会变成1，这make sense，因为说明是当前位遇到两个1了；反之如果之前one是0，那么现在two也就是0。注意更新的顺序是先更新two，再更新one，不理解的话只要带个只有一个数字1的输入数组看一下就不难理解了。然后我们更新three，如果此时one和two都是1了，那么由于我们先更新的two，再更新的one，two为1，说明此时至少有两个数字1了，而此时one为1，说明了此时已经有了三个数字1，这块要仔细想清楚，因为one是要‘亦或’一个1的，值能为1，说明之前one为0，实际情况是，当第二个1来的时候，two先更新为1，此时one再更新为0，下面three就是0了，那么‘与’上three的相反数1不会改变one和two的值；那么当第三个1来的时候，two还是1，此时one就更新为1了，那么three就更新为1了，此时就要清空one和two了，让它们‘与’上three的相反数0即可，最终结果将会保存在one中，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> singleNumber(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        </span><span style="color: #0000ff;">int</span> one = <span style="color: #800080;">0</span>, two = <span style="color: #800080;">0</span>, three = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; nums.size(); ++<span style="color: #000000;">i) {
            two </span>|= one &amp;<span style="color: #000000;"> nums[i];
            one </span>^=<span style="color: #000000;"> nums[i];
            three </span>= one &amp;<span style="color: #000000;"> two;
            one </span>&amp;= ~<span style="color: #000000;">three;
            two </span>&amp;= ~<span style="color: #000000;">three;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> one;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种解法思路也十分巧妙，根据上面解法的思路，我们把数组中数字的每一位累加起来对3取余，剩下的结果就是那个单独数组该位上的数字，由于我们累加的过程都要对3取余，那么每一位上累加的过程就是0-&gt;1-&gt;2-&gt;0，换成二进制的表示为00-&gt;01-&gt;10-&gt;00，那么我们可以写出对应关系：</p>
<p>00 (+) 1 = 01</p>
<p>01 (+) 1 = 10</p>
<p>10 (+) 1 = 00 ( mod 3)</p>
<p>那么我们用ab来表示开始的状态，对于加1操作后，得到的新状态的ab的算法如下：</p>
<p>b = b xor r &amp; ~a;</p>
<p>a = a xor r &amp; ~b;</p>
<p>我们这里的ab就是上面的三种状态00，01，10的十位和各位，刚开始的时候，a和b都是0，当此时遇到数字1的时候，b更新为1，a更新为0，就是01的状态；再次遇到1的时候，b更新为0，a更新为1，就是10的状态；再次遇到1的时候，b更新为0，a更新为0，就是00的状态，相当于重置了；最后的结果保存在b中。明白了上面的分析过程，就能写出代码如下；</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> singleNumber(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        </span><span style="color: #0000ff;">int</span> a = <span style="color: #800080;">0</span>, b = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; nums.size(); ++<span style="color: #000000;">i) {
            b </span>= (b ^ nums[i]) &amp; ~<span style="color: #000000;">a;
            a </span>= (a ^ nums[i]) &amp; ~<span style="color: #000000;">b;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> b;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4130577.html" target="_blank">Single Number</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4741122.html" target="_blank">Single Number III</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/2031/challenge-me-thx/58" target="_blank">https://discuss.leetcode.com/topic/2031/challenge-me-thx/58</a></p>
<p><a href="https://discuss.leetcode.com/topic/18085/java-bit-manipulation-solution" target="_blank">https://discuss.leetcode.com/topic/18085/java-bit-manipulation-solution</a></p>
<p><a href="https://discuss.leetcode.com/topic/43166/java-o-n-easy-to-understand-solution-easily-extended-to-any-times-of-occurance" target="_blank">https://discuss.leetcode.com/topic/43166/java-o-n-easy-to-understand-solution-easily-extended-to-any-times-of-occurance</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-01-31 13:05</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4263927" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4263927);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4130577.html" id="cb_post_title_url">[LeetCode] Single Number  单独的数字</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given an array of integers, every element appears <em>twice</em> except for one. Find that single one.</p>
<p>Note:<br/>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p>
<p> </p>
<p>本来是一道非常简单的题，但是由于加上了时间复杂度必须是O(n)，并且空间复杂度为O(1)，使得不能用排序方法，也不能使用map数据结构。那么只能另辟蹊径，需要用位操作Bit Operation来解此题，这个解法如果让我想，肯定想不出来，因为谁会想到用<a href="http://zh.wikipedia.org/wiki/%E9%80%BB%E8%BE%91%E5%BC%82%E6%88%96" target="_blank"><strong>逻辑异或</strong></a>来解题呢。逻辑异或的真值表为：</p>
<p> 异或运算<img alt="A \oplus B" class="mwe-math-fallback-image-inline tex" src="http://upload.wikimedia.org/math/0/2/1/021a6af6071cb77c364718edc0ca959b.png"/>的<a href="http://zh.wikipedia.org/wiki/%E7%9C%9F%E5%80%BC%E8%A1%A8" title="真值表">真值表</a>如下：</p>
<table class="wikitable">
<tbody>
<tr><th><big>A</big></th><th><big>B</big></th><th><big>⊕</big></th></tr>
<tr>
<td>F</td>
<td>F</td>
<td>F</td>
</tr>
<tr>
<td>F</td>
<td>T</td>
<td>T</td>
</tr>
<tr>
<td>T</td>
<td>F</td>
<td>T</td>
</tr>
<tr>
<td>T</td>
<td>T</td>
<td>F<br/><br/></td>
</tr>
</tbody>
</table>
<p>由于数字在计算机是以二进制存储的，每位上都是0或1，如果我们把两个相同的数字异或，0与0异或是0,1与1异或也是0，那么我们会得到0。根据这个特点，我们把数组中所有的数字都异或起来，则每对相同的数字都会得0，然后最后剩下来的数字就是那个只有1次的数字。这个方法确实很赞，但是感觉一般人不会忘异或上想，绝对是为CS专业的同学设计的好题呀，赞一个~~ </p>
<p> </p>
<p>C++ 解法：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> singleNumber(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (auto num : nums) res ^=<span style="color: #000000;"> num;
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>Java 解法：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span> singleNumber(<span style="color: #0000ff;">int</span><span style="color: #000000;">[] nums) {
        </span><span style="color: #0000ff;">int</span> res = 0<span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> num : nums) res ^=<span style="color: #000000;"> num;
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
}</span></pre>
</div>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2014-11-29 13:06</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4130577" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4130577);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4575026.html" id="cb_post_title_url">[LeetCode] Candy 分糖果问题</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>There are <em>N</em> children standing in a line. Each child is assigned a rating value.</p>
<p>You are giving candies to these children subjected to the following requirements:</p>
<ul>
<li>Each child must have at least one candy.</li>
<li>Children with a higher rating get more candies than their neighbors.</li>
</ul>
<p>What is the minimum candies you must give?</p>
<p> </p>
<p>这道题看起来很难，其实解法并没有那么复杂，当然我也是看了别人的解法才做出来的，先来看看两遍遍历的解法，首先初始化每个人一个糖果，然后这个算法需要遍历两遍，第一遍从左向右遍历，如果右边的小盆友的等级高，等加一个糖果，这样保证了一个方向上高等级的糖果多。然后再从右向左遍历一遍，如果相邻两个左边的等级高，而左边的糖果又少的话，则左边糖果数为右边糖果数加一。最后再把所有小盆友的糖果数都加起来返回即可。代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> candy(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> ratings) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, n =<span style="color: #000000;"> ratings.size();
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; nums(n, <span style="color: #800080;">1</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n - <span style="color: #800080;">1</span>; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (ratings[i + <span style="color: #800080;">1</span>] &gt; ratings[i]) nums[i + <span style="color: #800080;">1</span>] = nums[i] + <span style="color: #800080;">1</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = n - <span style="color: #800080;">1</span>; i &gt; <span style="color: #800080;">0</span>; --<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (ratings[i - <span style="color: #800080;">1</span>] &gt; ratings[i]) nums[i - <span style="color: #800080;">1</span>] = max(nums[i - <span style="color: #800080;">1</span>], nums[i] + <span style="color: #800080;">1</span><span style="color: #000000;">);
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> num : nums) res +=<span style="color: #000000;"> num;
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>下面来看一次遍历的方法，相比于遍历两次的思路简单明了，这种只遍历一次的解法就稍有些复杂了。首先我们给第一个同学一个糖果，那么对于接下来的一个同学就有三种情况：</p>
<p>1. 接下来的同学的rating等于前一个同学，那么给接下来的同学一个糖果就行。</p>
<p>2. 接下来的同学的rating大于前一个同学，那么给接下来的同学的糖果数要比前一个同学糖果数加1。</p>
<p>3.接下来的同学的rating小于前一个同学，那么我们此时不知道应该给这个同学多少个糖果，需要看后面的情况。</p>
<p>对于第三种情况，我们不确定要给几个，因为要是只给1个的话，那么有可能接下来还有rating更小的同学，总不能一个都不给吧。也不能直接给前一个同学的糖果数减1，有可能给多了，因为如果后面再没人了的话，其实只要给一个就行了。还有就是，如果后面好几个rating越来越小的同学，那么前一个同学的糖果数可能还得追加，以保证最后面的同学至少能有1个糖果。来一个例子吧，四个同学，他们的rating如下：</p>
<p>1 3 2 1</p>
<p>先给第一个rating为1的同学一个糖果，然后从第二个同学开始遍历，第二个同学rating为3，比1大，所以多给一个糖果，第二个同学得到两个糖果。下面第三个同学，他的rating为2，比前一个同学的rating小，如果我们此时给1个糖果的话，那么rating更小的第四个同学就得不到糖果了，所以我们要给第四个同学1个糖果，而给第三个同学2个糖果，此时要给第二个同学追加1个糖果，使其能够比第三个同学的糖果数多至少一个。那么我们就需要统计出多有个连着的同学的rating变小，用变量cnt来记录，找出了最后一个减小的同学，那么就可以往前推，每往前一个加一个糖果，这就是个等差数列，我们可以直接利用求和公式算出这些rating减小的同学的糖果之和。然后我们还要看第一个开始减小的同学的前一个同学需不需要追加糖果，只要比较cnt和pre的大小，pre是之前同学得到的最大糖果数，二者做差加1就是需要追加的糖果数，加到结果res中即可，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> candy(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> ratings) {
        </span><span style="color: #0000ff;">if</span> (ratings.empty()) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">1</span>, pre = <span style="color: #800080;">1</span>, cnt = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt; ratings.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (ratings[i] &gt;= ratings[i - <span style="color: #800080;">1</span><span style="color: #000000;">]) {
                </span><span style="color: #0000ff;">if</span> (cnt &gt; <span style="color: #800080;">0</span><span style="color: #000000;">) {
                    res </span>+= cnt * (cnt + <span style="color: #800080;">1</span>) / <span style="color: #800080;">2</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">if</span> (cnt &gt;= pre) res += cnt - pre + <span style="color: #800080;">1</span><span style="color: #000000;">;
                    cnt </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
                    pre </span>= <span style="color: #800080;">1</span><span style="color: #000000;">;
                }
                pre </span>= (ratings[i] == ratings[i - <span style="color: #800080;">1</span>]) ? <span style="color: #800080;">1</span> : pre + <span style="color: #800080;">1</span><span style="color: #000000;">;
                res </span>+=<span style="color: #000000;"> pre;
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                </span>++<span style="color: #000000;">cnt;
            }
        }     
        </span><span style="color: #0000ff;">if</span> (cnt &gt; <span style="color: #800080;">0</span><span style="color: #000000;">) {
            res </span>+= cnt * (cnt + <span style="color: #800080;">1</span>) / <span style="color: #800080;">2</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> (cnt &gt;= pre) res += cnt - pre + <span style="color: #800080;">1</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/5243/a-simple-solution">https://discuss.leetcode.com/topic/5243/a-simple-solution</a></p>
<p><a href="https://discuss.leetcode.com/topic/8208/one-pass-constant-space-java-solution">https://discuss.leetcode.com/topic/8208/one-pass-constant-space-java-solution</a></p>
<p><a href="https://discuss.leetcode.com/topic/17722/two-c-solutions-given-with-explanation-both-with-o-n-time-one-with-o-1-space-the-other-with-o-n-space">https://discuss.leetcode.com/topic/17722/two-c-solutions-given-with-explanation-both-with-o-n-time-one-with-o-1-space-the-other-with-o-n-space</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-06-14 14:21</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4575026" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4575026);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4266812.html" id="cb_post_title_url">[LeetCode] Gas Station 加油站问题</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>There are <em>N</em> gas stations along a circular route, where the amount of gas at station <em>i</em> is <code>gas[i]</code>.</p>
<p>You have a car with an unlimited gas tank and it costs <code>cost[i]</code> of gas to travel from station <em>i</em> to its next station (<em>i</em>+1). You begin the journey with an empty tank at one of the gas stations.</p>
<p>Return the starting gas station's index if you can travel around the circuit once, otherwise return -1.</p>
<p>Note:<br/>The solution is guaranteed to be unique.</p>
<p> </p>
<p>这道转圈加油问题不算很难，只要想通其中的原理就很简单。我们首先要知道能走完整个环的前提是gas的总量要大于cost的总量，这样才会有起点的存在。假设开始设置起点start = 0, 并从这里出发，如果当前的gas值大于cost值，就可以继续前进，此时到下一个站点，剩余的gas加上当前的gas再减去cost，看是否大于0，若大于0，则继续前进。当到达某一站点时，若这个值小于0了，则说明从起点到这个点中间的任何一个点都不能作为起点，则把起点设为下一个点，继续遍历。当遍历完整个环时，当前保存的起点即为所求。代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> canCompleteCircuit(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; gas, vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> cost) {
        </span><span style="color: #0000ff;">int</span> total = <span style="color: #800080;">0</span>, sum = <span style="color: #800080;">0</span>, start = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; gas.size(); ++<span style="color: #000000;">i) {
            total </span>+= gas[i] -<span style="color: #000000;"> cost[i];
            sum </span>+= gas[i] -<span style="color: #000000;"> cost[i];
            </span><span style="color: #0000ff;">if</span> (sum &lt; <span style="color: #800080;">0</span><span style="color: #000000;">) {
                start </span>= i + <span style="color: #800080;">1</span><span style="color: #000000;">;
                sum </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
            }
        }
        </span><span style="color: #0000ff;">return</span> (total &lt; <span style="color: #800080;">0</span>) ? -<span style="color: #800080;">1</span><span style="color: #000000;"> : start;
    }
};</span></pre>
</div>
<p> </p>
<p>我们也可以从后往前遍历，用一个变量mx来记录出现过的剩余油量的最大值，total记录当前剩余油量的值，start还是记录起点的位置。当total大于mx的时候，说明当前位置可以作为起点，更新start，并且更新mx。为啥呢？因为我们每次total加上的都是当前位置的油量减去消耗，如果这个差值大于0的话，说明当前位置可以当作起点，因为从当前位置到末尾都不会出现油量不够的情况，而一旦差值小于0的话，说明当前位置如果是起点的话，油量就不够，无法走完全程，所以我们不更新起点位置start。最后结束后我们还是看totoa是否大于等于0，如果其小于0的话，说明没有任何一个起点能走完全程，因为总油量都不够，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> canCompleteCircuit(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; gas, vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> cost) {
        </span><span style="color: #0000ff;">int</span> total = <span style="color: #800080;">0</span>, mx = -<span style="color: #800080;">1</span>, start = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = gas.size() - <span style="color: #800080;">1</span>; i &gt;= <span style="color: #800080;">0</span>; --<span style="color: #000000;">i) {
            total </span>+= gas[i] -<span style="color: #000000;"> cost[i];
            </span><span style="color: #0000ff;">if</span> (total &gt;<span style="color: #000000;"> mx) {
                start </span>=<span style="color: #000000;"> i;
                mx </span>=<span style="color: #000000;"> total;
            }
        }
        </span><span style="color: #0000ff;">return</span> (total &lt; <span style="color: #800080;">0</span>) ? -<span style="color: #800080;">1</span><span style="color: #000000;"> : start;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p>Reaching Points</p>
<p>Transform to Chessboard</p>
<p>Cheapest Flights Within K Stops</p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-02-02 09:19</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4266812" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4266812);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4267628.html" id="cb_post_title_url">[LeetCode] Clone Graph 无向图的复制</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Clone an undirected graph. Each node in the graph contains a <code>label</code> and a list of its <code>neighbors</code>.</p>
<div><br/>OJ's undirected graph serialization:
<p>Nodes are labeled uniquely.</p>


We use <code>#</code> as a separator for each node, and <code>,</code> as a separator for node label and each neighbor of the node.
<p> </p>
<p>As an example, consider the serialized graph <code><span style="color: red;">{<span style="color: black;">0</span>,1,2#</span><span style="color: blue;"><span style="color: black;">1</span>,2#</span><span style="color: green;"><span style="color: black;">2</span>,2}</span></code>.</p>
<p>The graph has a total of three nodes, and therefore contains three parts as separated by <code>#</code>.</p>
<ol>
<li>First node is labeled as <code><span style="color: black;">0</span></code>. Connect node <code><span style="color: black;">0</span></code> to both nodes <code><span style="color: red;">1</span></code> and <code><span style="color: red;">2</span></code>.</li>
<li>Second node is labeled as <code><span style="color: black;">1</span></code>. Connect node <code><span style="color: black;">1</span></code> to node <code><span style="color: blue;">2</span></code>.</li>
<li>Third node is labeled as <code><span style="color: black;">2</span></code>. Connect node <code><span style="color: black;">2</span></code> to node <code><span style="color: green;">2</span></code> (itself), thus forming a self-cycle.</li>
</ol>
<p> </p>
<p>Visually, the graph looks like the following:</p>
<pre>       1
      / \
     /   \
    0 --- 2
         / \
         \_/</pre>
</div>
<p> </p>
<p>这道无向图的复制问题和之前的<a href="http://www.cnblogs.com/grandyang/p/4261431.html" target="_blank">拷贝带有随机指针的链表</a>有些类似，那道题的难点是如何处理每个节点的随机指针，这道题目的难点在于如何处理每个节点的neighbors，由于在深度拷贝每一个节点后，还要将其所有neighbors放到一个vector中，而如何避免重复拷贝呢？这道题好就好在所有节点值不同，所以我们可以使用哈希表来对应节点值和新生成的节点。对于图的遍历的两大基本方法是深度优先搜索DFS和广度优先搜索BFS，此题的两种解法可参见网友<a href="http://www.cnblogs.com/springfor/p/3874591.html" target="_blank">爱做饭的小莹子的博客</a>，这里我们使用深度优先搜索DFS来解答此题，代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">/*</span><span style="color: #008000;">*
 * Definition for undirected graph.
 * struct UndirectedGraphNode {
 *     int label;
 *     vector&lt;UndirectedGraphNode *&gt; neighbors;
 *     UndirectedGraphNode(int x) : label(x) {};
 * };
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    UndirectedGraphNode </span>*cloneGraph(UndirectedGraphNode *<span style="color: #000000;">node) {
        unordered_map</span>&lt;<span style="color: #0000ff;">int</span>, UndirectedGraphNode*&gt;<span style="color: #000000;"> umap;
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> clone(node, umap);
    }
    UndirectedGraphNode </span>*clone(UndirectedGraphNode *node, unordered_map&lt;<span style="color: #0000ff;">int</span>, UndirectedGraphNode*&gt; &amp;<span style="color: #000000;">umap) {
        </span><span style="color: #0000ff;">if</span> (!node) <span style="color: #0000ff;">return</span><span style="color: #000000;"> node;
        </span><span style="color: #0000ff;">if</span> (umap.count(node-&gt;label)) <span style="color: #0000ff;">return</span> umap[node-&gt;<span style="color: #000000;">label];
        UndirectedGraphNode </span>*newNode = <span style="color: #0000ff;">new</span> UndirectedGraphNode(node-&gt;<span style="color: #000000;">label);
        umap[node</span>-&gt;label] =<span style="color: #000000;"> newNode;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; node-&gt;neighbors.size(); ++<span style="color: #000000;">i) {
            (newNode</span>-&gt;neighbors).push_back(clone(node-&gt;<span style="color: #000000;">neighbors[i], umap));
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> newNode;
    } 
};</span></pre>
</div>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-02-02 13:56</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4267628" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4267628);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4271456.html" id="cb_post_title_url">[LeetCode] Palindrome Partitioning II 拆分回文串之二</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a string <em>s</em>, partition <em>s</em> such that every substring of the partition is a palindrome.</p>
<p>Return the minimum cuts needed for a palindrome partitioning of <em>s</em>.</p>
<p> For example, given <em>s</em> = <code>"aab"</code>,<br/>
Return <code>1</code> since the palindrome partitioning <code>["aa","b"]</code> could be produced using 1 cut.
</p>
<p> </p>
<p>这道题是让找到把原字符串拆分成回文串的最小切割数，需要用动态规划Dynamic Programming来做，使用DP的核心是在于找出递推公式，之前有道<a href="http://www.cnblogs.com/grandyang/p/4233035.html" target="_blank">地牢游戏Dungeon Game</a>的题也是需要用DP来做，而那道题是二维DP来解，这道题由于只是拆分一个字符串，需要一个一维的递推公式，我们还是从后往前推，递推公式为：dp[i] = min(dp[i], 1+dp[j+1] )    i&lt;=j &lt;n，那么还有个问题，是否对于i到j之间的子字符串s[i][j]每次都判断一下是否是回文串，其实这个也可以用DP来简化，其DP递推公式为P[i][j] = s[i] == s[j] &amp;&amp; P[i+1][j-1]，其中P[i][j] = true if [i,j]为回文。代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> minCut(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        </span><span style="color: #0000ff;">int</span> len =<span style="color: #000000;"> s.size();
        </span><span style="color: #0000ff;">bool</span><span style="color: #000000;"> P[len][len];
        </span><span style="color: #0000ff;">int</span> dp[len + <span style="color: #800080;">1</span><span style="color: #000000;">];
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt;= len; ++<span style="color: #000000;">i) {
            dp[i] </span>= len - i - <span style="color: #800080;">1</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; len; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; len; ++<span style="color: #000000;">j) {
                P[i][j] </span>= <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            }
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = len - <span style="color: #800080;">1</span>; i &gt;= <span style="color: #800080;">0</span>; --<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = i; j &lt; len; ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> (s[i] == s[j] &amp;&amp; (j - i &lt;= <span style="color: #800080;">1</span> || P[i + <span style="color: #800080;">1</span>][j - <span style="color: #800080;">1</span><span style="color: #000000;">])) {
                    P[i][j] </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                    dp[i] </span>= min(dp[i], dp[j + <span style="color: #800080;">1</span>] + <span style="color: #800080;">1</span><span style="color: #000000;">);
                }
            }
        }
        </span><span style="color: #0000ff;">return</span> dp[<span style="color: #800080;">0</span><span style="color: #000000;">];
    }
};</span></pre>
</div>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-02-04 05:04</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4271456" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4271456);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4270008.html" id="cb_post_title_url">[LeetCode] Palindrome Partitioning 拆分回文串</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a string <em>s</em>, partition <em>s</em> such that every substring of the partition is a palindrome.</p>
<p>Return all possible palindrome partitioning of <em>s</em>.</p>
<p>For example, given <em>s</em> = <code>"aab"</code>,<br/>Return</p>
<pre>  [
    ["aa","b"],
    ["a","a","b"]
  ]</pre>
<p> </p>
<p>这又是一道需要用DFS来解的题目，既然题目要求找到所有可能拆分成回文数的情况，那么肯定是所有的情况都要遍历到，对于每一个子字符串都要分别判断一次是不是回文数，那么肯定有一个判断回文数的子函数，还需要一个DFS函数用来递归，再加上原本的这个函数，总共需要三个函数来求解。代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;vector&lt;<span style="color: #0000ff;">string</span>&gt;&gt; partition(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">string</span>&gt;&gt;<span style="color: #000000;"> res;
        vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; <span style="color: #0000ff;">out</span><span style="color: #000000;">;
        partitionDFS(s, </span><span style="color: #800080;">0</span>, <span style="color: #0000ff;">out</span><span style="color: #000000;">, res);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">void</span> partitionDFS(<span style="color: #0000ff;">string</span> s, <span style="color: #0000ff;">int</span> start, vector&lt;<span style="color: #0000ff;">string</span>&gt; &amp;<span style="color: #0000ff;">out</span>, vector&lt;vector&lt;<span style="color: #0000ff;">string</span>&gt;&gt; &amp;<span style="color: #000000;">res) {
        </span><span style="color: #0000ff;">if</span> (start ==<span style="color: #000000;"> s.size()) {
            res.push_back(</span><span style="color: #0000ff;">out</span><span style="color: #000000;">);
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = start; i &lt; s.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (isPalindrome(s, start, i)) {
                </span><span style="color: #0000ff;">out</span>.push_back(s.substr(start, i - start + <span style="color: #800080;">1</span><span style="color: #000000;">));
                partitionDFS(s, i </span>+ <span style="color: #800080;">1</span>, <span style="color: #0000ff;">out</span><span style="color: #000000;">, res);
                </span><span style="color: #0000ff;">out</span><span style="color: #000000;">.pop_back();
            }
        }
    }
    </span><span style="color: #0000ff;">bool</span> isPalindrome(<span style="color: #0000ff;">string</span> s, <span style="color: #0000ff;">int</span> start, <span style="color: #0000ff;">int</span><span style="color: #000000;"> end) {
        </span><span style="color: #0000ff;">while</span> (start &lt;<span style="color: #000000;"> end) {
            </span><span style="color: #0000ff;">if</span> (s[start] != s[end]) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            </span>++<span style="color: #000000;">start;
            </span>--<span style="color: #000000;">end;
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>那么，对原字符串的所有子字符串的访问顺序是什么呢，如果原字符串是 abcd, 那么访问顺序为: a -&gt; b -&gt; c -&gt; d -&gt; cd -&gt; bc -&gt; bcd-&gt; ab -&gt; abc -&gt; abcd, 这是对于没有两个或两个以上子回文串的情况。那么假如原字符串是 aabc，那么访问顺序为：a -&gt; a -&gt; b -&gt; c -&gt; bc -&gt; ab -&gt; abc -&gt; aa -&gt; b -&gt; c -&gt; bc -&gt; aab -&gt; aabc，中间当检测到aa时候，发现是回文串，那么对于剩下的bc当做一个新串来检测，于是有 b -&gt; c -&gt; bc，这样扫描了所有情况，即可得出最终答案。</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-02-03 14:54</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4270008" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4270008);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4555831.html" id="cb_post_title_url">[LeetCode] Surrounded Regions 包围区域</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a 2D board containing <code>'X'</code> and <code>'O'</code>, capture all regions surrounded by <code>'X'</code>.</p>
<p>A region is captured by flipping all <code>'O'</code>s into <code>'X'</code>s in that surrounded region.</p>
<p> For example,<br/>
</p>
<pre>X X X X
X O O X
X X O X
X O X X
</pre>
<p>After running your function, the board should be:</p>
<pre>X X X X
X X X X
X X X X
X O X X
</pre>
<p> </p>
<p>这道题有点像围棋，将包住的O都变成X，但不同的是边缘的O不算被包围，跟之前那道<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4402656.html" id="cb_post_title_url">Number of Islands 岛屿的数量</a>很类似，都可以用DFS来解。刚开始我的思路是DFS遍历中间的O，如果没有到达边缘，都变成X，如果到达了边缘，将之前变成X的再变回来。但是这样做非常的不方便，在网上看到大家普遍的做法是扫面矩阵的四条边，如果有O，则用DFS遍历，将所有连着的O都变成另一个字符，比如\$，这样剩下的O都是被包围的，然后将这些O变成X，把$变回O就行了。代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">void</span> solve(vector&lt;vector&lt;<span style="color: #0000ff;">char</span>&gt; &gt;&amp;<span style="color: #000000;"> board) {
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; board.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; board[i].size(); ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> ((i == <span style="color: #800080;">0</span> || i == board.size() - <span style="color: #800080;">1</span> || j == <span style="color: #800080;">0</span> || j == board[i].size() - <span style="color: #800080;">1</span>) &amp;&amp; board[i][j] == <span style="color: #800000;">'</span><span style="color: #800000;">O</span><span style="color: #800000;">'</span><span style="color: #000000;">)
                    solveDFS(board, i, j);
            }
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; board.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; board[i].size(); ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> (board[i][j] == <span style="color: #800000;">'</span><span style="color: #800000;">O</span><span style="color: #800000;">'</span>) board[i][j] = <span style="color: #800000;">'</span><span style="color: #800000;">X</span><span style="color: #800000;">'</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">if</span> (board[i][j] == <span style="color: #800000;">'</span><span style="color: #800000;">$</span><span style="color: #800000;">'</span>) board[i][j] = <span style="color: #800000;">'</span><span style="color: #800000;">O</span><span style="color: #800000;">'</span><span style="color: #000000;">;
            }
        }
    }
    </span><span style="color: #0000ff;">void</span> solveDFS(vector&lt;vector&lt;<span style="color: #0000ff;">char</span>&gt; &gt; &amp;board, <span style="color: #0000ff;">int</span> i, <span style="color: #0000ff;">int</span><span style="color: #000000;"> j) {
        </span><span style="color: #0000ff;">if</span> (board[i][j] == <span style="color: #800000;">'</span><span style="color: #800000;">O</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
            board[i][j] </span>= <span style="color: #800000;">'</span><span style="color: #800000;">$</span><span style="color: #800000;">'</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> (i &gt; <span style="color: #800080;">0</span> &amp;&amp; board[i - <span style="color: #800080;">1</span>][j] == <span style="color: #800000;">'</span><span style="color: #800000;">O</span><span style="color: #800000;">'</span><span style="color: #000000;">) 
                solveDFS(board, i </span>- <span style="color: #800080;">1</span><span style="color: #000000;">, j);
            </span><span style="color: #0000ff;">if</span> (j &lt; board[i].size() - <span style="color: #800080;">1</span> &amp;&amp; board[i][j + <span style="color: #800080;">1</span>] == <span style="color: #800000;">'</span><span style="color: #800000;">O</span><span style="color: #800000;">'</span><span style="color: #000000;">) 
                solveDFS(board, i, j </span>+ <span style="color: #800080;">1</span><span style="color: #000000;">);
            </span><span style="color: #0000ff;">if</span> (i &lt; board.size() - <span style="color: #800080;">1</span> &amp;&amp; board[i + <span style="color: #800080;">1</span>][j] == <span style="color: #800000;">'</span><span style="color: #800000;">O</span><span style="color: #800000;">'</span><span style="color: #000000;">) 
                solveDFS(board, i </span>+ <span style="color: #800080;">1</span><span style="color: #000000;">, j);
            </span><span style="color: #0000ff;">if</span> (<strong><span style="color: #ff0000;">j &gt; 1</span></strong> &amp;&amp; board[i][j - <span style="color: #800080;">1</span>] == <span style="color: #800000;">'</span><span style="color: #800000;">O</span><span style="color: #800000;">'</span><span style="color: #000000;">) 
                solveDFS(board, i, j </span>- <span style="color: #800080;">1</span><span style="color: #000000;">);
        }
    }
};</span></pre>
</div>
<p> </p>
<p>有网友提问上面的代码中红色部分为啥是j &gt; 1 而不是j &gt; 0，为啥j &gt; 0无法通过OJ的最后一个大数据集合，我开始也不知道其中奥秘，直到被另一个网友提醒在本地机子上可以通过最后一个大数据集合，于是我也写了一个程序来验证，请参见<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4759189.html" id="cb_post_title_url">验证LeetCode Surrounded Regions 包围区域的DFS方法</a>。发现j &gt; 0是正确的，可以得到相同的结果。</p>
<p>下面这种解法还是DFS解法，只是递归函数的写法稍有不同，但是本质上并没有太大的区别，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">void</span> solve(vector&lt;vector&lt;<span style="color: #0000ff;">char</span>&gt;&gt;&amp;<span style="color: #000000;"> board) {
        </span><span style="color: #0000ff;">if</span> (board.empty() || board[<span style="color: #800080;">0</span>].empty()) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> m = board.size(), n = board[<span style="color: #800080;">0</span><span style="color: #000000;">].size();
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; m; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; n; ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> (i == <span style="color: #800080;">0</span> || i == m - <span style="color: #800080;">1</span> || j == <span style="color: #800080;">0</span> || j == n - <span style="color: #800080;">1</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">if</span> (board[i][j] == <span style="color: #800000;">'</span><span style="color: #800000;">O</span><span style="color: #800000;">'</span><span style="color: #000000;">) dfs(board, i , j);
                }
            }   
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; m; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; n; ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> (board[i][j] == <span style="color: #800000;">'</span><span style="color: #800000;">O</span><span style="color: #800000;">'</span>) board[i][j] = <span style="color: #800000;">'</span><span style="color: #800000;">X</span><span style="color: #800000;">'</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">if</span> (board[i][j] == <span style="color: #800000;">'</span><span style="color: #800000;">$</span><span style="color: #800000;">'</span>) board[i][j] = <span style="color: #800000;">'</span><span style="color: #800000;">O</span><span style="color: #800000;">'</span><span style="color: #000000;">;
            }
        }
    }
    </span><span style="color: #0000ff;">void</span> dfs(vector&lt;vector&lt;<span style="color: #0000ff;">char</span>&gt;&gt; &amp;board, <span style="color: #0000ff;">int</span> x, <span style="color: #0000ff;">int</span><span style="color: #000000;"> y) {
        </span><span style="color: #0000ff;">int</span> m = board.size(), n = board[<span style="color: #800080;">0</span><span style="color: #000000;">].size();
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; dir{{<span style="color: #800080;">0</span>,-<span style="color: #800080;">1</span>},{-<span style="color: #800080;">1</span>,<span style="color: #800080;">0</span>},{<span style="color: #800080;">0</span>,<span style="color: #800080;">1</span>},{<span style="color: #800080;">1</span>,<span style="color: #800080;">0</span><span style="color: #000000;">}};
        board[x][y] </span>= <span style="color: #800000;">'</span><span style="color: #800000;">$</span><span style="color: #800000;">'</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; dir.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">int</span> dx = x + dir[i][<span style="color: #800080;">0</span>], dy = y + dir[i][<span style="color: #800080;">1</span><span style="color: #000000;">];
            </span><span style="color: #0000ff;">if</span> (dx &gt;= <span style="color: #800080;">0</span> &amp;&amp; dx &lt; m &amp;&amp; dy &gt; <span style="color: #800080;">0</span> &amp;&amp; dy &lt; n &amp;&amp; board[dx][dy] == <span style="color: #800000;">'</span><span style="color: #800000;">O</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                dfs(board, dx, dy);
            }
        }
    }
};</span></pre>
</div>
<p> </p>
<p>我们也可以使用迭代的解法，但是整体的思路还是一样的，我们在找到边界上的O后，然后利用队列queue进行BFS查找和其相连的所有O，然后都标记上美元号。最后的处理还是先把所有的O变成X，然后再把美元号变回O即可，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">void</span> solve(vector&lt;vector&lt;<span style="color: #0000ff;">char</span>&gt;&gt;&amp;<span style="color: #000000;"> board) {
        </span><span style="color: #0000ff;">if</span> (board.empty() || board[<span style="color: #800080;">0</span>].empty()) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> m = board.size(), n = board[<span style="color: #800080;">0</span><span style="color: #000000;">].size();
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; m; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; n; ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> (i != <span style="color: #800080;">0</span> &amp;&amp; i != m - <span style="color: #800080;">1</span> &amp;&amp; j != <span style="color: #800080;">0</span> &amp;&amp; j != n - <span style="color: #800080;">1</span>) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">if</span> (board[i][j] != <span style="color: #800000;">'</span><span style="color: #800000;">O</span><span style="color: #800000;">'</span>) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                board[i][j] </span>= <span style="color: #800000;">'</span><span style="color: #800000;">$</span><span style="color: #800000;">'</span><span style="color: #000000;">;
                queue</span>&lt;<span style="color: #0000ff;">int</span>&gt; q{{i * n +<span style="color: #000000;"> j}};
                </span><span style="color: #0000ff;">while</span> (!<span style="color: #000000;">q.empty()) {
                    </span><span style="color: #0000ff;">int</span> t = q.front(), x = t / n, y = t %<span style="color: #000000;"> n; q.pop();
                    </span><span style="color: #0000ff;">if</span> (x &gt;= <span style="color: #800080;">1</span> &amp;&amp; board[x - <span style="color: #800080;">1</span>][y] == <span style="color: #800000;">'</span><span style="color: #800000;">O</span><span style="color: #800000;">'</span>) {board[x - <span style="color: #800080;">1</span>][y] = <span style="color: #800000;">'</span><span style="color: #800000;">$</span><span style="color: #800000;">'</span>; q.push(t -<span style="color: #000000;"> n);}
                    </span><span style="color: #0000ff;">if</span> (x &lt; m - <span style="color: #800080;">1</span> &amp;&amp; board[x + <span style="color: #800080;">1</span>][y] == <span style="color: #800000;">'</span><span style="color: #800000;">O</span><span style="color: #800000;">'</span>) {board[x + <span style="color: #800080;">1</span>][y] = <span style="color: #800000;">'</span><span style="color: #800000;">$</span><span style="color: #800000;">'</span>; q.push(t +<span style="color: #000000;"> n);}
                    </span><span style="color: #0000ff;">if</span> (y &gt;= <span style="color: #800080;">1</span> &amp;&amp; board[x][y - <span style="color: #800080;">1</span>] == <span style="color: #800000;">'</span><span style="color: #800000;">O</span><span style="color: #800000;">'</span>) {board[x][y - <span style="color: #800080;">1</span>] = <span style="color: #800000;">'</span><span style="color: #800000;">$</span><span style="color: #800000;">'</span>; q.push(t - <span style="color: #800080;">1</span><span style="color: #000000;">);}
                    </span><span style="color: #0000ff;">if</span> (y &lt; n - <span style="color: #800080;">1</span> &amp;&amp; board[x][y + <span style="color: #800080;">1</span>] == <span style="color: #800000;">'</span><span style="color: #800000;">O</span><span style="color: #800000;">'</span>) {board[x][y + <span style="color: #800080;">1</span>] = <span style="color: #800000;">'</span><span style="color: #800000;">$</span><span style="color: #800000;">'</span>; q.push(t + <span style="color: #800080;">1</span><span style="color: #000000;">);}
                }
            }
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; m; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; n; ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> (board[i][j] == <span style="color: #800000;">'</span><span style="color: #800000;">O</span><span style="color: #800000;">'</span>) board[i][j] = <span style="color: #800000;">'</span><span style="color: #800000;">X</span><span style="color: #800000;">'</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">if</span> (board[i][j] == <span style="color: #800000;">'</span><span style="color: #800000;">$</span><span style="color: #800000;">'</span>) board[i][j] = <span style="color: #800000;">'</span><span style="color: #800000;">O</span><span style="color: #800000;">'</span><span style="color: #000000;">;
            }
        }
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4402656.html" target="_blank">Number of Islands</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/5285868.html" target="_blank">Walls and Gates</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-06-05 23:55</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4555831" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4555831);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4273700.html" id="cb_post_title_url">[LeetCode] Sum Root to Leaf Numbers 求根到叶节点数字之和</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a binary tree containing digits from <code>0-9</code> only, each root-to-leaf path could represent a number.</p>
<p>An example is the root-to-leaf path <code>1-&gt;2-&gt;3</code> which represents the number <code>123</code>.</p>
<p>Find the total sum of all root-to-leaf numbers.</p>
<p>For example,</p>
<pre>    1
   / \
  2   3
</pre>
<p> The root-to-leaf path <code>1-&gt;2</code> represents the number <code>12</code>.<br/>
The root-to-leaf path <code>1-&gt;3</code> represents the number <code>13</code>.
</p>
<p>
Return the sum = 12 + 13 = <code>25</code>.
</p>
<p> </p>
<p>这道求根到叶节点数字之和的题跟之前的求<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4036961.html" id="cb_post_title_url">Path Sum 二叉树的路径和</a><span class="postTitle2">很类似，都是利用DFS递归来解，这道题由于不是单纯的把各个节点的数字相加，而是每到一个新的数字，要把原来的数字扩大10倍之后再相加。代码如下：</span></p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">/*</span><span style="color: #008000;">*
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> sumNumbers(TreeNode *<span style="color: #000000;">root) {
        </span><span style="color: #0000ff;">return</span> sumNumbersDFS(root, <span style="color: #800080;">0</span><span style="color: #000000;">);
    }
    </span><span style="color: #0000ff;">int</span> sumNumbersDFS(TreeNode *root, <span style="color: #0000ff;">int</span><span style="color: #000000;"> sum) {
        </span><span style="color: #0000ff;">if</span> (!root) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        sum </span>= sum * <span style="color: #800080;">10</span> + root-&gt;<span style="color: #000000;">val;
        </span><span style="color: #0000ff;">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) <span style="color: #0000ff;">return</span><span style="color: #000000;"> sum;
        </span><span style="color: #0000ff;">return</span> sumNumbersDFS(root-&gt;left, sum) + sumNumbersDFS(root-&gt;<span style="color: #000000;">right, sum);
    }
};</span></pre>
</div>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-02-05 00:14</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4273700" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4273700);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4276225.html" id="cb_post_title_url">[LeetCode] Longest Consecutive Sequence 求最长连续序列</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given an unsorted array of integers, find the length of the longest consecutive elements sequence.</p>
<p> For example,<br/>
Given <code>[100, 4, 200, 1, 3, 2]</code>,<br/>
The longest consecutive elements sequence is <code>[1, 2, 3, 4]</code>. Return its length: <code>4</code>.
</p>
<p>
Your algorithm should run in O(<em>n</em>) complexity.
</p>
<p> </p>
<p>这道题要求求最长连续序列，并给定了O(n)复杂度限制，我们的思路是，使用一个集合set存入所有的数字，然后遍历数组中的每个数字，如果其在集合中存在，那么将其移除，然后分别用两个变量pre和next算出其前一个数跟后一个数，然后在集合中循环查找，如果pre在集合中，那么将pre移除集合，然后pre再自减1，直至pre不在集合之中，对next采用同样的方法，那么next-pre-1就是当前数字的最长连续序列，更新res即可。代码如下：</p>
<p> </p>
<p>C++ 解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> longestConsecutive(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        unordered_set</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> s(nums.begin(), nums.end());
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span><span style="color: #000000;"> val : nums) {
            </span><span style="color: #0000ff;">if</span> (!s.count(val)) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
            s.erase(val);
            </span><span style="color: #0000ff;">int</span> pre = val - <span style="color: #800080;">1</span>, next = val + <span style="color: #800080;">1</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">while</span> (s.count(pre)) s.erase(pre--<span style="color: #000000;">);
            </span><span style="color: #0000ff;">while</span> (s.count(next)) s.erase(next++<span style="color: #000000;">);
            res </span>= max(res, next - pre - <span style="color: #800080;">1</span><span style="color: #000000;">);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>Java 解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span> longestConsecutive(<span style="color: #0000ff;">int</span><span style="color: #000000;">[] nums) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        Set</span>&lt;Integer&gt; s = <span style="color: #0000ff;">new</span> HashSet&lt;Integer&gt;<span style="color: #000000;">();
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span><span style="color: #000000;"> num : nums) s.add(num);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span><span style="color: #000000;"> num : nums) {
            </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (s.remove(num)) {
                </span><span style="color: #0000ff;">int</span> pre = num - <span style="color: #800080;">1</span>, next = num + <span style="color: #800080;">1</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">while</span> (s.remove(pre)) --<span style="color: #000000;">pre;
                </span><span style="color: #0000ff;">while</span> (s.remove(next)) ++<span style="color: #000000;">next;
                res </span>= Math.max(res, next - pre - <span style="color: #800080;">1</span><span style="color: #000000;">);
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
}</span></pre>
</div>
<p> </p>
<p>我们也可以采用哈希表来做，刚开始哈希表为空，然后遍历所有数字，如果该数字不在哈希表中，那么我们分别看其左右两个数字是否在哈希表中，如果在，则返回其哈希表中映射值，若不在，则返回0，然后我们将left+right+1作为当前数字的映射，并更新res结果，然后更新d-left和d-right的映射值，参见代码如下：</p>
<p> </p>
<p>C++ 解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> longestConsecutive(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        unordered_map</span>&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> m;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span><span style="color: #000000;"> d : nums) {
            </span><span style="color: #0000ff;">if</span> (!<span style="color: #000000;">m.count(d)) {
                </span><span style="color: #0000ff;">int</span> left = m.count(d - <span style="color: #800080;">1</span>) ? m[d - <span style="color: #800080;">1</span>] : <span style="color: #800080;">0</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">int</span> right = m.count(d + <span style="color: #800080;">1</span>) ? m[d + <span style="color: #800080;">1</span>] : <span style="color: #800080;">0</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">int</span> sum = left + right + <span style="color: #800080;">1</span><span style="color: #000000;">;
                m[d] </span>=<span style="color: #000000;"> sum;
                res </span>=<span style="color: #000000;"> max(res, sum);
                m[d </span>- left] =<span style="color: #000000;"> sum;
                m[d </span>+ right] =<span style="color: #000000;"> sum;
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>Java 解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span> longestConsecutive(<span style="color: #0000ff;">int</span><span style="color: #000000;">[] nums) {
        </span><span style="color: #0000ff;">int</span> res = 0<span style="color: #000000;">;
        Map</span>&lt;Integer, Integer&gt; m = <span style="color: #0000ff;">new</span> HashMap&lt;Integer, Integer&gt;<span style="color: #000000;">();
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span><span style="color: #000000;"> num : nums) {
            </span><span style="color: #0000ff;">if</span> (m.containsKey(num)) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">int</span> left = m.containsKey(num - 1) ? m.get(num - 1) : 0<span style="color: #000000;">;
            </span><span style="color: #0000ff;">int</span> right = m.containsKey(num + 1) ? m.get(num + 1) : 0<span style="color: #000000;">;
            </span><span style="color: #0000ff;">int</span> sum = left + right + 1<span style="color: #000000;">;
            m.put(num, sum);
            res </span>=<span style="color: #000000;"> Math.max(res, sum);
            m.put(num </span>-<span style="color: #000000;"> left, sum);
            m.put(num </span>+<span style="color: #000000;"> right, sum);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
}</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/5252599.html" target="_blank">Binary Tree Longest Consecutive Sequence</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/6148/my-really-simple-java-o-n-solution-accepted" target="_blank">https://discuss.leetcode.com/topic/6148/my-really-simple-java-o-n-solution-accepted</a></p>
<p><a href="https://discuss.leetcode.com/topic/16483/a-simple-c-solution-using-unordered_set-and-simple-consideration-about-this-problem" target="_blank">https://discuss.leetcode.com/topic/16483/a-simple-c-solution-using-unordered_set-and-simple-consideration-about-this-problem</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-02-06 01:01</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4276225" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4276225);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4539768.html" id="cb_post_title_url">[LeetCode] Word Ladder 词语阶梯</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given two words (<em>beginWord</em> and <em>endWord</em>), and a dictionary's word list, find the length of shortest transformation sequence from <em>beginWord</em> to <em>endWord</em>, such that:</p>
<ol>
<li>Only one letter can be changed at a time.</li>
<li>Each transformed word must exist in the word list. Note that <em>beginWord</em> is <em>not</em> a transformed word.</li>
</ol>
<p>Note:</p>
<ul>
<li>Return 0 if there is no such transformation sequence.</li>
<li>All words have the same length.</li>
<li>All words contain only lowercase alphabetic characters.</li>
<li>You may assume no duplicates in the word list.</li>
<li>You may assume <em>beginWord</em> and <em>endWord</em> are non-empty and are not the same.</li>
</ul>
<p>Example 1:</p>
<pre>Input:
beginWord = "hit",
endWord = "cog",
wordList = ["hot","dot","dog","lot","log","cog"]

Output: 5

Explanation: As one shortest transformation is "hit" -&gt; "hot" -&gt; "dot" -&gt; "dog" -&gt; "cog",
return its length 5.
</pre>
<p>Example 2:</p>
<pre>Input:
beginWord = "hit"
endWord = "cog"
wordList = ["hot","dot","dog","lot","log"]

Output: 0

Explanation: The endWord "cog" is not in wordList, therefore no possible transformation.</pre>
<p> </p>
<p>这道词句阶梯的问题给了我们一个单词字典，里面有一系列很相似的单词，然后给了一个起始单词和一个结束单词，每次变换只能改变一个单词，并且中间过程的单词都必须是单词字典中的单词，让我们求出最短的变化序列的长度。这道题还是挺有难度的，我当然是看了别人的解法才写出来的，这没啥的，从不会到完全掌握才是成长嘛～</p>
<p>当拿到题就懵逼的我们如何才能找到一个科学的探索解题的路径呢，那就是先别去管代码实现，如果让我们肉身解题该怎么做呢？让你将 'hit' 变为 'cog'，那么我们发现这两个单词没有一个相同的字母，所以我们就尝试呗，博主会先将第一个 'h' 换成 'c'，看看 'cit' 在不在字典中，发现不在，那么把第二个 'i' 换成 'o'，看看 'hot' 在不在，发现在，完美！然后尝试 'cot' 或者 'hog'，发现都不在，那么就比较麻烦了，我们没法快速的达到目标单词，需要一些中间状态，但我们怎么知道中间状态是什么。简单粗暴的方法就是brute force，遍历所有的情况，我们将起始单词的每一个字母都用26个字母来替换，比如起始单词 'hit' 就要替换为 'ait', 'bit', 'cit', .... 'yit', 'zit'，将每个替换成的单词都在字典中查找一下，如果有的话，那么说明可能是潜在的路径，要保存下来。那么现在就有个问题，比如我们换到了 'hot' 的时候，此时发现在字典中存在，那么下一步我们是继续试接下来的 'hpt', 'hqt', 'hrt'... 还是直接从 'hot' 的首字母开始换 'aot', 'bot', 'cot' ... 这实际上就是BFS和DFS的区别，到底是广度优先，还是深度优先。讲到这里，不知道你有没有觉得这个跟什么很像？对了，跟迷宫遍历很像啊，你想啊，迷宫中每个点有上下左右四个方向可以走，而这里有26个字母，就是二十六个方向可以走，本质上没有啥区别啊！如果熟悉迷宫遍历的童鞋们应该知道，应该用BFS来求最短路径的长度，这也不难理解啊，DFS相当于一条路走到黑啊，你走的那条道不一定是最短的啊。而BFS相当于一个小圈慢慢的一层一层扩大，相当于往湖里扔个石头，一圈一圈扩大的水波纹那种感觉，当水波纹碰到湖上的树叶时，那么此时水圈的半径就是圆心到树叶的最短距离。脑海中有没有浮现出这个生动的场景呢？</p>
<p>明确了要用BFS，我们可以开始解题了，为了提到字典的查找效率，我们使用HashSet保存所有的单词。然后我们需要一个HashMap，来建立某条路径结尾单词和该路径长度之间的映射，并把起始单词映射为1。既然是BFS，我们需要一个队列queue，把起始单词排入队列中，开始队列的循环，取出队首词，然后对其每个位置上的字符，用26个字母进行替换，如果此时和结尾单词相同了，就可以返回取出词在哈希表中的值加一。如果替换词在字典中存在但在哈希表中不存在，则将替换词排入队列中，并在哈希表中的值映射为之前取出词加一。如果循环完成则返回0，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> ladderLength(<span style="color: #0000ff;">string</span> beginWord, <span style="color: #0000ff;">string</span> endWord, vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp;<span style="color: #000000;"> wordList) {
        unordered_set</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> wordSet(wordList.begin(), wordList.end());
        unordered_map</span>&lt;<span style="color: #0000ff;">string</span>, <span style="color: #0000ff;">int</span>&gt; pathCnt{{{beginWord, <span style="color: #800080;">1</span><span style="color: #000000;">}}};
        queue</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> q{{beginWord}};
        </span><span style="color: #0000ff;">while</span> (!<span style="color: #000000;">q.empty()) {
            </span><span style="color: #0000ff;">string</span> word =<span style="color: #000000;"> q.front(); q.pop();
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; word.size(); ++<span style="color: #000000;">i) {
                </span><span style="color: #0000ff;">string</span> newWord =<span style="color: #000000;"> word;
                </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span> ch = <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span>; ch &lt;= <span style="color: #800000;">'</span><span style="color: #800000;">z</span><span style="color: #800000;">'</span>; ++<span style="color: #000000;">ch) {
                    newWord[i] </span>=<span style="color: #000000;"> ch;
                    </span><span style="color: #0000ff;">if</span> (wordSet.count(newWord) &amp;&amp; newWord == endWord) <span style="color: #0000ff;">return</span> pathCnt[word] + <span style="color: #800080;">1</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">if</span> (wordSet.count(newWord) &amp;&amp; !<span style="color: #000000;">pathCnt.count(newWord)) {
                        q.push(newWord);
                        pathCnt[newWord] </span>= pathCnt[word] + <span style="color: #800080;">1</span><span style="color: #000000;">;
                    }   
                }
            }
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>其实我们并不需要上面解法中的HashMap，由于BFS的遍历机制就是一层一层的扩大的，那么我们只要记住层数就行，然后在while循环中使用一个小trick，加一个for循环，表示遍历完当前队列中的个数后，层数就自增1，这样的话我们就省去了HashMap，而仅仅用一个变量res来记录层数即可，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> ladderLength(<span style="color: #0000ff;">string</span> beginWord, <span style="color: #0000ff;">string</span> endWord, vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp;<span style="color: #000000;"> wordList) {
        unordered_set</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> wordSet(wordList.begin(), wordList.end());
        queue</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> q{{beginWord}};
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (!<span style="color: #000000;">q.empty()) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> k = q.size(); k &gt; <span style="color: #800080;">0</span>; --<span style="color: #000000;">k) {
                </span><span style="color: #0000ff;">string</span> word =<span style="color: #000000;"> q.front(); q.pop();
                </span><span style="color: #0000ff;">if</span> (word == endWord) <span style="color: #0000ff;">return</span> res + <span style="color: #800080;">1</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; word.size(); ++<span style="color: #000000;">i) {
                    </span><span style="color: #0000ff;">string</span> newWord =<span style="color: #000000;"> word;
                    </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span> ch = <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span>; ch &lt;= <span style="color: #800000;">'</span><span style="color: #800000;">z</span><span style="color: #800000;">'</span>; ++<span style="color: #000000;">ch) {
                        newWord[i] </span>=<span style="color: #000000;"> ch;
                        </span><span style="color: #0000ff;">if</span> (wordSet.count(newWord) &amp;&amp; newWord !=<span style="color: #000000;"> word) {
                            q.push(newWord);
                            wordSet.erase(newWord);
                        }   
                    }
                }
            }
            </span>++<span style="color: #000000;">res;
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4548184.html" target="_blank">Word Ladder II</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/7653006.html">Minimum Genetic Mutation</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-05-30 07:06</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4539768" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4539768);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4548184.html" id="cb_post_title_url">[LeetCode] Word Ladder II 词语阶梯之二</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given two words (<em>beginWord</em> and <em>endWord</em>), and a dictionary's word list, find all shortest transformation sequence(s) from <em>beginWord</em> to <em>endWord</em>, such that:</p>
<ol>
<li>Only one letter can be changed at a time</li>
<li>Each transformed word must exist in the word list. Note that <em>beginWord</em> is <em>not</em> a transformed word.</li>
</ol>
<p>Note:</p>
<ul>
<li>Return an empty list if there is no such transformation sequence.</li>
<li>All words have the same length.</li>
<li>All words contain only lowercase alphabetic characters.</li>
<li>You may assume no duplicates in the word list.</li>
<li>You may assume <em>beginWord</em> and <em>endWord</em> are non-empty and are not the same.</li>
</ul>
<p>Example 1:</p>
<pre>Input:
beginWord = "hit",
endWord = "cog",
wordList = ["hot","dot","dog","lot","log","cog"]

Output:
[
  ["hit","hot","dot","dog","cog"],
  ["hit","hot","lot","log","cog"]
]
</pre>
<p>Example 2:</p>
<pre>Input:
beginWord = "hit"
endWord = "cog"
wordList = ["hot","dot","dog","lot","log"]

Output: []

Explanation: The endWord "cog" is not in wordList, therefore no possible transformation.</pre>
<p> </p>
<p>个人感觉这道题是相当有难度的一道题，它比之前那道 <a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4539768.html" id="cb_post_title_url">Word Ladder</a> 要复杂很多，全场第四低的通过率12.9%正说明了这道题的难度，我也是研究了网上别人的解法很久才看懂，然后照葫芦画瓢的写了出来，下面这种解法的核心思想是BFS，大概思路如下：我们的目的是找出所有的路径，我们建立一个路径集paths，用以保存所有路径，然后是起始路径p，在p中先把起始单词放进去。然后定义两个整型变量level，和minLevel，其中level是记录循环中当前路径的长度，minLevel是记录最短路径的长度，这样的好处是，如果某条路径的长度超过了已有的最短路径的长度，那么舍弃，这样会提高运行速度，相当于一种剪枝。还要定义一个set变量words，用来记录已经循环过的路径中的词，然后就是BFS的核心了，循环路径集paths里的内容，取出队首路径，如果该路径长度大于level，说明字典中的有些词已经存入路径了，如果在路径中重复出现，则肯定不是最短路径，所以我们需要在字典中将这些词删去，然后将words清空，对循环对剪枝处理。然后我们取出当前路径的最后一个词，对每个字母进行替换并在字典中查找是否存在替换后的新词，这个过程在之前那道 <a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4539768.html" id="cb_post_title_url">Word Ladder</a> 里面也有。如果替换后的新词在字典中存在，将其加入words中，并在原有路径的基础上加上这个新词生成一条新路径，如果这个新词就是结束词，则此新路径为一条完整的路径，加入结果中，并更新minLevel，若不是结束词，解将新路径加入路径集中继续循环。写了这么多，不知道你看晕了没有，还是看代码吧，这个最有效：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;vector&lt;<span style="color: #0000ff;">string</span>&gt;&gt; findLadders(<span style="color: #0000ff;">string</span> beginWord, <span style="color: #0000ff;">string</span> endWord, vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp;<span style="color: #000000;"> wordList) {
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">string</span>&gt;&gt;<span style="color: #000000;"> res;
        unordered_set</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> dict(wordList.begin(), wordList.end());
        vector</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> p{beginWord};
        queue</span>&lt;vector&lt;<span style="color: #0000ff;">string</span>&gt;&gt;<span style="color: #000000;"> paths;
        paths.push(p);
        </span><span style="color: #0000ff;">int</span> level = <span style="color: #800080;">1</span>, minLevel =<span style="color: #000000;"> INT_MAX;
        unordered_set</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> words;
        </span><span style="color: #0000ff;">while</span> (!<span style="color: #000000;">paths.empty()) {
            auto t </span>=<span style="color: #000000;"> paths.front(); paths.pop();
            </span><span style="color: #0000ff;">if</span> (t.size() &gt;<span style="color: #000000;"> level) {
                </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">string</span><span style="color: #000000;"> w : words) dict.erase(w);
                words.clear();
                level </span>=<span style="color: #000000;"> t.size();
                </span><span style="color: #0000ff;">if</span> (level &gt; minLevel) <span style="color: #0000ff;">break</span><span style="color: #000000;">;
            }
            </span><span style="color: #0000ff;">string</span> last =<span style="color: #000000;"> t.back();
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; last.size(); ++<span style="color: #000000;">i) {
                </span><span style="color: #0000ff;">string</span> newLast =<span style="color: #000000;"> last;
                </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span> ch = <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span>; ch &lt;= <span style="color: #800000;">'</span><span style="color: #800000;">z</span><span style="color: #800000;">'</span>; ++<span style="color: #000000;">ch) {
                    newLast[i] </span>=<span style="color: #000000;"> ch;
                    </span><span style="color: #0000ff;">if</span> (!dict.count(newLast)) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                    words.insert(newLast);
                    vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; nextPath =<span style="color: #000000;"> t;
                    nextPath.push_back(newLast);
                    </span><span style="color: #0000ff;">if</span> (newLast ==<span style="color: #000000;"> endWord) {
                        res.push_back(nextPath);
                        minLevel </span>=<span style="color: #000000;"> level;
                    } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> paths.push(nextPath);
                }
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4539768.html" target="_blank">Word Ladder</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="http://yucoding.blogspot.com/2014/01/leetcode-question-word-ladder-ii.html" target="_blank">http://yucoding.blogspot.com/2014/01/leetcode-question-word-ladder-ii.html</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-06-03 02:31</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4548184" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4548184);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4030114.html" id="cb_post_title_url">[LeetCode] Valid Palindrome 验证回文字符串</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.</p>
<p> For example,<br/>
<code>"A man, a plan, a canal: Panama"</code> is a palindrome.<br/>
<code>"race a car"</code> is <em>not</em> a palindrome.
</p>
<p>
<strong>Note:</strong><br/>
Have you consider that the string might be empty? This is a good question to ask during an interview.</p>
<p>
For the purpose of this problem, we define empty string as valid palindrome.
</p>
<p> </p>
<p>验证回文字符串是比较常见的问题，所谓回文，就是一个正读和反读都一样的字符串，比如“level”或者“noon”等等就是回文串。但是这里，加入了空格和非字母数字的字符，增加了些难度，但其实原理还是很简单：只需要建立两个指针，left和right, 分别从字符的开头和结尾处开始遍历整个字符串，如果遇到非字母数字的字符就跳过，继续往下找，直到找到下一个字母数字或者结束遍历，如果遇到大写字母，就将其转为小写。等左右指针都找到字母数字时，比较这两个字符，若相等，则继续比较下面两个分别找到的字母数字，若不相等，直接返回false. </p>
<p>时间复杂度为O(n), 代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> isPalindrome(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        </span><span style="color: #0000ff;">int</span> left = <span style="color: #800080;">0</span>, right = s.size() - <span style="color: #800080;">1</span><span style="color: #000000;"> ;
        </span><span style="color: #0000ff;">while</span> (left &lt;<span style="color: #000000;"> right) {
            </span><span style="color: #0000ff;">if</span> (!isAlphaNum(s[left])) ++<span style="color: #000000;">left;
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (!isAlphaNum(s[right])) --<span style="color: #000000;">right;
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> ((s[left] + <span style="color: #800080;">32</span> - <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span>) %<span style="color: #800080;">32</span> != (s[right] + <span style="color: #800080;">32</span> - <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span>) % <span style="color: #800080;">32</span>) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                </span>++left; --<span style="color: #000000;">right;
            }
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
    </span><span style="color: #0000ff;">bool</span> isAlphaNum(<span style="color: #0000ff;">char</span> &amp;<span style="color: #000000;">ch) {
        </span><span style="color: #0000ff;">if</span> (ch &gt;= <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span> &amp;&amp; ch &lt;= <span style="color: #800000;">'</span><span style="color: #800000;">z</span><span style="color: #800000;">'</span>) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (ch &gt;= <span style="color: #800000;">'</span><span style="color: #800000;">A</span><span style="color: #800000;">'</span> &amp;&amp; ch &lt;= <span style="color: #800000;">'</span><span style="color: #800000;">Z</span><span style="color: #800000;">'</span>) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (ch &gt;= <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span> &amp;&amp; ch &lt;= <span style="color: #800000;">'</span><span style="color: #800000;">9</span><span style="color: #800000;">'</span>) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>我们也可以用系统自带的判断是否是数母字符的判断函数isalnum，参见代码如下；</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> isPalindrome(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        </span><span style="color: #0000ff;">int</span> left = <span style="color: #800080;">0</span>, right = s.size() - <span style="color: #800080;">1</span><span style="color: #000000;"> ;
        </span><span style="color: #0000ff;">while</span> (left &lt;<span style="color: #000000;"> right) {
            </span><span style="color: #0000ff;">if</span> (!isalnum(s[left])) ++<span style="color: #000000;">left;
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (!isalnum(s[right])) --<span style="color: #000000;">right;
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> ((s[left] + <span style="color: #800080;">32</span> - <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span>) %<span style="color: #800080;">32</span> != (s[right] + <span style="color: #800080;">32</span> - <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span>) % <span style="color: #800080;">32</span>) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                </span>++left; --<span style="color: #000000;">right;
            }
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>对于该问题的扩展，还有利用Manacher算法来求解最长回文字符串问题，参见我的另一篇博文<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4475985.html" id="cb_post_title_url">Manacher's Algorithm 马拉车算法</a>。</p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/5581/here-s-a-clean-c-solution/2" target="_blank">https://discuss.leetcode.com/topic/5581/here-s-a-clean-c-solution/2</a></p>
<p><a href="https://discuss.leetcode.com/topic/25405/my-three-line-java-solution" target="_blank">https://discuss.leetcode.com/topic/25405/my-three-line-java-solution</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2014-10-17 04:09</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4030114" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4030114);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4280120.html" id="cb_post_title_url">[LeetCode] Binary Tree Maximum Path Sum 求二叉树的最大路径和</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a binary tree, find the maximum path sum.</p>
<p>The path may start and end at any node in the tree.</p>
<p>For example:<br/>Given the below binary tree,</p>
<pre>       1
      / \
     2   3
</pre>
<p> </p>
<p>Return <code>6</code>.</p>
<p> </p>
<p>这道求二叉树的最大路径和是一道蛮有难度的题，难就难在起始位置和结束位置可以为任意位置，我当然是又不会了，于是上网看看大神们的解法，像这种类似数的遍历的题，一般来说都需要用DFS来求解，我们先来看一个简单的例子：</p>
<div class="cnblogs_code">
<pre>    <span style="color: #800080;">4</span>
   /<span style="color: #000000;"> \
  </span><span style="color: #800080;">11</span> <span style="color: #800080;">13</span>
 /<span style="color: #000000;"> \
</span><span style="color: #800080;">7</span>   <span style="color: #800080;">2</span></pre>
</div>
<p>由于这是一个很简单的例子，我们很容易就能找到最长路径为7-11-4-13，那么怎么用递归来找出正确的路径和呢？根据以往的经验，树的递归解法一般都是递归到叶节点，然后开始边处理边回溯到根节点。那么我们就假设此时已经递归到结点7了，那么其没有左右子节点，所以如果以结点7为根结点的子树最大路径和就是7。然后回溯到结点11，如果以结点11为根结点的子树，我们知道最大路径和为7+11+2=20。但是当回溯到结点4的时候，对于结点11来说，就不能同时取两条路径了，只能取左路径，或者是右路径，所以当根结点是4的时候，那么结点11只能取其左子结点7，因为7大于2。所以，对于每个结点来说，我们要知道经过其左子结点的path之和大还是经过右子节点的path之和大。那么我们的递归函数返回值就可以定义为以当前结点为根结点，到叶节点的最大路径之和，然后全局路径最大值放在参数中，用结果res来表示。</p>
<p>在递归函数中，如果当前结点不存在，那么直接返回0。否则就分别对其左右子节点调用递归函数，由于路径和有可能为负数，而我们当然不希望加上负的路径和，所以我们和0相比，取较大的那个，就是要么不加，加就要加正数。然后我们来更新全局最大值结果res，就是以左子结点为终点的最大path之和加上以右子结点为终点的最大path之和，还要加上当前结点值，这样就组成了一个条完整的路径。而我们返回值是取left和right中的较大值加上当前结点值，因为我们返回值的定义是以当前结点为终点的path之和，所以只能取left和right中较大的那个值，而不是两个都要，参见代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> maxPathSum(TreeNode*<span style="color: #000000;"> root) {
        </span><span style="color: #0000ff;">int</span> res =<span style="color: #000000;"> INT_MIN;
        helper(root, res);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">int</span> helper(TreeNode* node, <span style="color: #0000ff;">int</span>&amp;<span style="color: #000000;"> res) {
        </span><span style="color: #0000ff;">if</span> (!node) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> left = max(helper(node-&gt;left, res), <span style="color: #800080;">0</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">int</span> right = max(helper(node-&gt;right, res), <span style="color: #800080;">0</span><span style="color: #000000;">);
        res </span>= max(res, left + right + node-&gt;<span style="color: #000000;">val);
        </span><span style="color: #0000ff;">return</span> max(left, right) + node-&gt;<span style="color: #000000;">val;
    }
};</span></pre>
</div>
<p> </p>
<p>讨论：这道题有一个很好的Follow up，就是返回这个最大路径，那么就复杂很多，因为我们的递归函数就不能返回路径和了，而是返回该路径上所有的结点组成的数组，递归的参数还要保留最大路径之和，同时还需要最大路径结点的数组，然后对左右子节点调用递归函数后得到的是数组，我们要统计出数组之和，并且跟0比较，如果小于0，和清零，数组清空。然后就是更新最大路径之和跟数组啦，还要拼出来返回值数组，代码长了很多，有兴趣的童鞋可以在评论区贴上你的代码～</p>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4036961.html" target="_blank">Path Sum</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4273700.html" target="_blank">Sum Root to Leaf Numbers</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/7570954.html">Path Sum IV</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/7636259.html">Longest Univalue Path</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/4407/accepted-short-solution-in-java" target="_blank">https://discuss.leetcode.com/topic/4407/accepted-short-solution-in-java</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-02-08 15:55</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4280120" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4280120);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4281975.html" id="cb_post_title_url">[LeetCode] Best Time to Buy and Sell Stock III 买股票的最佳时间之三</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Say you have an array for which the <em>i</em>th element is the price of a given stock on day <em>i</em>.</p>
<p>Design an algorithm to find the maximum profit. You may complete at most <em>two</em> transactions.</p>
<p>Note:<br/>You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p>
<p> </p>
<p>这道是买股票的最佳时间系列问题中最难最复杂的一道，前面两道<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4280131.html" id="homepage1_HomePageDays_DaysList_ctl01_DayList_TitleUrl_0">Best Time to Buy and Sell Stock 买卖股票的最佳时间</a>和<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4280803.html" id="homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0">Best Time to Buy and Sell Stock II 买股票的最佳时间之二</a>的思路都非常的简洁明了，算法也很简单。而这道是要求最多交易两次，找到最大利润，还是需要用动态规划Dynamic Programming来解，而这里我们需要两个递推公式来分别更新两个变量local和global，参见网友<a href="http://blog.csdn.net/linhuanmars/article/details/23236995" target="_blank">Code Ganker的博客</a>，我们其实可以求至少k次交易的最大利润，找到通解后可以设定 k = 2，即为本题的解答。我们定义local[i][j]为在到达第i天时最多可进行j次交易并且最后一次交易在最后一天卖出的最大利润，此为局部最优。然后我们定义global[i][j]为在到达第i天时最多可进行j次交易的最大利润，此为全局最优。它们的递推式为：</p>
<p>local[i][j] = max(global[i - 1][j - 1] + max(diff, 0), local[i - 1][j] + diff)</p>
<p>global[i][j] = max(local[i][j], global[i - 1][j])</p>
<p>其中局部最优值是比较前一天并少交易一次的全局最优加上大于0的差值，和前一天的局部最优加上差值中取较大值，而全局最优比较局部最优和前一天的全局最优。代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> maxProfit(vector&lt;<span style="color: #0000ff;">int</span>&gt; &amp;<span style="color: #000000;">prices) {
        </span><span style="color: #0000ff;">if</span> (prices.empty()) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> n = prices.size(), g[n][<span style="color: #800080;">3</span>] = {<span style="color: #800080;">0</span>}, l[n][<span style="color: #800080;">3</span>] = {<span style="color: #800080;">0</span><span style="color: #000000;">};
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt; prices.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">int</span> diff = prices[i] - prices[i - <span style="color: #800080;">1</span><span style="color: #000000;">];
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">1</span>; j &lt;= <span style="color: #800080;">2</span>; ++<span style="color: #000000;">j) {
                l[i][j] </span>= max(g[i - <span style="color: #800080;">1</span>][j - <span style="color: #800080;">1</span>] + max(diff, <span style="color: #800080;">0</span>), l[i - <span style="color: #800080;">1</span>][j] +<span style="color: #000000;"> diff);
                g[i][j] </span>= max(l[i][j], g[i - <span style="color: #800080;">1</span><span style="color: #000000;">][j]);
            }
        }
        </span><span style="color: #0000ff;">return</span> g[n - <span style="color: #800080;">1</span>][<span style="color: #800080;">2</span><span style="color: #000000;">];
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种解法用一维数组来代替二维数组，可以极大的节省了空间，由于覆盖的顺序关系，我们需要j从2到1，这样可以取到正确的g[j-1]值，而非已经被覆盖过的值，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> maxProfit(vector&lt;<span style="color: #0000ff;">int</span>&gt; &amp;<span style="color: #000000;">prices) {
        </span><span style="color: #0000ff;">if</span> (prices.empty()) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> g[<span style="color: #800080;">3</span>] = {<span style="color: #800080;">0</span><span style="color: #000000;">};
        </span><span style="color: #0000ff;">int</span> l[<span style="color: #800080;">3</span>] = {<span style="color: #800080;">0</span><span style="color: #000000;">};
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; prices.size() - <span style="color: #800080;">1</span>; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">int</span> diff = prices[i + <span style="color: #800080;">1</span>] -<span style="color: #000000;"> prices[i];
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">2</span>; j &gt;= <span style="color: #800080;">1</span>; --<span style="color: #000000;">j) {
                l[j] </span>= max(g[j - <span style="color: #800080;">1</span>] + max(diff, <span style="color: #800080;">0</span>), l[j] +<span style="color: #000000;"> diff);
                g[j] </span>=<span style="color: #000000;"> max(l[j], g[j]);
            }
        }
        </span><span style="color: #0000ff;">return</span> g[<span style="color: #800080;">2</span><span style="color: #000000;">];
    }
};</span></pre>
</div>
<p> </p>
<p>我们如果假设prices数组为1, 3, 2, 9, 那么我们来看每次更新时local 和 global 的值：</p>
<p>第一天两次交易：　　　　　　第一天一次交易：</p>
<p>local:　　  0 0 0 　　　　　　local:　　  0 0 0 </p>
<p>global:　　0 0 0　　　　　 　global:　　0 0 0</p>
<p>第二天两次交易：　　　　　　第二天一次交易：</p>
<p>local:　　  0 0 2 　　　　　　local:　　  0 2 2 </p>
<p>global:　　0 0 2　　　　　 　global:　　0 2 2</p>
<p>第三天两次交易：　　　　　　第三天一次交易：</p>
<p>local:　　  0 2 2 　　　　　　local:　　  0 1 2 </p>
<p>global:　　0 2 2　　　　 　　global:　　0 2 2</p>
<p>第四天两次交易：　　　　　　第四天一次交易：</p>
<p>local:　　  0 1 9 　　　　　　local:　　  0 8 9 </p>
<p>global:　　0 2 9　　　　　 　global:　　0 8 9</p>
<p> </p>
<p>在网友@<a href="http://home.cnblogs.com/u/1221269/" id="a_comment_author_3761489" target="_blank">loveahnee</a>的提醒下，发现了其实上述的递推公式关于local[i][j]的可以稍稍化简一下，我们之前定义的local[i][j]为在到达第i天时最多可进行j次交易并且最后一次交易在最后一天卖出的最大利润，然后网友@<a href="http://home.cnblogs.com/u/985421/" id="a_comment_author_3650920" target="_blank">fgvlty</a>解释了一下第 i 天卖第 j 支股票的话，一定是下面的一种：</p>
<p>1. 今天刚买的<br/>那么 Local(i, j) = Global(i-1, j-1)<br/>相当于啥都没干</p>
<p>2. 昨天买的<br/>那么 Local(i, j) = Global(i-1, j-1) + diff<br/>等于Global(i-1, j-1) 中的交易，加上今天干的那一票</p>
<p>3. 更早之前买的<br/>那么 Local(i, j) = Local(i-1, j) + diff<br/>昨天别卖了，留到今天卖</p>
<p>但其实第一种情况是不需要考虑的，因为当天买当天卖不会增加利润，完全是重复操作，这种情况可以归纳在global[i-1][j-1]中，所以我们就不需要max(0, diff)了，那么由于两项都加上了diff，所以我们可以把diff抽到max的外面，所以更新后的递推公式为：</p>
<p>local[i][j] = max(global[i - 1][j - 1], local[i - 1][j]) + diff</p>
<p>global[i][j] = max(local[i][j], global[i - 1][j])</p>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4997417.html">Best Time to Buy and Sell Stock with Cooldown</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4295761.html" target="_blank">Best Time to Buy and Sell Stock IV</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4280803.html" target="_blank">Best Time to Buy and Sell Stock II</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4280131.html" target="_blank">Best Time to Buy and Sell Stock</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-02-09 17:09</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4281975" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4281975);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4280803.html" id="cb_post_title_url">[LeetCode] Best Time to Buy and Sell Stock II  买股票的最佳时间之二</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Say you have an array for which the <em>i</em>th element is the price of a given stock on day <em>i</em>.</p>
<p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p>
<p> </p>
<p>这道跟之前那道<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4280131.html" id="homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0">Best Time to Buy and Sell Stock 买卖股票的最佳时间</a>很类似，但都比较容易解答。这道题由于可以无限次买入和卖出。我们都知道炒股想挣钱当然是低价买入高价抛出，那么这里我们只需要从第二天开始，如果当前价格比之前价格高，则把差值加入利润中，因为我们可以昨天买入，今日卖出，若明日价更高的话，还可以今日买入，明日再抛出。以此类推，遍历完整个数组后即可求得最大利润。代码如下：</p>
<p> </p>
<p>C++ 解法：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> maxProfit(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> prices) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, n =<span style="color: #000000;"> prices.size();
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n - <span style="color: #800080;">1</span>; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (prices[i] &lt; prices[i + <span style="color: #800080;">1</span><span style="color: #000000;">]) {
                res </span>+= prices[i + <span style="color: #800080;">1</span>] -<span style="color: #000000;"> prices[i];
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>Java 解法：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span> maxProfit(<span style="color: #0000ff;">int</span><span style="color: #000000;">[] prices) {
        </span><span style="color: #0000ff;">int</span> res = 0<span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = 0; i &lt; prices.length - 1; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (prices[i] &lt; prices[i + 1<span style="color: #000000;">]) {
                res </span>+= prices[i + 1] -<span style="color: #000000;"> prices[i];
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
}</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4997417.html">Best Time to Buy and Sell Stock with Cooldown</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4295761.html" target="_blank">Best Time to Buy and Sell Stock IV</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4281975.html" target="_blank">Best Time to Buy and Sell Stock III</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4280131.html" target="_blank">Best Time to Buy and Sell Stock</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-02-09 08:39</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4280803" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4280803);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4280131.html" id="cb_post_title_url">[LeetCode] Best Time to Buy and Sell Stock  买卖股票的最佳时间</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Say you have an array for which the <em>i</em>th element is the price of a given stock on day <em>i</em>.</p>
<p>If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p>
<p> </p>
<p>这道题相当简单，感觉达不到Medium的难度，只需要遍历一次数组，用一个变量记录遍历过数中的最小值，然后每次计算当前值和这个最小值之间的差值最为利润，然后每次选较大的利润来更新。当遍历完成后当前利润即为所求，代码如下：</p>
<p> </p>
<p>C++ 解法：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> maxProfit(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> prices) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, buy =<span style="color: #000000;"> INT_MAX;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span><span style="color: #000000;"> price : prices) {
            buy </span>=<span style="color: #000000;"> min(buy, price);
            res </span>= max(res, price -<span style="color: #000000;"> buy);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>Java 解法：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span> maxProfit(<span style="color: #0000ff;">int</span><span style="color: #000000;">[] prices) {
        </span><span style="color: #0000ff;">int</span> res = 0, buy =<span style="color: #000000;"> Integer.MAX_VALUE;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span><span style="color: #000000;"> price : prices) {
            buy </span>=<span style="color: #000000;"> Math.min(buy, price);
            res </span>= Math.max(res, price -<span style="color: #000000;"> buy);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
}</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4997417.html">Best Time to Buy and Sell Stock with Cooldown</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4295761.html" target="_blank">Best Time to Buy and Sell Stock IV</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4281975.html" target="_blank">Best Time to Buy and Sell Stock III</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4280803.html" target="_blank">Best Time to Buy and Sell Stock II</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-02-08 16:12</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4280131" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4280131);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4286274.html" id="cb_post_title_url">[LeetCode] Triangle 三角形</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.</p>
<p>For example, given the following triangle</p>
<pre>[
     [<span style="color: red;">2</span>],
    [<span style="color: red;">3</span>,4],
   [6,<span style="color: red;">5</span>,7],
  [4,<span style="color: red;">1</span>,8,3]
]
</pre>
<p> </p>
<p>The minimum path sum from top to bottom is <code>11</code> (i.e., <span style="color: red;">2</span> + <span style="color: red;">3</span> + <span style="color: red;">5</span> + <span style="color: red;">1</span> = 11).</p>
<p>Note:<br/>Bonus point if you are able to do this using only <em>O</em>(<em>n</em>) extra space, where <em>n</em> is the total number of rows in the triangle.</p>
<p> </p>
<p>这道题和<a class="entrylistItemTitle" href="http://www.cnblogs.com/grandyang/p/4233035.html" id="CategoryEntryList1_EntryStoryList_ctl00_Entries_TitleUrl_23">Dungeon Game 地牢游戏</a>非常的类似，都是用动态规划Dynamic Programming来求解的问题。而且递推式也比较容易看出来，我最先想到的方法是:</p>
<p>从第二行开始，triangle[i][j] = min(triangle[i - 1][j - 1], triangle[i - 1][j]), 然后两边的数字直接赋值上一行的边界值，由于限制了空间复杂度，所以我干脆直接就更新triangle数组，代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> minimumTotal(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt; &gt; &amp;<span style="color: #000000;">triangle) {
        </span><span style="color: #0000ff;">int</span> n =<span style="color: #000000;"> triangle.size();
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; triangle[i].size(); ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> (j == <span style="color: #800080;">0</span>) triangle[i][j] += triangle[i - <span style="color: #800080;">1</span><span style="color: #000000;">][j];
                </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (j == triangle[i].size() - <span style="color: #800080;">1</span>) triangle[i][j] += triangle[i - <span style="color: #800080;">1</span>][j - <span style="color: #800080;">1</span><span style="color: #000000;">];
                </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    triangle[i][j] </span>+= min(triangle[i - <span style="color: #800080;">1</span>][j - <span style="color: #800080;">1</span>], triangle[i - <span style="color: #800080;">1</span><span style="color: #000000;">][j]);
                }
            }
        }
        </span><span style="color: #0000ff;">int</span> res = triangle[n - <span style="color: #800080;">1</span>][<span style="color: #800080;">0</span><span style="color: #000000;">];
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; triangle[n - <span style="color: #800080;">1</span>].size(); ++<span style="color: #000000;">i) {
            res </span>= min(res, triangle[n - <span style="color: #800080;">1</span><span style="color: #000000;">][i]);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>这种方法可以通过OJ，但是毕竟修改了原始数组triangle，并不是很理想的方法。在网上搜到一种更好的DP方法，这种方法复制了三角形最后一行，作为用来更新的一位数组。然后逐个遍历这个DP数组，对于每个数字，和它之后的元素比较选择较小的再加上上面一行相邻位置的元素做为新的元素，然后一层一层的向上扫描，整个过程和冒泡排序的原理差不多，最后最小的元素都冒到前面，第一个元素即为所求。代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> minimumTotal(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt; &gt; &amp;<span style="color: #000000;">triangle) {
        </span><span style="color: #0000ff;">int</span> n =<span style="color: #000000;"> triangle.size();
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> dp(triangle.back());
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = n - <span style="color: #800080;">2</span>; i &gt;= <span style="color: #800080;">0</span>; --<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt;= i; ++<span style="color: #000000;">j) {
                dp[j] </span>= min(dp[j], dp[j + <span style="color: #800080;">1</span>]) +<span style="color: #000000;"> triangle[i][j];
            }
        }
        </span><span style="color: #0000ff;">return</span> dp[<span style="color: #800080;">0</span><span style="color: #000000;">];
    }
};</span></pre>
</div>
<p> </p>
<p>下面我们来看一个例子，对于输入数组：</p>
<p>     -1</p>
<p>    2   3</p>
<p>  1  -1  -3</p>
<p>5   3   -1   2</p>
<p>下面我们来看DP数组的变换过程。</p>
<p>DP：5  3  -1  2</p>
<p>DP：<span style="color: #ff0000;">4</span>  3  -1  2</p>
<p>DP：4  <span style="color: #ff0000;">-2</span>  -1  2</p>
<p>DP：4  -2  <span style="color: #ff0000;">-4</span>  2</p>
<p>DP：<span style="color: #ff0000;">0</span>  -2  -4  2</p>
<p>DP：0  <span style="color: #ff0000;">-1</span>  -4  2</p>
<p>DP：<span style="color: #ff0000;">-2</span>  -1  -4  2</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-02-11 15:14</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4286274" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4286274);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4031536.html" id="cb_post_title_url">[LeetCode] Pascal's Triangle II 杨辉三角之二</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given an index <em>k</em>, return the <em>k</em>th row of the Pascal's triangle.</p>
<p>For example, given <em>k</em> = 3,<br/>Return <code>[1,3,3,1]</code>.</p>
<p><strong>Note:</strong><br/>Could you optimize your algorithm to use only <em>O</em>(<em>k</em>) extra space?</p>
<p> </p>
<p>杨辉三角想必大家并不陌生，应该最早出现在初高中的数学中，其实就是二项式系数的一种写法。</p>
<pre>　　　　　　　　１
　　　　　　　１　１
　　　　　　１　２　１
　　　　　１　３　３　１
　　　　１　４　６　４　１
　　　１　５　10　10　５　１
　　１　６　15　20　15　６　１
　１　７　21　35　35　21　７　１
１　８　28　56　70　56　28　８　１</pre>
<p>杨辉三角形第n层（顶层称第0层，第1行，第n层即第n+1行，此处n为包含0在内的自然数）正好对应于二项式<img alt="\left(a+b\right)^{n}" class="mwe-math-fallback-png-inline tex" src="http://upload.wikimedia.org/math/4/b/9/4b96ccc1bce6fcd32bc5bd2fd2de4b7a.png"/>展开的系数。例如第二层1 2 1是幂指数为2的二项式<img alt="\left(a+b\right)^{2}" class="mwe-math-fallback-png-inline tex" src="http://upload.wikimedia.org/math/8/2/0/820a2947ed4432430a12c5cb107561ed.png"/>展开形式<img alt="a^{2}+2ab+b^{2}" class="mwe-math-fallback-png-inline tex" src="http://upload.wikimedia.org/math/5/c/2/5c2982db60ef27dfb6249933d1be73a1.png"/>的系数。</p>
<p> </p>
<p>杨辉三角主要有下列五条性质：</p>
<ol>
<li>杨辉三角以正整数构成，数字左右对称，每行由1开始逐渐变大，然后变小，回到1。</li>
<li>第<img alt="n" class="mwe-math-fallback-png-inline tex" src="http://upload.wikimedia.org/math/7/b/8/7b8b965ad4bca0e41ab51de7b31363a1.png"/>行的数字个数为<img alt="n" class="mwe-math-fallback-png-inline tex" src="http://upload.wikimedia.org/math/7/b/8/7b8b965ad4bca0e41ab51de7b31363a1.png"/>个。</li>
<li>第<img alt="n" class="mwe-math-fallback-png-inline tex" src="http://upload.wikimedia.org/math/7/b/8/7b8b965ad4bca0e41ab51de7b31363a1.png"/>行的第<img alt="k" class="mwe-math-fallback-png-inline tex" src="http://upload.wikimedia.org/math/8/c/e/8ce4b16b22b58894aa86c421e8759df3.png"/>个数字为组合数<img alt="C_{n-1}^{k-1}" class="mwe-math-fallback-png-inline tex" src="http://upload.wikimedia.org/math/7/c/9/7c90e60eb2d8eaec74a30a81b1b4f1d9.png"/>。</li>
<li>第<img alt="n" class="mwe-math-fallback-png-inline tex" src="http://upload.wikimedia.org/math/7/b/8/7b8b965ad4bca0e41ab51de7b31363a1.png"/>行数字和为<img alt="2^{n-1}" class="mwe-math-fallback-png-inline tex" src="http://upload.wikimedia.org/math/4/2/e/42ef218254478d61d6f2afb986f4b88c.png"/>。</li>
<li>除每行最左侧与最右侧的数字以外，每个数字等于它的左上方与右上方两个数字之和（也就是说，第<img alt="n" class="mwe-math-fallback-png-inline tex" src="http://upload.wikimedia.org/math/7/b/8/7b8b965ad4bca0e41ab51de7b31363a1.png"/>行第<img alt="k" class="mwe-math-fallback-png-inline tex" src="http://upload.wikimedia.org/math/8/c/e/8ce4b16b22b58894aa86c421e8759df3.png"/>个数字等于第<img alt="n-1" class="mwe-math-fallback-png-inline tex" src="http://upload.wikimedia.org/math/a/4/3/a438673491daae8148eae77373b6a467.png"/>行的第<img alt="k-1" class="mwe-math-fallback-png-inline tex" src="http://upload.wikimedia.org/math/1/4/4/14464ac1dfe6fa8ad8fda94bb6f01571.png"/>个数字与第<img alt="k" class="mwe-math-fallback-png-inline tex" src="http://upload.wikimedia.org/math/8/c/e/8ce4b16b22b58894aa86c421e8759df3.png"/>个数字的和）。这是因为有组合恒等式：<img alt="C_{n}^{i}=C_{n-1}^{i-1}+C_{n-1}^{i}" class="mwe-math-fallback-png-inline tex" src="http://upload.wikimedia.org/math/c/7/0/c702e84dfa4142f435d9c2bbbbfeeae0.png"/>。可用此性质写出整个杨辉三角形。</li>
</ol>
<p> </p>
<p>由于题目有额外限制条件，程序只能使用O(k)的额外空间，那么这样就不能把每行都算出来，而是要用其他的方法, 我最先考虑用的是第三条性质，算出每个组合数来生成第n行系数，代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">/*</span><span style="color: #008000;">*
 * NOT Correct!
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; getRow(<span style="color: #0000ff;">int</span><span style="color: #000000;"> rowIndex) {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; <span style="color: #0000ff;">out</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (rowIndex &lt; <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">out</span><span style="color: #000000;">;
        
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt;= rowIndex; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> ( i == <span style="color: #800080;">0</span> || i ==<span style="color: #000000;"> rowIndex)
                </span><span style="color: #0000ff;">out</span>.push_back(<span style="color: #800080;">1</span><span style="color: #000000;">);
            </span><span style="color: #0000ff;">else</span>
                <span style="color: #0000ff;">out</span><span style="color: #000000;">.push_back (computeCnk(rowIndex, i));
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">out</span><span style="color: #000000;">;
    }
    
    </span><span style="color: #0000ff;">int</span> computeCnk(<span style="color: #0000ff;">int</span> n, <span style="color: #0000ff;">int</span><span style="color: #000000;"> k) {
        </span><span style="color: #0000ff;">if</span> (k &gt; n) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (k &gt; n/<span style="color: #800080;">2</span>) k = n -<span style="color: #000000;"> k;
        </span><span style="color: #0000ff;">int</span> numerator = <span style="color: #800080;">1</span>, denomator = <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; k; ++<span style="color: #000000;">i) {
            numerator </span>*= n -<span style="color: #000000;"> i;
            denomator </span>*= k -<span style="color: #000000;"> i;
        }
        </span><span style="color: #0000ff;">if</span> (denomator != <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span> numerator/<span style="color: #000000;">denomator;
        </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>本地调试输出前十行，没啥问题，拿到OJ上测试，程序在第18行跪了，中间有个系数不正确。那么问题出在哪了呢，仔细找找，原来出在计算组合数那里，由于算组合数时需要算连乘，而整形数int的数值范围只有-32768到32768之间，那么一旦n值过大，连乘肯定无法计算。而丧心病狂的OJ肯定会测试到成百上千行，所以这个方法不行。那么我们再来考虑利用第五条性质，除了第一个和最后一个数字之外，其他的数字都是上一行左右两个值之和。那么我们只需要两个for循环，除了第一个数为1之外，后面的数都是上一次循环的数值加上它前面位置的数值之和，不停地更新每一个位置的值，便可以得到第n行的数字，具体实现代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; getRow(<span style="color: #0000ff;">int</span><span style="color: #000000;"> rowIndex) {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; <span style="color: #0000ff;">out</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (rowIndex &lt; <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">out</span><span style="color: #000000;">;
        
        </span><span style="color: #0000ff;">out</span>.assign(rowIndex + <span style="color: #800080;">1</span>, <span style="color: #800080;">0</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt;= rowIndex; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> ( i == <span style="color: #800080;">0</span><span style="color: #000000;">) {
                </span><span style="color: #0000ff;">out</span>[<span style="color: #800080;">0</span>] = <span style="color: #800080;">1</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">continue</span><span style="color: #000000;">;
            }
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = rowIndex; j &gt;= <span style="color: #800080;">1</span>; --<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">out</span>[j] = <span style="color: #0000ff;">out</span>[j] + <span style="color: #0000ff;">out</span>[j-<span style="color: #800080;">1</span><span style="color: #000000;">];
            }
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">out</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2014-10-17 16:52</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4031536" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4031536);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4032449.html" id="cb_post_title_url">[LeetCode] Pascal's Triangle 杨辉三角</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given <em>numRows</em>, generate the first <em>numRows</em> of Pascal's triangle.</p>
<p>For example, given <em>numRows</em> = 5,<br/>Return</p>
<pre>[
     [1],
    [1,1],
   [1,2,1],
  [1,3,3,1],
 [1,4,6,4,1]
]<br/><br/></pre>
<p>杨辉三角是二项式系数的一种写法，如果熟悉杨辉三角的五个性质，那么很好生成，可参见我的上一篇博文：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4031536.html" target="_blank">http://www.cnblogs.com/grandyang/p/4031536.html</a></p>
<p> </p>
<p>具体生成算是：每一行的首个和结尾一个数字都是1，从第三行开始，中间的每个数字都是上一行的左右两个数字之和。代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt; &gt; generate(<span style="color: #0000ff;">int</span><span style="color: #000000;"> numRows) {
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt; &gt;<span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">if</span> (numRows &lt;= <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
        res.assign(numRows, vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;(<span style="color: #800080;">1</span><span style="color: #000000;">));
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; numRows; ++<span style="color: #000000;">i) {
            res[i][</span><span style="color: #800080;">0</span>] = <span style="color: #800080;">1</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> (i == <span style="color: #800080;">0</span>) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">1</span>; j &lt; i; ++<span style="color: #000000;">j) {
                res[i].push_back(res[i</span>-<span style="color: #800080;">1</span>][j] + res[i-<span style="color: #800080;">1</span>][j-<span style="color: #800080;">1</span><span style="color: #000000;">]);
            }
            res[i].push_back(</span><span style="color: #800080;">1</span><span style="color: #000000;">);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2014-10-18 04:17</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4032449" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4032449);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4290148.html" id="cb_post_title_url">[LeetCode] Populating Next Right Pointers in Each Node II 每个节点的右向指针之二</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Follow up for problem "<em>Populating Next Right Pointers in Each Node</em>".</p>
<p>What if the given tree could be any binary tree? Would your previous solution still work?</p>
<p>Note:</p>
<ul>
<li>You may only use constant extra space.</li>
</ul>
<p> </p>
<p>For example,<br/>Given the following binary tree,</p>
<pre>         1
       /  \
      2    3
     / \    \
    4   5    7
</pre>
<p> </p>
<p>After calling your function, the tree should look like:</p>
<pre>         1 -&gt; NULL
       /  \
      2 -&gt; 3 -&gt; NULL
     / \    \
    4-&gt; 5 -&gt; 7 -&gt; NULL</pre>
<p> </p>
<p>这道是之前那道<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4288151.html" id="homepage1_HomePageDays_DaysList_ctl01_DayList_TitleUrl_0">Populating Next Right Pointers in Each Node 每个节点的右向指针</a>的延续，原本的完全二叉树的条件不再满足，但是整体的思路还是很相似，仍然有递归和非递归的解法。我们先来看递归的解法，这里由于子树有可能残缺，故需要平行扫描父节点同层的节点，找到他们的左右子节点。代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> Recursion, more than constant space</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">void</span> connect(TreeLinkNode *<span style="color: #000000;">root) {
        </span><span style="color: #0000ff;">if</span> (!root) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
        TreeLinkNode </span>*p = root-&gt;<span style="color: #000000;">next;
        </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> (p) {
            </span><span style="color: #0000ff;">if</span> (p-&gt;<span style="color: #000000;">left) {
                p </span>= p-&gt;<span style="color: #000000;">left;
                </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
            }
            </span><span style="color: #0000ff;">if</span> (p-&gt;<span style="color: #000000;">right) {
                p </span>= p-&gt;<span style="color: #000000;">right;
                </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
            }
            p </span>= p-&gt;<span style="color: #000000;">next;
        }
        </span><span style="color: #0000ff;">if</span> (root-&gt;right) root-&gt;right-&gt;next =<span style="color: #000000;"> p; 
        </span><span style="color: #0000ff;">if</span> (root-&gt;left) root-&gt;left-&gt;next = root-&gt;right ? root-&gt;<span style="color: #000000;">right : p; 
        connect(root</span>-&gt;<span style="color: #000000;">right);
        connect(root</span>-&gt;<span style="color: #000000;">left);
    }
};</span></pre>
</div>
<p> </p>
<p>对于非递归的方法，我惊喜的发现之前的方法直接就能用，完全不需要做任何修改，算法思路可参见之前的博客<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4288151.html" id="homepage1_HomePageDays_DaysList_ctl01_DayList_TitleUrl_0">Populating Next Right Pointers in Each Node 每个节点的右向指针</a>，代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> Non-recursion, more than constant space</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">void</span> connect(TreeLinkNode *<span style="color: #000000;">root) {
        </span><span style="color: #0000ff;">if</span> (!root) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
        queue</span>&lt;TreeLinkNode*&gt;<span style="color: #000000;"> q;
        q.push(root);
        </span><span style="color: #0000ff;">while</span> (!<span style="color: #000000;">q.empty()) {
            </span><span style="color: #0000ff;">int</span> len =<span style="color: #000000;"> q.size();
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; len; ++<span style="color: #000000;">i) {
                TreeLinkNode </span>*t =<span style="color: #000000;"> q.front(); q.pop();
                </span><span style="color: #0000ff;">if</span> (i &lt; len - <span style="color: #800080;">1</span>) t-&gt;next =<span style="color: #000000;"> q.front();
                </span><span style="color: #0000ff;">if</span> (t-&gt;left) q.push(t-&gt;<span style="color: #000000;">left);
                </span><span style="color: #0000ff;">if</span> (t-&gt;right) q.push(t-&gt;<span style="color: #000000;">right);
            }
        }
    }
};</span></pre>
</div>
<p> </p>
<p>虽然以上的两种方法都能通过OJ，但其实它们都不符合题目的要求，题目说只能使用constant space，可是OJ却没有写专门检测space使用情况的test，那么下面贴上constant space的解法，这个解法也是用的层序遍历，只不过没有使用queue了，我们建立一个dummy结点来指向每层的首结点的前一个结点，然后指针t用来遍历这一层，我们实际上是遍历一层，然后连下一层的next，首先从根结点开始，如果左子结点存在，那么t的next连上左子结点，然后t指向其next指针；如果root的右子结点存在，那么t的next连上右子结点，然后t指向其next指针。此时root的左右子结点都连上了，此时root向右平移一位，指向其next指针，如果此时root不存在了，说明当前层已经遍历完了，我们重置t为dummy结点，root此时为dummy-&gt;next，即下一层的首结点，然后dummy的next指针清空，或者也可以将t的next指针清空，因为前面已经将t赋值为dummy了。那么现在想一想，为什么要清空？因为我们用dummy的目的就是要直到下一行的首结点的位置即dummy-&gt;next，而一旦将root赋值为dummy-&gt;next了之后，这个dummy的使命就已经完成了，必须要断开，如果不断开的话，那么假设现在root是叶结点了，那么while循环还会执行，不会进入前两个if，然后root右移赋空之后，会进入最后一个if，之前没有断开dummy-&gt;next的话，那么root又指向之前的叶结点了，死循环诞生了，跪了。所以一定要记得清空哦，呵呵哒～代码如下：</p>
<p> </p>
<p>解法三： </p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> Non-recursion, constant space</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">void</span> connect(TreeLinkNode *<span style="color: #000000;">root) {
        TreeLinkNode </span>*dummy = <span style="color: #0000ff;">new</span> TreeLinkNode(<span style="color: #800080;">0</span>), *t =<span style="color: #000000;"> dummy;
        </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> (root) {
            </span><span style="color: #0000ff;">if</span> (root-&gt;<span style="color: #000000;">left) {
                t</span>-&gt;next = root-&gt;<span style="color: #000000;">left;
                t </span>= t-&gt;<span style="color: #000000;">next;
            }
            </span><span style="color: #0000ff;">if</span> (root-&gt;<span style="color: #000000;">right) {
                t</span>-&gt;next = root-&gt;<span style="color: #000000;">right;
                t </span>= t-&gt;<span style="color: #000000;">next;
            }
            root </span>= root-&gt;<span style="color: #000000;">next;
            </span><span style="color: #0000ff;">if</span> (!<span style="color: #000000;">root) {
                t </span>=<span style="color: #000000;"> dummy;
                root </span>= dummy-&gt;<span style="color: #000000;">next;
                dummy</span>-&gt;next =<span style="color: #000000;"> NULL;
            }
        }
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4288151.html" target="_blank">Populating Next Right Pointers in Each Node</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/28580/java-solution-with-constant-space">https://discuss.leetcode.com/topic/28580/java-solution-with-constant-space</a></p>
<p><a href="https://discuss.leetcode.com/topic/1106/o-1-space-o-n-complexity-iterative-solution">https://discuss.leetcode.com/topic/1106/o-1-space-o-n-complexity-iterative-solution</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-02-13 13:51</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4290148" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4290148);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4288151.html" id="cb_post_title_url">[LeetCode] Populating Next Right Pointers in Each Node 每个节点的右向指针</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a binary tree</p>
<pre>    struct TreeLinkNode {
      TreeLinkNode *left;
      TreeLinkNode *right;
      TreeLinkNode *next;
    }
</pre>
<p> </p>
<p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to <code>NULL</code>.</p>
<p>Initially, all next pointers are set to <code>NULL</code>.</p>
<p>Note:</p>
<ul>
<li>You may only use constant extra space.</li>
<li>You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children).</li>
</ul>
<p> </p>
<p>For example,<br/>Given the following perfect binary tree,</p>
<pre>         1
       /  \
      2    3
     / \  / \
    4  5  6  7
</pre>
<p> </p>
<p>After calling your function, the tree should look like:</p>
<pre>         1 -&gt; NULL
       /  \
      2 -&gt; 3 -&gt; NULL
     / \  / \
    4-&gt;5-&gt;6-&gt;7 -&gt; NULL</pre>
<p>这道题实际上是树的层序遍历的应用，可以参考之前的博客<a class="link-post-title" href="http://www.cnblogs.com/grandyang/p/4051321.html" id="link_post_title">Binary Tree Level Order Traversal 二叉树层序遍历</a>，既然是遍历，就有递归和非递归两种方法，最好两种方法都要掌握，都要会写。下面先来看递归的解法，由于是完全二叉树，所以若节点的左子结点存在的话，其右子节点必定存在，所以左子结点的next指针可以直接指向其右子节点，对于其右子节点的处理方法是，判断其父节点的next是否为空，若不为空，则指向其next指针指向的节点的左子结点，若为空则指向NULL，代码如下：</p>
<p> </p>
<p>C++ 解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> Recursion, more than constant space</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">void</span> connect(TreeLinkNode *<span style="color: #000000;">root) {
        </span><span style="color: #0000ff;">if</span> (!root) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (root-&gt;left) root-&gt;left-&gt;next = root-&gt;<span style="color: #000000;">right;
        </span><span style="color: #0000ff;">if</span> (root-&gt;right) root-&gt;right-&gt;next = root-&gt;next? root-&gt;next-&gt;<span style="color: #000000;">left : NULL;
        connect(root</span>-&gt;<span style="color: #000000;">left);
        connect(root</span>-&gt;<span style="color: #000000;">right);
    }
};</span></pre>
</div>
<p> </p>
<p>对于非递归的解法要稍微复杂一点，但也不算特别复杂，需要用到queue来辅助，由于是层序遍历，每层的节点都按顺序加入queue中，而每当从queue中取出一个元素时，将其next指针指向queue中下一个节点即可。代码如下：</p>
<p> </p>
<p>C++ 解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> Non-recursion, more than constant space</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">void</span> connect(TreeLinkNode *<span style="color: #000000;">root) {
        </span><span style="color: #0000ff;">if</span> (!root) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
        queue</span>&lt;TreeLinkNode*&gt;<span style="color: #000000;"> q;
        q.push(root);
        q.push(NULL);
        </span><span style="color: #0000ff;">while</span> (<span style="color: #0000ff;">true</span><span style="color: #000000;">) {
            TreeLinkNode </span>*cur =<span style="color: #000000;"> q.front();
            q.pop();
            </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (cur) {
                cur</span>-&gt;next =<span style="color: #000000;"> q.front();
                </span><span style="color: #0000ff;">if</span> (cur-&gt;left) q.push(cur-&gt;<span style="color: #000000;">left);
                </span><span style="color: #0000ff;">if</span> (cur-&gt;right) q.push(cur-&gt;<span style="color: #000000;">right);
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                </span><span style="color: #0000ff;">if</span> (q.size() == <span style="color: #800080;">0</span> || q.front() == NULL) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
                q.push(NULL);
            }
        }
    }
};</span></pre>
</div>
<p> </p>
<p>上面的方法巧妙的通过给queue中添加空指针NULL来达到分层的目的，使每层的最后一个节点的next可以指向NULL，那么我们可以换一种方法来实现分层，我们对于每层的开头元素开始遍历之前，先统计一下该层的总个数，用个for循环，这样for循环结束的时候，我们就知道该层已经被遍历完了，这也是一种好办法：</p>
<p> </p>
<p>C++ 解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">void</span> connect(TreeLinkNode *<span style="color: #000000;">root) {
        </span><span style="color: #0000ff;">if</span> (!root) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
        queue</span>&lt;TreeLinkNode*&gt;<span style="color: #000000;"> q;
        q.push(root);
        </span><span style="color: #0000ff;">while</span> (!<span style="color: #000000;">q.empty()) {
            </span><span style="color: #0000ff;">int</span> size =<span style="color: #000000;"> q.size();
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; size; ++<span style="color: #000000;">i) {
                TreeLinkNode </span>*t =<span style="color: #000000;"> q.front(); q.pop();
                </span><span style="color: #0000ff;">if</span> (i &lt; size - <span style="color: #800080;">1</span><span style="color: #000000;">) {
                    t</span>-&gt;next =<span style="color: #000000;"> q.front();
                }
                </span><span style="color: #0000ff;">if</span> (t-&gt;left) q.push(t-&gt;<span style="color: #000000;">left);
                </span><span style="color: #0000ff;">if</span> (t-&gt;right) q.push(t-&gt;<span style="color: #000000;">right);
            }
        }
    }
};</span></pre>
</div>
<p> </p>
<p>上面三种方法虽然叼，但是都不符合题意，题目中要求用O(1)的空间复杂度，所以我们来看下面这种碉堡了的方法。用两个指针start和cur，其中start标记每一层的起始节点，cur用来遍历该层的节点，设计思路之巧妙，不得不服啊：</p>
<p> </p>
<p>C++ 解法四：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">void</span> connect(TreeLinkNode *<span style="color: #000000;">root) {
        </span><span style="color: #0000ff;">if</span> (!root) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
        TreeLinkNode </span>*start = root, *cur =<span style="color: #000000;"> NULL;
        </span><span style="color: #0000ff;">while</span> (start-&gt;<span style="color: #000000;">left) {
            cur </span>=<span style="color: #000000;"> start;
            </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> (cur) {
                cur</span>-&gt;left-&gt;next = cur-&gt;<span style="color: #000000;">right;
                </span><span style="color: #0000ff;">if</span> (cur-&gt;next) cur-&gt;right-&gt;next = cur-&gt;next-&gt;<span style="color: #000000;">left;
                cur </span>= cur-&gt;<span style="color: #000000;">next;
            }
            start </span>= start-&gt;<span style="color: #000000;">left;
        }
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4290148.html" target="_blank">Populating Next Right Pointers in Each Node II</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/2202/a-simple-accepted-solution" target="_blank">https://discuss.leetcode.com/topic/2202/a-simple-accepted-solution</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-02-12 15:07</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4288151" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4288151);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4294105.html" id="cb_post_title_url">[LeetCode] Distinct Subsequences 不同的子序列</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a string S and a string T, count the number of distinct subsequences of T in S.</p>
<p>A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, <code>"ACE"</code> is a subsequence of <code>"ABCDE"</code> while <code>"AEC"</code> is not).</p>
<p>Here is an example:<br/>S = <code>"rabbbit"</code>, T = <code>"rabbit"</code></p>
<p>Return <code>3</code>.</p>
<p> </p>
<p>看到有关字符串的子序列或者配准类的问题，首先应该考虑的就是用动态规划Dynamic Programming来求解，这个应成为条件反射。而所有DP问题的核心就是找出递推公式，想这道题就是递推一个二维的dp数组，下面我们从题目中给的例子来分析，这个二维dp数组应为：</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">  Ø r a b b b i t
Ø </span><span style="color: #0000ff;">1 1 1 1 1 1 1 1</span><span style="color: #000000;">
r </span><span style="color: #008000;">0</span> <span style="color: #ff0000;">1 1</span> <span style="color: #800080;">1</span> <span style="color: #800080;">1</span> <span style="color: #800080;">1</span> <span style="color: #800080;">1</span> <span style="color: #800080;">1</span><span style="color: #000000;">
a </span><span style="color: #008000;">0</span> <span style="color: #800080;">0</span> <span style="color: #ff0000;">1 1</span> <span style="color: #800080;">1</span> <span style="color: #800080;">1</span> <span style="color: #800080;">1</span> <span style="color: #800080;">1</span><span style="color: #000000;">
b </span><span style="color: #008000;">0 </span><span style="color: #800080;">0</span> <span style="color: #800080;">0</span> <span style="color: #ff0000;">1 2</span> <span style="color: #800080;">3</span> <span style="color: #800080;">3</span> <span style="color: #800080;">3</span><span style="color: #000000;">
b </span><span style="color: #008000;">0</span> <span style="color: #800080;">0</span> <span style="color: #800080;">0</span> <span style="color: #800080;">0</span> <span style="color: #ff0000;">1 3</span> <span style="color: #800080;">3</span> <span style="color: #800080;">3</span><span style="color: #000000;">
i </span><span style="color: #008000;">0</span> <span style="color: #800080;">0</span> <span style="color: #800080;">0</span> <span style="color: #800080;">0</span> <span style="color: #800080;">0</span> <span style="color: #ff0000;">0 3</span> <span style="color: #800080;">3</span><span style="color: #000000;">
t </span><span style="color: #008000;">0</span> <span style="color: #800080;">0</span> <span style="color: #800080;">0</span> <span style="color: #800080;">0</span> <span style="color: #800080;">0</span> <span style="color: #800080;">0</span> <span style="color: #ff0000;">0 3 </span></pre>
</div>
<p>首先，若原字符串和子序列都为空时，返回1，因为空串也是空串的一个子序列。若原字符串不为空，而子序列为空，也返回1，因为空串也是任意字符串的一个子序列。而当原字符串为空，子序列不为空时，返回0，因为非空字符串不能当空字符串的子序列。理清这些，二维数组dp的边缘便可以初始化了，下面只要找出递推式，就可以更新整个dp数组了。我们通过观察上面的二维数组可以发现，当更新到dp[i][j]时，dp[i][j] &gt;= dp[i][j - 1] 总是成立，再进一步观察发现，当 T[i - 1] == S[j - 1] 时，dp[i][j] = dp[i][j - 1] + dp[i - 1][j - 1]，若不等， dp[i][j] = dp[i][j - 1]，所以，综合以上，递推式为：</p>
<p>dp[i][j] = dp[i][j - 1] + (T[i - 1] == S[j - 1] ? dp[i - 1][j - 1] : 0)</p>
<p>根据以上分析，可以写出代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> numDistinct(<span style="color: #0000ff;">string</span> S, <span style="color: #0000ff;">string</span><span style="color: #000000;"> T) {
        </span><span style="color: #0000ff;">int</span> dp[T.size() + <span style="color: #800080;">1</span>][S.size() + <span style="color: #800080;">1</span><span style="color: #000000;">];
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt;= S.size(); ++i) dp[<span style="color: #800080;">0</span>][i] = <span style="color: #800080;">1</span><span style="color: #000000;">;    
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt;= T.size(); ++i) dp[i][<span style="color: #800080;">0</span>] = <span style="color: #800080;">0</span><span style="color: #000000;">;    
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt;= T.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">1</span>; j &lt;= S.size(); ++<span style="color: #000000;">j) {
                dp[i][j] </span>= dp[i][j - <span style="color: #800080;">1</span>] + (T[i - <span style="color: #800080;">1</span>] == S[j - <span style="color: #800080;">1</span>] ? dp[i - <span style="color: #800080;">1</span>][j - <span style="color: #800080;">1</span>] : <span style="color: #800080;">0</span><span style="color: #000000;">);
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> dp[T.size()][S.size()];
    }
};</span></pre>
</div>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-02-16 14:50</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4294105" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4294105);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4293853.html" id="cb_post_title_url">[LeetCode] Flatten Binary Tree to Linked List 将二叉树展开成链表</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a binary tree, flatten it to a linked list in-place.</p>
<p>For example,<br/>Given</p>
<pre>         1
        / \
       2   5
      / \   \
     3   4   6
</pre>
<p> </p>
<p><span style="font-size: 14px; line-height: 1.5;">The flattened tree should look like:<br/></span></p>
<pre>   1
    \
     2
      \
       3
        \
         4
          \
           5
            \
             6
</pre>
<div class="spoilers">Hints:
<p>If you notice carefully in the flattened tree, each node's right child points to the next node of a pre-order trave</p>
<p> </p>
</div>
<p><span style="font-size: 14px; line-height: 1.5;">这道题要求把二叉树展开成链表，根据展开后形成的链表的顺序分析出是使用先序遍历，那么只要是数的遍历就有递归和非递归的两种方法来求解，这里我们也用两种方法来求解。首先来看递归版本的，思路是先利用DFS的思路找到最左子节点，然后回到其父节点，把其父节点和右子节点断开，将原左子结点连上父节点的右子节点上，然后再把原右子节点连到新右子节点的右子节点上，然后再回到上一父节点做相同操作。代码如下：</span></p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> Recursion</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">void</span> flatten(TreeNode *<span style="color: #000000;">root) {
        </span><span style="color: #0000ff;">if</span> (!root) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (root-&gt;left) flatten(root-&gt;<span style="color: #000000;">left);
        </span><span style="color: #0000ff;">if</span> (root-&gt;right) flatten(root-&gt;<span style="color: #000000;">right);
        TreeNode </span>*tmp = root-&gt;<span style="color: #000000;">right;
        root</span>-&gt;right = root-&gt;<span style="color: #000000;">left;
        root</span>-&gt;left =<span style="color: #000000;"> NULL;
        </span><span style="color: #0000ff;">while</span> (root-&gt;right) root = root-&gt;<span style="color: #000000;">right;
        root</span>-&gt;right =<span style="color: #000000;"> tmp;
    }
};</span></pre>
</div>
<p> </p>
<p>例如，对于下面的二叉树，上述算法的变换的过程如下：</p>
<div class="cnblogs_code">
<pre>     <span style="color: #800080;">1</span>
    /<span style="color: #000000;"> \
   </span><span style="color: #800080;">2</span>   <span style="color: #800080;">5</span>
  /<span style="color: #000000;"> \   \
 </span><span style="color: #800080;">3</span>   <span style="color: #800080;">4</span>   <span style="color: #800080;">6</span>

     <span style="color: #800080;">1</span>
    /<span style="color: #000000;"> \
   </span><span style="color: #800080;">2</span>   <span style="color: #800080;">5</span><span style="color: #000000;">
    \   \
     </span><span style="color: #ff0000;">3 </span>  <span style="color: #800080;">6</span><span style="color: #000000;"><span style="color: #ff0000;">
      \</span>    
       </span><span style="color: #ff0000;">4</span>

   <span style="color: #800080;">1</span><span style="color: #000000;">
    \
     </span><span style="color: #ff0000;">2
      \
       3
        \
         4</span><span style="color: #000000;">
          \
           </span><span style="color: #800080;">5</span><span style="color: #000000;">
            \
             </span><span style="color: #800080;">6</span></pre>
</div>
<p> </p>
<p>下面我们再来看非迭代版本的实现，这个方法是从根节点开始出发，先检测其左子结点是否存在，如存在则将根节点和其右子节点断开，将左子结点及其后面所有结构一起连到原右子节点的位置，把原右子节点连到元左子结点最后面的右子节点之后。代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> Non-recursion</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">void</span> flatten(TreeNode *<span style="color: #000000;">root) {
        TreeNode </span>*cur =<span style="color: #000000;"> root;
        </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> (cur) {
            </span><span style="color: #0000ff;">if</span> (cur-&gt;<span style="color: #000000;">left) {
                TreeNode </span>*p = cur-&gt;<span style="color: #000000;">left;
                </span><span style="color: #0000ff;">while</span> (p-&gt;right) p = p-&gt;<span style="color: #000000;">right;
                p</span>-&gt;right = cur-&gt;<span style="color: #000000;">right;
                cur</span>-&gt;right = cur-&gt;<span style="color: #000000;">left;
                cur</span>-&gt;left =<span style="color: #000000;"> NULL;
            }
            cur </span>= cur-&gt;<span style="color: #000000;">right;
        }
    }
};</span></pre>
</div>
<p> </p>
<p>例如，对于下面的二叉树，上述算法的变换的过程如下：</p>
<div class="cnblogs_code">
<pre>     <span style="color: #800080;">1</span>
    /<span style="color: #000000;"> \
   </span><span style="color: #800080;">2</span>   <span style="color: #800080;">5</span>
  /<span style="color: #000000;"> \   \
 </span><span style="color: #800080;">3</span>   <span style="color: #800080;">4</span>   <span style="color: #800080;">6</span>

   <span style="color: #800080;">1</span><span style="color: #000000;">
    \
     </span><span style="color: #ff0000;">2
    / \
   3   4</span><span style="color: #000000;">
        \
         </span><span style="color: #800080;">5</span><span style="color: #000000;">
          \
           </span><span style="color: #800080;">6</span>
           
   <span style="color: #800080;">1</span><span style="color: #000000;">
    \
     </span><span style="color: #800080;">2</span><span style="color: #000000;">
      \
       </span><span style="color: #ff0000;">3</span><span style="color: #000000;">
        \
         </span><span style="color: #800080;">4</span><span style="color: #000000;">
          \
           </span><span style="color: #800080;">5</span><span style="color: #000000;">
            \
             </span><span style="color: #800080;">6</span></pre>
</div>
<p> </p>
<p>前序迭代解法如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">void</span> flatten(TreeNode*<span style="color: #000000;"> root) {
        </span><span style="color: #0000ff;">if</span> (!root) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
        stack</span>&lt;TreeNode*&gt;<span style="color: #000000;"> s;
        s.push(root);
        </span><span style="color: #0000ff;">while</span> (!<span style="color: #000000;">s.empty()) {
            TreeNode </span>*t =<span style="color: #000000;"> s.top(); s.pop();
            </span><span style="color: #0000ff;">if</span> (t-&gt;<span style="color: #000000;">left) {
                TreeNode </span>*r = t-&gt;<span style="color: #000000;">left;
                </span><span style="color: #0000ff;">while</span> (r-&gt;right) r = r-&gt;<span style="color: #000000;">right;
                r</span>-&gt;right = t-&gt;<span style="color: #000000;">right;
                t</span>-&gt;right = t-&gt;<span style="color: #000000;">left;
                t</span>-&gt;left =<span style="color: #000000;"> NULL;
            }
            </span><span style="color: #0000ff;">if</span> (t-&gt;right) s.push(t-&gt;<span style="color: #000000;">right);
        }
    }
};</span></pre>
</div>
<p> </p>
<p>此题还可以延伸到用中序，后序，层序的遍历顺序来展开原二叉树，分别又有其对应的递归和非递归的方法，有兴趣的童鞋可以自行实现。</p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/19087/my-recursive-solution-is-easy-and-clean" target="_blank">https://discuss.leetcode.com/topic/19087/my-recursive-solution-is-easy-and-clean</a></p>
<p><a href="https://discuss.leetcode.com/topic/11444/my-short-post-order-traversal-java-solution-for-share" target="_blank">https://discuss.leetcode.com/topic/11444/my-short-post-order-traversal-java-solution-for-share</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-02-16 11:07</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4293853" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4293853);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4042156.html" id="cb_post_title_url">[LeetCode] Path Sum II 二叉树路径之和之二</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a binary tree and a sum, find all root-to-leaf paths where each path's sum equals the given sum.</p>
<p>For example:<br/>Given the below binary tree and <code>sum = 22</code>,</p>
<pre>              5
             / \
            4   8
           /   / \
          11  13  4
         /  \    / \
        7    2  5   1
</pre>
<p>return</p>
<pre>[
   [5,4,11,2],
   [5,8,4,5]
]<br/><br/></pre>
<p>这道二叉树路径之和在之前的基础上又需要找出路径 (可以参见我之前的博客 <a href="http://www.cnblogs.com/grandyang/p/4036961.html" target="_blank">http://www.cnblogs.com/grandyang/p/4036961.html</a>)，但是基本思想都一样，还是需要用深度优先搜索DFS，只不过数据结构相对复杂一点，需要用到二维的vector，而且每当DFS搜索到新节点时，都要保存该节点。而且每当找出一条路径之后，都将这个保存为一维vector的路径保存到最终结果二位vector中。并且，每当DFS搜索到子节点，发现不是路径和时，返回上一个结点时，需要把该节点从一维vector中移除。代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt; &gt; pathSum(TreeNode *root, <span style="color: #0000ff;">int</span><span style="color: #000000;"> sum) {
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;<span style="color: #000000;"> res;
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; <span style="color: #0000ff;">out</span><span style="color: #000000;">;
        helper(root, sum, </span><span style="color: #0000ff;">out</span><span style="color: #000000;">, res);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">void</span> helper(TreeNode* node, <span style="color: #0000ff;">int</span> sum, vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; <span style="color: #0000ff;">out</span>, vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> res) {
        </span><span style="color: #0000ff;">if</span> (!node) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">out</span>.push_back(node-&gt;<span style="color: #000000;">val);
        </span><span style="color: #0000ff;">if</span> (sum == node-&gt;val &amp;&amp; !node-&gt;left &amp;&amp; !node-&gt;<span style="color: #000000;">right) {
            res.push_back(</span><span style="color: #0000ff;">out</span><span style="color: #000000;">);
        }
        helper(node</span>-&gt;left, sum - node-&gt;val, <span style="color: #0000ff;">out</span><span style="color: #000000;">, res);
        helper(node</span>-&gt;right, sum - node-&gt;val, <span style="color: #0000ff;">out</span><span style="color: #000000;">, res);
        </span><span style="color: #0000ff;">out</span><span style="color: #000000;">.pop_back();
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种方法是迭代的写法，用的是中序遍历的顺序，参考之前那道<a href="http://www.cnblogs.com/grandyang/p/4297300.html" target="_blank">Binary Tree Inorder Traversal</a>，中序遍历本来是要用栈来辅助运算的，由于我们要取出路径上的节点值，所以我们用一个vector来代替stack，首先利用while循环找到最左子节点，在找的过程中，把路径中的节点值都加起来，这时候我们取出vector中的尾元素，如果其左右子节点都不存在且当前累加值正好等于sum了，我们将这条路径取出来存入结果res中，下面的部分是和一般的迭代中序写法有所不同的地方，因为如果当前最左节点已经是个叶节点了，我们要转移到其他的节点上时需要把当前的节点值减去，而如果当前最左节点不是叶节点，下面还有一个右子节点，这时候移动指针时就不能减去当前节点值，为了区分这两种情况，我们需要用一个额外指针pre来指向前一个节点，如果右子节点存在且不等于pre，我们直接将指针移到右子节点，反之我们更新pre为cur，cur重置为空，val减去当前节点，s删掉最后一个节点，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt; &gt; pathSum(TreeNode *root, <span style="color: #0000ff;">int</span><span style="color: #000000;"> sum) {
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;<span style="color: #000000;"> res;
        vector</span>&lt;TreeNode*&gt;<span style="color: #000000;"> s;
        TreeNode </span>*cur = root, *pre =<span style="color: #000000;"> NULL;
        </span><span style="color: #0000ff;">int</span> val = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (cur || !<span style="color: #000000;">s.empty()) {
            </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> (cur) {
                s.push_back(cur);
                val </span>+= cur-&gt;<span style="color: #000000;">val;
                cur </span>= cur-&gt;<span style="color: #000000;">left;
            }
            cur </span>=<span style="color: #000000;"> s.back(); 
            </span><span style="color: #0000ff;">if</span> (!cur-&gt;left &amp;&amp; !cur-&gt;right &amp;&amp; val ==<span style="color: #000000;"> sum) {
                vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> v;
                </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto it : s) {
                    v.push_back(it</span>-&gt;<span style="color: #000000;">val);
                }
                res.push_back(v);
            }
            </span><span style="color: #0000ff;">if</span> (cur-&gt;right &amp;&amp; cur-&gt;right != pre) cur = cur-&gt;<span style="color: #000000;">right;
            </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                pre </span>=<span style="color: #000000;"> cur;
                val </span>-= cur-&gt;<span style="color: #000000;">val;
                s.pop_back();
                cur </span>=<span style="color: #000000;"> NULL;
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4036961.html" target="_blank">Path Sum</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/18454/12ms-11-lines-c-solution" target="_blank">https://discuss.leetcode.com/topic/18454/12ms-11-lines-c-solution</a></p>
<p><a href="https://discuss.leetcode.com/topic/39728/c-dfs-17ms-non-recursive-solution" target="_blank">https://discuss.leetcode.com/topic/39728/c-dfs-17ms-non-recursive-solution</a></p>
<p><a href="https://discuss.leetcode.com/topic/19646/accepted-cpp-dfs-solution-only-one-function" target="_blank">https://discuss.leetcode.com/topic/19646/accepted-cpp-dfs-solution-only-one-function</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2014-10-22 06:45</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4042156" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4042156);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4036961.html" id="cb_post_title_url">[LeetCode] Path Sum 二叉树的路径和</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.</p>
<p>For example:<br/>Given the below binary tree and <code>sum = 22</code>,</p>
<pre>              5
             / \
            4   8
           /   / \
          11  13  4
         /  \      \
        7    2      1
</pre>
<p>return true, as there exist a root-to-leaf path <code>5-&gt;4-&gt;11-&gt;2</code> which sum is 22.</p>
<p> </p>
<p>这道求二叉树的路径需要用深度优先算法DFS的思想来遍历每一条完整的路径，也就是利用递归不停找子节点的左右子节点，而调用递归函数的参数只有当前节点和sum值。首先，如果输入的是一个空节点，则直接返回false，如果如果输入的只有一个根节点，则比较当前根节点的值和参数sum值是否相同，若相同，返回true，否则false。 这个条件也是递归的终止条件。下面我们就要开始递归了，由于函数的返回值是Ture/False，我们可以同时两个方向一起递归，中间用或||连接，只要有一个是True，整个结果就是True。递归左右节点时，这时候的sum值应该是原sum值减去当前节点的值。代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">/*</span><span style="color: #008000;">*
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> hasPathSum(TreeNode *root, <span style="color: #0000ff;">int</span><span style="color: #000000;"> sum) {
        </span><span style="color: #0000ff;">if</span> (root == NULL) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL &amp;&amp; root-&gt;val == sum ) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span> hasPathSum(root-&gt;left, sum - root-&gt;val) || hasPathSum(root-&gt;right, sum - root-&gt;<span style="color: #000000;">val);
    }
};</span></pre>
</div>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2014-10-20 13:08</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4036961" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4036961);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4042168.html" id="cb_post_title_url">[LeetCode] Minimum Depth of Binary Tree 二叉树的最小深度</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a binary tree, find its minimum depth.</p>
<p>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p>
<p> </p>
<p>二叉树的经典问题之最小深度问题就是就最短路径的节点个数，还是用深度优先搜索DFS来完成，万能的递归啊。。。请看代码：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">/*</span><span style="color: #008000;">*
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> minDepth(TreeNode *<span style="color: #000000;">root) {
        </span><span style="color: #0000ff;">if</span> (root == NULL) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL) <span style="color: #0000ff;">return</span> <span style="color: #800080;">1</span><span style="color: #000000;">;
        
        </span><span style="color: #0000ff;">if</span> (root-&gt;left == NULL) <span style="color: #0000ff;">return</span> minDepth(root-&gt;right) + <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (root-&gt;right == NULL) <span style="color: #0000ff;">return</span> minDepth(root-&gt;left) + <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">return</span> <span style="color: #800080;">1</span> + min(minDepth(root-&gt;left), minDepth(root-&gt;<span style="color: #000000;">right));
    }
    
};</span></pre>
</div>
<p> </p>
<p>求二叉树的最大深度可以参见我的博文：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4051348.html" target="_blank">http://www.cnblogs.com/grandyang/p/4051348.html</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2014-10-22 07:27</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4042168" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4042168);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4045660.html" id="cb_post_title_url">[LeetCode] Balanced Binary Tree 平衡二叉树</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="content__1c40">
<p>Given a binary tree, determine if it is height-balanced.</p>
<p>For this problem, a height-balanced binary tree is defined as:</p>
<blockquote>
<p>a binary tree in which the depth of the two subtrees of <em>every</em>node never differ by more than 1.</p>
</blockquote>
<p>Example 1:</p>
<p>Given the following tree <code>[3,9,20,null,null,15,7]</code>:</p>
<pre>    3
   / \
  9  20
    /  \
   15   7</pre>
<p>Return true.<br/><br/>Example 2:</p>
<p>Given the following tree <code>[1,2,2,3,3,null,null,4,4]</code>:</p>
<pre>       1
      / \
     2   2
    / \
   3   3
  / \
 4   4
</pre>
<p>Return false.</p>
</div>
<div class="header__2cgQ"> </div>
<p>求二叉树是否平衡，根据题目中的定义，高度平衡二叉树是每一个结点的两个子树的深度差不能超过1，那么我们肯定需要一个求各个点深度的函数，然后对每个节点的两个子树来比较深度差，时间复杂度为O(NlgN)，代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> isBalanced(TreeNode *<span style="color: #000000;">root) {
        </span><span style="color: #0000ff;">if</span> (!root) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (abs(getDepth(root-&gt;left) - getDepth(root-&gt;right)) &gt; <span style="color: #800080;">1</span>) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span> isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;<span style="color: #000000;">right);    
    }
    </span><span style="color: #0000ff;">int</span> getDepth(TreeNode *<span style="color: #000000;">root) {
        </span><span style="color: #0000ff;">if</span> (!root) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">1</span> + max(getDepth(root-&gt;left), getDepth(root-&gt;<span style="color: #000000;">right));
    }
};</span></pre>
</div>
<p> </p>
<p>上面那个方法正确但不是很高效，因为每一个点都会被上面的点计算深度时访问一次，我们可以进行优化。方法是如果我们发现子树不平衡，则不计算具体的深度，而是直接返回-1。那么优化后的方法为：对于每一个节点，我们通过checkDepth方法递归获得左右子树的深度，如果子树是平衡的，则返回真实的深度，若不平衡，直接返回-1，此方法时间复杂度O(N)，空间复杂度O(H)，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:    
    </span><span style="color: #0000ff;">bool</span> isBalanced(TreeNode *<span style="color: #000000;">root) {
        </span><span style="color: #0000ff;">if</span> (checkDepth(root) == -<span style="color: #800080;">1</span>) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
    </span><span style="color: #0000ff;">int</span> checkDepth(TreeNode *<span style="color: #000000;">root) {
        </span><span style="color: #0000ff;">if</span> (!root) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> left = checkDepth(root-&gt;<span style="color: #000000;">left);
        </span><span style="color: #0000ff;">if</span> (left == -<span style="color: #800080;">1</span>) <span style="color: #0000ff;">return</span> -<span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> right = checkDepth(root-&gt;<span style="color: #000000;">right);
        </span><span style="color: #0000ff;">if</span> (right == -<span style="color: #800080;">1</span>) <span style="color: #0000ff;">return</span> -<span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> diff = abs(left -<span style="color: #000000;"> right);
        </span><span style="color: #0000ff;">if</span> (diff &gt; <span style="color: #800080;">1</span>) <span style="color: #0000ff;">return</span> -<span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">return</span> <span style="color: #800080;">1</span> +<span style="color: #000000;"> max(left, right);
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4051348.html" target="_blank">Maximum Depth of Binary Tree</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2014-10-23 13:59</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4045660" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4045660);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4295618.html" id="cb_post_title_url">[LeetCode]  Convert Sorted List to Binary Search Tree 将有序链表转为二叉搜索树</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.</p>
<p> </p>
<p>这道题是要求把有序链表转为二叉搜索树，和之前那道<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4295245.html" id="homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0">Convert Sorted Array to Binary Search Tree 将有序数组转为二叉搜索树</a>思路完全一样，只不过是操作的数据类型有所差别，一个是数组，一个是链表。数组方便就方便在可以通过index直接访问任意一个元素，而链表不行。由于二分查找法每次需要找到中点，而链表的查找中间点可以通过快慢指针来操作，可参见之前的两篇博客<a class="entrylistItemTitle" href="http://www.cnblogs.com/grandyang/p/4254860.html" id="CategoryEntryList1_EntryStoryList_ctl00_Entries_TitleUrl_20">Reorder List 链表重排序</a>和<a class="link-post-title" href="http://www.cnblogs.com/grandyang/p/4137302.html" id="link_post_title">Linked List Cycle II 单链表中的环之二</a>有关快慢指针的应用。找到中点后，要以中点的值建立一个数的根节点，然后需要把原链表断开，分为前后两个链表，都不能包含原中节点，然后再分别对这两个链表递归调用原函数，分别连上左右子节点即可。代码如下：<br/><br/></p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">/*</span><span style="color: #008000;">*
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 </span><span style="color: #008000;">*/</span>
<span style="color: #008000;">/*</span><span style="color: #008000;">*
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    TreeNode </span>*sortedListToBST(ListNode *<span style="color: #000000;">head) {
        </span><span style="color: #0000ff;">if</span> (!head) <span style="color: #0000ff;">return</span><span style="color: #000000;"> NULL;
        </span><span style="color: #0000ff;">if</span> (!head-&gt;next) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span> TreeNode(head-&gt;<span style="color: #000000;">val);
        ListNode </span>*slow =<span style="color: #000000;"> head;
        ListNode </span>*fast =<span style="color: #000000;"> head;
        ListNode </span>*last =<span style="color: #000000;"> slow;
        </span><span style="color: #0000ff;">while</span> (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;<span style="color: #000000;">next) {
            last </span>=<span style="color: #000000;"> slow;
            slow </span>= slow-&gt;<span style="color: #000000;">next;
            fast </span>= fast-&gt;next-&gt;<span style="color: #000000;">next;
        }
        fast </span>= slow-&gt;<span style="color: #000000;">next;
        last</span>-&gt;next =<span style="color: #000000;"> NULL;
        TreeNode </span>*cur = <span style="color: #0000ff;">new</span> TreeNode(slow-&gt;<span style="color: #000000;">val);
        </span><span style="color: #0000ff;">if</span> (head != slow) cur-&gt;left =<span style="color: #000000;"> sortedListToBST(head);
        cur</span>-&gt;right =<span style="color: #000000;"> sortedListToBST(fast);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> cur;
    }
};</span></pre>
</div>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-02-18 07:54</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4295618" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4295618);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4295245.html" id="cb_post_title_url">[LeetCode] Convert Sorted Array to Binary Search Tree 将有序数组转为二叉搜索树</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given an array where elements are sorted in ascending order, convert it to a height balanced BST.</p>
<p> </p>
<p>这道题是要将有序数组转为二叉搜索树，所谓<a href="http://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%B0%8B%E6%A8%B9" target="_blank">二叉搜索树</a>，是一种始终满足左&lt;根&lt;右的特性，如果将二叉搜索树按中序遍历的话，得到的就是一个有序数组了。那么反过来，我们可以得知，根节点应该是有序数组的中间点，从中间点分开为左右两个有序数组，在分别找出其中间点作为原中间点的左右两个子节点，这不就是是二分查找法的核心思想么。所以这道题考的就是二分查找法，代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">/*</span><span style="color: #008000;">*
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    TreeNode </span>*sortedArrayToBST(vector&lt;<span style="color: #0000ff;">int</span>&gt; &amp;<span style="color: #000000;">num) {
        </span><span style="color: #0000ff;">return</span> sortedArrayToBST(num, <span style="color: #800080;">0</span> , num.size() - <span style="color: #800080;">1</span><span style="color: #000000;">);
    }
    TreeNode </span>*sortedArrayToBST(vector&lt;<span style="color: #0000ff;">int</span>&gt; &amp;num, <span style="color: #0000ff;">int</span> left, <span style="color: #0000ff;">int</span><span style="color: #000000;"> right) {
        </span><span style="color: #0000ff;">if</span> (left &gt; right) <span style="color: #0000ff;">return</span><span style="color: #000000;"> NULL;
        </span><span style="color: #0000ff;">int</span> mid = (left + right) / <span style="color: #800080;">2</span><span style="color: #000000;">;
        TreeNode </span>*cur = <span style="color: #0000ff;">new</span><span style="color: #000000;"> TreeNode(num[mid]);
        cur</span>-&gt;left = sortedArrayToBST(num, left, mid - <span style="color: #800080;">1</span><span style="color: #000000;">);
        cur</span>-&gt;right = sortedArrayToBST(num, mid + <span style="color: #800080;">1</span><span style="color: #000000;">, right);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> cur;
    }
};</span></pre>
</div>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-02-17 14:45</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4295245" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4295245);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4051326.html" id="cb_post_title_url">[LeetCode] Binary Tree Level Order Traversal II 二叉树层序遍历之二</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a binary tree, return the <em>bottom-up level order</em> traversal of its nodes' values. (ie, from left to right, level by level from leaf to root).</p>
<p>For example:<br/>Given binary tree <code>{3,9,20,#,#,15,7}</code>,</p>
<pre>    3
   / \
  9  20
    /  \
   15   7
</pre>
<p> </p>
<p>return its bottom-up level order traversal as:</p>
<pre>[
  [15,7],
  [9,20],
  [3]
]<br/><br/></pre>
<p>从底部层序遍历其实还是从顶部开始遍历，只不过最后存储的方式有所改变，可以参见我之前的博文<a href="http://www.cnblogs.com/grandyang/p/4051321.html" target="_blank"> http://www.cnblogs.com/grandyang/p/4051321.html</a>。 代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> Iterative</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt; &gt; levelOrderBottom(TreeNode *<span style="color: #000000;">root) {
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt; &gt;<span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">if</span> (root == NULL) <span style="color: #0000ff;">return</span><span style="color: #000000;"> res;

        queue</span>&lt;TreeNode*&gt;<span style="color: #000000;"> q;
        q.push(root);
        </span><span style="color: #0000ff;">while</span> (!<span style="color: #000000;">q.empty()) {
            vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> oneLevel;
            </span><span style="color: #0000ff;">int</span> size =<span style="color: #000000;"> q.size();
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; size; ++<span style="color: #000000;">i) {
                TreeNode </span>*node =<span style="color: #000000;"> q.front();
                q.pop();
                oneLevel.push_back(node</span>-&gt;<span style="color: #000000;">val);
                </span><span style="color: #0000ff;">if</span> (node-&gt;left) q.push(node-&gt;<span style="color: #000000;">left);
                </span><span style="color: #0000ff;">if</span> (node-&gt;right) q.push(node-&gt;<span style="color: #000000;">right);
            }
            res.insert(res.begin(), oneLevel);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>下面我们来看递归的解法，核心就在于我们需要一个二维数组，和一个变量level，当level递归到上一层的个数，我们新建一个空层，继续往里面加数字，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> Recurive</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; levelOrderBottom(TreeNode*<span style="color: #000000;"> root) {
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt; &gt;<span style="color: #000000;"> res;
        levelorder(root, </span><span style="color: #800080;">0</span><span style="color: #000000;">, res);
        </span><span style="color: #0000ff;">return</span> vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt; &gt;<span style="color: #000000;"> (res.rbegin(), res.rend());
    }
    </span><span style="color: #0000ff;">void</span> levelorder(TreeNode *root, <span style="color: #0000ff;">int</span> level, vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt; &gt; &amp;<span style="color: #000000;">res) {
        </span><span style="color: #0000ff;">if</span> (!root) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (res.size() ==<span style="color: #000000;"> level) res.push_back({});
        res[level].push_back(root</span>-&gt;<span style="color: #000000;">val);
        </span><span style="color: #0000ff;">if</span> (root-&gt;left) levelorder(root-&gt;left, level + <span style="color: #800080;">1</span><span style="color: #000000;">, res);
        </span><span style="color: #0000ff;">if</span> (root-&gt;right) levelorder(root-&gt;right, level + <span style="color: #800080;">1</span><span style="color: #000000;">, res);
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4297009.html" target="_blank">Binary Tree Zigzag Level Order Traversal</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4051321.html" target="_blank">Binary Tree Level Order Traversal</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2014-10-26 05:23</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4051326" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4051326);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4296193.html" id="cb_post_title_url">[LeetCode] Construct Binary Tree from Inorder and Postorder Traversal 由中序和后序遍历建立二叉树</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given inorder and postorder traversal of a tree, construct the binary tree.</p>
<p><strong>Note:</strong><br/>
You may assume that duplicates do not exist in the tree.
</p>
<p> </p>
<p>这道题要求从中序和后序遍历的结果来重建原二叉树，我们知道中序的遍历顺序是左-根-右，后序的顺序是左-右-根，对于这种树的重建一般都是采用递归来做，可参见我之前的一篇博客<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4295245.html" id="cb_post_title_url">Convert Sorted Array to Binary Search Tree 将有序数组转为二叉搜索树</a>。针对这道题，由于后序的顺序的最后一个肯定是根，所以原二叉树的根节点可以知道，题目中给了一个很关键的条件就是树中没有相同元素，有了这个条件我们就可以在中序遍历中也定位出根节点的位置，并以根节点的位置将中序遍历拆分为左右两个部分，分别对其递归调用原函数。代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">/*</span><span style="color: #008000;">*
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    TreeNode </span>*buildTree(vector&lt;<span style="color: #0000ff;">int</span>&gt; &amp;inorder, vector&lt;<span style="color: #0000ff;">int</span>&gt; &amp;<span style="color: #000000;">postorder) {
        </span><span style="color: #0000ff;">return</span> buildTree(inorder, <span style="color: #800080;">0</span>, inorder.size() - <span style="color: #800080;">1</span>, postorder, <span style="color: #800080;">0</span>, postorder.size() - <span style="color: #800080;">1</span><span style="color: #000000;">);
    }
    TreeNode </span>*buildTree(vector&lt;<span style="color: #0000ff;">int</span>&gt; &amp;inorder, <span style="color: #0000ff;">int</span> iLeft, <span style="color: #0000ff;">int</span> iRight, vector&lt;<span style="color: #0000ff;">int</span>&gt; &amp;postorder, <span style="color: #0000ff;">int</span> pLeft, <span style="color: #0000ff;">int</span><span style="color: #000000;"> pRight) {
        </span><span style="color: #0000ff;">if</span> (iLeft &gt; iRight || pLeft &gt; pRight) <span style="color: #0000ff;">return</span><span style="color: #000000;"> NULL;
        TreeNode </span>*cur = <span style="color: #0000ff;">new</span><span style="color: #000000;"> TreeNode(postorder[pRight]);
        </span><span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (i = iLeft; i &lt; inorder.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (inorder[i] == cur-&gt;val) <span style="color: #0000ff;">break</span><span style="color: #000000;">;
        }
        cur</span>-&gt;left = buildTree(inorder, iLeft, i - <span style="color: #800080;">1</span>, postorder, pLeft, pLeft + i - iLeft - <span style="color: #800080;">1</span><span style="color: #000000;">);
        cur</span>-&gt;right = buildTree(inorder, i + <span style="color: #800080;">1</span>, iRight, postorder, pLeft + i - iLeft, pRight - <span style="color: #800080;">1</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> cur;
    }
};</span></pre>
</div>
<p>上述代码中需要小心的地方就是递归是postorder的左右index很容易写错，比如 pLeft + i - iLeft - 1, 这个又长又不好记，首先我们要记住 i - iLeft 是计算inorder中根节点位置和左边起始点的距离，然后再加上postorder左边起始点然后再减1。我们可以这样分析，如果根节点就是左边起始点的话，那么拆分的话左边序列应该为空集，此时i - iLeft 为0， pLeft + 0 - 1 &lt; pLeft, 那么再递归调用时就会返回NULL, 成立。如果根节点是左边起始点紧跟的一个，那么i - iLeft 为1， pLeft + 1 - 1 = pLeft，再递归调用时还会生成一个节点，就是pLeft位置上的节点，为原二叉树的一个叶节点。</p>
<p>我们下面来看一个例子, 某一二叉树的中序和后序遍历分别为：</p>
<p>Inorder:　　 　11　　4　　5　　13　　8　　9</p>
<p>Postorder:　　11　　4　　13　　9　　8　　5　　</p>
<p> </p>
<p>11　　4　　<span style="color: #ff0000;">5</span>　　13　　8　　9　　　　　　=&gt;　　　　　　　　　 5</p>
<p>11　　4　　13　　9　　8　　<span style="color: #ff0000;">5　　　　　　　　　　　　　　　<span style="color: #000000;">　/　　\</span></span></p>
<p> </p>
<p><span style="color: #000000;">11　　<span style="color: #ff0000;">4</span>　　 　　13　　 <span style="color: #ff0000;">8</span>　　9　　　　　　=&gt;　　　　　　　　　5</span></p>
<p><span style="color: #000000;">11　　<span style="color: #ff0000;">4</span>　　　　 13　　9　　<span style="color: #ff0000;">8</span>　　 　　　　　　　　　　　　　  /　　\</span></p>
<p>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　4　　　8</p>
<p> </p>
<p><span style="color: #000000;"><span style="color: #ff0000;">11</span>　　　　 　　<span style="color: #ff0000;">13</span>　　　　<span style="color: #ff0000;">9</span>　　　　　　　　=&gt;　　　　　　　　　5</span></p>
<p><span style="color: #000000;"><span style="color: #ff0000;">11</span>　　　　　　 <span style="color: #ff0000;">13</span>　　　　<span style="color: #ff0000;">9</span>　　　　 　　　　　　　　　　　　   /　　\</span></p>
<p>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　4　　　8</p>
<p>　　　　　　　　　　　　　　　　　　　　　　　　　　　　/　　　 /     \</p>
<p>　　　　　　　　　　　　　　　　　　　　　　　　　　　11　　  13　　  9</p>
<p> </p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p>
<p> </p>
<p>　　</p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-02-19 17:29</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4296193" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4296193);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4296500.html" id="cb_post_title_url">[LeetCode] Construct Binary Tree from Preorder and Inorder Traversal  由先序和中序遍历建立二叉树</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given preorder and inorder traversal of a tree, construct the binary tree.</p>
<p>Note:<br/>You may assume that duplicates do not exist in the tree.</p>
<p> </p>
<p>这道题要求用先序和中序遍历来建立二叉树，跟之前那道<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4296193.html" id="homepage1_HomePageDays_DaysList_ctl01_DayList_TitleUrl_0">Construct Binary Tree from Inorder and Postorder Traversal 由中序和后序遍历建立二叉树</a>原理基本相同，针对这道题，由于先序的顺序的第一个肯定是根，所以原二叉树的根节点可以知道，题目中给了一个很关键的条件就是树中没有相同元素，有了这个条件我们就可以在中序遍历中也定位出根节点的位置，并以根节点的位置将中序遍历拆分为左右两个部分，分别对其递归调用原函数。代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">/*</span><span style="color: #008000;">*
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    TreeNode </span>*buildTree(vector&lt;<span style="color: #0000ff;">int</span>&gt; &amp;preorder, vector&lt;<span style="color: #0000ff;">int</span>&gt; &amp;<span style="color: #000000;">inorder) {
        </span><span style="color: #0000ff;">return</span> buildTree(preorder, <span style="color: #800080;">0</span>, preorder.size() - <span style="color: #800080;">1</span>, inorder, <span style="color: #800080;">0</span>, inorder.size() - <span style="color: #800080;">1</span><span style="color: #000000;">);
    }
    TreeNode </span>*buildTree(vector&lt;<span style="color: #0000ff;">int</span>&gt; &amp;preorder, <span style="color: #0000ff;">int</span> pLeft, <span style="color: #0000ff;">int</span> pRight, vector&lt;<span style="color: #0000ff;">int</span>&gt; &amp;inorder, <span style="color: #0000ff;">int</span> iLeft, <span style="color: #0000ff;">int</span><span style="color: #000000;"> iRight) {
        </span><span style="color: #0000ff;">if</span> (pLeft &gt; pRight || iLeft &gt; iRight) <span style="color: #0000ff;">return</span><span style="color: #000000;"> NULL;
        </span><span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (i = iLeft; i &lt;= iRight; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (preorder[pLeft] == inorder[i]) <span style="color: #0000ff;">break</span><span style="color: #000000;">;
        }
        TreeNode </span>*cur = <span style="color: #0000ff;">new</span><span style="color: #000000;"> TreeNode(preorder[pLeft]);
        cur</span>-&gt;left = buildTree(preorder, pLeft + <span style="color: #800080;">1</span>, pLeft + i - iLeft, inorder, iLeft, i - <span style="color: #800080;">1</span><span style="color: #000000;">);
        cur</span>-&gt;right = buildTree(preorder, pLeft + i - iLeft + <span style="color: #800080;">1</span>, pRight, inorder, i + <span style="color: #800080;">1</span><span style="color: #000000;">, iRight);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> cur;
    }
};</span></pre>
</div>
<p> </p>
<p>我们下面来看一个例子, 某一二叉树的中序和后序遍历分别为：</p>
<p>Preorder:　  　5　　4　　11　　8　　13　　9</p>
<p>Inorder:　　 　11　　4　　5　　13　　8　　9</p>
<p> </p>
<p><span style="color: #ff0000;">5</span>　　4　　11　　8　　13　　9　　　　　　=&gt;　　　　　　　　　 5</p>
<p>11　　4　　<span style="color: #ff0000;">5</span>　　13　　8　　9　　　　　　　　　　　　　　　　/　　\</p>
<p> </p>
<p><span style="color: #ff0000;">4</span>　　11　　 　　<span style="color: #ff0000;">8</span>　　 13　　9　　　　　　=&gt;　　　　　　　　　5</p>
<p>11　　<span style="color: #ff0000;">4</span>　　　　 13　　<span style="color: #ff0000;">8</span>　　9　　 　　　　　　　　　　　　　  /　　\</p>
<p>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　4　　　8</p>
<p> </p>
<p><span style="color: #ff0000;">11　　　　 　　13　　　　9</span>　　　　　　　　=&gt;　　　　　　　　　5</p>
<p><span style="color: #ff0000;">11　　　　　　 13　　　　9</span>　　　　 　　　　　　　　　　　　   /　　\</p>
<p>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　4　　　8</p>
<p>　　　　　　　　　　　　　　　　　　　　　　　　　　　　/　　　 /     \</p>
<p>　　　　　　　　　　　　　　　　　　　　　　　　　　　11　　  13　　  9</p>
<p> </p>
<p>做完这道题后，大多人可能会有个疑问，怎么没有由先序和后序遍历建立二叉树呢，这是因为先序和后序遍历不能唯一的确定一个二叉树，比如下面五棵树：</p>
<p>    1　　　　　　preorder:　　  1　　2　　3<br/>   / \　　　　　  inorder:　　     <span style="color: #ff0000;">2　　1　　3</span><br/> 2    3　　  　　 postorder:　　 2　　3　　1</p>
<p> </p>
<p>       1   　　　　preorder:　　   1　　2　　3<br/>      / 　　　　　 inorder:　　     <span style="color: #ff0000;">3　　2　　1</span><br/>    2 　　　　     postorder: 　　3　　2　　1<br/>   /<br/> 3</p>
<p> </p>
<p>       1　　　　    preorder:　　  1　　2　　3<br/>      / 　　　　　  inorder:　　    <span style="color: #ff0000;">2　　3　　1</span><br/>    2 　　　　　　postorder:　　3　　2　　1<br/>      \<br/>       3</p>
<p> </p>
<p>       1　　　　     preorder:　　  1　　2　　3<br/>         \ 　　　　   inorder:　　    <span style="color: #ff0000;">1　　3　　2</span><br/>          2 　　　　 postorder:　　3　　2　　1<br/>         /<br/>       3</p>
<p> </p>
<p>       1　　　　     preorder:　　  1　　2　　3<br/>         \ 　　　　　inorder:　　    <span style="color: #ff0000;">1　　2　　3</span><br/>          2 　　　　 postorder:　　3　　2　　1<br/>            \<br/>		          　　　　3</p>
<p> </p>
<p> 从上面我们可以看出，对于先序遍历都为1 2 3的五棵二叉树，它们的中序遍历都不相同，而它们的后序遍历却有相同的，所以只有和中序遍历一起才能唯一的确定一棵二叉树。</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p>
<p> </p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-02-20 13:52</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4296500" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4296500);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4051348.html" id="cb_post_title_url">[LeetCode] Maximum Depth of Binary Tree 二叉树的最大深度</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a binary tree, find its maximum depth.</p>
<p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>
<p>Note: A leaf is a node with no children.</p>
<p>Example:</p>
<p>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p>
<pre>    3
   / \
  9  20
    /  \
   15   7</pre>
<p>return its depth = 3.</p>
<p> </p>
<p>求二叉树的最大深度问题用到深度优先搜索DFS，递归的完美应用，跟求二叉树的最小深度问题原理相同。代码如下：</p>
<p> </p>
<p>C++ 解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> maxDepth(TreeNode*<span style="color: #000000;"> root) {
        </span><span style="color: #0000ff;">if</span> (!root) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">1</span> + max(maxDepth(root-&gt;left), maxDepth(root-&gt;<span style="color: #000000;">right));
    }
};</span></pre>
</div>
<p> </p>
<p>Java 解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> maxDepth(TreeNode root) {
        </span><span style="color: #0000ff;">return</span> root == <span style="color: #0000ff;">null</span> ? 0 : (1 +<span style="color: #000000;"> Math.max(maxDepth(root.left), maxDepth(root.right)));
    }
}</span></pre>
</div>
<p> </p>
<p>我们也可以使用层序遍历二叉树，然后计数总层数，即为二叉树的最大深度，参见代码如下：</p>
<p> </p>
<p>C++ 解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> maxDepth(TreeNode*<span style="color: #000000;"> root) {
        </span><span style="color: #0000ff;">if</span> (!root) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        queue</span>&lt;TreeNode*&gt;<span style="color: #000000;"> q;
        q.push(root);
        </span><span style="color: #0000ff;">while</span> (!<span style="color: #000000;">q.empty()) {
            </span>++<span style="color: #000000;">res;
            </span><span style="color: #0000ff;">int</span> n =<span style="color: #000000;"> q.size();
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
                TreeNode </span>*t =<span style="color: #000000;"> q.front(); q.pop();
                </span><span style="color: #0000ff;">if</span> (t-&gt;left) q.push(t-&gt;<span style="color: #000000;">left);
                </span><span style="color: #0000ff;">if</span> (t-&gt;right) q.push(t-&gt;<span style="color: #000000;">right);
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>Java 解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> maxDepth(TreeNode root) {
        </span><span style="color: #0000ff;">if</span> (root == <span style="color: #0000ff;">null</span>) <span style="color: #0000ff;">return</span> 0<span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> res = 0<span style="color: #000000;">;
        Queue</span>&lt;TreeNode&gt; q = <span style="color: #0000ff;">new</span> LinkedList&lt;&gt;<span style="color: #000000;">();
        q.offer(root);
        </span><span style="color: #0000ff;">while</span> (!<span style="color: #000000;">q.isEmpty()) {
            </span>++<span style="color: #000000;">res;
            </span><span style="color: #0000ff;">int</span> n =<span style="color: #000000;"> q.size();
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = 0; i &lt; n; ++<span style="color: #000000;">i) {
                TreeNode t </span>=<span style="color: #000000;"> q.poll();
                </span><span style="color: #0000ff;">if</span> (t.left != <span style="color: #0000ff;">null</span><span style="color: #000000;">) q.offer(t.left);
                </span><span style="color: #0000ff;">if</span> (t.right != <span style="color: #0000ff;">null</span><span style="color: #000000;">) q.offer(t.right);
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
}</span></pre>
</div>
<p> </p>
<p>求二叉树的最小深度可以参见我的博文：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4042168.html" target="_blank">http://www.cnblogs.com/grandyang/p/4042168.html</a></p>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4045660.html" target="_blank">Balanced Binary Tree</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4042168.html" target="_blank">Minimum Depth of Binary Tree</a></p>
<p><a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/9873496.html" id="homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0">Maximum Depth of N-ary Tree</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/10317/my-code-of-c-depth-first-search-and-breadth-first-search" target="_blank">https://discuss.leetcode.com/topic/10317/my-code-of-c-depth-first-search-and-breadth-first-search</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2014-10-26 07:32</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4051348" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4051348);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4297009.html" id="cb_post_title_url">[LeetCode] Binary Tree Zigzag Level Order Traversal  二叉树的之字形层序遍历</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a binary tree, return the <em>zigzag level order</em> traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between).</p>
<p>For example:<br/>Given binary tree <code>{3,9,20,#,#,15,7}</code>,</p>
<pre>    3
   / \
  9  20
    /  \
   15   7
</pre>
<p> </p>
<p>return its zigzag level order traversal as:</p>
<pre>[
  [3],
  [20,9],
  [15,7]
]
</pre>
<p> </p>
<p class="showspoilers"> </p>
<p class="showspoilers">这道二叉树的之字形层序遍历是之前那道<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4051321.html" id="cb_post_title_url">[LeetCode] Binary Tree Level Order Traversal 二叉树层序遍历</a>的变形，不同之处在于一行是从左到右遍历，下一行是从右往左遍历，交叉往返的之字形的层序遍历。根据其特点我们用到栈的后进先出的特点，这道题我们维护两个栈，相邻两行分别存到两个栈中，进栈的顺序也不相同，一个栈是先进左子结点然后右子节点，另一个栈是先进右子节点然后左子结点，这样出栈的顺序就是我们想要的之字形了，代码如下：</p>
<p class="showspoilers"> </p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">/*</span><span style="color: #008000;">*
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt; &gt; zigzagLevelOrder(TreeNode *<span style="color: #000000;">root) {
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt; &gt;<span style="color: #000000;">res;
        </span><span style="color: #0000ff;">if</span> (!root) <span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
        stack</span>&lt;TreeNode*&gt;<span style="color: #000000;"> s1;
        stack</span>&lt;TreeNode*&gt;<span style="color: #000000;"> s2;
        s1.push(root);
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; <span style="color: #0000ff;">out</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (!s1.empty() || !<span style="color: #000000;">s2.empty()) {
            </span><span style="color: #0000ff;">while</span> (!<span style="color: #000000;">s1.empty()) {
                TreeNode </span>*cur =<span style="color: #000000;"> s1.top();
                s1.pop();
                </span><span style="color: #0000ff;">out</span>.push_back(cur-&gt;<span style="color: #000000;">val);
                </span><span style="color: #0000ff;">if</span> (cur-&gt;left) s2.push(cur-&gt;<span style="color: #000000;">left);
                </span><span style="color: #0000ff;">if</span> (cur-&gt;right) s2.push(cur-&gt;<span style="color: #000000;">right);
            } 
            </span><span style="color: #0000ff;">if</span> (!<span style="color: #0000ff;">out</span>.empty()) res.push_back(<span style="color: #0000ff;">out</span><span style="color: #000000;">);
            </span><span style="color: #0000ff;">out</span><span style="color: #000000;">.clear();
            </span><span style="color: #0000ff;">while</span> (!<span style="color: #000000;">s2.empty()) {
                TreeNode </span>*cur =<span style="color: #000000;"> s2.top();
                s2.pop();
                </span><span style="color: #0000ff;">out</span>.push_back(cur-&gt;<span style="color: #000000;">val);
                </span><span style="color: #0000ff;">if</span> (cur-&gt;right) s1.push(cur-&gt;<span style="color: #000000;">right);
                </span><span style="color: #0000ff;">if</span> (cur-&gt;left) s1.push(cur-&gt;<span style="color: #000000;">left);
            }
            </span><span style="color: #0000ff;">if</span> (!<span style="color: #0000ff;">out</span>.empty()) res.push_back(<span style="color: #0000ff;">out</span><span style="color: #000000;">);
            </span><span style="color: #0000ff;">out</span><span style="color: #000000;">.clear();
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p class="showspoilers">比如对于题干中的那个例子：</p>
<pre>    3
   / \
  9  20
    /  \
   15   7</pre>
<p class="showspoilers">我们来看每一层两个栈s1, s2的情况：</p>
<p class="showspoilers">s1:　　3</p>
<p class="showspoilers">s2:</p>
<p class="showspoilers"> </p>
<p class="showspoilers">s1:　　</p>
<p class="showspoilers">s2:　　9　　20</p>
<p class="showspoilers"> </p>
<p class="showspoilers">s1:　　7　　15</p>
<p class="showspoilers">s2: </p>
<p class="showspoilers"> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-02-21 14:55</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4297009" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4297009);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4051321.html" id="cb_post_title_url">[LeetCode] Binary Tree Level Order Traversal 二叉树层序遍历</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a binary tree, return the <em>level order</em> traversal of its nodes' values. (ie, from left to right, level by level).</p>
<p>For example:<br/>Given binary tree <code>{3,9,20,#,#,15,7}</code>,</p>
<pre>    3
   / \
  9  20
    /  \
   15   7
</pre>
<p> </p>
<p>return its level order traversal as:</p>
<pre>[
  [3],
  [9,20],
  [15,7]
]<br/><br/></pre>
<p>层序遍历二叉树是典型的广度优先搜索BFS的应用，但是这里稍微复杂一点的是，我们要把各个层的数分开，存到一个二维向量里面，大体思路还是基本相同的，建立一个queue，然后先把根节点放进去，这时候找根节点的左右两个子节点，这时候去掉根节点，此时queue里的元素就是下一层的所有节点，用一个for循环遍历它们，然后存到一个一维向量里，遍历完之后再把这个一维向量存到二维向量里，以此类推，可以完成层序遍历。代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> Iterative</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt; &gt; levelOrder(TreeNode *<span style="color: #000000;">root) {
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt; &gt;<span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">if</span> (root == NULL) <span style="color: #0000ff;">return</span><span style="color: #000000;"> res;

        queue</span>&lt;TreeNode*&gt;<span style="color: #000000;"> q;
        q.push(root);
        </span><span style="color: #0000ff;">while</span> (!<span style="color: #000000;">q.empty()) {
            vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> oneLevel;
            </span><span style="color: #0000ff;">int</span> size =<span style="color: #000000;"> q.size();
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; size; ++<span style="color: #000000;">i) {
                TreeNode </span>*node =<span style="color: #000000;"> q.front();
                q.pop();
                oneLevel.push_back(node</span>-&gt;<span style="color: #000000;">val);
                </span><span style="color: #0000ff;">if</span> (node-&gt;left) q.push(node-&gt;<span style="color: #000000;">left);
                </span><span style="color: #0000ff;">if</span> (node-&gt;right) q.push(node-&gt;<span style="color: #000000;">right);
            }
            res.push_back(oneLevel);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>下面我们来看递归的写法，核心就在于我们需要一个二维数组，和一个变量level，当level递归到上一层的个数，我们新建一个空层，继续往里面加数字，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> Recursive</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; levelOrder(TreeNode*<span style="color: #000000;"> root) {
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt; &gt;<span style="color: #000000;"> res;
        levelorder(root, </span><span style="color: #800080;">0</span><span style="color: #000000;">, res);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">void</span> levelorder(TreeNode *root, <span style="color: #0000ff;">int</span> level, vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt; &gt; &amp;<span style="color: #000000;">res) {
        </span><span style="color: #0000ff;">if</span> (!root) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (res.size() ==<span style="color: #000000;"> level) res.push_back({});
        res[level].push_back(root</span>-&gt;<span style="color: #000000;">val);
        </span><span style="color: #0000ff;">if</span> (root-&gt;left) levelorder(root-&gt;left, level + <span style="color: #800080;">1</span><span style="color: #000000;">, res);
        </span><span style="color: #0000ff;">if</span> (root-&gt;right) levelorder(root-&gt;right, level + <span style="color: #800080;">1</span><span style="color: #000000;">, res);
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4051326.html" target="_blank">Binary Tree Level Order Traversal II</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4297009.html" target="_blank">Binary Tree Zigzag Level Order Traversal</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2014-10-26 04:57</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4051321" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4051321);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4051715.html" id="cb_post_title_url">[LeetCode] Symmetric Tree 判断对称树</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).</p>
<p>For example, this binary tree is symmetric:</p>
<pre>    1
   / \
  2   2
 / \ / \
3  4 4  3
</pre>
<p> </p>
<p>But the following is not:</p>
<pre>    1
   / \
  2   2
   \   \
   3    3
</pre>
<p> </p>
<p>Note:<br/>Bonus points if you could solve it both recursively and iteratively.</p>
<p> </p>
<p>判断二叉树是否是平衡树，比如有两个节点n1, n2，我们需要比较n1的左子节点的值和n2的右子节点的值是否相等，同时还要比较n1的右子节点的值和n2的左子结点的值是否相等，以此类推比较完所有的左右两个节点。我们可以用递归和迭代两种方法来实现，写法不同，但是算法核心都一样。</p>
<p>递归方法 (Recursive Solution)：</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">/*</span><span style="color: #008000;">*
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> isSymmetric(TreeNode *<span style="color: #000000;">root) {
        </span><span style="color: #0000ff;">if</span> (!root) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span> isSymmetric(root-&gt;left, root-&gt;<span style="color: #000000;">right);
    }
    </span><span style="color: #0000ff;">bool</span> isSymmetric(TreeNode *left, TreeNode *<span style="color: #000000;">right) {
        </span><span style="color: #0000ff;">if</span> (!left &amp;&amp; !right) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (left &amp;&amp; !right || !left &amp;&amp; right || left-&gt;val != right-&gt;val) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span> isSymmetric(left-&gt;left, right-&gt;right) &amp;&amp; isSymmetric(left-&gt;right, right-&gt;<span style="color: #000000;">left);
    }
    
};</span></pre>
</div>
<p> </p>
<p>迭代方法 (Iterative Solution)：</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">/*</span><span style="color: #008000;">*
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> isSymmetric(TreeNode *<span style="color: #000000;">root) {
        </span><span style="color: #0000ff;">if</span> (!root) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        queue</span>&lt;TreeNode*&gt;<span style="color: #000000;"> q1, q2;
        q1.push(root</span>-&gt;<span style="color: #000000;">left);
        q2.push(root</span>-&gt;<span style="color: #000000;">right);
        
        </span><span style="color: #0000ff;">while</span> (!q1.empty() &amp;&amp; !<span style="color: #000000;">q2.empty()) {
            TreeNode </span>*node1 =<span style="color: #000000;"> q1.front();
            TreeNode </span>*node2 =<span style="color: #000000;"> q2.front();
            q1.pop();
            q2.pop();
            </span><span style="color: #0000ff;">if</span>((node1 &amp;&amp; !node2) || (!node1 &amp;&amp; node2)) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (node1) {
                </span><span style="color: #0000ff;">if</span> (node1-&gt;val != node2-&gt;val) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                q1.push(node1</span>-&gt;<span style="color: #000000;">left);
                q1.push(node1</span>-&gt;<span style="color: #000000;">right);
                q2.push(node2</span>-&gt;<span style="color: #000000;">right);
                q2.push(node2</span>-&gt;<span style="color: #000000;">left);
            }
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2014-10-26 10:49</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4051715" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4051715);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4053384.html" id="cb_post_title_url">[LeetCode] Same Tree 判断相同树</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given two binary trees, write a function to check if they are equal or not.</p>
<p>Two binary trees are considered equal if they are structurally identical and the nodes have the same value.</p>
<p> </p>
<p>判断两棵树是否相同和之前的判断两棵树是否对称都是一样的原理，利用深度优先搜索DFS来递归。代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> isSameTree(TreeNode *p, TreeNode *<span style="color: #000000;">q) {
        </span><span style="color: #0000ff;">if</span> (!p &amp;&amp; !q) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> ((p &amp;&amp; !q) || (!p &amp;&amp; q) || (p-&gt;val != q-&gt;val)) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span> isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;<span style="color: #000000;">right);
    }
};</span></pre>
</div>
<p> </p>
<p>这道题还有非递归的解法，因为二叉树的四种遍历(层序，先序，中序，后序)均有各自的迭代和递归的写法，这里我们先来看先序的迭代写法，相当于同时遍历两个数，然后每个节点都进行比较，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> isSameTree(TreeNode* p, TreeNode*<span style="color: #000000;"> q) {
        stack</span>&lt;TreeNode*&gt;<span style="color: #000000;"> s1, s2;
        </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (p) s1.push(p);
        </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (q) s2.push(q);
        </span><span style="color: #0000ff;">while</span> (!s1.empty() &amp;&amp; !<span style="color: #000000;">s2.empty()) {
            TreeNode </span>*t1 =<span style="color: #000000;"> s1.top(); s1.pop();
            TreeNode </span>*t2 =<span style="color: #000000;"> s2.top(); s2.pop();
            </span><span style="color: #0000ff;">if</span> (t1-&gt;val != t2-&gt;val) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> (t1-&gt;left) s1.push(t1-&gt;<span style="color: #000000;">left);
            </span><span style="color: #0000ff;">if</span> (t2-&gt;left) s2.push(t2-&gt;<span style="color: #000000;">left);
            </span><span style="color: #0000ff;">if</span> (s1.size() != s2.size()) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> (t1-&gt;right) s1.push(t1-&gt;<span style="color: #000000;">right);
            </span><span style="color: #0000ff;">if</span> (t2-&gt;right) s2.push(t2-&gt;<span style="color: #000000;">right);
            </span><span style="color: #0000ff;">if</span> (s1.size() != s2.size()) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> s1.size() ==<span style="color: #000000;"> s2.size();
    }
};</span></pre>
</div>
<p> </p>
<p>其他几种遍历顺序的迭代写法应该也能实现，有时间补充完整~</p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://leetcode.com/discuss/22197/my-non-recursive-method" target="_blank">https://leetcode.com/discuss/22197/my-non-recursive-method</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2014-10-27 07:54</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4053384" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4053384);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4298069.html" id="cb_post_title_url">[LeetCode] Recover Binary Search Tree 复原二叉搜索树</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Two elements of a binary search tree (BST) are swapped by mistake.</p>
<p>Recover the tree without changing its structure.</p>
<p>Note:<br/>A solution using O(<em>n</em>) space is pretty straight forward. Could you devise a constant space solution?</p>
<p> </p>
<p> </p>
<p>这道题要求我们复原一个<a href="http://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%B0%8B%E6%A8%B9" target="_blank">二叉搜索树</a>，说是其中有两个的顺序被调换了，题目要求上说O(n)的解法很直观，这种解法需要用到递归，用中序遍历树，并将所有节点存到一个一维向量中，把所有节点值存到另一个一维向量中，然后对存节点值的一维向量排序，在将排好的数组按顺序赋给节点。这种最一般的解法可针对任意个数目的节点错乱的情况，这里先贴上此种解法：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> O(n) space complexity</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">void</span> recoverTree(TreeNode *<span style="color: #000000;">root) {
        vector</span>&lt;TreeNode*&gt;<span style="color: #000000;"> list;
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> vals;
        inorder(root, list, vals);
        sort(vals.begin(), vals.end());
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; list.size(); ++<span style="color: #000000;">i) {
            list[i]</span>-&gt;val =<span style="color: #000000;"> vals[i];
        }
    }
    </span><span style="color: #0000ff;">void</span> inorder(TreeNode *root, vector&lt;TreeNode*&gt; &amp;list, vector&lt;<span style="color: #0000ff;">int</span>&gt; &amp;<span style="color: #000000;">vals) {
        </span><span style="color: #0000ff;">if</span> (!root) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
        inorder(root</span>-&gt;<span style="color: #000000;">left, list, vals);
        list.push_back(root);
        vals.push_back(root</span>-&gt;<span style="color: #000000;">val);
        inorder(root</span>-&gt;<span style="color: #000000;">right, list, vals);
    }
};</span></pre>
</div>
<p> </p>
<p>然后我上网搜了许多其他解法，看到另一种是用双指针来代替一维向量的，但是这种方法用到了递归，也不是O(1)空间复杂度的解法，这里需要三个指针，first，second分别表示第一个和第二个错乱位置的节点，pre指向当前节点的中序遍历的前一个节点。这里用传统的中序遍历递归来做，不过再应该输出节点值的地方，换成了判断pre和当前节点值的大小，如果pre的大，若first为空，则将first指向pre指的节点，把second指向当前节点。这样中序遍历完整个树，若first和second都存在，则交换它们的节点值即可。这个算法的空间复杂度仍为O(n)，n为树的高度，代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> Still O(n) space complexity</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    TreeNode </span>*<span style="color: #000000;">pre;
    TreeNode </span>*<span style="color: #000000;">first;
    TreeNode </span>*<span style="color: #000000;">second;
    </span><span style="color: #0000ff;">void</span> recoverTree(TreeNode *<span style="color: #000000;">root) {
        pre </span>=<span style="color: #000000;"> NULL;
        first </span>=<span style="color: #000000;"> NULL;
        second </span>=<span style="color: #000000;"> NULL;
        inorder(root);
        </span><span style="color: #0000ff;">if</span> (first &amp;&amp; second) swap(first-&gt;val, second-&gt;<span style="color: #000000;">val);
    }
    </span><span style="color: #0000ff;">void</span> inorder(TreeNode *<span style="color: #000000;">root) {
        </span><span style="color: #0000ff;">if</span> (!root) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
        inorder(root</span>-&gt;<span style="color: #000000;">left);
        </span><span style="color: #0000ff;">if</span> (!pre) pre =<span style="color: #000000;"> root;
        </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            </span><span style="color: #0000ff;">if</span> (pre-&gt;val &gt; root-&gt;<span style="color: #000000;">val) {
                </span><span style="color: #0000ff;">if</span> (!first) first =<span style="color: #000000;"> pre;
                second </span>=<span style="color: #000000;"> root;
            }
            pre </span>=<span style="color: #000000;"> root;
        }
        inorder(root</span>-&gt;<span style="color: #000000;">right);
    }
};</span></pre>
</div>
<p> </p>
<p>这道题的真正符合要求的解法应该用的Morris遍历，这是一种非递归且不使用栈，空间复杂度为O(1)的遍历方法，可参见我之前的博客<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4297300.html" id="cb_post_title_url">Binary Tree Inorder Traversal 二叉树的中序遍历</a>，在其基础上做些修改，加入first, second和parent指针，来比较当前节点值和中序遍历的前一节点值的大小，跟上面递归算法的思路相似，代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> Now O(1) space complexity</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">void</span> recoverTree(TreeNode *<span style="color: #000000;">root) {
        TreeNode </span>*first = NULL, *second = NULL, *parent =<span style="color: #000000;"> NULL;
        TreeNode </span>*cur, *<span style="color: #000000;">pre;
        cur </span>=<span style="color: #000000;"> root;
        </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> (cur) {
            </span><span style="color: #0000ff;">if</span> (!cur-&gt;<span style="color: #000000;">left) {
                </span><span style="color: #0000ff;">if</span> (parent &amp;&amp; parent-&gt;val &gt; cur-&gt;<span style="color: #000000;">val) {
                    </span><span style="color: #0000ff;">if</span> (!first) first =<span style="color: #000000;"> parent;
                    second </span>=<span style="color: #000000;"> cur;
                }
                parent </span>=<span style="color: #000000;"> cur;
                cur </span>= cur-&gt;<span style="color: #000000;">right;
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                pre </span>= cur-&gt;<span style="color: #000000;">left;
                </span><span style="color: #0000ff;">while</span> (pre-&gt;right &amp;&amp; pre-&gt;right != cur) pre = pre-&gt;<span style="color: #000000;">right;
                </span><span style="color: #0000ff;">if</span> (!pre-&gt;<span style="color: #000000;">right) {
                    pre</span>-&gt;right =<span style="color: #000000;"> cur;
                    cur </span>= cur-&gt;<span style="color: #000000;">left;
                } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    pre</span>-&gt;right =<span style="color: #000000;"> NULL;
                    </span><span style="color: #0000ff;">if</span> (parent-&gt;val &gt; cur-&gt;<span style="color: #000000;">val) {
                        </span><span style="color: #0000ff;">if</span> (!first) first =<span style="color: #000000;"> parent;
                        second </span>=<span style="color: #000000;"> cur;
                    }
                    parent </span>=<span style="color: #000000;"> cur;
                    cur </span>= cur-&gt;<span style="color: #000000;">right;
                }
            }
        }
        </span><span style="color: #0000ff;">if</span> (first &amp;&amp; second) swap(first-&gt;val, second-&gt;<span style="color: #000000;">val);
    }
};</span></pre>
</div>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p>
<div class="postBody"> </div></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-02-23 15:13</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4298069" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4298069);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4298435.html" id="cb_post_title_url">[LeetCode] Validate Binary Search Tree 验证二叉搜索树</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a binary tree, determine if it is a valid binary search tree (BST).</p>
<p>Assume a BST is defined as follows:</p>
<ul>
<li>The left subtree of a node contains only nodes with keys <strong>less than</strong> the node's key.</li>
<li>The right subtree of a node contains only nodes with keys <strong>greater than</strong> the node's key.</li>
<li>Both the left and right subtrees must also be binary search trees.</li>
</ul>
<p> </p>
<p>这道验证二叉搜索树有很多种解法，可以利用它本身的性质来做，即左&lt;根&lt;右，也可以通过利用中序遍历结果为有序数列来做，下面我们先来看最简单的一种，就是利用其本身性质来做，初始化时带入系统最大值和最小值，在递归过程中换成它们自己的节点值，用long代替int就是为了包括int的边界条件，代码如下：</p>
<p> </p>
<p>C++ 解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> Recursion without inorder traversal</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> isValidBST(TreeNode *<span style="color: #000000;">root) {
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> isValidBST(root, LONG_MIN, LONG_MAX);
    }
    </span><span style="color: #0000ff;">bool</span> isValidBST(TreeNode *root, <span style="color: #0000ff;">long</span> mn, <span style="color: #0000ff;">long</span><span style="color: #000000;"> mx) {
        </span><span style="color: #0000ff;">if</span> (!root) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (root-&gt;val &lt;= mn || root-&gt;val &gt;= mx) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span> isValidBST(root-&gt;left, mn, root-&gt;val) &amp;&amp; isValidBST(root-&gt;right, root-&gt;<span style="color: #000000;">val, mx);
    }
};</span></pre>
</div>
<p> </p>
<p>Java 解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">boolean</span><span style="color: #000000;"> isValidBST(TreeNode root) {
        </span><span style="color: #0000ff;">if</span> (root == <span style="color: #0000ff;">null</span>) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> valid(root, Long.MIN_VALUE, Long.MAX_VALUE);
    }
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">boolean</span> valid(TreeNode root, <span style="color: #0000ff;">long</span> low, <span style="color: #0000ff;">long</span><span style="color: #000000;"> high) {
        </span><span style="color: #0000ff;">if</span> (root == <span style="color: #0000ff;">null</span>) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (root.val &lt;= low || root.val &gt;= high) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span> valid(root.left, low, root.val) &amp;&amp;<span style="color: #000000;"> valid(root.right, root.val, high);
    }
}</span></pre>
</div>
<p> </p>
<p>这题实际上简化了难度，因为一般的二叉搜索树是左&lt;=根&lt;右，而这道题设定为左&lt;根&lt;右，那么就可以用中序遍历来做。因为如果不去掉左=根这个条件的话，那么下边两个数用中序遍历无法区分：</p>
<p>   20       20<br/>   /           \<br/> 20           20</p>
<p>它们的中序遍历结果都一样，但是左边的是BST，右边的不是BST。去掉等号的条件则相当于去掉了这种限制条件。下面我们来看使用中序遍历来做，这种方法思路很直接，通过中序遍历将所有的节点值存到一个数组里，然后再来判断这个数组是不是有序的，代码如下：</p>
<p> </p>
<p>C++ 解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> Recursion</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> isValidBST(TreeNode *<span style="color: #000000;">root) {
        </span><span style="color: #0000ff;">if</span> (!root) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> vals;
        inorder(root, vals);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; vals.size() - <span style="color: #800080;">1</span>; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (vals[i] &gt;= vals[i + <span style="color: #800080;">1</span>]) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
    </span><span style="color: #0000ff;">void</span> inorder(TreeNode *root, vector&lt;<span style="color: #0000ff;">int</span>&gt; &amp;<span style="color: #000000;">vals) {
        </span><span style="color: #0000ff;">if</span> (!root) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
        inorder(root</span>-&gt;<span style="color: #000000;">left, vals);
        vals.push_back(root</span>-&gt;<span style="color: #000000;">val);
        inorder(root</span>-&gt;<span style="color: #000000;">right, vals);
    }
};</span></pre>
</div>
<p> </p>
<p>Java 解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">boolean</span><span style="color: #000000;"> isValidBST(TreeNode root) {
        List</span>&lt;Integer&gt; list = <span style="color: #0000ff;">new</span> ArrayList&lt;Integer&gt;<span style="color: #000000;">();
        inorder(root, list);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = 0; i &lt; list.size() - 1; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (list.get(i) &gt;= list.get(i + 1)) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> inorder(TreeNode node, List&lt;Integer&gt;<span style="color: #000000;"> list) {
        </span><span style="color: #0000ff;">if</span> (node == <span style="color: #0000ff;">null</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
        inorder(node.left, list);
        list.add(node.val);
        inorder(node.right, list);
    }
}</span></pre>
</div>
<p> </p>
<p>下面这种解法跟上面那个很类似，都是用递归的中序遍历，但不同之处是不将遍历结果存入一个数组遍历完成再比较，而是每当遍历到一个新节点时和其上一个节点比较，如果不大于上一个节点那么则返回false，全部遍历完成后返回true。代码如下：</p>
<p> </p>
<p>C++ 解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> Still recursion</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    TreeNode </span>*<span style="color: #000000;">pre;
    </span><span style="color: #0000ff;">bool</span> isValidBST(TreeNode *<span style="color: #000000;">root) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">1</span><span style="color: #000000;">;
        pre </span>=<span style="color: #000000;"> NULL;
        inorder(root, res);
        </span><span style="color: #0000ff;">if</span> (res == <span style="color: #800080;">1</span>) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
    }
    </span><span style="color: #0000ff;">void</span> inorder(TreeNode *root, <span style="color: #0000ff;">int</span> &amp;<span style="color: #000000;">res) {
        </span><span style="color: #0000ff;">if</span> (!root) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
        inorder(root</span>-&gt;<span style="color: #000000;">left, res);
        </span><span style="color: #0000ff;">if</span> (!pre) pre =<span style="color: #000000;"> root;
        </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            </span><span style="color: #0000ff;">if</span> (root-&gt;val &lt;= pre-&gt;val) res = <span style="color: #800080;">0</span><span style="color: #000000;">;
            pre </span>=<span style="color: #000000;"> root;
        }
        inorder(root</span>-&gt;<span style="color: #000000;">right, res);
    }
};</span></pre>
</div>
<p> </p>
<p>当然这道题也可以用非递归来做，需要用到栈，因为中序遍历可以非递归来实现，所以只要在其上面稍加改动便可，代码如下：</p>
<p> </p>
<p>C++ 解法四：</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> Non-recursion with stack</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> isValidBST(TreeNode*<span style="color: #000000;"> root) {
        stack</span>&lt;TreeNode*&gt;<span style="color: #000000;"> s;
        TreeNode </span>*p = root, *pre =<span style="color: #000000;"> NULL;
        </span><span style="color: #0000ff;">while</span> (p || !<span style="color: #000000;">s.empty()) {
            </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> (p) {
                s.push(p);
                p </span>= p-&gt;<span style="color: #000000;">left;
            }
            TreeNode </span>*t =<span style="color: #000000;"> s.top(); s.pop();
            </span><span style="color: #0000ff;">if</span> (pre &amp;&amp; t-&gt;val &lt;= pre-&gt;val) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            pre </span>=<span style="color: #000000;"> t;
            p </span>= t-&gt;<span style="color: #000000;">right;
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>Java 解法四：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">boolean</span><span style="color: #000000;"> isValidBST(TreeNode root) {
        Stack</span>&lt;TreeNode&gt; s = <span style="color: #0000ff;">new</span> Stack&lt;TreeNode&gt;<span style="color: #000000;">();
        TreeNode p </span>= root, pre = <span style="color: #0000ff;">null</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (p != <span style="color: #0000ff;">null</span> || !<span style="color: #000000;">s.empty()) {
            </span><span style="color: #0000ff;">while</span> (p != <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
                s.push(p);
                p </span>=<span style="color: #000000;"> p.left;
            }
            TreeNode t </span>=<span style="color: #000000;"> s.pop();
            </span><span style="color: #0000ff;">if</span> (pre != <span style="color: #0000ff;">null</span> &amp;&amp; t.val &lt;= pre.val) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            pre </span>=<span style="color: #000000;"> t;
            p </span>=<span style="color: #000000;"> t.right;
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
}</span></pre>
</div>
<p> </p>
<p>最后还有一种方法，由于中序遍历还有非递归且无栈的实现方法，称之为Morris遍历，可以参考我之前的博客<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4297300.html" id="homepage1_HomePageDays_DaysList_ctl01_DayList_TitleUrl_0"> Binary Tree Inorder Traversal</a>，这种实现方法虽然写起来比递归版本要复杂的多，但是好处在于是O(1)空间复杂度，参见代码如下：</p>
<p> </p>
<p>C++ 解法五:</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> isValidBST(TreeNode *<span style="color: #000000;">root) {
        </span><span style="color: #0000ff;">if</span> (!root) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        TreeNode </span>*cur = root, *pre, *parent =<span style="color: #000000;"> NULL;
        </span><span style="color: #0000ff;">bool</span> res = <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> (cur) {
            </span><span style="color: #0000ff;">if</span> (!cur-&gt;<span style="color: #000000;">left) {
                </span><span style="color: #0000ff;">if</span> (parent &amp;&amp; parent-&gt;val &gt;= cur-&gt;val) res = <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                parent </span>=<span style="color: #000000;"> cur;
                cur </span>= cur-&gt;<span style="color: #000000;">right;
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                pre </span>= cur-&gt;<span style="color: #000000;">left;
                </span><span style="color: #0000ff;">while</span> (pre-&gt;right &amp;&amp; pre-&gt;right != cur) pre = pre-&gt;<span style="color: #000000;">right;
                </span><span style="color: #0000ff;">if</span> (!pre-&gt;<span style="color: #000000;">right) {
                    pre</span>-&gt;right =<span style="color: #000000;"> cur;
                    cur </span>= cur-&gt;<span style="color: #000000;">left;
                } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    pre</span>-&gt;right =<span style="color: #000000;"> NULL;
                    </span><span style="color: #0000ff;">if</span> (parent-&gt;val &gt;= cur-&gt;val) res = <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                    parent </span>=<span style="color: #000000;"> cur;
                    cur </span>= cur-&gt;<span style="color: #000000;">right;
                }
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4297300.html" target="_blank">Binary Tree Inorder Traversal</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/6436150.html">Find Mode in Binary Search Tree</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-02-24 02:26</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4298435" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4298435);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4298664.html" id="cb_post_title_url">[LeetCode] Interleaving String 交织相错的字符串</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given <em>s1</em>, <em>s2</em>, <em>s3</em>, find whether <em>s3</em> is formed by the interleaving of <em>s1</em> and <em>s2</em>.</p>
<p> For example,<br/>
Given:<br/>
<em>s1</em> = <code>"aabcc"</code>,<br/>
<em>s2</em> = <code>"dbbca"</code>,
</p>
<p>
When <em>s3</em> = <code>"aadbbcbcac"</code>, return true.<br/>
When <em>s3</em> = <code>"aadbbbaccc"</code>, return false.
</p>
<p> </p>
<p>这道求交织相错的字符串和之前那道<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4257740.html" id="cb_post_title_url"> Word Break 拆分词句</a> 的题很类似，就想我之前说的只要是遇到字符串的子序列或是匹配问题直接就上动态规划Dynamic Programming，其他的都不要考虑，什么递归呀的都是浮云，千辛万苦的写了递归结果拿到OJ上妥妥Time Limit Exceeded，能把人气昏了，所以还是直接就考虑DP解法省事些。一般来说字符串匹配问题都是更新一个二维dp数组，核心就在于找出递推公式。那么我们还是从题目中给的例子出发吧，手动写出二维数组dp如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">  Ø d b b c a
Ø <span style="color: #ff0000;">T</span> <span style="color: #008000;">F F F F F</span>
a <span style="color: #0000ff;">T</span> F F F F F
a <span style="color: #0000ff;">T</span> T T T T F
b <span style="color: #0000ff;">F</span> T T F T F
c <span style="color: #0000ff;">F</span> F T T T T
c <span style="color: #0000ff;">F</span> F F T F T</span></pre>
</div>
<p> </p>
<p>首先，这道题的大前提是字符串s1和s2的长度和必须等于s3的长度，如果不等于，肯定返回false。那么当s1和s2是空串的时候，s3必然是空串，则返回true。所以直接给dp[0][0]赋值true，然后若s1和s2其中的一个为空串的话，那么另一个肯定和s3的长度相等，则按位比较，若相同且上一个位置为True，赋True，其余情况都赋False，这样的二维数组dp的边缘就初始化好了。下面只需要找出递推公式来更新整个数组即可，我们发现，在任意非边缘位置dp[i][j]时，它的左边或上边有可能为True或是False，两边都可以更新过来，只要有一条路通着，那么这个点就可以为True。那么我们得分别来看，如果左边的为True，那么我们去除当前对应的s2中的字符串s2[j - 1] 和 s3中对应的位置的字符相比（计算对应位置时还要考虑已匹配的s1中的字符），为s3[j - 1 + i], 如果相等，则赋True，反之赋False。 而上边为True的情况也类似，所以可以求出递推公式为：</p>
<p>dp[i][j] = (dp[i - 1][j] &amp;&amp; s1[i - 1] == s3[i - 1 + j]) || (dp[i][j - 1] &amp;&amp; s2[j - 1] == s3[j - 1 + i]);</p>
<p>其中dp[i][j] 表示的是 s2 的前 i 个字符和 s1 的前 j 个字符是否匹配 s3 的前 i+j 个字符，根据以上分析，可写出代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> isInterleave(<span style="color: #0000ff;">string</span> s1, <span style="color: #0000ff;">string</span> s2, <span style="color: #0000ff;">string</span><span style="color: #000000;"> s3) {
        </span><span style="color: #0000ff;">if</span> (s1.size() + s2.size() != s3.size()) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> n1 =<span style="color: #000000;"> s1.size();
        </span><span style="color: #0000ff;">int</span> n2 =<span style="color: #000000;"> s2.size();
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">bool</span>&gt; &gt; dp(n1 + <span style="color: #800080;">1</span>, vector&lt;<span style="color: #0000ff;">bool</span>&gt; (n2 + <span style="color: #800080;">1</span>, <span style="color: #0000ff;">false</span><span style="color: #000000;">)); 
        dp[</span><span style="color: #800080;">0</span>][<span style="color: #800080;">0</span>] = <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt;= n1; ++<span style="color: #000000;">i) {
            dp[i][</span><span style="color: #800080;">0</span>] = dp[i - <span style="color: #800080;">1</span>][<span style="color: #800080;">0</span>] &amp;&amp; (s1[i - <span style="color: #800080;">1</span>] == s3[i - <span style="color: #800080;">1</span><span style="color: #000000;">]);
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt;= n2; ++<span style="color: #000000;">i) {
            dp[</span><span style="color: #800080;">0</span>][i] = dp[<span style="color: #800080;">0</span>][i - <span style="color: #800080;">1</span>] &amp;&amp; (s2[i - <span style="color: #800080;">1</span>] == s3[i - <span style="color: #800080;">1</span><span style="color: #000000;">]);
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt;= n1; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">1</span>; j &lt;= n2; ++<span style="color: #000000;">j) {
                dp[i][j] </span>= (dp[i - <span style="color: #800080;">1</span>][j] &amp;&amp; s1[i - <span style="color: #800080;">1</span>] == s3[i - <span style="color: #800080;">1</span> + j]) || (dp[i][j - <span style="color: #800080;">1</span>] &amp;&amp; s2[j - <span style="color: #800080;">1</span>] == s3[j - <span style="color: #800080;">1</span> +<span style="color: #000000;"> i]);
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> dp[n1][n2];
    }
};</span></pre>
</div>
<p> </p>
<p>我们也可以把for循环合并到一起，用if条件来处理边界情况，整体思路和上面的解法没有太大的区别，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> isInterleave(<span style="color: #0000ff;">string</span> s1, <span style="color: #0000ff;">string</span> s2, <span style="color: #0000ff;">string</span><span style="color: #000000;"> s3) {
        </span><span style="color: #0000ff;">if</span> (s1.size() + s2.size() != s3.size()) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> n1 = s1.size(), n2 =<span style="color: #000000;"> s2.size();
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">bool</span>&gt; &gt; dp(n1 + <span style="color: #800080;">1</span>, vector&lt;<span style="color: #0000ff;">bool</span>&gt; (n2 + <span style="color: #800080;">1</span>, <span style="color: #0000ff;">false</span><span style="color: #000000;">)); 
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt;= n1; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt;= n2; ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> (i == <span style="color: #800080;">0</span> &amp;&amp; j == <span style="color: #800080;">0</span><span style="color: #000000;">) {
                    dp[i][j] </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (i == <span style="color: #800080;">0</span><span style="color: #000000;">) {
                    dp[i][j] </span>= dp[i][j - <span style="color: #800080;">1</span>] &amp;&amp; s2[j - <span style="color: #800080;">1</span>] == s3[i + j - <span style="color: #800080;">1</span><span style="color: #000000;">];
                } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (j == <span style="color: #800080;">0</span><span style="color: #000000;">) {
                    dp[i][j] </span>= dp[i - <span style="color: #800080;">1</span>][j] &amp;&amp; s1[i - <span style="color: #800080;">1</span>] == s3[i + j - <span style="color: #800080;">1</span><span style="color: #000000;">];
                } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    dp[i][j] </span>= (dp[i - <span style="color: #800080;">1</span>][j] &amp;&amp; s1[i - <span style="color: #800080;">1</span>] == s3[i + j - <span style="color: #800080;">1</span>]) || (dp[i][j - <span style="color: #800080;">1</span>] &amp;&amp; s2[j - <span style="color: #800080;">1</span>] == s3[i + j - <span style="color: #800080;">1</span><span style="color: #000000;">]);
                }
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> dp[n1][n2];
    }
};</span></pre>
</div>
<p> </p>
<p>这道题也可以使用带优化的DFS来做，我们使用一个哈希集合，用来保存匹配失败的情况，我们分别用变量i，j，和k来记录字符串s1，s2，和s3匹配到的位置，初始化的时候都传入0。在递归函数中，首先根据i和j，算出key值，由于我们的哈希集合中只能放一个数字，而我们要encode两个数字i和j，所以通过用i乘以s3的长度再加上j来得到key，此时我们看，如果key已经在集合中，直接返回false，因为集合中存的是无法匹配的情况。然后先来处理corner case的情况，如果i等于s1的长度了，说明s1的字符都匹配完了，此时s2剩下的字符和s3剩下的字符可以直接进行匹配了，所以我们直接返回两者是否能匹配的bool值。同理，如果j等于s2的长度了，说明s2的字符都匹配完了，此时s1剩下的字符和s3剩下的字符可以直接进行匹配了，所以我们直接返回两者是否能匹配的bool值。如果s1和s2都有剩余字符，那么当s1的当前字符等于s3的当前字符，那么调用递归函数，注意i和k都加上1，如果递归函数返回true，则当前函数也返回true；还有一种情况是，当s2的当前字符等于s3的当前字符，那么调用递归函数，注意j和k都加上1，如果递归函数返回true，那么当前函数也返回true。如果匹配失败了，则将key加入集合中，并返回false即可，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> isInterleave(<span style="color: #0000ff;">string</span> s1, <span style="color: #0000ff;">string</span> s2, <span style="color: #0000ff;">string</span><span style="color: #000000;"> s3) {
        </span><span style="color: #0000ff;">if</span> (s1.size() + s2.size() != s3.size()) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        unordered_set</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> s;
        </span><span style="color: #0000ff;">return</span> helper(s1, <span style="color: #800080;">0</span>, s2, <span style="color: #800080;">0</span>, s3, <span style="color: #800080;">0</span><span style="color: #000000;">, s);
    }
    </span><span style="color: #0000ff;">bool</span> helper(<span style="color: #0000ff;">string</span>&amp; s1, <span style="color: #0000ff;">int</span> i, <span style="color: #0000ff;">string</span>&amp; s2, <span style="color: #0000ff;">int</span> j, <span style="color: #0000ff;">string</span>&amp; s3, <span style="color: #0000ff;">int</span> k, unordered_set&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> s) {
        </span><span style="color: #0000ff;">int</span> key = i * s3.size() +<span style="color: #000000;"> j;
        </span><span style="color: #0000ff;">if</span> (s.count(key)) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (i == s1.size()) <span style="color: #0000ff;">return</span> s2.substr(j) ==<span style="color: #000000;"> s3.substr(k);
        </span><span style="color: #0000ff;">if</span> (j == s2.size()) <span style="color: #0000ff;">return</span> s1.substr(i) ==<span style="color: #000000;"> s3.substr(k);
        </span><span style="color: #0000ff;">if</span> ((s1[i] == s3[k] &amp;&amp; helper(s1, i + <span style="color: #800080;">1</span>, s2, j, s3, k + <span style="color: #800080;">1</span>, s)) ||<span style="color: #000000;"> 
            (s2[j] </span>== s3[k] &amp;&amp; helper(s1, i, s2, j + <span style="color: #800080;">1</span>, s3, k + <span style="color: #800080;">1</span>, s))) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        s.insert(key);
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>既然DFS可以，那么BFS也就坐不住了，也要出来浪一波。这里我们需要用队列queue来辅助运算，如果将解法一讲解中的那个二维dp数组列出来的TF图当作一个迷宫的话，那么BFS的目的就是要从(0, 0)位置找一条都是T的路径通到(n1, n2)位置，这里我们还要使用哈希集合，不过此时保存到是已经遍历过的位置，队列中还是存key值，key值的encode方法跟上面DFS解法的相同，初识时放个0进去。然后我们进行while循环，循环条件除了q不为空，还有一个是k小于n3，因为匹配完s3中所有的字符就结束了。然后由于是一层层的遍历，所以要直接循环queue中元素个数的次数，在for循环中，对队首元素进行解码，得到i和j值，如果i小于n1，说明s1还有剩余字符，如果s1当前字符等于s3当前字符，那么把s1的下一个位置i+1跟j一起加码算出key值，如果该key值不在于集合中，则加入集合，同时加入队列queue中；同理，如果j小于n2，说明s2还有剩余字符，如果s2当前字符等于s3当前字符，那么把s2的下一个位置j+1跟i一起加码算出key值，如果该key值不在于集合中，则加入集合，同时加入队列queue中。for循环结束后，k自增1。最后如果匹配成功的话，那么queue中应该只有一个(n1, n2)的key值，且k此时等于n3，所以当queue为空或者k不等于n3的时候都要返回false，参见代码如下：</p>
<p> </p>
<p>解法四：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> isInterleave(<span style="color: #0000ff;">string</span> s1, <span style="color: #0000ff;">string</span> s2, <span style="color: #0000ff;">string</span><span style="color: #000000;"> s3) {
        </span><span style="color: #0000ff;">if</span> (s1.size() + s2.size() != s3.size()) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> n1 = s1.size(), n2 = s2.size(), n3 = s3.size(), k = <span style="color: #800080;">0</span><span style="color: #000000;">;
        unordered_set</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> s;
        queue</span>&lt;<span style="color: #0000ff;">int</span>&gt; q{{<span style="color: #800080;">0</span><span style="color: #000000;">}};
        </span><span style="color: #0000ff;">while</span> (!q.empty() &amp;&amp; k &lt;<span style="color: #000000;"> n3) {
            </span><span style="color: #0000ff;">int</span> len =<span style="color: #000000;"> q.size();
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> t = <span style="color: #800080;">0</span>; t &lt; len; ++<span style="color: #000000;">t) {
                </span><span style="color: #0000ff;">int</span> i = q.front() / n3, j = q.front() %<span style="color: #000000;"> n3; q.pop();
                </span><span style="color: #0000ff;">if</span> (i &lt; n1 &amp;&amp; s1[i] ==<span style="color: #000000;"> s3[k]) {
                    </span><span style="color: #0000ff;">int</span> key = (i + <span style="color: #800080;">1</span>) * n3 +<span style="color: #000000;"> j;
                    </span><span style="color: #0000ff;">if</span> (!<span style="color: #000000;">s.count(key)) {
                        s.insert(key);
                        q.push(key);
                    }
                }
                </span><span style="color: #0000ff;">if</span> (j &lt; n2 &amp;&amp; s2[j] ==<span style="color: #000000;"> s3[k]) {
                    </span><span style="color: #0000ff;">int</span> key = i * n3 + j + <span style="color: #800080;">1</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">if</span> (!<span style="color: #000000;">s.count(key)) {
                        s.insert(key);
                        q.push(key);
                    }
                }
            }
            </span>++<span style="color: #000000;">k;
        }
        </span><span style="color: #0000ff;">return</span> !q.empty() &amp;&amp; k ==<span style="color: #000000;"> n3;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/7728/dp-solution-in-java">https://discuss.leetcode.com/topic/7728/dp-solution-in-java</a></p>
<p><a href="https://discuss.leetcode.com/topic/3532/my-dp-solution-in-c">https://discuss.leetcode.com/topic/3532/my-dp-solution-in-c</a> </p>
<p><a href="https://discuss.leetcode.com/topic/30127/summary-of-solutions-bfs-dfs-dp">https://discuss.leetcode.com/topic/30127/summary-of-solutions-bfs-dfs-dp</a></p>
<p><a href="https://discuss.leetcode.com/topic/3436/my-accepted-java-recursive-solution-for-interleaving-string">https://discuss.leetcode.com/topic/3436/my-accepted-java-recursive-solution-for-interleaving-string</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-02-24 14:03</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4298664" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4298664);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4299608.html" id="cb_post_title_url">[LeetCode] Unique Binary Search Trees 独一无二的二叉搜索树</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given <em>n</em>, how many structurally unique BST's (binary search trees) that store values 1...<em>n</em>?</p>
<p>For example,<br/>Given <em>n</em> = 3, there are a total of 5 unique BST's.</p>
<pre>   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3</pre>
<p> </p>
<p>这道题实际上是<a href="http://zh.wikipedia.org/wiki/%E5%8D%A1%E5%A1%94%E5%85%B0%E6%95%B0" target="_blank"> Catalan Number卡塔兰数</a>的一个例子，如果对卡塔兰数不熟悉的童鞋可能真不太好做。话说其实我也是今天才知道的好嘛-.-|||，为啥我以前都不知道捏？！为啥卡塔兰数不像斐波那契数那样人尽皆知呢，是我太孤陋寡闻么？！不过今天知道也不晚，不断的学习新的东西，这才是刷题的意义所在嘛! 好了，废话不多说了，赶紧回到题目上来吧。我们先来看当 n = 1的情况，只能形成唯一的一棵二叉搜索树，n分别为1,2,3的情况如下所示：</p>
<p> </p>
<div class="cnblogs_code">
<pre>                    <span style="color: #800080;">1</span>                        n = <span style="color: #800080;">1</span>

                <span style="color: #800080;">2</span>        <span style="color: #800080;">1</span>                   n = <span style="color: #800080;">2</span>
               /<span style="color: #000000;">          \
              </span><span style="color: #800080;">1</span>            <span style="color: #800080;">2</span>
  
   <span style="color: #800080;">1</span>         <span style="color: #800080;">3</span>     <span style="color: #800080;">3</span>      <span style="color: #800080;">2</span>      <span style="color: #800080;">1</span>           n = <span style="color: #800080;">3</span><span style="color: #000000;">
    \       </span>/     /      /<span style="color: #000000;"> \      \
     </span><span style="color: #800080;">3</span>     <span style="color: #800080;">2</span>     <span style="color: #800080;">1</span>      <span style="color: #800080;">1</span>   <span style="color: #800080;">3</span>      <span style="color: #800080;">2</span>
    /     /<span style="color: #000000;">       \                 \
   </span><span style="color: #800080;">2</span>     <span style="color: #800080;">1</span>         <span style="color: #800080;">2</span>                 <span style="color: #800080;">3</span></pre>
</div>
<p> </p>
<p>就跟斐波那契数列一样，我们把n = 0 时赋为1，因为空树也算一种二叉搜索树，那么n = 1时的情况可以看做是其左子树个数乘以右子树的个数，左右字数都是空树，所以1乘1还是1。那么n = 2时，由于1和2都可以为跟，分别算出来，再把它们加起来即可。n = 2的情况可由下面式子算出：</p>
<p>dp[2] =  dp[0] * dp[1]　　　(1为根的情况)</p>
<p>　　　　+ dp[1] * dp[0]　　  (2为根的情况)</p>
<p>同理可写出 n = 3 的计算方法：</p>
<p>dp[3] =  dp[0] * dp[2]　　　(1为根的情况)</p>
<p>　　　　+ dp[1] * dp[1]　　  (2为根的情况)</p>
<p> 　　　  + dp[2] * dp[0]　　  (3为根的情况)</p>
<p>由此可以得出卡塔兰数列的递推式为：</p>
<p><img alt="C_0 = 1 \quad \mbox{and} \quad C_{n+1}=\sum_{i=0}^{n}C_i\,C_{n-i}\quad\mbox{for }n\ge 0." class="mwe-math-fallback-image-inline tex" src="http://upload.wikimedia.org/math/6/2/1/6217b3c99a3243afcd5d8dbd58186822.png"/></p>
<p>我们根据以上的分析，可以写出代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> numTrees(<span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; dp(n + <span style="color: #800080;">1</span>, <span style="color: #800080;">0</span><span style="color: #000000;">);
        dp[</span><span style="color: #800080;">0</span>] = <span style="color: #800080;">1</span><span style="color: #000000;">;
        dp[</span><span style="color: #800080;">1</span>] = <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">2</span>; i &lt;= n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; i; ++<span style="color: #000000;">j) {
                dp[i] </span>+= dp[j] * dp[i - j - <span style="color: #800080;">1</span><span style="color: #000000;">];
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> dp[n];
    }
};</span></pre>
</div>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p>
<p><span style="font-size: 14px; line-height: 1.5;">　</span></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-02-25 14:56</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4299608" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4299608);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4301096.html" id="cb_post_title_url">[LeetCode] Unique Binary Search Trees II 独一无二的二叉搜索树之二</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given <em>n</em>, generate all structurally unique BST's (binary search trees) that store values 1...<em>n</em>.</p>
<p>For example,<br/>Given <em>n</em> = 3, your program should return all 5 unique BST's shown below.</p>
<pre>   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
</pre>
<p> </p>
<div class="spoilers"><br/>OJ's Binary Tree Serialization:
<p>The serialization of a binary tree follows a level order traversal, where '#' signifies a path terminator where no node exists below.</p>
<p>Here's an example:</p>
<pre>   1
  / \
 2   3
    /
   4
    \
     5
</pre>
The above binary tree is serialized as <code>"{1,2,3,#,#,4,#,#,5}"</code>.</div>
<p> </p>
<p>这道题是之前的<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4299608.html" id="homepage1_HomePageDays_DaysList_ctl01_DayList_TitleUrl_0"> Unique Binary Search Trees 独一无二的二叉搜索树</a>的延伸，之前那个只要求算出所有不同的二叉搜索树的个数，这道题让把那些二叉树都建立出来。这种建树问题一般来说都是用递归来解，这道题也不例外，划分左右子树，递归构造。至于递归函数中为啥都用的是指针，是参考了网友<a href="http://fisherlei.blogspot.com/2013/03/leetcode-unique-binary-search-trees-ii.html" target="_blank">水中的鱼的博客</a>，若不用指针，全部实例化的话会存在大量的对象拷贝，要调用拷贝构造函数，具体我也不太懂，反正感觉挺有道理的，不明觉厉啊-.-!!!</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;TreeNode *&gt; generateTrees(<span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        </span><span style="color: #0000ff;">if</span> (n == <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;"> {};
        </span><span style="color: #0000ff;">return</span> *generateTreesDFS(<span style="color: #800080;">1</span><span style="color: #000000;">, n);
    }
    vector</span>&lt;TreeNode*&gt; *generateTreesDFS(<span style="color: #0000ff;">int</span> start, <span style="color: #0000ff;">int</span><span style="color: #000000;"> end) {
        vector</span>&lt;TreeNode*&gt; *subTree = <span style="color: #0000ff;">new</span> vector&lt;TreeNode*&gt;<span style="color: #000000;">();
        </span><span style="color: #0000ff;">if</span> (start &gt; end) subTree-&gt;<span style="color: #000000;">push_back(NULL);
        </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = start; i &lt;= end; ++<span style="color: #000000;">i) {
                vector</span>&lt;TreeNode*&gt; *leftSubTree = generateTreesDFS(start, i - <span style="color: #800080;">1</span><span style="color: #000000;">);
                vector</span>&lt;TreeNode*&gt; *rightSubTree = generateTreesDFS(i + <span style="color: #800080;">1</span><span style="color: #000000;">, end);
                </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; leftSubTree-&gt;size(); ++<span style="color: #000000;">j) {
                    </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> k = <span style="color: #800080;">0</span>; k &lt; rightSubTree-&gt;size(); ++<span style="color: #000000;">k) {
                        TreeNode </span>*node = <span style="color: #0000ff;">new</span><span style="color: #000000;"> TreeNode(i);
                        node</span>-&gt;left = (*<span style="color: #000000;">leftSubTree)[j];
                        node</span>-&gt;right = (*<span style="color: #000000;">rightSubTree)[k];
                        subTree</span>-&gt;<span style="color: #000000;">push_back(node);
                    }
                }
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> subTree;
    }
};</span></pre>
</div>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-02-26 13:16</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4301096" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4301096);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4297300.html" id="cb_post_title_url">[LeetCode] Binary Tree Inorder Traversal 二叉树的中序遍历</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a binary tree, return the <em>inorder</em> traversal of its nodes' values.</p>
<p>For example:<br/>Given binary tree <code>{1,#,2,3}</code>,</p>
<pre>   1
    \
     2
    /
   3
</pre>
<p> </p>
<p>return <code>[1,3,2]</code>.</p>
<p>Note: Recursive solution is trivial, could you do it iteratively?</p>
<p> </p>
<p>二叉树的中序遍历顺序为左-根-右，可以有递归和非递归来解，其中非递归解法又分为两种，一种是使用栈来接，另一种不需要使用栈。我们先来看递归方法，十分直接，对左子结点调用递归函数，根节点访问值，右子节点再调用递归函数，代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> Recursion</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; inorderTraversal(TreeNode *<span style="color: #000000;">root) {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> res;
        inorder(root, res);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">void</span> inorder(TreeNode *root, vector&lt;<span style="color: #0000ff;">int</span>&gt; &amp;<span style="color: #000000;">res) {
        </span><span style="color: #0000ff;">if</span> (!root) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (root-&gt;left) inorder(root-&gt;<span style="color: #000000;">left, res);
        res.push_back(root</span>-&gt;<span style="color: #000000;">val);
        </span><span style="color: #0000ff;">if</span> (root-&gt;right) inorder(root-&gt;<span style="color: #000000;">right, res);
    }
};</span></pre>
</div>
<p> </p>
<p>下面我们再来看非递归使用栈的解法，也是符合本题要求使用的解法之一，需要用栈来做，思路是从根节点开始，先将根节点压入栈，然后再将其所有左子结点压入栈，然后取出栈顶节点，保存节点值，再将当前指针移到其右子节点上，若存在右子节点，则在下次循环时又可将其所有左子结点压入栈中。这样就保证了访问顺序为左-根-右，代码如下：</p>
<p> </p>
<p>解法二： </p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> Non-recursion</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; inorderTraversal(TreeNode *<span style="color: #000000;">root) {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> res;
        stack</span>&lt;TreeNode*&gt;<span style="color: #000000;"> s;
        TreeNode </span>*p =<span style="color: #000000;"> root;
        </span><span style="color: #0000ff;">while</span> (p || !<span style="color: #000000;">s.empty()) {
            </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> (p) {
                s.push(p);
                p </span>= p-&gt;<span style="color: #000000;">left;
            }
            p </span>=<span style="color: #000000;"> s.top();
            s.pop();
            res.push_back(p</span>-&gt;<span style="color: #000000;">val);
            p </span>= p-&gt;<span style="color: #000000;">right;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种解法跟<a href="http://www.cnblogs.com/grandyang/p/4146981.html" target="_blank">Binary Tree Preorder Traversal</a>中的解法二几乎一样，就是把结点值加入结果res的步骤从if中移动到了else中，因为中序遍历的顺序是左-根-右，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; inorderTraversal(TreeNode*<span style="color: #000000;"> root) {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> res;
        stack</span>&lt;TreeNode*&gt;<span style="color: #000000;"> s;
        TreeNode </span>*p =<span style="color: #000000;"> root;
        </span><span style="color: #0000ff;">while</span> (!s.empty() ||<span style="color: #000000;"> p) {
            </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (p) {
                s.push(p);
                p </span>= p-&gt;<span style="color: #000000;">left;
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                TreeNode </span>*t =<span style="color: #000000;"> s.top(); s.pop();
                res.push_back(t</span>-&gt;<span style="color: #000000;">val);
                p </span>= t-&gt;<span style="color: #000000;">right;
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>下面我们来看另一种很巧妙的解法，这种方法不需要使用栈，所以空间复杂度为常量，这种非递归不用栈的遍历方法有个专门的名字，叫Morris Traversal，在介绍这种方法之前，我们先来引入一种新型树，叫 <a href="http://en.wikipedia.org/wiki/Threaded_binary_tree" target="_blank">Threaded binary tree</a>，这个还不太好翻译，我第一眼看上去以为是叫线程二叉树，但是感觉好像又跟线程没啥关系，后来看到网上有人翻译为螺纹二叉树，但本人认为这翻译也不太敢直视，很容易让人联想到为计划生育做出突出贡献的某世界著名品牌，但是苦于找不到更合理的翻译方法，就暂且叫螺纹二叉树吧。我们先来看看维基百科上关于它的英文定义：</p>
<p>A binary tree is <em>threaded</em> by making all right child pointers that would normally be null point to the inorder successor of the node (<strong>if</strong> it exists), and all left child pointers that would normally be null point to the inorder predecessor of the node.</p>
<p>就是说螺纹二叉树实际上是把所有原本为空的右子节点指向了中序遍历顺序之后的那个节点，把所有原本为空的左子节点都指向了中序遍历之前的那个节点，具体例子可以点击<a href="http://en.wikipedia.org/wiki/Threaded_binary_tree" target="_blank">这里</a>。那么这道题跟这个螺纹二叉树又有啥关系呢？由于我们既不能用递归，又不能用栈，那我们如何保证访问顺序是中序遍历的左-根-右呢。原来我们需要构建一个螺纹二叉树，我们需要将所有为空的右子节点指向中序遍历的下一个节点，这样我们中序遍历完左子结点后，就能顺利的回到其根节点继续遍历了。具体算法如下：</p>
<p>1. 初始化指针cur指向root</p>
<p>2. 当cur不为空时</p>
<p>　 - 如果cur没有左子结点</p>
<p>　     a) 打印出cur的值</p>
<p>　　  b) 将cur指针指向其右子节点</p>
<p>　 - 反之</p>
<p>　    将pre指针指向cur的左子树中的最右子节点　</p>
<p>　　　  * 若pre不存在右子节点</p>
<p>　　　       a) 将其右子节点指回cur</p>
<p>　　　　    b) cur指向其左子节点</p>
<p>　　　  * 反之</p>
<p>　　　　　 a) 将pre的右子节点置空</p>
<p>　　　　　 b) 打印cur的值</p>
<p>　　　　　 c) 将cur指针指向其右子节点</p>
<p> </p>
<p>解法四：</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> Non-recursion and no stack</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; inorderTraversal(TreeNode *<span style="color: #000000;">root) {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">if</span> (!root) <span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
        TreeNode </span>*cur, *<span style="color: #000000;">pre;
        cur </span>=<span style="color: #000000;"> root;
        </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> (cur) {
            </span><span style="color: #0000ff;">if</span> (!cur-&gt;<span style="color: #000000;">left) {
                res.push_back(cur</span>-&gt;<span style="color: #000000;">val);
                cur </span>= cur-&gt;<span style="color: #000000;">right;
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                pre </span>= cur-&gt;<span style="color: #000000;">left;
                </span><span style="color: #0000ff;">while</span> (pre-&gt;right &amp;&amp; pre-&gt;right != cur) pre = pre-&gt;<span style="color: #000000;">right;
                </span><span style="color: #0000ff;">if</span> (!pre-&gt;<span style="color: #000000;">right) {
                    pre</span>-&gt;right =<span style="color: #000000;"> cur;
                    cur </span>= cur-&gt;<span style="color: #000000;">left;
                } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    pre</span>-&gt;right =<span style="color: #000000;"> NULL;
                    res.push_back(cur</span>-&gt;<span style="color: #000000;">val);
                    cur </span>= cur-&gt;<span style="color: #000000;">right;
                }
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>其实Morris遍历不仅仅对中序遍历有用，对先序和后序同样有用，具体可参见网友<a href="http://noalgo.info/832.html" target="_blank">NOALGO博客</a>，和 <a href="http://www.cnblogs.com/AnnieKim/archive/2013/06/15/morristraversal.html" target="_blank">Annie Kim's Blog的博客</a>。所以对二叉树的三种常见遍历顺序(先序，中序，后序)就有三种解法(递归，非递归，Morris遍历)，总共有九段代码呀，熟练掌握这九种写法才算初步掌握了树的遍历挖~~ 至于二叉树的层序遍历也有递归和非递归解法，至于有没有Morris遍历的解法还有待大神们的解答，若真有也请劳烦告知博主一声~~</p>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4298435.html" target="_blank">Validate Binary Search Tree</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4146981.html" target="_blank">Binary Tree Preorder Traversal</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4251757.html" target="_blank">Binary Tree Postorder Traversal</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4231455.html" target="_blank">Binary Search Tree Iterator</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4620012.html">Kth Smallest Element in a BST</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/5247398.html" target="_blank">Closest Binary Search Tree Value II</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/5306162.html" target="_blank">Inorder Successor in BST</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/6478/iterative-solution-in-java-simple-and-readable">https://discuss.leetcode.com/topic/6478/iterative-solution-in-java-simple-and-readable</a></p>
<p><a href="https://discuss.leetcode.com/topic/30632/preorder-inorder-and-postorder-iteratively-summarization">https://discuss.leetcode.com/topic/30632/preorder-inorder-and-postorder-iteratively-summarization</a></p>
<p><a href="https://discuss.leetcode.com/topic/44231/preorder-inorder-and-postorder-traversal-iterative-java-solution">https://discuss.leetcode.com/topic/44231/preorder-inorder-and-postorder-traversal-iterative-java-solution</a></p>
<p><a href="https://discuss.leetcode.com/topic/14475/clear-c-solutions-iterative-recursive-and-morris-traversal-3-different-solutions">https://discuss.leetcode.com/topic/14475/clear-c-solutions-iterative-recursive-and-morris-traversal-3-different-solutions</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-02-22 05:51</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4297300" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4297300);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4305572.html" id="cb_post_title_url">[LeetCode] Restore IP Addresses  复原IP地址</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a string containing only digits, restore it by returning all possible valid IP address combinations.</p>
<p>For example:<br/>Given <code>"25525511135"</code>,</p>
<p>return <code>["255.255.11.135", "255.255.111.35"]</code>. (Order does not matter)</p>
<p> </p>
<p>这道题要求是复原<a href="http://zh.wikipedia.org/wiki/IP%E5%9C%B0%E5%9D%80" target="_blank">IP地址</a>，IP地址对我们并不陌生，就算我们不是学CS的，只要我们是广大网友之一，就应该对其并不陌生。IP地址由32位<a href="http://zh.wikipedia.org/wiki/%E4%BA%8C%E8%BF%9B%E5%88%B6" title="二进制">二进制</a>数组成，为便于使用，常以XXX.XXX.XXX.XXX形式表现，每组XXX代表小于或等于255的10进制数。所以说IP地址总共有四段，每一段可能有一位，两位或者三位，范围是[0, 255]，题目明确指出输入字符串只含有数字，所以当某段是三位时，我们要判断其是否越界（&gt;255)，还有一点很重要的是，当只有一位时，0可以成某一段，如果有两位或三位时，像 00， 01， 001， 011， 000等都是不合法的，所以我们还是需要有一个判定函数来判断某个字符串是否合法。这道题其实也可以看做是字符串的分段问题，在输入字符串中加入三个点，将字符串分为四段，每一段必须合法，求所有可能的情况。根据目前刷了这么多题，得出了两个经验，<strong>一是只要遇到字符串的子序列或配准问题首先考虑动态规划DP，二是只要遇到需要求出所有可能情况首先考虑用递归</strong>。这道题并非是求字符串的子序列或配准问题，更符合第二种情况，所以我们要用递归来解。我们用k来表示当前还需要分的段数，如果k = 0，则表示三个点已经加入完成，四段已经形成，若这时字符串刚好为空，则将当前分好的结果保存。若k != 0, 则对于每一段，我们分别用一位，两位，三位来尝试，分别判断其合不合法，如果合法，则调用递归继续分剩下的字符串，最终和求出所有合法组合，代码如下：</p>
<p> </p>
<p>C++ 解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; restoreIpAddresses(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        vector</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> res;
        restore(s, </span><span style="color: #800080;">4</span>, <span style="color: #800000;">""</span><span style="color: #000000;">, res);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">void</span> restore(<span style="color: #0000ff;">string</span> s, <span style="color: #0000ff;">int</span> k, <span style="color: #0000ff;">string</span> <span style="color: #0000ff;">out</span>, vector&lt;<span style="color: #0000ff;">string</span>&gt; &amp;<span style="color: #000000;">res) {
        </span><span style="color: #0000ff;">if</span> (k == <span style="color: #800080;">0</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">if</span> (s.empty()) res.push_back(<span style="color: #0000ff;">out</span><span style="color: #000000;">);
        }
        </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt;= <span style="color: #800080;">3</span>; ++<span style="color: #000000;">i) {
                </span><span style="color: #0000ff;">if</span> (s.size() &gt;= i &amp;&amp; isValid(s.substr(<span style="color: #800080;">0</span><span style="color: #000000;">, i))) {
                    </span><span style="color: #0000ff;">if</span> (k == <span style="color: #800080;">1</span>) restore(s.substr(i), k - <span style="color: #800080;">1</span>, <span style="color: #0000ff;">out</span> + s.substr(<span style="color: #800080;">0</span><span style="color: #000000;">, i), res);
                    </span><span style="color: #0000ff;">else</span> restore(s.substr(i), k - <span style="color: #800080;">1</span>, <span style="color: #0000ff;">out</span> + s.substr(<span style="color: #800080;">0</span>, i) + <span style="color: #800000;">"</span><span style="color: #800000;">.</span><span style="color: #800000;">"</span><span style="color: #000000;">, res);
                }
            }
        }
    }
    </span><span style="color: #0000ff;">bool</span> isValid(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        </span><span style="color: #0000ff;">if</span> (s.empty() || s.size() &gt; <span style="color: #800080;">3</span> || (s.size() &gt; <span style="color: #800080;">1</span> &amp;&amp; s[<span style="color: #800080;">0</span>] == <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span>)) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> res =<span style="color: #000000;"> atoi(s.c_str());
        </span><span style="color: #0000ff;">return</span> res &lt;= <span style="color: #800080;">255</span> &amp;&amp; res &gt;= <span style="color: #800080;">0</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>我们也可以省掉isValid函数，直接在调用递归之前用if语句来滤掉不符合题意的情况，这里面用了k != std::to_string(val).size()，其实并不难理解，比如当k=3时，说明应该是个三位数，但如果字符是"010"，那么转为整型val=10，再转回字符串就是"10"，此时的长度和k值不同了，这样就可以找出不合要求的情况了，参见代码如下；</p>
<p> </p>
<p>C++ 解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; restoreIpAddresses(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        vector</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> res;
        helper(s, </span><span style="color: #800080;">0</span>, <span style="color: #800000;">""</span><span style="color: #000000;">, res);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">void</span> helper(<span style="color: #0000ff;">string</span> s, <span style="color: #0000ff;">int</span> n, <span style="color: #0000ff;">string</span> <span style="color: #0000ff;">out</span>, vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp;<span style="color: #000000;"> res) {
        </span><span style="color: #0000ff;">if</span> (n == <span style="color: #800080;">4</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">if</span> (s.empty()) res.push_back(<span style="color: #0000ff;">out</span><span style="color: #000000;">);
        } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> k = <span style="color: #800080;">1</span>; k &lt; <span style="color: #800080;">4</span>; ++<span style="color: #000000;">k) {
                </span><span style="color: #0000ff;">if</span> (s.size() &lt; k) <span style="color: #0000ff;">break</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">int</span> val = atoi(s.substr(<span style="color: #800080;">0</span><span style="color: #000000;">, k).c_str());
                </span><span style="color: #0000ff;">if</span> (val &gt; <span style="color: #800080;">255</span> || k != std::to_string(val).size()) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                helper(s.substr(k), n </span>+ <span style="color: #800080;">1</span>, <span style="color: #0000ff;">out</span> + s.substr(<span style="color: #800080;">0</span>, k) + (n == <span style="color: #800080;">3</span> ? <span style="color: #800000;">""</span> : <span style="color: #800000;">"</span><span style="color: #800000;">.</span><span style="color: #800000;">"</span><span style="color: #000000;">), res);
            }
        }
    }
};</span></pre>
</div>
<p> </p>
<p>Java 解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
    </span><span style="color: #0000ff;">public</span> List&lt;String&gt;<span style="color: #000000;"> restoreIpAddresses(String s) {
        List</span>&lt;String&gt; res = <span style="color: #0000ff;">new</span> ArrayList&lt;String&gt;<span style="color: #000000;">();
        helper(s, </span>0, ""<span style="color: #000000;">, res);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> helper(String s, <span style="color: #0000ff;">int</span> n, String out, List&lt;String&gt;<span style="color: #000000;"> res) {
        </span><span style="color: #0000ff;">if</span> (n == 4<span style="color: #000000;">) {
            </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (s.isEmpty()) res.add(out);
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> k = 1; k &lt; 4; ++<span style="color: #000000;">k) {
            </span><span style="color: #0000ff;">if</span> (s.length() &lt; k) <span style="color: #0000ff;">break</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">int</span> val = Integer.parseInt(s.substring(0<span style="color: #000000;">, k));
            </span><span style="color: #0000ff;">if</span> (val &gt; 255 || k != String.valueOf(val).length()) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
            helper(s.substring(k), n </span>+ 1, out + s.substring(0, k) + (n == 3 ? "" : "."<span style="color: #000000;">), res);
        }
    }
}</span></pre>
</div>
<p> </p>
<p>由于每段数字最多只能有三位，而且只能分为四段，所以情况并不是很多，我们可以使用暴力搜索的方法，每一段都循环1到3，然后当4段位数之和等于原字符串长度时，我们进一步判断每段数字是否不大于255，然后滤去不合要求的数字，加入结果中即可，参见代码如下；</p>
<p> </p>
<p>C++ 解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; restoreIpAddresses(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        vector</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> a = <span style="color: #800080;">1</span>; a &lt; <span style="color: #800080;">4</span>; ++<span style="color: #000000;">a) 
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> b = <span style="color: #800080;">1</span>; b &lt; <span style="color: #800080;">4</span>; ++<span style="color: #000000;">b) 
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> c = <span style="color: #800080;">1</span>; c &lt; <span style="color: #800080;">4</span>; ++<span style="color: #000000;">c) 
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> d = <span style="color: #800080;">1</span>; d &lt; <span style="color: #800080;">4</span>; ++<span style="color: #000000;">d) 
            </span><span style="color: #0000ff;">if</span> (a + b + c + d ==<span style="color: #000000;"> s.size()) {
                </span><span style="color: #0000ff;">int</span> A = stoi(s.substr(<span style="color: #800080;">0</span><span style="color: #000000;">, a));
                </span><span style="color: #0000ff;">int</span> B =<span style="color: #000000;"> stoi(s.substr(a, b));
                </span><span style="color: #0000ff;">int</span> C = stoi(s.substr(a +<span style="color: #000000;"> b, c));
                </span><span style="color: #0000ff;">int</span> D = stoi(s.substr(a + b +<span style="color: #000000;"> c, d));
                </span><span style="color: #0000ff;">if</span> (A &lt;= <span style="color: #800080;">255</span> &amp;&amp; B &lt;= <span style="color: #800080;">255</span> &amp;&amp; C &lt;= <span style="color: #800080;">255</span> &amp;&amp; D &lt;= <span style="color: #800080;">255</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">string</span> t = to_string(A) + <span style="color: #800000;">"</span><span style="color: #800000;">.</span><span style="color: #800000;">"</span> + to_string(B) + <span style="color: #800000;">"</span><span style="color: #800000;">.</span><span style="color: #800000;">"</span> + to_string(C) + <span style="color: #800000;">"</span><span style="color: #800000;">.</span><span style="color: #800000;">"</span> +<span style="color: #000000;"> to_string(D);
                    </span><span style="color: #0000ff;">if</span> (t.size() == s.size() + <span style="color: #800080;">3</span><span style="color: #000000;">) res.push_back(t);
                }
            }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>Java 解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
    </span><span style="color: #0000ff;">public</span> List&lt;String&gt;<span style="color: #000000;"> restoreIpAddresses(String s) {
        List</span>&lt;String&gt; res = <span style="color: #0000ff;">new</span> ArrayList&lt;String&gt;<span style="color: #000000;">();
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> a = 1; a &lt; 4; ++<span style="color: #000000;">a) 
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> b = 1; b &lt; 4; ++<span style="color: #000000;">b) 
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> c = 1; c &lt; 4; ++<span style="color: #000000;">c)
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> d = 1; d &lt; 4; ++<span style="color: #000000;">d) 
            </span><span style="color: #0000ff;">if</span> (a + b + c + d ==<span style="color: #000000;"> s.length()) {
                </span><span style="color: #0000ff;">int</span> A = Integer.parseInt(s.substring(0<span style="color: #000000;">, a));
                </span><span style="color: #0000ff;">int</span> B = Integer.parseInt(s.substring(a, a +<span style="color: #000000;"> b));
                </span><span style="color: #0000ff;">int</span> C = Integer.parseInt(s.substring(a + b, a + b +<span style="color: #000000;"> c));
                </span><span style="color: #0000ff;">int</span> D = Integer.parseInt(s.substring(a + b +<span style="color: #000000;"> c));
                </span><span style="color: #0000ff;">if</span> (A &lt;= 255 &amp;&amp; B &lt;= 255 &amp;&amp; C &lt;= 255 &amp;&amp; D &lt;= 255<span style="color: #000000;">) {
                    String t </span>= String.valueOf(A) + "." + String.valueOf(B) + "." + String.valueOf(C) + "." +<span style="color: #000000;"> String.valueOf(D);
                    </span><span style="color: #0000ff;">if</span> (t.length() == s.length() + 3<span style="color: #000000;">) res.add(t);
                }
            }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
}</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/38342/who-can-beat-this-code/2" target="_blank">https://discuss.leetcode.com/topic/38342/who-can-beat-this-code/2</a></p>
<p><a href="https://discuss.leetcode.com/topic/20009/easy-java-code-of-backtracking-within-16-lines" target="_blank">https://discuss.leetcode.com/topic/20009/easy-java-code-of-backtracking-within-16-lines</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-02-28 15:28</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4305572" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4305572);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4306611.html" id="cb_post_title_url">[LeetCode] Reverse Linked List II 倒置链表之二</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Reverse a linked list from position <em>m</em> to <em>n</em>. Do it in-place and in one-pass.</p>
<p>For example:<br/>Given <code>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</code>, <em>m</em> = 2 and <em>n</em> = 4,</p>
<p>return <code>1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</code>.</p>
<p>Note:<br/>Given <em>m</em>, <em>n</em> satisfy the following condition:<br/>1 ≤ <em>m</em> ≤ <em>n</em> ≤ length of list.</p>
<p> </p>
<p>很奇怪为何没有倒置链表之一，就来了这个倒置链表之二，不过猜也能猜得到之一就是单纯的倒置整个链表，而这道作为延伸的地方就是倒置其中的某一小段。对于链表的问题，根据以往的经验一般都是要建一个dummy node，连上原链表的头结点，这样的话就算头结点变动了，我们还可以通过dummy-&gt;next来获得新链表的头结点。这道题的要求是只通过一次遍历完成，就拿题目中的例子来说，变换的是2,3,4这三个点，那么我们可以先取出2，用front指针指向2，然后当取出3的时候，我们把3加到2的前面，把front指针前移到3，依次类推，到4后停止，这样我们得到一个新链表4-&gt;3-&gt;2, front指针指向4。对于原链表连说，有两个点的位置很重要，需要用指针记录下来，分别是1和5，因为当2,3,4被取走时，原链表就变成了1-&gt;5-&gt;NULL，要把新链表插入的时候需要这两个点的位置。1的位置很好找，因为知道m的值，我们用pre指针记录1的位置，5的位置最后才能记录，当4结点被取走后，5的位置需要记下来，这样我们就可以把倒置后的那一小段链表加入到原链表中。代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">/*</span><span style="color: #008000;">*
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    ListNode </span>*reverseBetween(ListNode *head, <span style="color: #0000ff;">int</span> m, <span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        ListNode </span>*dummy = <span style="color: #0000ff;">new</span> ListNode(-<span style="color: #800080;">1</span><span style="color: #000000;">);
        dummy</span>-&gt;next =<span style="color: #000000;"> head;
        ListNode </span>*cur =<span style="color: #000000;"> dummy;
        ListNode </span>*pre, *front, *<span style="color: #000000;">last;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt;= m - <span style="color: #800080;">1</span>; ++i) cur = cur-&gt;<span style="color: #000000;">next;
        pre </span>=<span style="color: #000000;"> cur;
        last </span>= cur-&gt;<span style="color: #000000;">next;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = m; i &lt;= n; ++<span style="color: #000000;">i) {
            cur </span>= pre-&gt;<span style="color: #000000;">next;
            pre</span>-&gt;next = cur-&gt;<span style="color: #000000;">next;
            cur</span>-&gt;next =<span style="color: #000000;"> front;
            front </span>=<span style="color: #000000;"> cur;
        }
        cur </span>= pre-&gt;<span style="color: #000000;">next;
        pre</span>-&gt;next =<span style="color: #000000;"> front;
        last</span>-&gt;next =<span style="color: #000000;"> cur;
        </span><span style="color: #0000ff;">return</span> dummy-&gt;<span style="color: #000000;">next;
    }
};</span></pre>
</div>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-03-01 09:17</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4306611" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4306611);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4313384.html" id="cb_post_title_url">[LeetCode] Decode Ways 解码方法</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>A message containing letters from <code>A-Z</code> is being encoded to numbers using the following mapping:</p>
<pre>'A' -&gt; 1
'B' -&gt; 2
...
'Z' -&gt; 26
</pre>
<p>Given an encoded message containing digits, determine the total number of ways to decode it.</p>
<p>For example,<br/>Given encoded message <code>"12"</code>, it could be decoded as <code>"AB"</code> (1 2) or <code>"L"</code> (12).</p>
<p>The number of ways decoding <code>"12"</code> is 2.</p>
<p> </p>
<p>这道题要求解码方法，跟之前那道<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4079165.html" id="cb_post_title_url"> Climbing Stairs 爬梯子问题</a> 非常的相似，但是还有一些其他的限制条件，比如说一位数时不能为0，两位数不能大于26，其十位上的数也不能为0，出去这些限制条件，根爬梯子基本没啥区别，也勉强算特殊的斐波那契数列，当然需要用动态规划Dynamci Programming来解。建立一位dp数组，长度比输入数组长多多2，全部初始化为1，因为斐波那契数列的前两项也为1，然后从第三个数开始更新，对应数组的第一个数。对每个数组首先判断其是否为0，若是将改为dp赋0，若不是，赋上一个dp值，此时相当如加上了dp[i - 1], 然后看数组前一位是否存在，如果存在且满足前一位不是0，且和当前为一起组成的两位数不大于26，则当前dp值加上dp[i - 2], 至此可以看出来跟斐波那契数组的递推式一样，代码如下：</p>
<p> </p>
<p>C++ 解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> numDecodings(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        </span><span style="color: #0000ff;">if</span> (s.empty() || (s.size() &gt; <span style="color: #800080;">1</span> &amp;&amp; s[<span style="color: #800080;">0</span>] == <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span>)) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; dp(s.size() + <span style="color: #800080;">1</span>, <span style="color: #800080;">0</span><span style="color: #000000;">);
        dp[</span><span style="color: #800080;">0</span>] = <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt; dp.size(); ++<span style="color: #000000;">i) {
            dp[i] </span>= (s[i - <span style="color: #800080;">1</span>] == <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span>) ? <span style="color: #800080;">0</span> : dp[i - <span style="color: #800080;">1</span><span style="color: #000000;">];
            </span><span style="color: #0000ff;">if</span> (i &gt; <span style="color: #800080;">1</span> &amp;&amp; (s[i - <span style="color: #800080;">2</span>] == <span style="color: #800000;">'</span><span style="color: #800000;">1</span><span style="color: #800000;">'</span> || (s[i - <span style="color: #800080;">2</span>] == <span style="color: #800000;">'</span><span style="color: #800000;">2</span><span style="color: #800000;">'</span> &amp;&amp; s[i - <span style="color: #800080;">1</span>] &lt;= <span style="color: #800000;">'</span><span style="color: #800000;">6</span><span style="color: #800000;">'</span><span style="color: #000000;">))) {
                dp[i] </span>+= dp[i - <span style="color: #800080;">2</span><span style="color: #000000;">];
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> dp.back();
    }
};</span></pre>
</div>
<p> </p>
<p>Java 解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> numDecodings(String s) {
        </span><span style="color: #0000ff;">if</span> (s.isEmpty() || (s.length() &gt; 1 &amp;&amp; s.charAt(0) == '0')) <span style="color: #0000ff;">return</span> 0<span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span>[] dp = <span style="color: #0000ff;">new</span> <span style="color: #0000ff;">int</span>[s.length() + 1<span style="color: #000000;">];
        dp[</span>0] = 1<span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = 1; i &lt; dp.length; ++<span style="color: #000000;">i) {
            dp[i] </span>= (s.charAt(i - 1) == '0') ? 0 : dp[i - 1<span style="color: #000000;">];
            </span><span style="color: #0000ff;">if</span> (i &gt; 1 &amp;&amp; (s.charAt(i - 2) == '1' || (s.charAt(i - 2) == '2' &amp;&amp; s.charAt(i - 1) &lt;= '6'<span style="color: #000000;">))) {
                dp[i] </span>+= dp[i - 2<span style="color: #000000;">];
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> dp[s.length()];
    }
}</span></pre>
</div>
<p> </p>
<p>下面这种方法跟上面的方法的思路一样，只是写法略有不同：</p>
<p> </p>
<p>C++ 解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> numDecodings(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        </span><span style="color: #0000ff;">if</span> (s.empty()) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; dp(s.size() + <span style="color: #800080;">1</span>, <span style="color: #800080;">0</span><span style="color: #000000;">);
        dp[</span><span style="color: #800080;">0</span>] = <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt; dp.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (s[i - <span style="color: #800080;">1</span>] != <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span>) dp[i] += dp[i - <span style="color: #800080;">1</span><span style="color: #000000;">];
            </span><span style="color: #0000ff;">if</span> (i &gt;= <span style="color: #800080;">2</span> &amp;&amp; s.substr(i - <span style="color: #800080;">2</span>, <span style="color: #800080;">2</span>) &lt;= <span style="color: #800000;">"</span><span style="color: #800000;">26</span><span style="color: #800000;">"</span> &amp;&amp; s.substr(i - <span style="color: #800080;">2</span>, <span style="color: #800080;">2</span>) &gt;= <span style="color: #800000;">"</span><span style="color: #800000;">10</span><span style="color: #800000;">"</span><span style="color: #000000;">) {
                dp[i] </span>+= dp[i - <span style="color: #800080;">2</span><span style="color: #000000;">];
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> dp.back();
    }
};</span></pre>
</div>
<p> </p>
<p>我们再来看一种空间复杂度为O(1)的解法，我们用两个变量c1, c2来分别表示s[i-1]和s[i-2]的解码方法，然后我们从i=1开始遍历，也就是字符串的第二个字符，我们判断如果当前字符为'0'，说明当前字符不能单独拆分出来，只能和前一个字符一起，我们先将c1赋为0，然后我们看前面的字符，如果前面的字符是1或者2时，我们就可以更新c1 = c1 + c2，然后c2 = c1 - c2，其实c2赋值为之前的c1，如果不满足这些条件的话，那么c2 = c1，参见代码如下：</p>
<p> </p>
<p>C++ 解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> numDecodings(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        </span><span style="color: #0000ff;">if</span> (s.empty() || s.front() == <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span>) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> c1 = <span style="color: #800080;">1</span>, c2 = <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt; s.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (s[i] == <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span>) c1 = <span style="color: #800080;">0</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> (s[i - <span style="color: #800080;">1</span>] == <span style="color: #800000;">'</span><span style="color: #800000;">1</span><span style="color: #800000;">'</span> || (s[i - <span style="color: #800080;">1</span>] == <span style="color: #800000;">'</span><span style="color: #800000;">2</span><span style="color: #800000;">'</span> &amp;&amp; s[i] &lt;= <span style="color: #800000;">'</span><span style="color: #800000;">6</span><span style="color: #800000;">'</span><span style="color: #000000;">)) {
                c1 </span>= c1 +<span style="color: #000000;"> c2;
                c2 </span>= c1 -<span style="color: #000000;"> c2;
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                c2 </span>=<span style="color: #000000;"> c1;
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> c1;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/7025/a-concise-dp-solution" target="_blank">https://discuss.leetcode.com/topic/7025/a-concise-dp-solution</a></p>
<p><a href="https://discuss.leetcode.com/topic/6647/accepted-solution-to-decode-ways-no-need-to-take-care-of-0-case" target="_blank">https://discuss.leetcode.com/topic/6647/accepted-solution-to-decode-ways-no-need-to-take-care-of-0-case</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-03-04 15:03</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4313384" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4313384);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4310964.html" id="cb_post_title_url">[LeetCode] Subsets II 子集合之二</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a collection of integers that might contain duplicates, <em>S</em>, return all possible subsets.</p>
<p>Note:</p>
<ul>
<li>Elements in a subset must be in non-descending order.</li>
<li>The solution set must not contain duplicate subsets.</li>
</ul>
<p> </p>
<p>For example,<br/>If <em>S</em> = <code>[1,2,2]</code>, a solution is:</p>
<pre>[
  [2],
  [1],
  [1,2,2],
  [2,2],
  [1,2],
  []
]</pre>
<p> </p>
<p>这道子集合之二是之前那道<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4309345.html" id="homepage1_HomePageDays_DaysList_ctl01_DayList_TitleUrl_0"> Subsets 子集合</a> 的延伸，这次输入数组允许有重复项，其他条件都不变，只需要在之前那道题解法的基础上稍加改动便可以做出来，我们先来看非递归解法，拿题目中的例子[1 2 2]来分析，根据之前<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4309345.html" id="homepage1_HomePageDays_DaysList_ctl01_DayList_TitleUrl_0"> Subsets 子集合</a> 里的分析可知，当处理到第一个2时，此时的子集合为[], [1], [2], [1, 2]，而这时再处理第二个2时，如果在[]和[1]后直接加2会产生重复，所以只能在上一个循环生成的后两个子集合后面加2，发现了这一点，题目就可以做了，我们用last来记录上一个处理的数字，然后判定当前的数字和上面的是否相同，若不同，则循环还是从0到当前子集的个数，若相同，则新子集个数减去之前循环时子集的个数当做起点来循环，这样就不会产生重复了，代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; subsetsWithDup(vector&lt;<span style="color: #0000ff;">int</span>&gt; &amp;<span style="color: #000000;">S) {
        </span><span style="color: #0000ff;">if</span> (S.empty()) <span style="color: #0000ff;">return</span><span style="color: #000000;"> {};
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; res(<span style="color: #800080;">1</span><span style="color: #000000;">);
        sort(S.begin(), S.end());
        </span><span style="color: #0000ff;">int</span> size = <span style="color: #800080;">1</span>, last = S[<span style="color: #800080;">0</span><span style="color: #000000;">];
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; S.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (last !=<span style="color: #000000;"> S[i]) {
                last </span>=<span style="color: #000000;"> S[i];
                size </span>=<span style="color: #000000;"> res.size();
            }
            </span><span style="color: #0000ff;">int</span> newSize =<span style="color: #000000;"> res.size();
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = newSize - size; j &lt; newSize; ++<span style="color: #000000;">j) {
                res.push_back(res[j]);
                res.back().push_back(S[i]);
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>整个添加的顺序为：</p>
<p>[]<br/>[1]<br/>[2]<br/>[1 2]<br/>[2 2]<br/>[1 2 2]</p>
<p> </p>
<p><span style="font-size: 14px; line-height: 1.5;">对于递归的解法，根据之前<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4309345.html" id="homepage1_HomePageDays_DaysList_ctl01_DayList_TitleUrl_0"> Subsets 子集合</a> 里的构建树的方法，在处理到第二个2时，由于前面已经处理了一次2，这次我们只在添加过2的[2] 和 [1 2]后面添加2，其他的都不添加，那么这样构成的二叉树如下图所示：</span></p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">                        []        
                   </span>/<span style="color: #000000;">          \        
                  </span>/<span style="color: #000000;">            \     
                 </span>/<span style="color: #000000;">              \
              [</span><span style="color: #800080;">1</span><span style="color: #000000;">]                []
           </span>/       \           /<span style="color: #000000;">    \
          </span>/         \         /<span style="color: #000000;">      \        
       [</span><span style="color: #800080;">1</span> <span style="color: #800080;">2</span>]       [<span style="color: #800080;">1</span>]       [<span style="color: #800080;">2</span><span style="color: #000000;">]     []
      </span>/     \     /   \     /   \    /<span style="color: #000000;"> \
  [</span><span style="color: #800080;">1</span> <span style="color: #800080;">2</span> <span style="color: #800080;">2</span>] [<span style="color: #800080;">1</span> <span style="color: #800080;">2</span>]  X   [<span style="color: #800080;">1</span>]  [<span style="color: #800080;">2</span> <span style="color: #800080;">2</span>] [<span style="color: #800080;">2</span>] X  []</pre>
</div>
<p> </p>
<p>代码只需在原有的基础上增加一句话，while (S[i] == S[i + 1]) ++i; 这句话的作用是跳过树中为X的叶节点，因为它们是重复的子集，应被抛弃。代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; subsetsWithDup(vector&lt;<span style="color: #0000ff;">int</span>&gt; &amp;<span style="color: #000000;">S) {
        </span><span style="color: #0000ff;">if</span> (S.empty()) <span style="color: #0000ff;">return</span><span style="color: #000000;"> {};
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;<span style="color: #000000;"> res;
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; <span style="color: #0000ff;">out</span><span style="color: #000000;">;
        sort(S.begin(), S.end());
        getSubsets(S, </span><span style="color: #800080;">0</span>, <span style="color: #0000ff;">out</span><span style="color: #000000;">, res);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">void</span> getSubsets(vector&lt;<span style="color: #0000ff;">int</span>&gt; &amp;S, <span style="color: #0000ff;">int</span> pos, vector&lt;<span style="color: #0000ff;">int</span>&gt; &amp;<span style="color: #0000ff;">out</span>, vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; &amp;<span style="color: #000000;">res) {
        res.push_back(</span><span style="color: #0000ff;">out</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = pos; i &lt; S.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">out</span><span style="color: #000000;">.push_back(S[i]);
            getSubsets(S, i </span>+ <span style="color: #800080;">1</span>, <span style="color: #0000ff;">out</span><span style="color: #000000;">, res);
            </span><span style="color: #0000ff;">out</span><span style="color: #000000;">.pop_back();
            </span><span style="color: #0000ff;">while</span> (i + <span style="color: #800080;">1</span> &lt; S.size() &amp;&amp; S[i] == S[i + <span style="color: #800080;">1</span>]) ++<span style="color: #000000;">i;
        }
    }
};</span></pre>
</div>
<p> </p>
<p>整个添加的顺序为：</p>
<p>[]<br/>[1]<br/>[1 2]<br/>[1 2 2]<br/>[2]<br/>[2 2]<br/><br/></p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-03-03 14:57</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4310964" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4310964);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4315649.html" id="cb_post_title_url">[LeetCode] Gray Code 格雷码</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>The gray code is a binary numeral system where two successive values differ in only one bit.</p>
<p>Given a non-negative integer <em>n</em> representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0.</p>
<p>For example, given <em>n</em> = 2, return <code>[0,1,3,2]</code>. Its gray code sequence is:</p>
<pre>00 - 0
01 - 1
11 - 3
10 - 2
</pre>
<p><strong>Note:</strong><br/>
For a given <em>n</em>, a gray code sequence is not uniquely defined.
</p>
<p>For example, <code>[0,2,3,1]</code> is also a valid gray code sequence according to the above definition.</p>
<p>For now, the judge is able to judge based on one instance of gray code sequence. Sorry about that.</p>
<p> </p>
<p>这道题是关于<a href="http://zh.wikipedia.org/wiki/%E6%A0%BC%E9%9B%B7%E7%A0%81" target="_blank">格雷码</a>的，猛地一看感觉完全没接触过<a href="http://zh.wikipedia.org/wiki/%E6%A0%BC%E9%9B%B7%E7%A0%81" target="_blank">格雷码</a>，但是看了维基百科后，隐约的感觉原来好像哪门可提到过，哎全还给老师了。这道题如果不了解格雷码，还真不太好做，幸亏脑补了维基百科，上面说格雷码是一种循环二进制单位距离码，主要特点是两个相邻数的代码只有一位二进制数不同的编码，格雷码的处理主要是位操作 Bit Operation，LeetCode中关于位操作的题也挺常见，比如 <a class="entrylistItemTitle" href="http://www.cnblogs.com/grandyang/p/4284205.html" id="CategoryEntryList1_EntryStoryList_ctl00_Entries_TitleUrl_24">Repeated DNA Sequences 求重复的DNA序列</a>，<a class="entrylistItemTitle" href="http://www.cnblogs.com/grandyang/p/4130577.html" id="CategoryEntryList1_EntryStoryList_ctl00_Entries_TitleUrl_57"> Single Number 单独的数字</a>, 和 <a class="entrylistItemTitle" href="http://www.cnblogs.com/grandyang/p/4263927.html" id="CategoryEntryList1_EntryStoryList_ctl00_Entries_TitleUrl_35"> Single Number II 单独的数字之二</a> 等等。三位的格雷码和二进制数如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">Int    Grey Code    Binary
 </span><span style="color: #800080;">0</span>  　　  <span style="color: #800080;">000</span>        <span style="color: #800080;">000</span>
 <span style="color: #800080;">1</span>  　　  <span style="color: #800080;">001</span>        <span style="color: #800080;">001</span>
 <span style="color: #800080;">2</span>   　 　<span style="color: #800080;">011</span>        <span style="color: #800080;">010</span>
 <span style="color: #800080;">3</span>   　 　<span style="color: #800080;">010</span>        <span style="color: #800080;">011</span>
 <span style="color: #800080;">4</span>   　 　<span style="color: #800080;">110</span>        <span style="color: #800080;">100</span>
 <span style="color: #800080;">5</span>   　 　<span style="color: #800080;">111</span>        <span style="color: #800080;">101</span>
 <span style="color: #800080;">6</span>   　 　<span style="color: #800080;">101</span>        <span style="color: #800080;">110</span>
 <span style="color: #800080;">7</span>   　　 <span style="color: #800080;">100</span>        <span style="color: #800080;">111</span></pre>
</div>
<p> </p>
<p>其实这道题还有多种解法。首先来看一种最简单的，是用到格雷码和二进制数之间的相互转化，可参见我之前的博客 <a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4315607.html" id="homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_1">Convertion of grey code and binary 格雷码和二进制数之间的转换</a> ，明白了转换方法后，这道题完全没有难度，代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> Binary to grey code</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; grayCode(<span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; pow(<span style="color: #800080;">2</span>,n); ++<span style="color: #000000;">i) {
            res.push_back((i </span>&gt;&gt; <span style="color: #800080;">1</span>) ^<span style="color: #000000;"> i);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>然后我们来看看其他的解法，参考维基百科上关于格雷码的性质，有一条是说<a href="http://zh.wikipedia.org/wiki/%E6%A0%BC%E9%9B%B7%E7%A0%81" target="_blank">镜面排列</a>的，n位元的格雷码可以从n-1位元的格雷码以上下镜射后加上新位元的方式快速的得到，如下图所示一般。</p>
<p><img alt="" src="http://upload.wikimedia.org/wikipedia/commons/thumb/c/c1/Binary-reflected_Gray_code_construction.svg/250px-Binary-reflected_Gray_code_construction.svg.png"/></p>
<p>有了这条性质，我们很容易的写出代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> Mirror arrangement</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; grayCode(<span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; res{<span style="color: #800080;">0</span><span style="color: #000000;">};
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">int</span> size =<span style="color: #000000;"> res.size();
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = size - <span style="color: #800080;">1</span>; j &gt;= <span style="color: #800080;">0</span>; --<span style="color: #000000;">j) {
                res.push_back(res[j] </span>| (<span style="color: #800080;">1</span> &lt;&lt;<span style="color: #000000;"> i));
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p><span style="line-height: 1.5;"> </span></p>
<p>维基百科上还有一条格雷码的性质是<a href="http://zh.wikipedia.org/wiki/%E6%A0%BC%E9%9B%B7%E7%A0%81" target="_blank">直接排列</a>，以二进制为0值的格雷码为第零项，第一项改变最右边的位元，第二项改变右起第一个为1的位元的左边位元，第三、四项方法同第一、二项，如此反复，即可排列出n个位元的格雷码。根据这条性质也可以写出代码，不过相比前面的略微复杂，代码如下：</p>
<p>0 0 0<br/>0 0 <span style="color: #ff0000;">1</span><br/>0 <span style="color: #ff0000;">1</span> 1<br/>0 1 <span style="color: #ff0000;">0</span><br/><span style="color: #ff0000;">1</span> 1 0<br/>1 1 <span style="color: #ff0000;">1</span><br/>1 <span style="color: #ff0000;">0</span> 1<br/>1 0 <span style="color: #ff0000;">0</span></p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> Direct arrangement </span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; grayCode(<span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; res{<span style="color: #800080;">0</span><span style="color: #000000;">};
        </span><span style="color: #0000ff;">int</span> len = pow(<span style="color: #800080;">2</span><span style="color: #000000;">, n);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt; len; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">int</span> pre =<span style="color: #000000;"> res.back();
            </span><span style="color: #0000ff;">if</span> (i % <span style="color: #800080;">2</span> == <span style="color: #800080;">1</span><span style="color: #000000;">) {
                pre </span>= (pre &amp; (len - <span style="color: #800080;">2</span>)) | ((~pre) &amp; <span style="color: #800080;">1</span><span style="color: #000000;">);
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                </span><span style="color: #0000ff;">int</span> cnt = <span style="color: #800080;">1</span>, t =<span style="color: #000000;"> pre;
                </span><span style="color: #0000ff;">while</span> ((t &amp; <span style="color: #800080;">1</span>) != <span style="color: #800080;">1</span><span style="color: #000000;">) {
                    </span>++<span style="color: #000000;">cnt;
                    t </span>&gt;&gt;= <span style="color: #800080;">1</span><span style="color: #000000;">;
                }
                </span><span style="color: #0000ff;">if</span> ((pre &amp; (<span style="color: #800080;">1</span> &lt;&lt; cnt)) == <span style="color: #800080;">0</span>) pre |= (<span style="color: #800080;">1</span> &lt;&lt;<span style="color: #000000;"> cnt);
                </span><span style="color: #0000ff;">else</span> pre &amp;= ~(<span style="color: #800080;">1</span> &lt;&lt;<span style="color: #000000;"> cnt);
            }
            res.push_back(pre);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>上面三种解法都需要事先了解格雷码及其性质，假如我们之前并没有接触过格雷码，那么我们其实也可以用比较笨的方法来找出结果，比如下面这种方法用到了一个set来保存已经产生的结果，我们从0开始，遍历其二进制每一位，对其取反，然后看其是否在set中出现过，如果没有，我们将其加入set和结果res中，然后再对这个数的每一位进行遍历，以此类推就可以找出所有的格雷码了，参见代码如下：</p>
<p> </p>
<p>解法四：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; grayCode(<span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> res;
        unordered_set</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> s;
        helper(n, s, </span><span style="color: #800080;">0</span><span style="color: #000000;">, res);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">void</span> helper(<span style="color: #0000ff;">int</span> n, unordered_set&lt;<span style="color: #0000ff;">int</span>&gt;&amp; s, <span style="color: #0000ff;">int</span> <span style="color: #0000ff;">out</span>, vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> res) {
        </span><span style="color: #0000ff;">if</span> (!s.count(<span style="color: #0000ff;">out</span><span style="color: #000000;">)) {
            s.insert(</span><span style="color: #0000ff;">out</span><span style="color: #000000;">);
            res.push_back(</span><span style="color: #0000ff;">out</span><span style="color: #000000;">);
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">int</span> t = <span style="color: #0000ff;">out</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> ((t &amp; (<span style="color: #800080;">1</span> &lt;&lt; i)) == <span style="color: #800080;">0</span>) t |= (<span style="color: #800080;">1</span> &lt;&lt;<span style="color: #000000;"> i);
            </span><span style="color: #0000ff;">else</span> t &amp;= ~(<span style="color: #800080;">1</span> &lt;&lt;<span style="color: #000000;"> i);
            </span><span style="color: #0000ff;">if</span> (s.count(t)) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
            helper(n, s, t, res);
            </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
        }
    }
};</span></pre>
</div>
<p> </p>
<p>既然递归方法可以实现，那么就有对应的迭代的写法，当然需要用stack来辅助，参见代码如下：</p>
<p> </p>
<p>解法五：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; grayCode(<span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; res{<span style="color: #800080;">0</span><span style="color: #000000;">};
        unordered_set</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> s;
        stack</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> st;
        st.push(</span><span style="color: #800080;">0</span><span style="color: #000000;">);
        s.insert(</span><span style="color: #800080;">0</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">while</span> (!<span style="color: #000000;">st.empty()) {
            </span><span style="color: #0000ff;">int</span> t =<span style="color: #000000;"> st.top(); st.pop();
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
                </span><span style="color: #0000ff;">int</span> k =<span style="color: #000000;"> t;
                </span><span style="color: #0000ff;">if</span> ((k &amp; (<span style="color: #800080;">1</span> &lt;&lt; i)) == <span style="color: #800080;">0</span>) k |= (<span style="color: #800080;">1</span> &lt;&lt;<span style="color: #000000;"> i);
                </span><span style="color: #0000ff;">else</span> k &amp;= ~(<span style="color: #800080;">1</span> &lt;&lt;<span style="color: #000000;"> i);
                </span><span style="color: #0000ff;">if</span> (s.count(k)) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                s.insert(k);
                st.push(k);
                res.push_back(k);
                </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/8557/an-accepted-three-line-solution-in-java" target="_blank">https://discuss.leetcode.com/topic/8557/an-accepted-three-line-solution-in-java</a></p>
<p><span style="line-height: 1.5;"> </span></p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-03-05 13:52</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4315649" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4315649);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4059650.html" id="cb_post_title_url">[LeetCode] Merge Sorted Array  混合插入有序数组</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p>Given two sorted integer arrays A and B, merge B into A as one sorted array.</p>
<p>Note:<br/>You may assume that A has enough space (size that is greater or equal to <em>m</em> + <em>n</em>) to hold additional elements from B. The number of elements initialized in A and B are <em>m</em> and<em>n</em> respectively.</p>
<p> </p>
<p>混合插入有序数组，由于两个数组都是有序的，所有只要按顺序比较大小即可。最先想到的方法是建立一个m+n大小的新数组，然后逐个从A和B数组中取出元素比较，把较小的加入新数组，然后在考虑A数组有剩余和B数组有剩余的两种情况，最后在把新数组的元素重新赋值到A数组中即可。代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">void</span> merge(<span style="color: #0000ff;">int</span> A[], <span style="color: #0000ff;">int</span> m, <span style="color: #0000ff;">int</span> B[], <span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        </span><span style="color: #0000ff;">if</span> (m &lt;= <span style="color: #800080;">0</span> &amp;&amp; n &lt;= <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> a = <span style="color: #800080;">0</span>, b = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> C[m +<span style="color: #000000;"> n];
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; m + n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (a &lt; m &amp;&amp; b &lt;<span style="color: #000000;"> n) {
                </span><span style="color: #0000ff;">if</span> (A[a] &lt;<span style="color: #000000;"> B[b]) {
                    C[i] </span>=<span style="color: #000000;"> A[a];
                    </span>++<span style="color: #000000;">a;
                }
                </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    C[i] </span>=<span style="color: #000000;"> B[b];
                    </span>++<span style="color: #000000;">b;
                }
            }
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (a &lt; m &amp;&amp; b &gt;=<span style="color: #000000;"> n) {
                C[i] </span>=<span style="color: #000000;"> A[a];
                </span>++<span style="color: #000000;">a;
            }
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (a &gt;= m &amp;&amp; b &lt;<span style="color: #000000;"> n) {
                C[i] </span>=<span style="color: #000000;"> B[b];
                </span>++<span style="color: #000000;">b;
            }
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">return</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; m + n; ++i) A[i] =<span style="color: #000000;"> C[i];
    }
};</span></pre>
</div>
<p> </p>
<p>这样固然没错，但是还有更简洁的方法，而且不用申请新变量。算法思想是：由于合并后A数组的大小必定是m+n，所以从最后面开始往前赋值，先比较A和B中最后一个元素的大小，把较大的那个插入到m+n-1的位置上，再依次向前推。如果A中所有的元素都比B小，那么前m个还是A原来的内容，没有改变。如果A中的数组比B大的，当A循环完了，B中还有元素没加入A，直接用个循环把B中所有的元素覆盖到A剩下的位置。代码如下:</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">void</span> merge(<span style="color: #0000ff;">int</span> A[], <span style="color: #0000ff;">int</span> m, <span style="color: #0000ff;">int</span> B[], <span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        </span><span style="color: #0000ff;">int</span> count = m + n - <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span>--m; --<span style="color: #000000;">n;
        </span><span style="color: #0000ff;">while</span> (m &gt;= <span style="color: #800080;">0</span> &amp;&amp; n &gt;= <span style="color: #800080;">0</span>) A[count--] = A[m] &gt; B[n] ? A[m--] : B[n--<span style="color: #000000;">];
        </span><span style="color: #0000ff;">while</span> (n &gt;= <span style="color: #800080;">0</span>) A[count--] = B[n--<span style="color: #000000;">];
    }
};</span></pre>
</div>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2014-10-29 15:25</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4059650" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4059650);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4318500.html" id="cb_post_title_url">[LeetCode] Scramble String 爬行字符串</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a string <em>s1</em>, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively.</p>
<p>Below is one possible representation of <em>s1</em> = <code>"great"</code>:</p>
<pre>    great
   /    \
  gr    eat
 / \    /  \
g   r  e   at
           / \
          a   t
</pre>
<p>To scramble the string, we may choose any non-leaf node and swap its two children.</p>
<p>For example, if we choose the node <code>"gr"</code> and swap its two children, it produces a scrambled string<code>"rgeat"</code>.</p>
<pre>    rgeat
   /    \
  rg    eat
 / \    /  \
r   g  e   at
           / \
          a   t
</pre>
<p>We say that <code>"rgeat"</code> is a scrambled string of <code>"great"</code>.</p>
<p>Similarly, if we continue to swap the children of nodes <code>"eat"</code> and <code>"at"</code>, it produces a scrambled string<code>"rgtae"</code>.</p>
<pre>    rgtae
   /    \
  rg    tae
 / \    /  \
r   g  ta  e
       / \
      t   a
</pre>
<p>We say that <code>"rgtae"</code> is a scrambled string of <code>"great"</code>.</p>
<p>Given two strings <em>s1</em> and <em>s2</em> of the same length, determine if <em>s2</em> is a scrambled string of <em>s1</em>.</p>
<p> </p>
<p>这道题定义了一种爬行字符串，就是说假如把一个字符串当做一个二叉树的根，然后它的非空子字符串是它的子节点，然后交换某个子字符串的两个子节点，重新爬行回去形成一个新的字符串，这个新字符串和原来的字符串互为爬行字符串。这道题可以用递归Recursion或是动态规划Dynamic Programming来做，我们先来看递归的解法，参见网友<a href="http://blog.unieagle.net/2012/10/23/leetcode%E9%A2%98%E7%9B%AE%EF%BC%9Ascramble-string%EF%BC%8C%E4%B8%89%E7%BB%B4%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" target="_blank">uniEagle的博客</a>，<strong>简单的说，就是s1和s2是scramble的话，那么必然存在一个在s1上的长度l1，将s1分成s11和s12两段，同样有s21和s22.那么要么s11和s21是scramble的并且s12和s22是scramble的；要么s11和s22是scramble的并且s12和s21是scramble的。</strong>就拿题目中的例子 rgeat 和 great 来说，rgeat 可分成 rg 和 eat 两段， great 可分成 gr 和 eat 两段，rg 和 gr 是scrambled的， eat 和 eat 当然是scrambled。根据这点，我们可以写出代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> Recursion</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> isScramble(<span style="color: #0000ff;">string</span> s1, <span style="color: #0000ff;">string</span><span style="color: #000000;"> s2) {
        </span><span style="color: #0000ff;">if</span> (s1.size() != s2.size()) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (s1 == s2) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">string</span> str1 = s1, str2 =<span style="color: #000000;"> s2;
        sort(str1.begin(), str1.end());
        sort(str2.begin(), str2.end());
        </span><span style="color: #0000ff;">if</span> (str1 != str2) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt; s1.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">string</span> s11 = s1.substr(<span style="color: #800080;">0</span><span style="color: #000000;">, i);
            </span><span style="color: #0000ff;">string</span> s12 =<span style="color: #000000;"> s1.substr(i);
            </span><span style="color: #0000ff;">string</span> s21 = s2.substr(<span style="color: #800080;">0</span><span style="color: #000000;">, i);
            </span><span style="color: #0000ff;">string</span> s22 =<span style="color: #000000;"> s2.substr(i);
            </span><span style="color: #0000ff;">if</span> (isScramble(s11, s21) &amp;&amp; isScramble(s12, s22)) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
            s21 </span>= s2.substr(s1.size() -<span style="color: #000000;"> i);
            s22 </span>= s2.substr(<span style="color: #800080;">0</span>, s1.size() -<span style="color: #000000;"> i);
            </span><span style="color: #0000ff;">if</span> (isScramble(s11, s21) &amp;&amp; isScramble(s12, s22)) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>当然，这道题也可以用动态规划Dynamic Programming，根据以往的经验来说，根字符串有关的题十有八九可以用DP来做，那么难点就在于如何找出递推公式。参见网友<a href="http://blog.csdn.net/linhuanmars/article/details/24506703" target="_blank">Code Ganker的博客</a>，这其实是一道三维动态规划的题目，我们提出维护量res[i][j][n]，其中i是s1的起始字符，j是s2的起始字符，而n是当前的字符串长度，res[i][j][len]表示的是以i和j分别为s1和s2起点的长度为len的字符串是不是互为scramble。<br/>有了维护量我们接下来看看递推式，也就是怎么根据历史信息来得到res[i][j][len]。判断这个是不是满足，其实我们首先是把当前s1[i...i+len-1]字符串劈一刀分成两部分，然后分两种情况：第一种是左边和s2[j...j+len-1]左边部分是不是scramble，以及右边和s2[j...j+len-1]右边部分是不是scramble；第二种情况是左边和s2[j...j+len-1]右边部分是不是scramble，以及右边和s2[j...j+len-1]左边部分是不是scramble。如果以上两种情况有一种成立，说明s1[i...i+len-1]和s2[j...j+len-1]是scramble的。而对于判断这些左右部分是不是scramble我们是有历史信息的，因为长度小于n的所有情况我们都在前面求解过了（也就是长度是最外层循环）。<br/>上面说的是劈一刀的情况，对于s1[i...i+len-1]我们有len-1种劈法，在这些劈法中只要有一种成立，那么两个串就是scramble的。<br/>总结起来递推式是res[i][j][len] = || (res[i][j][k]&amp;&amp;res[i+k][j+k][len-k] || res[i][j+len-k][k]&amp;&amp;res[i+k][j][len-k]) 对于所有1&lt;=k&lt;len，也就是对于所有len-1种劈法的结果求或运算。因为信息都是计算过的，对于每种劈法只需要常量操作即可完成，因此求解递推式是需要O(len)（因为len-1种劈法）。<br/>如此总时间复杂度因为是三维动态规划，需要三层循环，加上每一步需要线行时间求解递推式，所以是O(n^4)。虽然已经比较高了，但是至少不是指数量级的，动态规划还是有很大优势的，空间复杂度是O(n^3)。代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> DP </span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> isScramble(<span style="color: #0000ff;">string</span> s1, <span style="color: #0000ff;">string</span><span style="color: #000000;"> s2) {
        </span><span style="color: #0000ff;">if</span> (s1.size() != s2.size()) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (s1 == s2) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> n =<span style="color: #000000;"> s1.size();
        vector</span>&lt;vector&lt;vector&lt;<span style="color: #0000ff;">bool</span>&gt; &gt; &gt; dp (n, vector&lt;vector&lt;<span style="color: #0000ff;">bool</span>&gt; &gt;(n, vector&lt;<span style="color: #0000ff;">bool</span>&gt;(n + <span style="color: #800080;">1</span>, <span style="color: #0000ff;">false</span><span style="color: #000000;">)));
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; n; ++<span style="color: #000000;">j) {
                dp[i][j][</span><span style="color: #800080;">1</span>] = s1[i] ==<span style="color: #000000;"> s2[j];
            }
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> len = <span style="color: #800080;">2</span>; len &lt;= n; ++<span style="color: #000000;">len) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt;= n - len; ++<span style="color: #000000;">i) {
                </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt;= n - len; ++<span style="color: #000000;">j) {
                    </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> k = <span style="color: #800080;">1</span>; k &lt; len; ++<span style="color: #000000;">k) {
                        </span><span style="color: #0000ff;">if</span> ((dp[i][j][k] &amp;&amp; dp[i + k][j + k][len - k]) || (dp[i + k][j][len - k] &amp;&amp; dp[i][j + len -<span style="color: #000000;"> k][k])) {
                            dp[i][j][len] </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                        }
                    }
                }
            }
        }
        </span><span style="color: #0000ff;">return</span> dp[<span style="color: #800080;">0</span>][<span style="color: #800080;">0</span><span style="color: #000000;">][n];
    }
};</span></pre>
</div>
<p> </p>
<p>上面的代码的实现过程如下，首先按单个字符比较，判断它们之间是否是scrambled的。在更新第二个表中第一个值(gr和rg是否为scrambled的)时，比较了第一个表中的两种构成，一种是 g与r, r与g，另一种是 g与g, r与r，其中后者是真，只要其中一个为真，则将该值赋真。其实这个原理和之前递归的原理很像，在判断某两个字符串是否为scrambled时，比较它们所有可能的拆分方法的子字符串是否是scrambled的，只要有一个种拆分方法为真，则比较的两个字符串一定是scrambled的。比较 rge 和 gre 的实现过程如下所示：</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">     r    g    e
g    x    √    x
r    √    x    x
e    x    x    √


     rg    ge
gr    √    x
re    x    x


     rge
gre   √</span></pre>
</div>
<p> </p>
<p>DP的另一种写法，参考<a href="http://blog.sina.com.cn/s/blog_b9285de20101gy6n.html" target="_blank">网友加载中..的博客</a>，思路都一样，代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> Still DP</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> isScramble(<span style="color: #0000ff;">string</span> s1, <span style="color: #0000ff;">string</span><span style="color: #000000;"> s2) {
        </span><span style="color: #0000ff;">if</span> (s1.size() != s2.size()) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (s1 == s2) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> n =<span style="color: #000000;"> s1.size();
        vector</span>&lt;vector&lt;vector&lt;<span style="color: #0000ff;">bool</span>&gt; &gt; &gt; dp (n, vector&lt;vector&lt;<span style="color: #0000ff;">bool</span>&gt; &gt;(n, vector&lt;<span style="color: #0000ff;">bool</span>&gt;(n + <span style="color: #800080;">1</span>, <span style="color: #0000ff;">false</span><span style="color: #000000;">)));
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = n - <span style="color: #800080;">1</span>; i &gt;= <span style="color: #800080;">0</span>; --<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = n - <span style="color: #800080;">1</span>; j &gt;= <span style="color: #800080;">0</span>; --<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> k = <span style="color: #800080;">1</span>; k &lt;= n - max(i, j); ++<span style="color: #000000;">k) {
                    </span><span style="color: #0000ff;">if</span> (s1.substr(i, k) ==<span style="color: #000000;"> s2.substr(j, k)) {
                        dp[i][j][k] </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                    } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> t = <span style="color: #800080;">1</span>; t &lt; k; ++<span style="color: #000000;">t) {
                            </span><span style="color: #0000ff;">if</span> ((dp[i][j][t] &amp;&amp; dp[i + t][j + t][k - t]) || (dp[i][j + k - t][t] &amp;&amp; dp[i + t][j][k -<span style="color: #000000;"> t])) {
                                dp[i][j][k] </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                                </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                            }
                        }
                    }
                }
            }
        }
        </span><span style="color: #0000ff;">return</span> dp[<span style="color: #800080;">0</span>][<span style="color: #800080;">0</span><span style="color: #000000;">][n];
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种解法和第一个解法思路相同，只不过没有用排序算法，而是采用了类似于求异构词的方法，用一个数组来保存每个字母出现的次数，后面判断Scramble字符串的方法和之前的没有区别：</p>
<p> </p>
<p>解法四：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> isScramble(<span style="color: #0000ff;">string</span> s1, <span style="color: #0000ff;">string</span><span style="color: #000000;"> s2) {
        </span><span style="color: #0000ff;">if</span> (s1 == s2) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (s1.size() != s2.size()) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> n = s1.size(), m[<span style="color: #800080;">26</span>] = {<span style="color: #800080;">0</span><span style="color: #000000;">};
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span>++m[s1[i] - <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span><span style="color: #000000;">];
            </span>--m[s2[i] - <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span><span style="color: #000000;">];
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; <span style="color: #800080;">26</span>; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (m[i] != <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> ((isScramble(s1.substr(<span style="color: #800080;">0</span>, i), s2.substr(<span style="color: #800080;">0</span>, i)) &amp;&amp; isScramble(s1.substr(i), s2.substr(i))) || (isScramble(s1.substr(<span style="color: #800080;">0</span>, i), s2.substr(n - i)) &amp;&amp; isScramble(s1.substr(i), s2.substr(<span style="color: #800080;">0</span>, n -<span style="color: #000000;"> i)))) {
                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
            }
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种解法实际上是解法二的递归形式，我们用了memo数组来减少了大量的运算，注意这里的memo数组一定要有三种状态，初始化为-1，区域内为scramble是1，不是scramble是0，这样就避免了已经算过了某个区间，但由于不是scramble，从而又进行一次计算，从而会TLE，感谢网友<a href="http://www.cnblogs.com/bambu/" id="a_comment_author_3803895" target="_blank">bambu</a>的提供的思路，参见代码如下：</p>
<p> </p>
<p>解法五：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> isScramble(<span style="color: #0000ff;">string</span> s1, <span style="color: #0000ff;">string</span><span style="color: #000000;"> s2) {
        </span><span style="color: #0000ff;">if</span> (s1 == s2) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (s1.size() != s2.size()) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> n =<span style="color: #000000;"> s1.size();
        vector</span>&lt;vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&gt; memo(n, vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;(n, vector&lt;<span style="color: #0000ff;">int</span>&gt;(n + <span style="color: #800080;">1</span>, -<span style="color: #800080;">1</span><span style="color: #000000;">)));
        </span><span style="color: #0000ff;">return</span> helper(s1, s2, <span style="color: #800080;">0</span>, <span style="color: #800080;">0</span><span style="color: #000000;">, n, memo);
    }
    </span><span style="color: #0000ff;">bool</span> helper(<span style="color: #0000ff;">string</span>&amp; s1, <span style="color: #0000ff;">string</span>&amp; s2, <span style="color: #0000ff;">int</span> idx1, <span style="color: #0000ff;">int</span> idx2, <span style="color: #0000ff;">int</span> len, vector&lt;vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&gt;&amp;<span style="color: #000000;"> memo) {
        </span><span style="color: #0000ff;">if</span> (len == <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (len == <span style="color: #800080;">1</span>) memo[idx1][idx2][len] = s1[idx1] ==<span style="color: #000000;"> s2[idx2];
        </span><span style="color: #0000ff;">if</span> (memo[idx1][idx2][len] != -<span style="color: #800080;">1</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;"> memo[idx1][idx2][len];
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> k = <span style="color: #800080;">1</span>; k &lt; len; ++<span style="color: #000000;">k) {
            </span><span style="color: #0000ff;">if</span> ((helper(s1, s2, idx1, idx2, k, memo) &amp;&amp; helper(s1, s2, idx1 + k, idx2 + k, len - k, memo)) || (helper(s1, s2, idx1, idx2 + len - k, k, memo) &amp;&amp; helper(s1, s2, idx1 + k, idx2, len -<span style="color: #000000;"> k, memo))) {
                </span><span style="color: #0000ff;">return</span> memo[idx1][idx2][len] = <span style="color: #800080;">1</span><span style="color: #000000;">;
            }
        }
        </span><span style="color: #0000ff;">return</span> memo[idx1][idx2][len] = <span style="color: #800080;">0</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/14337/share-my-4ms-c-recursive-solution" target="_blank">https://discuss.leetcode.com/topic/14337/share-my-4ms-c-recursive-solution</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-03-06 15:53</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4318500" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4318500);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4321292.html" id="cb_post_title_url">[LeetCode] Partition List 划分链表</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a linked list and a value <em>x</em>, partition it such that all nodes less than <em>x</em> come before nodes greater than or equal to <em>x</em>.</p>
<p>You should preserve the original relative order of the nodes in each of the two partitions.</p>
<p>For example,<br/>Given <code>1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2</code> and <em>x</em> = 3,<br/>return <code>1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</code>.</p>
<p> </p>
<p>这道题要求我们划分链表，把所有小于给定值的节点都移到前面，大于该值的节点顺序不变，相当于一个局部排序的问题。那么可以想到的一种解法是首先找到第一个大于或等于给定值的节点，用题目中给的例子来说就是先找到4，然后再找小于3的值，每找到一个就将其取出置于4之前即可，代码如下：</p>
<p>解法一</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    ListNode </span>*partition(ListNode *head, <span style="color: #0000ff;">int</span><span style="color: #000000;"> x) {
        ListNode </span>*dummy = <span style="color: #0000ff;">new</span> ListNode(-<span style="color: #800080;">1</span><span style="color: #000000;">);
        dummy</span>-&gt;next =<span style="color: #000000;"> head;
        ListNode </span>*pre = dummy, *cur =<span style="color: #000000;"> head;;
        </span><span style="color: #0000ff;">while</span> (pre-&gt;next &amp;&amp; pre-&gt;next-&gt;val &lt; x) pre = pre-&gt;<span style="color: #000000;">next;
        cur </span>=<span style="color: #000000;"> pre;
        </span><span style="color: #0000ff;">while</span> (cur-&gt;<span style="color: #000000;">next) {
            </span><span style="color: #0000ff;">if</span> (cur-&gt;next-&gt;val &lt;<span style="color: #000000;"> x) {
                ListNode </span>*tmp = cur-&gt;<span style="color: #000000;">next;
                cur</span>-&gt;next = tmp-&gt;<span style="color: #000000;">next;
                tmp</span>-&gt;next = pre-&gt;<span style="color: #000000;">next;
                pre</span>-&gt;next =<span style="color: #000000;"> tmp;
                pre </span>= pre-&gt;<span style="color: #000000;">next;
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                cur </span>= cur-&gt;<span style="color: #000000;">next;
            }
        }
        </span><span style="color: #0000ff;">return</span> dummy-&gt;<span style="color: #000000;">next;
    }
};</span></pre>
</div>
<p> </p>
<p> </p>
<p>这种解法的链表变化顺序为：</p>
<p>1 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; 2 </p>
<p>1 -&gt; 2 -&gt; 4 -&gt; 3 -&gt; 5 -&gt; 2 </p>
<p>1 -&gt; 2 -&gt; 2 -&gt; 4 -&gt; 3 -&gt; 5</p>
<p> </p>
<p>此题还有一种解法，就是将所有小于给定值的节点取出组成一个新的链表，此时原链表中剩余的节点的值都大于或等于给定值，只要将原链表直接接在新链表后即可，代码如下：</p>
<p>解法二</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    ListNode </span>*partition(ListNode *head, <span style="color: #0000ff;">int</span><span style="color: #000000;"> x) {
        </span><span style="color: #0000ff;">if</span> (!head) <span style="color: #0000ff;">return</span><span style="color: #000000;"> head;
        ListNode </span>*dummy = <span style="color: #0000ff;">new</span> ListNode(-<span style="color: #800080;">1</span><span style="color: #000000;">);
        ListNode </span>*newDummy = <span style="color: #0000ff;">new</span> ListNode(-<span style="color: #800080;">1</span><span style="color: #000000;">);
        dummy</span>-&gt;next =<span style="color: #000000;"> head;
        ListNode </span>*cur = dummy, *p =<span style="color: #000000;"> newDummy;
        </span><span style="color: #0000ff;">while</span> (cur-&gt;<span style="color: #000000;">next) {
            </span><span style="color: #0000ff;">if</span> (cur-&gt;next-&gt;val &lt;<span style="color: #000000;"> x) {
                p</span>-&gt;next = cur-&gt;<span style="color: #000000;">next;
                p </span>= p-&gt;<span style="color: #000000;">next;
                cur</span>-&gt;next = cur-&gt;next-&gt;<span style="color: #000000;">next;
                p</span>-&gt;next =<span style="color: #000000;"> NULL;
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                cur </span>= cur-&gt;<span style="color: #000000;">next;
            }
        }
        p</span>-&gt;next = dummy-&gt;<span style="color: #000000;">next;
        </span><span style="color: #0000ff;">return</span> newDummy-&gt;<span style="color: #000000;">next;
    }
};</span></pre>
</div>
<p> </p>
<p>此种解法链表变化顺序为：</p>
<p>Original: 1 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; 2 </p>
<p>New:</p>
<p> </p>
<p>Original: 4 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; 2 </p>
<p>New:　  1</p>
<p> </p>
<p>Original: 4 -&gt; 3 -&gt; 5 -&gt; 2 </p>
<p>New:　  1 -&gt; 2</p>
<p> </p>
<p>Original: 4 -&gt; 3 -&gt; 5 </p>
<p>New:　  1 -&gt; 2 -&gt; 2</p>
<p> </p>
<p>Original: </p>
<p>New:　  1 -&gt; 2 -&gt; 2 -&gt; 4 -&gt; 3 -&gt; 5 </p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-03-08 08:37</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4321292" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4321292);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4322667.html" id="cb_post_title_url">[LeetCode] Maximal Rectangle 最大矩形</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a 2D binary matrix filled with 0's and 1's, find the largest rectangle containing all ones and return its area.</p>
<p> </p>
<p>此题是之前那道的<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4322653.html" id="homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0"> Largest Rectangle in Histogram 直方图中最大的矩形</a> 的扩展，这道题的二维矩阵每一层向上都可以看做一个直方图，输入矩阵有多少行，就可以形成多少个直方图，对每个直方图都调用<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4322653.html" id="homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0"> Largest Rectangle in Histogram 直方图中最大的矩形</a> 中的方法，就可以得到最大的矩形面积。那么这道题唯一要做的就是将每一层构成直方图，由于题目限定了输入矩阵的字符只有 '0' 和 '1' 两种，所以处理起来也相对简单。方法是，对于每一个点，如果是‘0’，则赋0，如果是 ‘1’，就赋 之前的height值加上1。具体参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> maximalRectangle(vector&lt;vector&lt;<span style="color: #0000ff;">char</span>&gt; &gt; &amp;<span style="color: #000000;">matrix) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> height;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; matrix.size(); ++<span style="color: #000000;">i) {
            height.resize(matrix[i].size());
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; matrix[i].size(); ++<span style="color: #000000;">j) {
                height[j] </span>= matrix[i][j] == <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span> ? <span style="color: #800080;">0</span> : (<span style="color: #800080;">1</span> +<span style="color: #000000;"> height[j]);
            }
            res </span>=<span style="color: #000000;"> max(res, largestRectangleArea(height));
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">int</span> largestRectangleArea(vector&lt;<span style="color: #0000ff;">int</span>&gt; &amp;<span style="color: #000000;">height) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        stack</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> s;
        height.push_back(</span><span style="color: #800080;">0</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; height.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (s.empty() || height[s.top()] &lt;=<span style="color: #000000;"> height[i]) s.push(i);
            </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                </span><span style="color: #0000ff;">int</span> tmp =<span style="color: #000000;"> s.top();
                s.pop();
                res </span>= max(res, height[tmp] * (s.empty() ? i : (i - s.top() - <span style="color: #800080;">1</span><span style="color: #000000;">)));
                </span>--<span style="color: #000000;">i;
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>我们也可以在一个函数内完成，这样代码看起来更加简洁一些：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> maximalRectangle(vector&lt;vector&lt;<span style="color: #0000ff;">char</span>&gt;&gt;&amp;<span style="color: #000000;"> matrix) {
        </span><span style="color: #0000ff;">if</span> (matrix.empty() || matrix[<span style="color: #800080;">0</span>].empty()) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, m = matrix.size(), n = matrix[<span style="color: #800080;">0</span><span style="color: #000000;">].size();
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; height(n + <span style="color: #800080;">1</span>, <span style="color: #800080;">0</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; m; ++<span style="color: #000000;">i) {
            stack</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> s;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; n + <span style="color: #800080;">1</span>; ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> (j &lt;<span style="color: #000000;"> n) {
                    height[j] </span>= matrix[i][j] == <span style="color: #800000;">'</span><span style="color: #800000;">1</span><span style="color: #800000;">'</span> ? height[j] + <span style="color: #800080;">1</span> : <span style="color: #800080;">0</span><span style="color: #000000;">;
                }
                </span><span style="color: #0000ff;">while</span> (!s.empty() &amp;&amp; height[s.top()] &gt;=<span style="color: #000000;"> height[j]) {
                    </span><span style="color: #0000ff;">int</span> cur =<span style="color: #000000;"> s.top(); s.pop();
                    res </span>= max(res, height[cur] * (s.empty() ? j : (j - s.top() - <span style="color: #800080;">1</span><span style="color: #000000;">)));
                }
                s.push(j);
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种方法的思路很巧妙，height数组和上面一样，这里的left数组表示左边界是1的位置，right数组表示右边界是1的位置，那么对于任意一行的第j个位置，矩形为(right[j] - left[j]) * height[j]，我们举个例子来说明，比如给定矩阵为：</p>
<pre><code>[
  [1, 1, 0, 0, 1],
  [0, 1, 0, 0, 1],
  [0, 0, 1, 1, 1],
  [0, 0, 1, 1, 1],
  [0, 0, 0, 0, 1]
]</code></pre>
<p>第0行：</p>
<div class="cnblogs_code">
<pre>h: <span style="color: #800080;">1</span> <span style="color: #800080;">1</span> <span style="color: #800080;">0</span> <span style="color: #800080;">0</span> <span style="color: #800080;">1</span><span style="color: #000000;">
l: </span><span style="color: #800080;">0</span> <span style="color: #800080;">0</span> <span style="color: #800080;">0</span> <span style="color: #800080;">0</span> <span style="color: #800080;">4</span><span style="color: #000000;">
r: </span><span style="color: #800080;">2</span> <span style="color: #800080;">2</span> <span style="color: #800080;">5</span> <span style="color: #800080;">5</span> <span style="color: #800080;">5</span> </pre>
</div>
<p> </p>
<p>第1行：</p>
<div class="cnblogs_code">
<pre>h: <span style="color: #800080;">1</span> <span style="color: #800080;">1</span> <span style="color: #800080;">0</span> <span style="color: #800080;">0</span> <span style="color: #800080;">1</span><span style="color: #000000;">
l: </span><span style="color: #800080;">0</span> <span style="color: #800080;">0</span> <span style="color: #800080;">0</span> <span style="color: #800080;">0</span> <span style="color: #800080;">4</span><span style="color: #000000;">
r: </span><span style="color: #800080;">2</span> <span style="color: #800080;">2</span> <span style="color: #800080;">5</span> <span style="color: #800080;">5</span> <span style="color: #800080;">5</span> </pre>
</div>
<p> </p>
<p>第2行：</p>
<div class="cnblogs_code">
<pre>h: <span style="color: #800080;">0</span> <span style="color: #800080;">0</span> <span style="color: #800080;">1</span> <span style="color: #800080;">1</span> <span style="color: #800080;">3</span><span style="color: #000000;">
l: </span><span style="color: #800080;">0</span> <span style="color: #800080;">0</span> <span style="color: #800080;">2</span> <span style="color: #800080;">2</span> <span style="color: #800080;">4</span><span style="color: #000000;">
r: </span><span style="color: #800080;">5</span> <span style="color: #800080;">5</span> <span style="color: #800080;">5</span> <span style="color: #800080;">5</span> <span style="color: #800080;">5</span></pre>
</div>
<p> </p>
<p>第3行：</p>
<div class="cnblogs_code">
<pre>h: <span style="color: #800080;">0</span> <span style="color: #800080;">0</span> <span style="color: #800080;">2</span> <span style="color: #800080;">2</span> <span style="color: #800080;">4</span><span style="color: #000000;">
l: </span><span style="color: #800080;">0</span> <span style="color: #800080;">0</span> <span style="color: #800080;">2</span> <span style="color: #800080;">2</span> <span style="color: #800080;">4</span><span style="color: #000000;">
r: </span><span style="color: #800080;">5</span> <span style="color: #800080;">5</span> <span style="color: #800080;">5</span> <span style="color: #800080;">5</span> <span style="color: #800080;">5</span></pre>
</div>
<p> </p>
<p>第4行：</p>
<div class="cnblogs_code">
<pre>h: <span style="color: #800080;">0</span> <span style="color: #800080;">0</span> <span style="color: #800080;">0</span> <span style="color: #800080;">0</span> <span style="color: #800080;">5</span><span style="color: #000000;">
l: </span><span style="color: #800080;">0</span> <span style="color: #800080;">0</span> <span style="color: #800080;">0</span> <span style="color: #800080;">0</span> <span style="color: #800080;">4</span><span style="color: #000000;">
r: </span><span style="color: #800080;">5</span> <span style="color: #800080;">5</span> <span style="color: #800080;">5</span> <span style="color: #800080;">5</span> <span style="color: #800080;">5</span> </pre>
</div>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> maximalRectangle(vector&lt;vector&lt;<span style="color: #0000ff;">char</span>&gt;&gt;&amp;<span style="color: #000000;"> matrix) {
        </span><span style="color: #0000ff;">if</span> (matrix.empty() || matrix[<span style="color: #800080;">0</span>].empty()) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, m = matrix.size(), n = matrix[<span style="color: #800080;">0</span><span style="color: #000000;">].size();
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; height(n, <span style="color: #800080;">0</span>), left(n, <span style="color: #800080;">0</span><span style="color: #000000;">), right(n, n);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; m; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">int</span> cur_left = <span style="color: #800080;">0</span>, cur_right =<span style="color: #000000;"> n;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; n; ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> (matrix[i][j] == <span style="color: #800000;">'</span><span style="color: #800000;">1</span><span style="color: #800000;">'</span>) ++<span style="color: #000000;">height[j];
                </span><span style="color: #0000ff;">else</span> height[j] = <span style="color: #800080;">0</span><span style="color: #000000;">;
            }
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; n; ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> (matrix[i][j] == <span style="color: #800000;">'</span><span style="color: #800000;">1</span><span style="color: #800000;">'</span>) left[j] =<span style="color: #000000;"> max(left[j], cur_left);
                </span><span style="color: #0000ff;">else</span> {left[j] = <span style="color: #800080;">0</span>; cur_left = j + <span style="color: #800080;">1</span><span style="color: #000000;">;}
            }
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = n - <span style="color: #800080;">1</span>; j &gt;= <span style="color: #800080;">0</span>; --<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> (matrix[i][j] == <span style="color: #800000;">'</span><span style="color: #800000;">1</span><span style="color: #800000;">'</span>) right[j] =<span style="color: #000000;"> min(right[j], cur_right);
                </span><span style="color: #0000ff;">else</span> {right[j] = n; cur_right =<span style="color: #000000;"> j;}
            }
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; n; ++<span style="color: #000000;">j) {
                res </span>= max(res, (right[j] - left[j]) *<span style="color: #000000;"> height[j]);
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>我们也可以通过合并一些for循环，使得运算速度更快一些：</p>
<p> </p>
<p>解法四：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> maximalRectangle(vector&lt;vector&lt;<span style="color: #0000ff;">char</span>&gt;&gt;&amp;<span style="color: #000000;"> matrix) {
        </span><span style="color: #0000ff;">if</span> (matrix.empty() || matrix[<span style="color: #800080;">0</span>].empty()) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, m = matrix.size(), n = matrix[<span style="color: #800080;">0</span><span style="color: #000000;">].size();
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; height(n, <span style="color: #800080;">0</span>), left(n, <span style="color: #800080;">0</span><span style="color: #000000;">), right(n, n);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; m; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">int</span> cur_left = <span style="color: #800080;">0</span>, cur_right =<span style="color: #000000;"> n;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; n; ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> (matrix[i][j] == <span style="color: #800000;">'</span><span style="color: #800000;">1</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                    </span>++<span style="color: #000000;">height[j];
                    left[j] </span>=<span style="color: #000000;"> max(left[j], cur_left);
                } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    height[j] </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
                    left[j] </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
                    cur_left </span>= j + <span style="color: #800080;">1</span><span style="color: #000000;">;
                }
            }
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = n - <span style="color: #800080;">1</span>; j &gt;= <span style="color: #800080;">0</span>; --<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> (matrix[i][j] == <span style="color: #800000;">'</span><span style="color: #800000;">1</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                    right[j] </span>=<span style="color: #000000;"> min(right[j], cur_right);
                } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    right[j] </span>=<span style="color: #000000;"> n;
                    cur_right </span>=<span style="color: #000000;"> j;
                }
                res </span>= max(res, (right[j] - left[j]) *<span style="color: #000000;"> height[j]);
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4550604.html" target="_blank">Maximal Square</a></p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4322653.html" id="homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0">Largest Rectangle in Histogram</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://leetcode.com/discuss/20240/share-my-dp-solution" target="_blank">https://leetcode.com/discuss/20240/share-my-dp-solution</a></p>
<p><a href="https://leetcode.com/discuss/5198/a-o-n-2-solution-based-on-largest-rectangle-in-histogram" target="_blank">https://leetcode.com/discuss/5198/a-o-n-2-solution-based-on-largest-rectangle-in-histogram</a></p>
<p><a href="https://leetcode.com/discuss/17993/sharing-straightforward-solution-with-time-with-explanation" target="_blank">https://leetcode.com/discuss/17993/sharing-straightforward-solution-with-time-with-explanation</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-03-09 06:43</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4322667" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4322667);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4322653.html" id="cb_post_title_url">[LeetCode] Largest Rectangle in Histogram 直方图中最大的矩形</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given <em>n</em> non-negative integers representing the histogram's bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.</p>
<p> </p>
<p><img alt="" src="https://images0.cnblogs.com/blog2015/391947/201503/090209166127586.png"/></p>
<p>Above is a histogram where width of each bar is 1, given height = <code>[2,1,5,6,2,3]</code>.</p>
<p> </p>
<p><img alt="" src="https://images0.cnblogs.com/blog2015/391947/201503/090209241434121.png"/></p>
<p>The largest rectangle is shown in the shaded area, which has area = <code>10</code> unit.</p>
<p> </p>
<p>For example,<br/>Given height = <code>[2,1,5,6,2,3]</code>,<br/>return <code>10</code>.</p>
<p> </p>
<p>这道题让求直方图中最大的矩形，刚开始看到求极值问题以为要用DP来做，可是想不出递推式，只得作罢。这道题如果用暴力搜索法估计肯定没法通过OJ，但是我也没想出好的优化方法，在网上搜到了网友<a href="http://fisherlei.blogspot.com/2012/12/leetcode-largest-rectangle-in-histogram.html" target="_blank">水中的鱼的博客</a>，发现他想出了一种很好的优化方法，就是遍历数组，每找到一个局部峰值，然后向前遍历所有的值，算出共同的矩形面积，每次对比保留最大值，代码如下：</p>
<p> </p>
<p>解法一： </p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> Pruning optimize</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> largestRectangleArea(vector&lt;<span style="color: #0000ff;">int</span>&gt; &amp;<span style="color: #000000;">height) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; height.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (i + <span style="color: #800080;">1</span> &lt; height.size() &amp;&amp; height[i] &lt;= height[i + <span style="color: #800080;">1</span><span style="color: #000000;">]) {
                </span><span style="color: #0000ff;">continue</span><span style="color: #000000;">;
            }
            </span><span style="color: #0000ff;">int</span> minH =<span style="color: #000000;"> height[i];
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = i; j &gt;= <span style="color: #800080;">0</span>; --<span style="color: #000000;">j) {
                minH </span>=<span style="color: #000000;"> min(minH, height[j]);
                </span><span style="color: #0000ff;">int</span> area = minH * (i - j + <span style="color: #800080;">1</span><span style="color: #000000;">);
                res </span>=<span style="color: #000000;"> max(res, area);
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>后来又在网上发现一种比较流行的解法，是利用栈来解，可参见网友<a href="http://www.cnblogs.com/lichen782/p/leetcode_Largest_Rectangle_in_Histogram.html" target="_blank">实验室小纸贴校外版的博客</a>，但是经过仔细研究，其核心思想跟上面那种剪枝的方法有异曲同工之妙，这里维护一个栈，用来保存递增序列，相当于上面那种方法的找局部峰值。我们可以看到，直方图矩形面积要最大的话，需要尽可能的使得连续的矩形多，并且最低一块的高度要高。有点像木桶原理一样，总是最低的那块板子决定桶的装水量。那么既然需要用单调栈来做，首先要考虑到底用递增栈，还是用递减栈来做。我们想啊，递增栈是维护递增的顺序，当遇到小于栈顶元素的数就开始处理，而递减栈正好相反，维护递减的顺序，当遇到大于栈顶元素的数开始处理。那么根据这道题的特点，我们需要按从高板子到低板子的顺序处理，先处理最高的板子，宽度为1，然后再处理旁边矮一些的板子，此时长度为2，因为之前的高板子可组成矮板子的矩形 ，因此我们需要一个递增栈，当遇到大的数字直接进栈，而当遇到小于栈顶元素的数字时，就要取出栈顶元素进行处理了，那取出的顺序就是从高板子到矮板子了，于是乎遇到的较小的数字只是一个触发，表示现在需要开始计算矩形面积了，为了使得最后一块板子也被处理，这里用了个小trick，在高度数组最后面加上一个0，这样原先的最后一个板子也可以被处理了。由于栈顶元素是矩形的高度，那么关键就是求出来宽度，那么跟之前那道<a href="http://www.cnblogs.com/grandyang/p/4402392.html" target="_blank">Trapping Rain Water</a>一样，单调栈中不能放高度，而是需要放坐标。由于我们先取出栈中最高的板子，那么就可以先算出长度为1的矩形面积了，然后再取下一个板子，此时根据矮板子的高度算长度为2的矩形面积，以此类推，知道数字大于栈顶元素为止，再次进栈，巧妙的一比！关于单调栈问题可以参见博主的一篇总结帖<a class="link-post-title" href="http://www.cnblogs.com/grandyang/p/8887985.html" id="link_post_title">LeetCode Monotonous Stack Summary 单调栈小结</a>，代码如下：</p>
<p> </p>
<p>解法二： </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> largestRectangleArea(vector&lt;<span style="color: #0000ff;">int</span>&gt; &amp;<span style="color: #000000;">height) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        stack</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> st;
        height.push_back(</span><span style="color: #800080;">0</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; height.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (st.empty() || height[st.top()] &lt;<span style="color: #000000;"> height[i]) {
                st.push(i);
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                </span><span style="color: #0000ff;">int</span> cur =<span style="color: #000000;"> st.top(); st.pop();
                res </span>= max(res, height[cur] * (st.empty() ? i : (i - st.top() - <span style="color: #800080;">1</span><span style="color: #000000;">)));
                </span>--<span style="color: #000000;">i;
            }     
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>我们可以将上面的方法稍作修改，使其更加简洁一些：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> largestRectangleArea(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> heights) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        stack</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> st;
        heights.push_back(</span><span style="color: #800080;">0</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; heights.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">while</span> (!st.empty() &amp;&amp; heights[st.top()] &gt;=<span style="color: #000000;"> heights[i]) {
                </span><span style="color: #0000ff;">int</span> cur =<span style="color: #000000;"> st.top(); st.pop();
                res </span>= max(res, heights[cur] * (st.empty() ? i : (i - st.top() - <span style="color: #800080;">1</span><span style="color: #000000;">)));
            }
            st.push(i);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4550604.html" target="_blank">Maximal Square</a></p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4322667.html" id="cb_post_title_url">Maximal Rectangle</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://leetcode.com/discuss/22431/o-n-stack-based-java-solution" target="_blank">https://leetcode.com/discuss/22431/o-n-stack-based-java-solution</a></p>
<p><a href="https://leetcode.com/discuss/47267/my-c-dp-solution-16ms-easy-to-understand" target="_blank">https://leetcode.com/discuss/47267/my-c-dp-solution-16ms-easy-to-understand</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-03-09 02:38</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4322653" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4322653);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4066453.html" id="cb_post_title_url">[LeetCode] Remove Duplicates from Sorted List 移除有序链表中的重复项</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p>Given a sorted linked list, delete all duplicates such that each element appear only <em>once</em>.</p>
<p>For example,<br/>Given <code>1-&gt;1-&gt;2</code>, return <code>1-&gt;2</code>.<br/>Given <code>1-&gt;1-&gt;2-&gt;3-&gt;3</code>, return <code>1-&gt;2-&gt;3</code>.</p>
<p> </p>
<p>移除有序链表中的重复项需要定义个指针指向该链表的第一个元素，然后第一个元素和第二个元素比较，如果重复了，则删掉第二个元素，如果不重复，指针指向第二个元素。这样遍历完整个链表，则剩下的元素没有重复项。代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">/*</span><span style="color: #008000;">*
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    ListNode </span>*deleteDuplicates(ListNode *<span style="color: #000000;">head) {
        </span><span style="color: #0000ff;">if</span> (!head || !head-&gt;next) <span style="color: #0000ff;">return</span><span style="color: #000000;"> head;
        
        ListNode </span>*start =<span style="color: #000000;"> head;
        </span><span style="color: #0000ff;">while</span> (start &amp;&amp; start-&gt;<span style="color: #000000;">next) {
            </span><span style="color: #0000ff;">if</span> (start-&gt;val == start-&gt;next-&gt;<span style="color: #000000;">val) {
                ListNode </span>*tmp = start-&gt;<span style="color: #000000;">next;
                start</span>-&gt;next = start-&gt;next-&gt;<span style="color: #000000;">next;
                delete tmp;
            } </span><span style="color: #0000ff;">else</span> start = start-&gt;<span style="color: #000000;">next;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> head;
    }
};</span></pre>
</div>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2014-11-01 09:43</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4066453" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4066453);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4069003.html" id="cb_post_title_url">[LeetCode] Remove Duplicates from Sorted List II 移除有序链表中的重复项之二</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p>Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only <em>distinct</em> numbers from the original list.</p>
<p>For example,<br/>Given <code>1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5</code>, return <code>1-&gt;2-&gt;5</code>.<br/>Given <code>1-&gt;1-&gt;1-&gt;2-&gt;3</code>, return <code>2-&gt;3</code>.</p>
<p> </p>
<p>和之前那道 (<a href="http://www.cnblogs.com/grandyang/p/4066453.html" target="_blank"> http://www.cnblogs.com/grandyang/p/4066453.html </a>) 不同的地方是这里要删掉所有的重复项，由于链表开头可能会有重复项，被删掉的话头指针会改变，而最终却还需要返回链表的头指针。所以需要定义一个新的节点，然后链上原链表，然后定义一个前驱指针和一个现指针，每当前驱指针指向新建的节点，现指针从下一个位置开始往下遍历，遇到相同的则继续往下，直到遇到不同项时，把前驱指针的next指向下面那个不同的元素。如果现指针遍历的第一个元素就不相同，则把前驱指针向下移一位。代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">/*</span><span style="color: #008000;">*
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    ListNode </span>*deleteDuplicates(ListNode *<span style="color: #000000;">head) {
        </span><span style="color: #0000ff;">if</span> (!head || !head-&gt;next) <span style="color: #0000ff;">return</span><span style="color: #000000;"> head;
        
        ListNode </span>*start = <span style="color: #0000ff;">new</span> ListNode(<span style="color: #800080;">0</span><span style="color: #000000;">);
        start</span>-&gt;next =<span style="color: #000000;"> head;
        ListNode </span>*pre =<span style="color: #000000;"> start;
        </span><span style="color: #0000ff;">while</span> (pre-&gt;<span style="color: #000000;">next) {
            ListNode </span>*cur = pre-&gt;<span style="color: #000000;">next;
            </span><span style="color: #0000ff;">while</span> (cur-&gt;next &amp;&amp; cur-&gt;next-&gt;val == cur-&gt;val) cur = cur-&gt;<span style="color: #000000;">next;
            </span><span style="color: #0000ff;">if</span> (cur != pre-&gt;next) pre-&gt;next = cur-&gt;<span style="color: #000000;">next;
            </span><span style="color: #0000ff;">else</span> pre = pre-&gt;<span style="color: #000000;">next;
        }
        </span><span style="color: #0000ff;">return</span> start-&gt;<span style="color: #000000;">next;
    }
};</span></pre>
</div>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2014-11-02 12:47</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4069003" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4069003);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4325840.html" id="cb_post_title_url">[LeetCode] Search in Rotated Sorted Array II 在旋转有序数组中搜索之二</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Follow up for "Search in Rotated Sorted Array":<br/>What if <em>duplicates</em> are allowed?</p>
<p>Would this affect the run-time complexity? How and why?</p>
<p>Write a function to determine if a given target is in the array.</p>
<p> </p>
<p>这道是之前那道<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4325648.html" id="cb_post_title_url"> Search in Rotated Sorted Array 在旋转有序数组中搜索</a> 的延伸，现在数组中允许出现重复数字，这个也会影响我们选择哪半边继续搜索，由于之前那道题不存在相同值，我们在比较中间值和最右值时就完全符合之前所说的规律：<strong>如果中间的数小于最右边的数，则右半段是有序的，若中间数大于最右边数，则左半段是有序的</strong>。而如果可以有重复值，就会出现来面两种情况，[3 1 1] 和 [1 1 3 1]，对于这两种情况中间值等于最右值时，目标值3既可以在左边又可以在右边，那怎么办么，对于这种情况其实处理非常简单，只要把最右值向左一位即可继续循环，如果还相同则继续移，直到移到不同值为止，然后其他部分还采用<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4325648.html" id="cb_post_title_url"> Search in Rotated Sorted Array 在旋转有序数组中搜索</a> 中的方法，可以得到代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> search(<span style="color: #0000ff;">int</span> A[], <span style="color: #0000ff;">int</span> n, <span style="color: #0000ff;">int</span><span style="color: #000000;"> target) {
        </span><span style="color: #0000ff;">if</span> (n == <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> left = <span style="color: #800080;">0</span>, right = n - <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (left &lt;=<span style="color: #000000;"> right) {
            </span><span style="color: #0000ff;">int</span> mid = (left + right) / <span style="color: #800080;">2</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> (A[mid] == target) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (A[mid] &lt;<span style="color: #000000;"> A[right]) {
                </span><span style="color: #0000ff;">if</span> (A[mid] &lt; target &amp;&amp; A[right] &gt;= target) left = mid + <span style="color: #800080;">1</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">else</span> right = mid - <span style="color: #800080;">1</span><span style="color: #000000;">;
            } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (A[mid] &gt;<span style="color: #000000;"> A[right]){
                </span><span style="color: #0000ff;">if</span> (A[left] &lt;= target &amp;&amp; A[mid] &gt; target) right = mid - <span style="color: #800080;">1</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">else</span> left = mid + <span style="color: #800080;">1</span><span style="color: #000000;">;
            } </span><span style="color: #0000ff;">else</span> --<span style="color: #000000;">right;
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2015-03-10 13:47</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=4325840" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(4325840);return false;">收藏</a></div>
</div>
</html>