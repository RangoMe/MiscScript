<html lang="zh-cn">
<head>
<meta charset="utf-8"/>
<div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/9601243.html" id="cb_post_title_url">[LeetCode] Linked List Components 链表组件</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="question-description__3U1T">
<div>
<p>We are given <code>head</code>, the head node of a linked list containing unique integer values.</p>
<p>We are also given the list <code>G</code>, a subset of the values in the linked list.</p>
<p>Return the number of connected components in <code>G</code>, where two values are connected if they appear consecutively in the linked list.</p>
<p>Example 1:</p>
<pre>Input: 
head: 0-&gt;1-&gt;2-&gt;3
G = [0, 1, 3]
Output: 2
Explanation: 
0 and 1 are connected, so [0, 1] and [3] are the two connected components.
</pre>
<p>Example 2:</p>
<pre>Input: 
head: 0-&gt;1-&gt;2-&gt;3-&gt;4
G = [0, 3, 1, 4]
Output: 2
Explanation: 
0 and 1 are connected, 3 and 4 are connected, so [0, 1] and [3, 4] are the two connected components.
</pre>
<p>Note:</p>
<ul>
<li>If <code>N</code> is the length of the linked list given by <code>head</code>, <code>1 &lt;= N &lt;= 10000</code>.</li>
<li>The value of each node in the linked list will be in the range<code> [0, N - 1]</code>.</li>
<li><code>1 &lt;= G.length &lt;= 10000</code>.</li>
<li><code>G</code> is a subset of all values in the linked list.</li>
</ul>
</div>
</div>
<p> </p>
<p>这道题给了我们一个链表，又给了我们一个结点值数组，里面不一定包括了链表中所有的结点值。让我们返回结点值数组中有多少个相连的组件，因为缺失的结点值会将原链表断开，实际上就是让我们求有多少个相连的子链表，题目中给的例子很好的说明题意。这道题并不需要什么特别高深的技巧，难懂的算法，直接按题目的要求来找就可以了。首先，为了快速的在结点值数组中查找某个结点值是否存在，我们可以将所有的结点值放到一个HashSet中，这样我们就能在常数级的时间复杂度中查找。然后我们就可以来遍历链表了，对于遍历到的每个结点值，我们只有两种情况，在或者不在HashSet中。不在HashSet中的情况比较好办，说明此时断开了，而在HashSet中的结点，有可能是该连续子链表的起始点，或者是中间的某个点，而我们的计数器对该子链表只能自增1，所以我们需要想办法来hanlde这种情况。博主最先想到的办法是先处理不在HashSet中的结点，处理方法就是直接跳到下一个结点。那么对于在HashSet中的结点，我们首先将计数器res自增1，然后再来个循环，将之后所有在集合中的结点都遍历完，这样才不会对同一个子链表多次增加计数器，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> numComponents(ListNode* head, vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> G) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        unordered_set</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> nodeSet(G.begin(), G.end());
        </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> (head) {
            </span><span style="color: #0000ff;">if</span> (!nodeSet.count(head-&gt;<span style="color: #000000;">val)) {
                head </span>= head-&gt;<span style="color: #000000;">next;
                </span><span style="color: #0000ff;">continue</span><span style="color: #000000;">;
            }
            </span>++<span style="color: #000000;">res;
            </span><span style="color: #0000ff;">while</span> (head &amp;&amp; nodeSet.count(head-&gt;<span style="color: #000000;">val)) {
                head </span>= head-&gt;<span style="color: #000000;">next;
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>我们可以稍稍修改代码，使其更加简洁，我们在遍历的时候进行判断，如果当前结点在集合中，并且当前结点是尾结点或者下一个结点不在集合中的时候，我们让计数器自增1，通过这种操作，我们不会多加也不会漏加计数器，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> numComponents(ListNode* head, vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> G) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        unordered_set</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> nodeSet(G.begin(), G.end());
        </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> (head) {
            </span><span style="color: #0000ff;">if</span> (nodeSet.count(head-&gt;val) &amp;&amp; (!head-&gt;next || !nodeSet.count(head-&gt;next-&gt;<span style="color: #000000;">val))) {
                </span>++<span style="color: #000000;">res;
            }
            head </span>= head-&gt;<span style="color: #000000;">next;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a href="http://www.cnblogs.com/grandyang/p/4606334.html" target="_blank">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-09-06 21:56</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=9601243" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(9601243);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/9563418.html" id="cb_post_title_url">[LeetCode] Ambiguous Coordinates 模糊的坐标</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>We had some 2-dimensional coordinates, like <code>"(1, 3)"</code> or <code>"(2, 0.5)"</code>.  Then, we removed all commas, decimal points, and spaces, and ended up with the string <code>S</code>.  Return a list of strings representing all possibilities for what our original coordinates could have been.</p>
<p>Our original representation never had extraneous zeroes, so we never started with numbers like "00", "0.0", "0.00", "1.0", "001", "00.01", or any other number that can be represented with less digits.  Also, a decimal point within a number never occurs without at least one digit occuring before it, so we never started with numbers like ".1".</p>
<p>The final answer list can be returned in any order.  Also note that all coordinates in the final answer have exactly one space between them (occurring after the comma.)</p>
<pre>Example 1:
Input: "(123)"
Output: ["(1, 23)", "(12, 3)", "(1.2, 3)", "(1, 2.3)"]
</pre>
<pre>Example 2:
Input: "(00011)"
Output:  ["(0.001, 1)", "(0, 0.011)"]
Explanation: 
0.0, 00, 0001 or 00.01 are not allowed.
</pre>
<pre>Example 3:
Input: "(0123)"
Output: ["(0, 123)", "(0, 12.3)", "(0, 1.23)", "(0.1, 23)", "(0.1, 2.3)", "(0.12, 3)"]
</pre>
<pre>Example 4:
Input: "(100)"
Output: [(10, 0)]
Explanation: 
1.0 is not allowed.
</pre>
<p> </p>
<p>Note:</p>
<ul>
<li><code>4 &lt;= S.length &lt;= 12</code>.</li>
<li><code>S[0]</code> = "(", <code>S[S.length - 1]</code> = ")", and the other elements in <code>S</code> are digits.</li>
</ul>
<p> </p>
<p>这道题给了我们一个模糊坐标，括号里面很只有一个数字字符串，没有逗号也没有小数点，让我们自己添加逗号和小数点，让把所有可能的组合都返回。题目中给了很多例子，理解起题意来很容易。这道题的难点是如何合理的拆分，很多拆分是不合法的，题目举了很多不合法的例子，比如 "00", "0.0", "0.00", "1.0", "001", "00.01"。那么我们需要归纳出所有不合法的corner case，然后剩下一般情况比如123，我们就按位加小数点即可。那么我们再来看一下那些非法的例子，我们发现一眼望去好多0，不错，0就是trouble maker，首先不能有0开头的长度大于1的整数，比如00， 001。其次，不能有0结尾的小数，比如0.0，0.00，1.0等。还有，小数的整数位上也不能有0开头的长度大于1的整数。那么我们来归纳一下吧，首先如果字符串为空，那么直接返回空集合。然后如果字符串长度大于1，且首尾字符都是0的话，那么不可分，比如 0xxx0，因为整数长度大于1的话不能以0开头，中间也没法加小数点，因为小数最后一位不能是0。如果长度大于1，第一位是0，但最后一位不是0，那我们可以在第一个0后面加个小数点返回，这时就必须要加小数点了，因为长度大于1的整数不能以0开头。再之后，如果最后一位是0，说明不能加小数点，直接把当前值返回即可。最后就是一般情况了，我们先把原数加入结果res，然后遍历中间的每个位置，都加个小数点，所有情况归纳如下：</p>
<p>if S == "": return []<br/>if S == "0": return [S]<br/>if S == "0XXX0": return []<br/>if S == "0XXX": return ["0.XXX"]<br/>if S == "XXX0": return [S]<br/>return [S, "X.XXX", "XX.XX", "XXX.X"...]</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; ambiguousCoordinates(<span style="color: #0000ff;">string</span><span style="color: #000000;"> S) {
        vector</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">int</span> n =<span style="color: #000000;"> S.size();
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt; n - <span style="color: #800080;">2</span>; ++<span style="color: #000000;">i) {
            vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; A = findAll(S.substr(<span style="color: #800080;">1</span>, i)), B = findAll(S.substr(i + <span style="color: #800080;">1</span>, n - <span style="color: #800080;">2</span> -<span style="color: #000000;"> i));
            </span><span style="color: #0000ff;">for</span> (auto &amp;<span style="color: #000000;">a : A) {
                </span><span style="color: #0000ff;">for</span> (auto &amp;<span style="color: #000000;">b : B) {
                    res.push_back(</span><span style="color: #800000;">"</span><span style="color: #800000;">(</span><span style="color: #800000;">"</span> + a + <span style="color: #800000;">"</span><span style="color: #800000;">, </span><span style="color: #800000;">"</span> + b + <span style="color: #800000;">"</span><span style="color: #800000;">)</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                }
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; findAll(<span style="color: #0000ff;">string</span><span style="color: #000000;"> S) {
        </span><span style="color: #0000ff;">int</span> n =<span style="color: #000000;"> S.size();
        </span><span style="color: #0000ff;">if</span> (n == <span style="color: #800080;">0</span> || (n &gt; <span style="color: #800080;">1</span> &amp;&amp; S[<span style="color: #800080;">0</span>] == <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span> &amp;&amp; S[n - <span style="color: #800080;">1</span>] == <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span>)) <span style="color: #0000ff;">return</span><span style="color: #000000;"> {};
        </span><span style="color: #0000ff;">if</span> (n &gt; <span style="color: #800080;">1</span> &amp;&amp; S[<span style="color: #800080;">0</span>] == <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span>) <span style="color: #0000ff;">return</span> {<span style="color: #800000;">"</span><span style="color: #800000;">0.</span><span style="color: #800000;">"</span> + S.substr(<span style="color: #800080;">1</span><span style="color: #000000;">)};
        </span><span style="color: #0000ff;">if</span> (S[n - <span style="color: #800080;">1</span>] == <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;"> {S};
        vector</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> res{S};
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt; n; ++i) res.push_back(S.substr(<span style="color: #800080;">0</span>, i) + <span style="color: #800000;">"</span><span style="color: #800000;">.</span><span style="color: #800000;">"</span> +<span style="color: #000000;"> S.substr(i));
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a href="http://www.cnblogs.com/grandyang/p/4606334.html" target="_blank">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-08-30 23:56</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=9563418" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(9563418);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/9539584.html" id="cb_post_title_url">[LeetCode] Binary Tree Pruning 二叉树修剪</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>We are given the head node <code>root</code> of a binary tree, where additionally every node's value is either a 0 or a 1.</p>
<p>Return the same tree where every subtree (of the given tree) not containing a 1 has been removed.</p>
<p>(Recall that the subtree of a node X is X, plus every node that is a descendant of X.)</p>
<pre>Example 1:
Input: [1,null,0,0,1]
Output: [1,null,0,null,1]
 
Explanation: 
Only the red nodes satisfy the property "every subtree not containing a 1".
The diagram on the right represents the answer.

</pre>
<p><img alt="" height="135" src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/04/06/1028_2.png" width="482"/></p>
<pre>Example 2:
Input: [1,0,1,0,0,0,1]
Output: [1,null,1,null,1]


</pre>
<p><img alt="" height="130" src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/04/06/1028_1.png" width="564"/></p>
<pre>Example 3:
Input: [1,1,0,1,1,0,1,0]
Output: [1,1,0,1,1,null,1]


</pre>
<p><img alt="" height="151" src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/04/05/1028.png" width="562"/></p>
<p>Note:</p>
<ul>
<li>The binary tree will have at most <code>100 nodes</code>.</li>
<li>The value of each node will only be <code>0</code> or <code>1</code>.</li>
</ul>
<p> </p>
<p>这道题给了我们一棵二叉树，说是结点只有0或者1，让我们移除所有没有含有结点1的子树。题目中也给了一些图例，不难理解。这道题的难点就在于怎么看待没有结点1的子树，我们知道子树也是由一个个结点组成的，需要明确的是一个单独的叶结点也可算作是子树，所以值为0的叶结点一定要移除，就像上面的例子1和3中的几个叶结点要被移除一样。对于例子2来说，如果移除了第三行的3个叶结点后，那么第二行的那个值为0的结点也变成了叶结点，继续移除即可，所以与其找值全为0的子树，我们可以不断的移除值为0的叶结点，全都移除后那么值全为0的子树也就都被移除了。</p>
<p>好，想通了这一点后，我们看如何来实现。对于玩二叉树的题，十有八九都是用递归，所以我们应该首先就考虑递归的解法，然后再想按什么顺序来遍历二叉树呢？层序，先序，中序，还是后序？根据这道题的特点，我们要从末尾来一层一层的移除值为0的叶结点，所以天然时候用后序遍历。那么想到这里，解题思路跃然纸上了吧，我们首先对结点判空，如果不存在，直接返回空。然后分别对左右子结点调用递归函数，此时判断，如果当前结点是值为1的叶结点，那么移除该结点，即返回空，否则返回原结点即可，参见代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    TreeNode</span>* pruneTree(TreeNode*<span style="color: #000000;"> root) {
        </span><span style="color: #0000ff;">if</span> (!root) <span style="color: #0000ff;">return</span><span style="color: #000000;"> NULL;
        root</span>-&gt;left = pruneTree(root-&gt;<span style="color: #000000;">left);
        root</span>-&gt;right = pruneTree(root-&gt;<span style="color: #000000;">right);
        </span><span style="color: #0000ff;">return</span> (!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; root-&gt;val == <span style="color: #800080;">0</span>) ?<span style="color: #000000;"> NULL : root;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a href="http://www.cnblogs.com/grandyang/p/4606334.html" target="_blank">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-08-26 23:45</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=9539584" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(9539584);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/9504413.html" id="cb_post_title_url">[LeetCode] Largest Sum of Averages 最大的平均数之和</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>We partition a row of numbers <code>A</code> into at most <code>K</code> adjacent (non-empty) groups, then our score is the sum of the average of each group. What is the largest score we can achieve?</p>
<p>Note that our partition must use every number in A, and that scores are not necessarily integers.</p>
<pre>Example:
Input: 
A = [9,1,2,3,9]
K = 3
Output: 20
Explanation: 
The best choice is to partition A into [9], [1, 2, 3], [9]. The answer is 9 + (1 + 2 + 3) / 3 + 9 = 20.
We could have also partitioned A into [9, 1], [2], [3, 9], for example.
That partition would lead to a score of 5 + 2 + 6 = 13, which is worse.
</pre>
<p> </p>
<p>Note:</p>
<ul>
<li><code>1 &lt;= A.length &lt;= 100</code>.</li>
<li><code>1 &lt;= A[i] &lt;= 10000</code>.</li>
<li><code>1 &lt;= K &lt;= A.length</code>.</li>
<li>Answers within <code>10^-6</code> of the correct answer will be accepted as correct.</li>
</ul>
<p> </p>
<p>这道题给了我们一个数组，说是让我们将数组分成至多K个非空组，然后说需要统计的分数是各组的平均数之和，让我们求一个分割方法，使得这个分数值最大，当然这个分数值不一定是整型数。这道题限制了分割的组必须为非空组，那么就是说K值要小于等于数组的元素个数。但是实际上博主感觉这个必须为非空的限制有没有都一样，因为题目中说至多分成K组，也就是说可以根本不分组，那么比如你输入个A=[9,1], K=3，照样返回一个10，给人的感觉好像是分成了[9], [1], [] 这三组一样，但其实只是分成了两组[9] 和 [1]。但我们不必纠结这些，不是重点。没有啥思路的情况下我们就先想想brute force的解法呗，对于题目中给的那个例子，我们用最暴力的方法就是遍历所有的可能性，即遍历所有分割成三个组的情况，用三个for循环。貌似行的通，但问题来了，如果K大于3呢，每大一个，多加一个for循环么，总共K个for循环？如果K=100呢，100个for循环么？画面太美我不敢看！显然这道题用brute force是行不通的，那么换个方法呗！像这种求极值的题，又是玩数组的题，根据老夫行走江湖多年的经验，十有八九都是用Dynamic Programming来做的。玩子数组且跟极值有关的题天然适合用DP来做，想想为什么？DP的本质是什么，不就是状态转移方程，根据前面的状态来更新当前的状态。而子数组不就是整个数组的前一个状态，不停的更新的使得我们最终能得到极值。</p>
<p>好，下面进入正题。DP走起，首先来考虑dp数组的定义，我们如何定义dp数组有时候很关键，定义的不好，那么就无法写出正确的状态转移方程。对于这道题，我们很容易直接用一个一维数组dp，其中dp[i]表示范围为[0, i]的子数组分成三组能得到的最大分数。用这样定义的dp数组的话，状态转移方程将会非常难写，因为我们忽略了一个重要的信息，即K。dp数组不把K加进去的话就不知道当前要分几组，这个Hidden Information是解题的关键。这是DP中比较难的一类，有些DP题的隐藏信息藏的更深，不挖出来就无法解题。这道题的dp数组应该是个二维数组，其中dp[i][k]表示范围是[i, n-1]的子数组分成k组的最大得分。那么这里你就会纳闷了，为啥范围是[i, n-1]而不是[0, i]，为啥要取后半段呢，不着急，听博主慢慢道来。由于把[i, n-1]范围内的子数组分成k组，那么suppose我们已经知道了任意范围内分成k-1组的最大分数，这是此类型题目的破题关键所在，要求状态k，一定要先求出所有的状态k-1，那么问题就转换成了从k-1组变成k组，即多分出一组，那么在范围[i, n-1]多分出一组，实际上就是将其分成两部分，一部分是一组，另一部分是k-1组，怎么分，就用一个变量j，遍历范围(i, n-1)中的每一个位置，那么分成的这两部分的分数如何计算呢？第一部分[i, j)，由于是一组，那么直接求出平均值即可，另一部分由于是k-1组，由于我们已经知道了所有k-1的情况，可以直接从cache中读出来dp[j][k-1]，二者相加即可 avg(i, j) + dp[j][k-1]，所以我们可以得出状态转移方程如下：</p>
<p>dp[i][k] = max(avg(i, n) + max_{j &gt; i} (avg(i, j) + dp[j][k-1]))</p>
<p>这里的avg(i, n)是其可能出现的情况，由于是至多分为k组，所以我们可以不分组，所以直接计算范围[i, n-1]内的平均值，然后用j来遍历区间(i, n-1)中的每一个位置，最终得到的dp[i][k]就即为所求。注意这里我们通过建立累加和数组sums来快速计算某个区间之和。博主觉得这道题十分的经典，考察点非常的多，很具有代表性，标为Hard都不过分，前面提到了dp[i][k]表示的是范围[i, n-1]的子数组分成k组的最大得分，现在想想貌似定义为[0, i]范围内的子数组分成k组的最大得分应该也是可以的，那么此时j就是遍历(0, i)中的每个位置了，好像也没什么不妥的地方，有兴趣的童鞋可以尝试的写一下～</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">double</span> largestSumOfAverages(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; A, <span style="color: #0000ff;">int</span><span style="color: #000000;"> K) {
        </span><span style="color: #0000ff;">int</span> n =<span style="color: #000000;"> A.size();
        vector</span>&lt;<span style="color: #0000ff;">double</span>&gt; sums(n + <span style="color: #800080;">1</span><span style="color: #000000;">);
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">double</span>&gt;&gt; dp(n, vector&lt;<span style="color: #0000ff;">double</span>&gt;<span style="color: #000000;">(K));
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            sums[i </span>+ <span style="color: #800080;">1</span>] = sums[i] +<span style="color: #000000;"> A[i];
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            dp[i][</span><span style="color: #800080;">0</span>] = (sums[n] - sums[i]) / (n -<span style="color: #000000;"> i);
        }    
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> k = <span style="color: #800080;">1</span>; k &lt; K; ++<span style="color: #000000;">k) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n - <span style="color: #800080;">1</span>; ++<span style="color: #000000;">i) {
                </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = i + <span style="color: #800080;">1</span>; j &lt; n; ++<span style="color: #000000;">j) {
                    dp[i][k] </span>= max(dp[i][k], (sums[j] - sums[i]) / (j - i) + dp[j][k - <span style="color: #800080;">1</span><span style="color: #000000;">]);
                }
            }
        }
        </span><span style="color: #0000ff;">return</span> dp[<span style="color: #800080;">0</span>][K - <span style="color: #800080;">1</span><span style="color: #000000;">];
    }
};</span></pre>
</div>
<p> </p>
<p>我们可以对空间进行优化，由于每次的状态k，只跟前一个状态k-1有关，所以我们不需要将所有的状态都保存起来，只需要保存前一个状态的值就行了，那么我们就用一个一维数组就可以了，不断的进行覆盖，从而达到了节省空间的目的，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">double</span> largestSumOfAverages(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; A, <span style="color: #0000ff;">int</span><span style="color: #000000;"> K) {
        </span><span style="color: #0000ff;">int</span> n =<span style="color: #000000;"> A.size();
        vector</span>&lt;<span style="color: #0000ff;">double</span>&gt; sums(n + <span style="color: #800080;">1</span><span style="color: #000000;">);
        vector</span>&lt;<span style="color: #0000ff;">double</span>&gt;<span style="color: #000000;"> dp(n);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            sums[i </span>+ <span style="color: #800080;">1</span>] = sums[i] +<span style="color: #000000;"> A[i];
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            dp[i] </span>= (sums[n] - sums[i]) / (n -<span style="color: #000000;"> i);
        }    
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> k = <span style="color: #800080;">1</span>; k &lt; K; ++<span style="color: #000000;">k) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n - <span style="color: #800080;">1</span>; ++<span style="color: #000000;">i) {
                </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = i + <span style="color: #800080;">1</span>; j &lt; n; ++<span style="color: #000000;">j) {
                    dp[i] </span>= max(dp[i], (sums[j] - sums[i]) / (j - i) +<span style="color: #000000;"> dp[j]);
                }
            }
        }
        </span><span style="color: #0000ff;">return</span> dp[<span style="color: #800080;">0</span><span style="color: #000000;">];
    }
};</span></pre>
</div>
<p> </p>
<p>我们也可以是用递归加记忆数组的方式来实现，记忆数组的运作原理和DP十分类似，也是一种cache，将已经计算过的结果保存起来，用的时候直接取即可，避免了大量的重复计算，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">double</span> largestSumOfAverages(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; A, <span style="color: #0000ff;">int</span><span style="color: #000000;"> K) {
        </span><span style="color: #0000ff;">int</span> n =<span style="color: #000000;"> A.size();
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">double</span>&gt;&gt; memo(<span style="color: #800080;">101</span>, vector&lt;<span style="color: #0000ff;">double</span>&gt;(<span style="color: #800080;">101</span><span style="color: #000000;">));
        </span><span style="color: #0000ff;">double</span> cur = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            cur </span>+=<span style="color: #000000;"> A[i];
            memo[i </span>+ <span style="color: #800080;">1</span>][<span style="color: #800080;">1</span>] = cur / (i + <span style="color: #800080;">1</span><span style="color: #000000;">);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> helper(A, K, n, memo);
    }
    </span><span style="color: #0000ff;">double</span> helper(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; A, <span style="color: #0000ff;">int</span> k, <span style="color: #0000ff;">int</span> j, vector&lt;vector&lt;<span style="color: #0000ff;">double</span>&gt;&gt;&amp;<span style="color: #000000;"> memo) {
        </span><span style="color: #0000ff;">if</span> (memo[j][k] &gt; <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;"> memo[j][k];
        </span><span style="color: #0000ff;">double</span> cur = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = j - <span style="color: #800080;">1</span>; i &gt; <span style="color: #800080;">0</span>; --<span style="color: #000000;">i) {
            cur </span>+=<span style="color: #000000;"> A[i];
            memo[j][k] </span>= max(memo[j][k], helper(A, k - <span style="color: #800080;">1</span>, i, memo) + cur / (j -<span style="color: #000000;"> i));
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> memo[j][k];
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a href="http://www.cnblogs.com/grandyang/p/4606334.html" target="_blank">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-08-20 11:05</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=9504413" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(9504413);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/9461484.html" id="cb_post_title_url">[LeetCode] Largest Triangle Area 最大的三角区域</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>You have a list of points in the plane. Return the area of the largest triangle that can be formed by any 3 of the points.</p>
<pre>Example:
Input: points = [[0,0],[0,1],[1,0],[0,2],[2,0]]
Output: 2
Explanation: 
The five points are show in the figure below. The red triangle is the largest.
</pre>
<p><img alt="" height="192" src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/04/04/1027.png" width="234"/></p>
<p>Notes:</p>
<ul>
<li><code>3 &lt;= points.length &lt;= 50</code>.</li>
<li>No points will be duplicated.</li>
<li> <code>-50 &lt;= points[i][j] &lt;= 50</code>.</li>
<li>Answers within <code>10^-6</code> of the true value will be accepted as correct.</li>
</ul>
<p> </p>
<p>这道题给了我们一系列的二维平面上的点，让我们找出任意三个点能组成的最大三角形的面积。那么我们只能遍历所有的三角形面积，然后找出最大的那个。貌似这道题也没有啥特别简便的方法，不遍历不行啊。遍历任意三个点简单，问题来了，如何通过三个顶点的坐标求出三角形面积，这个可就是初中几何题了，博主也不记得，只能上网搜一波。就是用下面这个公式即可：</p>
<p><img alt="" height="87" src="https://images2018.cnblogs.com/blog/391947/201808/391947-20180827003457034-465504228.jpg" width="493"/></p>
<p>这里面三个顶点分别是(x1, y1)，(x2, y2)，(x3, y3)，有了公式后，本题就没有什么难点了，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">double</span> largestTriangleArea(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> points) {
        </span><span style="color: #0000ff;">double</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; points.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = i + <span style="color: #800080;">1</span>; j &lt; points.size(); ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> k = j + <span style="color: #800080;">1</span>; k &lt; points.size(); ++<span style="color: #000000;">k) {
                    </span><span style="color: #0000ff;">int</span> x1 = points[i][<span style="color: #800080;">0</span>], y1 = points[i][<span style="color: #800080;">1</span><span style="color: #000000;">];
                    </span><span style="color: #0000ff;">int</span> x2 = points[j][<span style="color: #800080;">0</span>], y2 = points[j][<span style="color: #800080;">1</span><span style="color: #000000;">];
                    </span><span style="color: #0000ff;">int</span> x3 = points[k][<span style="color: #800080;">0</span>], y3 = points[k][<span style="color: #800080;">1</span><span style="color: #000000;">];
                    </span><span style="color: #0000ff;">double</span> area = abs(<span style="color: #800080;">0.5</span> * (x2 * y3 + x1 * y2 + x3 * y1 - x3 * y2 - x2 * y1 - x1 *<span style="color: #000000;"> y3));
                    res </span>=<span style="color: #000000;"> max(res, area);
                }
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>我们也可以稍稍简化一下上面的写法，但是解题思路没有任何区别，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">double</span> largestTriangleArea(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> points) {
        </span><span style="color: #0000ff;">double</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (auto &amp;<span style="color: #000000;">i : points) {
            </span><span style="color: #0000ff;">for</span> (auto &amp;<span style="color: #000000;">j : points) {
                </span><span style="color: #0000ff;">for</span> (auto &amp;<span style="color: #000000;">k : points) {
                    res </span>= max(res, <span style="color: #800080;">0.5</span> * abs(i[<span style="color: #800080;">0</span>] * j[<span style="color: #800080;">1</span>] + j[<span style="color: #800080;">0</span>] * k[<span style="color: #800080;">1</span>] + k[<span style="color: #800080;">0</span>] * i[<span style="color: #800080;">1</span>]- j[<span style="color: #800080;">0</span>] * i[<span style="color: #800080;">1</span>] - k[<span style="color: #800080;">0</span>] * j[<span style="color: #800080;">1</span>] - i[<span style="color: #800080;">0</span>] * k[<span style="color: #800080;">1</span><span style="color: #000000;">]));
                }
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a href="http://www.cnblogs.com/grandyang/p/4606334.html" target="_blank">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-08-11 23:00</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=9461484" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(9461484);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/9486061.html" id="cb_post_title_url">[LeetCode] Subdomain Visit Count 子域名访问量统计</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="question-description__3U1T">
<p>A website domain like "discuss.leetcode.com" consists of various subdomains. At the top level, we have "com", at the next level, we have "leetcode.com", and at the lowest level, "discuss.leetcode.com". When we visit a domain like "discuss.leetcode.com", we will also visit the parent domains "leetcode.com" and "com" implicitly.</p>
<p>Now, call a "count-paired domain" to be a count (representing the number of visits this domain received), followed by a space, followed by the address. An example of a count-paired domain might be "9001 discuss.leetcode.com".</p>
<p>We are given a list <code>cpdomains</code> of count-paired domains. We would like a list of count-paired domains, (in the same format as the input, and in any order), that explicitly counts the number of visits to each subdomain.</p>
<pre>Example 1:
Input: 
["9001 discuss.leetcode.com"]
Output: 
["9001 discuss.leetcode.com", "9001 leetcode.com", "9001 com"]
Explanation: 
We only have one website domain: "discuss.leetcode.com". As discussed above, the subdomain "leetcode.com" and "com" will also be visited. So they will all be visited 9001 times.

</pre>
<pre>Example 2:
Input: 
["900 google.mail.com", "50 yahoo.com", "1 intel.mail.com", "5 wiki.org"]
Output: 
["901 mail.com","50 yahoo.com","900 google.mail.com","5 wiki.org","5 org","1 intel.mail.com","951 com"]
Explanation: 
We will visit "google.mail.com" 900 times, "yahoo.com" 50 times, "intel.mail.com" once and "wiki.org" 5 times. For the subdomains, we will visit "mail.com" 900 + 1 = 901 times, "com" 900 + 50 + 1 = 951 times, and "org" 5 times.

</pre>
<p>Notes:</p>
<ul>
<li>The length of <code>cpdomains</code> will not exceed <code>100</code>. </li>
<li>The length of each domain name will not exceed <code>100</code>.</li>
<li>Each address will have either 1 or 2 "." characters.</li>
<li>The input count in any count-paired domain will not exceed <code>10000</code>.</li>
<li>The answer output can be returned in any order.</li>
</ul>
</div>
<p> </p>
<p>这道题让我们统计子域名的访问量，所谓的子域名，就是一个完整的域名以点断开的，每个断开的地方到末尾之间的子字符串就是一个子域名，现在给了我们很多完整域名的访问量，让我们统计所有子域名的访问量，题目中给的例子很好的说明了问题。那么这种统计字符串出现个数的问题，我们应该不难想到需要用一个HashMap来建立字符串和其出现次数的映射。那么接下来要做的就是将每一个全域名提取出来，然后拆分成子域名。提取全域名操作不难，因为给的格式都是一样的，前面是数字，中间一个空格，后面是全域名。我们只需要找到空格的位置，前面的部分转为整型数cnt，后面的就是全域名了。取出全域名之后就要进行拆分成子域名了，我们可以进行遍历，每当找到小数点的位置时，将后面的子字符串的映射值增加cnt，以此类推直到拆完所有的子域名。注意之前的全域名的映射值别忘了也要加上cnt，最后的最后我们只要将HashMap中的映射对组成题目中要求返回的格式即可，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; subdomainVisits(vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp;<span style="color: #000000;"> cpdomains) {
        vector</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> res;
        unordered_map</span>&lt;<span style="color: #0000ff;">string</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> subdomainCnt;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">string</span><span style="color: #000000;"> cpdomain : cpdomains) {
            </span><span style="color: #0000ff;">int</span> spaceIdx = cpdomain.find(<span style="color: #800000;">"</span> <span style="color: #800000;">"</span><span style="color: #000000;">);
            </span><span style="color: #0000ff;">int</span> cnt = stoi(cpdomain.substr(<span style="color: #800080;">0</span><span style="color: #000000;">, spaceIdx));
            </span><span style="color: #0000ff;">string</span> rem = cpdomain.substr(spaceIdx + <span style="color: #800080;">1</span><span style="color: #000000;">);
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; rem.size(); ++<span style="color: #000000;">i) {
                </span><span style="color: #0000ff;">if</span> (rem[i] == <span style="color: #800000;">'</span><span style="color: #800000;">.</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                    subdomainCnt[rem.substr(i </span>+ <span style="color: #800080;">1</span>)] +=<span style="color: #000000;"> cnt;
                }
            }
            subdomainCnt[rem] </span>+=<span style="color: #000000;"> cnt;
        }
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto a : subdomainCnt) {
            res.push_back(to_string(a.second) </span>+ <span style="color: #800000;">"</span> <span style="color: #800000;">"</span> +<span style="color: #000000;"> a.first);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种解法和上面的基本相同，唯一改变的地方就是拆分子域名的时候，没用使用遍历的for循环，而是继续使用了find函数来查找下一个小数点的位置，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; subdomainVisits(vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp;<span style="color: #000000;"> cpdomains) {
        vector</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> res;
        unordered_map</span>&lt;<span style="color: #0000ff;">string</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> subdomainCnt;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">string</span><span style="color: #000000;"> cpdomain : cpdomains) {
            </span><span style="color: #0000ff;">int</span> spaceIdx = cpdomain.find(<span style="color: #800000;">"</span> <span style="color: #800000;">"</span><span style="color: #000000;">);
            </span><span style="color: #0000ff;">int</span> cnt = stoi(cpdomain.substr(<span style="color: #800080;">0</span><span style="color: #000000;">, spaceIdx));
            </span><span style="color: #0000ff;">while</span> (spaceIdx != <span style="color: #0000ff;">string</span><span style="color: #000000;">::npos) {
                subdomainCnt[cpdomain.substr(spaceIdx </span>+ <span style="color: #800080;">1</span>)] +=<span style="color: #000000;"> cnt;
                spaceIdx </span>= cpdomain.find(<span style="color: #800000;">'</span><span style="color: #800000;">.</span><span style="color: #800000;">'</span>, spaceIdx + <span style="color: #800080;">1</span><span style="color: #000000;">);
            }
        }
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto a : subdomainCnt) {
            res.push_back(to_string(a.second) </span>+ <span style="color: #800000;">"</span> <span style="color: #800000;">"</span> +<span style="color: #000000;"> a.first);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a href="http://www.cnblogs.com/grandyang/p/4606334.html" target="_blank">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-08-16 11:01</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=9486061" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(9486061);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/9445951.html" id="cb_post_title_url">[LeetCode] Chalkboard XOR Game 黑板亦或游戏</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>We are given non-negative integers nums[i] which are written on a chalkboard.  Alice and Bob take turns erasing exactly one number from the chalkboard, with Alice starting first.  If erasing a number causes the bitwise XOR of all the elements of the chalkboard to become 0, then that player loses.  (Also, we'll say the bitwise XOR of one element is that element itself, and the bitwise XOR of no elements is 0.)</p>
<p>Also, if any player starts their turn with the bitwise XOR of all the elements of the chalkboard equal to 0, then that player wins.</p>
<p>Return True if and only if Alice wins the game, assuming both players play optimally.</p>
<pre>Example:
Input: nums = [1, 1, 2]
Output: false
Explanation: 
Alice has two choices: erase 1 or erase 2. 
If she erases 1, the nums array becomes [1, 2]. The bitwise XOR of all the elements of the chalkboard is 1 XOR 2 = 3. Now Bob can remove any element he wants, because Alice will be the one to erase the last element and she will lose. 
If Alice erases 2 first, now nums becomes [1, 1]. The bitwise XOR of all the elements of the chalkboard is 1 XOR 1 = 0. Alice will lose.

</pre>
<p>Notes:</p>
<ul>
<li><code>1 &lt;= N &lt;= 1000</code>. </li>
<li><code>0 &lt;= nums[i] &lt;= 2^16</code>.</li>
</ul>
<p> </p>
<p>这道题介绍了一种亦或游戏，写在黑板上，（黑板一脸懵逼，跟我有个毛关系）。爱丽丝和鲍勃两个人轮流擦除一个数字，如果剩下的数字亦或值为0的话，那么当前选手就输了。反过来也可以这么说，如果某一个选手开始游戏时，当前数字的亦或值为0了，那么直接就赢了。现在给了我们一个数组，问先手的爱丽丝能否获胜。那么其实这道题是一道有技巧的题，并不是让我们按照游戏规则那样去遍历所有的情况，有海量的运算。这题有点像之前那道<a href="http://www.cnblogs.com/grandyang/p/4873248.html">Nim Game</a>，重要的是技巧！技巧！技巧！重要的事情说三遍～但我等凡夫俗子如何看的出技巧啊，看不出技巧只能看Discuss了，博主也没看出来。但实际上这道题的解法可以非常的简单，两三行就搞定了。辣么开始讲解吧：首先根据题目的描述，我们知道了某个选手在开始移除数字之前，如果数组的亦或值为0的话，选手直接获胜，那么先手爱丽丝在开始开始之前也应该检查一遍数组的亦或值，如果是0的话，直接获胜。我们再来分析亦或值不为0的情况，既然不为0，那么亦或值肯定是有一个值的，我们假设其是x。下面就是本题的精髓了，是要考虑数组个数的奇偶情况（尼玛谁能想到！），这个数组个数一旦是偶数的话，就大有文章了，现在数字个数是偶数，且亦或值不为0，说明数组中的数字不全相同，因为偶数个相同数字的亦或值为0，那么爱丽丝只要移除一个不为x的数字就行了，这样移除后数组的亦或值也不会是0，那么由于鲍勃也是个机智的boy，他也不会移除一个使得剩余数组亦或值为0的数字，but，到了最后一个数字时，鲍勃别无选择只能移除最后一个数字，此时数组为0，亦或值为0，爱丽丝获胜。那此时你可能会有疑问，为啥奇数个数字且亦或值不为0时，爱丽丝一定会输？因为即便爱丽丝先移除掉了一个数字，使得数组亦或值仍不为0，那么此时鲍勃面对的情况就是偶数个数字使得数组亦或值不为0，这跟上面推论爱丽丝一定会赢的情况一样，鲍勃也是个聪明的蓝孩纸，所以爱丽丝会输，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> xorGame(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        </span><span style="color: #0000ff;">int</span> x = <span style="color: #800080;">0</span>, n =<span style="color: #000000;"> nums.size();
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> num : nums) x ^=<span style="color: #000000;"> num;
        </span><span style="color: #0000ff;">return</span> x == <span style="color: #800080;">0</span> || n % <span style="color: #800080;">2</span> == <span style="color: #800080;">0</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种解法就很秀了，比大军师大司马吴秀波还秀，直接用个accumulate一行搞定亦或值，博主只想吐槽这道题的难度级别，大家有见过一行解出一道Hard题吗，做梦都要笑醒了吧～</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> xorGame(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        </span><span style="color: #0000ff;">return</span> nums.size() % <span style="color: #800080;">2</span> == <span style="color: #800080;">0</span> || !accumulate(nums.begin(), nums.end(), <span style="color: #800080;">0</span>, bit_xor&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;">());
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4873248.html">Nim Game</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a href="http://www.cnblogs.com/grandyang/p/4606334.html" target="_blank">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-08-08 21:58</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=9445951" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(9445951);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/9406434.html" id="cb_post_title_url">[LeetCode] Soup Servings 供应汤</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="question-description__3U1T">
<div>
<p>There are two types of soup: type A and type B. Initially we have <code>N</code> ml of each type of soup. There are four kinds of operations:</p>
<ol>
<li>Serve 100 ml of soup A and 0 ml of soup B</li>
<li>Serve 75 ml of soup A and 25 ml of soup B</li>
<li>Serve 50 ml of soup A and 50 ml of soup B</li>
<li>Serve 25 ml of soup A and 75 ml of soup B</li>
</ol>
<p>When we serve some soup, we give it to someone and we no longer have it.  Each turn, we will choose from the four operations with equal probability 0.25. If the remaining volume of soup is not enough to complete the operation, we will serve as much as we can.  We stop once we no longer have some quantity of both types of soup.</p>
<p>Note that we do not have the operation where all 100 ml's of soup B are used first.  </p>
<p>Return the probability that soup A will be empty first, plus half the probability that A and B become empty at the same time.</p>
<p> </p>
<pre>Example:
Input: N = 50
Output: 0.625
Explanation: 
If we choose the first two operations, A will become empty first. For the third operation, A and B will become empty at the same time. For the fourth operation, B will become empty first. So the total probability of A becoming empty first plus half the probability that A and B become empty at the same time, is 0.25 * (1 + 1 + 0.5 + 0) = 0.625.

</pre>
<p>Notes:</p>
<ul>
<li><code>0 &lt;= N &lt;= 10^9</code>. </li>
<li>Answers within <code>10^-6</code> of the true value will be accepted as correct.</li>
</ul>
</div>
</div>
<p> </p>
<p>这道题给了我们两种汤，A和B，开始时各给了N毫升的。然后说是有下面四种操作：</p>
<p>1. 供应100毫升A汤，0毫升B汤。</p>
<p>2. 供应75毫升A汤，25毫升B汤。</p>
<p>3. 供应50毫升A汤，50毫升B汤。</p>
<p>4. 供应25毫升A汤，75毫升B汤。</p>
<p>我们选择每种操作的概率是一样的，让我们返回A汤先供应完的概率加上A汤和B汤同时供应完的一半概率。又给了一个例子来帮助我们理解。说实话，博主觉得这道题挺让人费解的，反正博主是没有啥思路，是直接研究答案的，现在就照着大神们的帖子来讲一讲吧。</p>
<p>先来看这四种操作，由于概率相同，所以每一种操作都的有，所以这四种操作可以想象成迷宫遍历的周围四个方向，那么我们就可以用递归来做。再看一下题目中给的N的范围，可以到10的9次方，而每次汤的消耗最多不过100毫升，由于纯递归基本就是暴力搜索，所以我们需要加上记忆数组memo，来避免重复运算，提高运行的效率。既然用记忆数组，我们不想占用太多空间，可以对工件进行优化。怎么优化呢，我们发现汤的供应量都是25的倍数，所以我们可以将25毫升当作一份汤的量，所以这四种操作就变成了：</p>
<p>1. 供应4份A汤，0份B汤。</p>
<p>2. 供应3份A汤，1份B汤。</p>
<p>3. 供应2份A汤，2份B汤。</p>
<p>4. 供应1份A汤，3份B汤。</p>
<p>所以我们的汤份数就是可以通过除以25来获得，由于N可能不是25的倍数，会有余数，但是就算不到一份的量，也算是完成了一个操作，所以我们可以直接加上24再除以25就可以得到正确的份数。那么接下来就是调用递归了，其实递归函数很直接了当，首先判断如果两种汤都没了，那么返回0.5，因为题目中说了如果两种汤都供应完了，返回一半的概率；如果A汤没了，返回1；如果B汤没了，返回0；如果上面的情况都没有进入，说明此时A汤和B汤都有剩余，所以我们先查记忆数组memo，如果其大于0，说明当前情况已经被计算过了，我们直接返回该值即可。如果没有的话，我们就要计算这种情况的值，通过对四种情况分别调用递归函数中，将返回的概率值累加后除以4即可。这道题还有一个很大的优化，就是当N大过某一个数值的时候，返回的都是1。这里的4800就是这个阈值返回，这样的话memo数组的大小就可以是200x200了，至于是怎么提前设定的，博主就不知道了，估计是强行试出来的吧，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">double</span> memo[<span style="color: #800080;">200</span>][<span style="color: #800080;">200</span><span style="color: #000000;">];
    </span><span style="color: #0000ff;">double</span> soupServings(<span style="color: #0000ff;">int</span><span style="color: #000000;"> N) {
        </span><span style="color: #0000ff;">return</span> N &gt;= <span style="color: #800080;">4800</span> ? <span style="color: #800080;">1.0</span> : f((N + <span style="color: #800080;">24</span>) / <span style="color: #800080;">25</span>, (N + <span style="color: #800080;">24</span>) / <span style="color: #800080;">25</span><span style="color: #000000;">);
    }
    </span><span style="color: #0000ff;">double</span> f(<span style="color: #0000ff;">int</span> a, <span style="color: #0000ff;">int</span><span style="color: #000000;"> b) {
        </span><span style="color: #0000ff;">if</span> (a &lt;= <span style="color: #800080;">0</span> &amp;&amp; b &lt;= <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0.5</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (a &lt;= <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span> <span style="color: #800080;">1.0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (b &lt;= <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (memo[a][b] &gt; <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;"> memo[a][b];
        memo[a][b] </span>= <span style="color: #800080;">0.25</span> * (f(a - <span style="color: #800080;">4</span>, b) + f(a - <span style="color: #800080;">3</span>, b - <span style="color: #800080;">1</span>) + f(a - <span style="color: #800080;">2</span>, b - <span style="color: #800080;">2</span>) + f(a - <span style="color: #800080;">1</span>, b - <span style="color: #800080;">3</span><span style="color: #000000;">));
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> memo[a][b];
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种解法的思路基本一样，就是没有用二维数组，而是用了一个HashMap来保存计算过的值，建立字符串到double到映射，这里的字符串是由A汤和B汤的剩余量拼成的，为了保证唯一性，将二者的值先转为字符串，然后在中间加一个冒号拼在一起。由于是字符串，所以我们也不用将毫升数变成份数，直接就原样保存吧，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    unordered_map</span>&lt;<span style="color: #0000ff;">string</span>, <span style="color: #0000ff;">double</span>&gt;<span style="color: #000000;"> m;
    </span><span style="color: #0000ff;">double</span> soupServings(<span style="color: #0000ff;">int</span><span style="color: #000000;"> N) {
        </span><span style="color: #0000ff;">return</span> N &gt;= <span style="color: #800080;">4800</span> ? <span style="color: #800080;">1.0</span><span style="color: #000000;"> : f(N, N);
    }
    </span><span style="color: #0000ff;">double</span> f(<span style="color: #0000ff;">int</span> a, <span style="color: #0000ff;">int</span><span style="color: #000000;"> b) {
        </span><span style="color: #0000ff;">if</span> (a &lt;= <span style="color: #800080;">0</span> &amp;&amp; b &lt;= <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0.5</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (a &lt;= <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span> <span style="color: #800080;">1.0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (b &lt;= <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">string</span> spoon = to_string(a) + <span style="color: #800000;">"</span><span style="color: #800000;">:</span><span style="color: #800000;">"</span> +<span style="color: #000000;"> to_string(b);
        </span><span style="color: #0000ff;">if</span> (!<span style="color: #000000;">m.count(spoon)) {
            m[spoon] </span>= <span style="color: #800080;">0.25</span> * (f(a - <span style="color: #800080;">100</span>, b) + f(a - <span style="color: #800080;">75</span>, b - <span style="color: #800080;">25</span>) + f(a - <span style="color: #800080;">50</span>, b - <span style="color: #800080;">50</span>) + f(a - <span style="color: #800080;">25</span>, b - <span style="color: #800080;">75</span><span style="color: #000000;">));
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> m[spoon];
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a href="http://www.cnblogs.com/grandyang/p/4606334.html" target="_blank">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-08-02 12:21</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=9406434" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(9406434);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/9426942.html" id="cb_post_title_url">[LeetCode] Expressive Words 富于表现力的单词</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Sometimes people repeat letters to represent extra feeling, such as "hello" -&gt; "heeellooo", "hi" -&gt; "hiiii".  Here, we have groups, of adjacent letters that are all the same character, and adjacent characters to the group are different.  A group is extended if that group is length 3 or more, so "e" and "o" would be extended in the first example, and "i" would be extended in the second example.  As another example, the groups of "abbcccaaaa" would be "a", "bb", "ccc", and "aaaa"; and "ccc" and "aaaa" are the extended groups of that string.</p>
<p>For some given string S, a query word is <em>stretchy</em> if it can be made to be equal to S by extending some groups.  Formally, we are allowed to repeatedly choose a group (as defined above) of characters <code>c</code>, and add some number of the same character <code>c</code> to it so that the length of the group is 3 or more.  Note that we cannot extend a group of size one like "h" to a group of size two like "hh" - all extensions must leave the group extended - ie., at least 3 characters long.</p>
<p>Given a list of query words, return the number of words that are stretchy. </p>
<pre>Example:
Input: 
S = "heeellooo"
words = ["hello", "hi", "helo"]
Output: 1
Explanation: 
We can extend "e" and "o" in the word "hello" to get "heeellooo".
We can't extend "helo" to get "heeellooo" because the group "ll" is not extended.
</pre>
<p>Notes:</p>
<ul>
<li><code>0 &lt;= len(S) &lt;= 100</code>.</li>
<li><code>0 &lt;= len(words) &lt;= 100</code>.</li>
<li><code>0 &lt;= len(words[i]) &lt;= 100</code>.</li>
<li><code>S</code> and all words in <code>words</code> consist only of lowercase letters</li>
</ul>
<p> </p>
<p>这道题定义了一种富于表现力的单词，就是说某个字母可以重复三次或以上，那么对于这种重复后的单词，我们称之为可拉伸的（stretchy）。现在给了我们一个拉伸后的单词S，又给了我们一个单词数组，问我们里面有多少个单词可以拉伸成为S。其实这道题的关键就在于看某个字母是否被重复了三次，重复两次是不行的。那么我们就只能遍历单词数组words中的单词，来分别和S比较了。每个遍历到的单词的长度suppose是应该小于等于S的，因为S是拉伸后的单词，当然S也可以和遍历到的单词相等，那么表示没有拉伸。我们需要两个指针i和j来分别指向S和遍历单词word，我们需要逐个比较，由于S的长度要大于等于word，所以我们for循环直接遍历S的字母就好了，首先看如果j没越界，并且此时S[i]和word[j]相等的话，那么j自增1，i在for循环中也会自增1，遍历下一个字母。如果此时不相等或者j已经越界的话，我们再看当前的S[i]是否是3个重复中的中间那个，即S[i-1]和S[i+1]需要等于S[i]，是的话，i自增1，然后加上for循环中的自增1，相当于总共增了2个，正好跳过这个重复三连。否则的话再看是否前两个都和当前的字母相等，即S[i-1]和S[i-2]需要等于S[i]，因为可能重复的个数多于3个，如果这个条件不满足的话，直接break就行了。for循环结束或者跳出后，我们看S和word是否正好遍历完，即i和j是否分别等于S和word的长度，是的话结果res自增1，参见代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> expressiveWords(<span style="color: #0000ff;">string</span> S, vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp;<span style="color: #000000;"> words) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, m = S.size(), n =<span style="color: #000000;"> words.size();
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">string</span><span style="color: #000000;"> word : words) {
            </span><span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>, j = <span style="color: #800080;">0</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">for</span> (; i &lt; m; ++<span style="color: #000000;">i) {
                </span><span style="color: #0000ff;">if</span> (j &lt; word.size() &amp;&amp; S[i] == word[j]) ++<span style="color: #000000;">j;
                </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (i &gt; <span style="color: #800080;">0</span> &amp;&amp; S[i] == S[i - <span style="color: #800080;">1</span>] &amp;&amp; i + <span style="color: #800080;">1</span> &lt; m &amp;&amp; S[i] == S[i + <span style="color: #800080;">1</span>]) ++<span style="color: #000000;">i;
                </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (!(i &gt; <span style="color: #800080;">1</span> &amp;&amp; S[i] == S[i - <span style="color: #800080;">1</span>] &amp;&amp; S[i] == S[i - <span style="color: #800080;">2</span>])) <span style="color: #0000ff;">break</span><span style="color: #000000;">;
            }
            </span><span style="color: #0000ff;">if</span> (i == m &amp;&amp; j == word.size()) ++<span style="color: #000000;">res;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a href="http://www.cnblogs.com/grandyang/p/4606334.html" target="_blank">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-08-05 20:03</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=9426942" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(9426942);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/9406434.html" id="cb_post_title_url">[LeetCode] Soup Servings 供应汤</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="question-description__3U1T">
<div>
<p>There are two types of soup: type A and type B. Initially we have <code>N</code> ml of each type of soup. There are four kinds of operations:</p>
<ol>
<li>Serve 100 ml of soup A and 0 ml of soup B</li>
<li>Serve 75 ml of soup A and 25 ml of soup B</li>
<li>Serve 50 ml of soup A and 50 ml of soup B</li>
<li>Serve 25 ml of soup A and 75 ml of soup B</li>
</ol>
<p>When we serve some soup, we give it to someone and we no longer have it.  Each turn, we will choose from the four operations with equal probability 0.25. If the remaining volume of soup is not enough to complete the operation, we will serve as much as we can.  We stop once we no longer have some quantity of both types of soup.</p>
<p>Note that we do not have the operation where all 100 ml's of soup B are used first.  </p>
<p>Return the probability that soup A will be empty first, plus half the probability that A and B become empty at the same time.</p>
<p> </p>
<pre>Example:
Input: N = 50
Output: 0.625
Explanation: 
If we choose the first two operations, A will become empty first. For the third operation, A and B will become empty at the same time. For the fourth operation, B will become empty first. So the total probability of A becoming empty first plus half the probability that A and B become empty at the same time, is 0.25 * (1 + 1 + 0.5 + 0) = 0.625.

</pre>
<p>Notes:</p>
<ul>
<li><code>0 &lt;= N &lt;= 10^9</code>. </li>
<li>Answers within <code>10^-6</code> of the true value will be accepted as correct.</li>
</ul>
</div>
</div>
<p> </p>
<p>这道题给了我们两种汤，A和B，开始时各给了N毫升的。然后说是有下面四种操作：</p>
<p>1. 供应100毫升A汤，0毫升B汤。</p>
<p>2. 供应75毫升A汤，25毫升B汤。</p>
<p>3. 供应50毫升A汤，50毫升B汤。</p>
<p>4. 供应25毫升A汤，75毫升B汤。</p>
<p>我们选择每种操作的概率是一样的，让我们返回A汤先供应完的概率加上A汤和B汤同时供应完的一半概率。又给了一个例子来帮助我们理解。说实话，博主觉得这道题挺让人费解的，反正博主是没有啥思路，是直接研究答案的，现在就照着大神们的帖子来讲一讲吧。</p>
<p>先来看这四种操作，由于概率相同，所以每一种操作都的有，所以这四种操作可以想象成迷宫遍历的周围四个方向，那么我们就可以用递归来做。再看一下题目中给的N的范围，可以到10的9次方，而每次汤的消耗最多不过100毫升，由于纯递归基本就是暴力搜索，所以我们需要加上记忆数组memo，来避免重复运算，提高运行的效率。既然用记忆数组，我们不想占用太多空间，可以对工件进行优化。怎么优化呢，我们发现汤的供应量都是25的倍数，所以我们可以将25毫升当作一份汤的量，所以这四种操作就变成了：</p>
<p>1. 供应4份A汤，0份B汤。</p>
<p>2. 供应3份A汤，1份B汤。</p>
<p>3. 供应2份A汤，2份B汤。</p>
<p>4. 供应1份A汤，3份B汤。</p>
<p>所以我们的汤份数就是可以通过除以25来获得，由于N可能不是25的倍数，会有余数，但是就算不到一份的量，也算是完成了一个操作，所以我们可以直接加上24再除以25就可以得到正确的份数。那么接下来就是调用递归了，其实递归函数很直接了当，首先判断如果两种汤都没了，那么返回0.5，因为题目中说了如果两种汤都供应完了，返回一半的概率；如果A汤没了，返回1；如果B汤没了，返回0；如果上面的情况都没有进入，说明此时A汤和B汤都有剩余，所以我们先查记忆数组memo，如果其大于0，说明当前情况已经被计算过了，我们直接返回该值即可。如果没有的话，我们就要计算这种情况的值，通过对四种情况分别调用递归函数中，将返回的概率值累加后除以4即可。这道题还有一个很大的优化，就是当N大过某一个数值的时候，返回的都是1。这里的4800就是这个阈值返回，这样的话memo数组的大小就可以是200x200了，至于是怎么提前设定的，博主就不知道了，估计是强行试出来的吧，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">double</span> memo[<span style="color: #800080;">200</span>][<span style="color: #800080;">200</span><span style="color: #000000;">];
    </span><span style="color: #0000ff;">double</span> soupServings(<span style="color: #0000ff;">int</span><span style="color: #000000;"> N) {
        </span><span style="color: #0000ff;">return</span> N &gt;= <span style="color: #800080;">4800</span> ? <span style="color: #800080;">1.0</span> : f((N + <span style="color: #800080;">24</span>) / <span style="color: #800080;">25</span>, (N + <span style="color: #800080;">24</span>) / <span style="color: #800080;">25</span><span style="color: #000000;">);
    }
    </span><span style="color: #0000ff;">double</span> f(<span style="color: #0000ff;">int</span> a, <span style="color: #0000ff;">int</span><span style="color: #000000;"> b) {
        </span><span style="color: #0000ff;">if</span> (a &lt;= <span style="color: #800080;">0</span> &amp;&amp; b &lt;= <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0.5</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (a &lt;= <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span> <span style="color: #800080;">1.0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (b &lt;= <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (memo[a][b] &gt; <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;"> memo[a][b];
        memo[a][b] </span>= <span style="color: #800080;">0.25</span> * (f(a - <span style="color: #800080;">4</span>, b) + f(a - <span style="color: #800080;">3</span>, b - <span style="color: #800080;">1</span>) + f(a - <span style="color: #800080;">2</span>, b - <span style="color: #800080;">2</span>) + f(a - <span style="color: #800080;">1</span>, b - <span style="color: #800080;">3</span><span style="color: #000000;">));
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> memo[a][b];
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种解法的思路基本一样，就是没有用二维数组，而是用了一个HashMap来保存计算过的值，建立字符串到double到映射，这里的字符串是由A汤和B汤的剩余量拼成的，为了保证唯一性，将二者的值先转为字符串，然后在中间加一个冒号拼在一起。由于是字符串，所以我们也不用将毫升数变成份数，直接就原样保存吧，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    unordered_map</span>&lt;<span style="color: #0000ff;">string</span>, <span style="color: #0000ff;">double</span>&gt;<span style="color: #000000;"> m;
    </span><span style="color: #0000ff;">double</span> soupServings(<span style="color: #0000ff;">int</span><span style="color: #000000;"> N) {
        </span><span style="color: #0000ff;">return</span> N &gt;= <span style="color: #800080;">4800</span> ? <span style="color: #800080;">1.0</span><span style="color: #000000;"> : f(N, N);
    }
    </span><span style="color: #0000ff;">double</span> f(<span style="color: #0000ff;">int</span> a, <span style="color: #0000ff;">int</span><span style="color: #000000;"> b) {
        </span><span style="color: #0000ff;">if</span> (a &lt;= <span style="color: #800080;">0</span> &amp;&amp; b &lt;= <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0.5</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (a &lt;= <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span> <span style="color: #800080;">1.0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (b &lt;= <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">string</span> spoon = to_string(a) + <span style="color: #800000;">"</span><span style="color: #800000;">:</span><span style="color: #800000;">"</span> +<span style="color: #000000;"> to_string(b);
        </span><span style="color: #0000ff;">if</span> (!<span style="color: #000000;">m.count(spoon)) {
            m[spoon] </span>= <span style="color: #800080;">0.25</span> * (f(a - <span style="color: #800080;">100</span>, b) + f(a - <span style="color: #800080;">75</span>, b - <span style="color: #800080;">25</span>) + f(a - <span style="color: #800080;">50</span>, b - <span style="color: #800080;">50</span>) + f(a - <span style="color: #800080;">25</span>, b - <span style="color: #800080;">75</span><span style="color: #000000;">));
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> m[spoon];
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a href="http://www.cnblogs.com/grandyang/p/4606334.html" target="_blank">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-08-02 12:21</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=9406434" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(9406434);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/9383482.html" id="cb_post_title_url">[LeetCode] Max Increase to Keep City Skyline 保持城市天际线的最大增高</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="question-description__3U1T">
<div>
<p>In a 2 dimensional array <code>grid</code>, each value <code>grid[i][j]</code> represents the height of a building located there. We are allowed to increase the height of any number of buildings, by any amount (the amounts can be different for different buildings). Height 0 is considered to be a building as well. </p>
<p>At the end, the "skyline" when viewed from all four directions of the grid, i.e. top, bottom, left, and right, must be the same as the skyline of the original grid. A city's skyline is the outer contour of the rectangles formed by all the buildings when viewed from a distance. See the following example.</p>
<p>What is the maximum total sum that the height of the buildings can be increased?</p>
<pre>Example:
Input: grid = [[3,0,8,4],[2,4,5,7],[9,2,6,3],[0,3,1,0]]
Output: 35
Explanation: 
The grid is:
[ [3, 0, 8, 4], 
  [2, 4, 5, 7],
  [9, 2, 6, 3],
  [0, 3, 1, 0] ]

The skyline viewed from top or bottom is: [9, 4, 8, 7]
The skyline viewed from left or right is: [8, 7, 9, 3]

The grid after increasing the height of buildings without affecting skylines is:

gridNew = [ [8, 4, 8, 7],
            [7, 4, 7, 7],
            [9, 4, 8, 7],
            [3, 3, 3, 3] ]

</pre>
<p>Notes:</p>
<ul>
<li><code>1 &lt; grid.length = grid[0].length &lt;= 50</code>.</li>
<li>All heights <code>grid[i][j]</code> are in the range <code>[0, 100]</code>.</li>
<li>All buildings in <code>grid[i][j]</code> occupy the entire grid cell: that is, they are a <code>1 x 1 x grid[i][j]</code>rectangular prism.</li>
</ul>
</div>
</div>
<p> </p>
<p>这道题给了我们一个二维数组，说是数组中的每个数字代表了一栋建筑的高度，那么从四个方向看去，就会有城市的天际线，这个天际线就是由这些建筑的最高的边形成的，现在让我们在不改变天际线的前提下，问最多可以增高建筑的总高度。那么既然不能改变天际线，我们就要清楚天际线是由啥组成的，是最高的建筑物，那么就是说每行或每列的最高那个建筑不能变，而其他建筑物在不超过该行该列中最高建筑的高度情况下是可以有升高空间的。那么思路就该很清晰了，我们首先需要求出各行各列的最大值，成为一个限制高度，然后就遍历每个建筑，每一个建筑的高度都有可能影响该行或者该列的天际线，那么该行该列中的较小值应该是该建筑物的高度极限，如果超过了这个值，那么原来的天际线就会被破坏，所以这个极限值和当前的高度之差就是可以增加的高度，我们累计所有建筑的可增加的高度，就是所求的最大增高，参见代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> maxIncreaseKeepingSkyline(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> grid) {
        </span><span style="color: #0000ff;">int</span> m = grid.size(), n = grid[<span style="color: #800080;">0</span>].size(), res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; row(m, <span style="color: #800080;">0</span>), col(n, <span style="color: #800080;">0</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; m; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; n; ++<span style="color: #000000;">j) {
                row[i] </span>=<span style="color: #000000;"> max(row[i], grid[i][j]);
                col[j] </span>=<span style="color: #000000;"> max(col[j], grid[i][j]);
            }
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; m; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; n; ++<span style="color: #000000;">j) {
                res </span>+= min(row[i] - grid[i][j], col[j] -<span style="color: #000000;"> grid[i][j]);
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-07-28 21:21</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=9383482" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(9383482);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/9348596.html" id="cb_post_title_url">[LeetCode] Number of Lines To Write String 写字符串需要的行数</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>We are to write the letters of a given string <code>S</code>, from left to right into lines. Each line has maximum width 100 units, and if writing a letter would cause the width of the line to exceed 100 units, it is written on the next line. We are given an array <code>widths</code>, an array where widths[0] is the width of 'a', widths[1] is the width of 'b', ..., and widths[25] is the width of 'z'.</p>
<p>Now answer two questions: how many lines have at least one character from <code>S</code>, and what is the width used by the last such line? Return your answer as an integer list of length 2.</p>
<p> </p>
<pre>Example :
Input: 
widths = [10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10]
S = "abcdefghijklmnopqrstuvwxyz"
Output: [3, 60]
Explanation: 
All letters have the same length of 10. To write all 26 letters,
we need two full lines and one line with 60 units.
</pre>
<pre>Example :
Input: 
widths = [4,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10]
S = "bbbcccdddaaa"
Output: [2, 4]
Explanation: 
All letters except 'a' have the same length of 10, and 
"bbbcccdddaa" will cover 9 * 10 + 2 * 4 = 98 units.
For the last 'a', it is written on the second line because
there is only 2 units left in the first line.
So the answer is 2 lines, plus 4 units in the second line.
</pre>
<p> </p>
<p>Note:</p>
<ul>
<li>The length of <code>S</code> will be in the range [1, 1000].</li>
<li><code>S</code> will only contain lowercase letters.</li>
<li><code>widths</code> is an array of length <code>26</code>.</li>
<li><code>widths[i]</code> will be in the range of <code>[2, 10]</code>.</li>
</ul>
<p> </p>
<p>这道题给了我们一个字符串，让我们把里面的字母写下来，规定了每一行的长度为100，然后每个字母的长度可以在widths数组中查询，说是如果某一个字母加上后超过了长度100的限制，那么就移动到下一行，问我们最终需要多少行，和最后一行的长度。这道题并没有太大的难度和技巧，就是楞头写呗，遍历所有的字母，然后查表得到其宽度，然后看加上这个新宽度是否超了100，超了的话，行数计数器自增1，并且当前长度为这个字母的长度，因为另起了一行。如果没超100，那么行长度就直接加上这个字母的长度。遍历完成后返回行数和当前行长度即可，参见代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; numberOfLines(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; widths, <span style="color: #0000ff;">string</span><span style="color: #000000;"> S) {
        </span><span style="color: #0000ff;">int</span> cnt = <span style="color: #800080;">1</span>, cur = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span><span style="color: #000000;"> c : S) {
            </span><span style="color: #0000ff;">int</span> t = widths[c - <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span><span style="color: #000000;">];
            </span><span style="color: #0000ff;">if</span> (cur + t &gt; <span style="color: #800080;">100</span>) ++<span style="color: #000000;">cnt;
            cur </span>= (cur + t &gt; <span style="color: #800080;">100</span>) ? t : cur +<span style="color: #000000;"> t;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> {cnt, cur};
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-07-21 23:51</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=9348596" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(9348596);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/9338988.html" id="cb_post_title_url">[LeetCode] Unique Morse Code Words 独特的摩斯码单词</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>International Morse Code defines a standard encoding where each letter is mapped to a series of dots and dashes, as follows: <code>"a"</code> maps to <code>".-"</code>, <code>"b"</code> maps to <code>"-..."</code>, <code>"c"</code> maps to <code>"-.-."</code>, and so on.</p>
<p>For convenience, the full table for the 26 letters of the English alphabet is given below:</p>
<pre>[".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."]</pre>
<p>Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, "cab" can be written as "-.-.-....-", (which is the concatenation "-.-." + "-..." + ".-"). We'll call such a concatenation, the transformation of a word.</p>
<p>Return the number of different transformations among all words we have.</p>
<pre>Example:
Input: words = ["gin", "zen", "gig", "msg"]
Output: 2
Explanation: 
The transformation of each word is:
"gin" -&gt; "--...-."
"zen" -&gt; "--...-."
"gig" -&gt; "--...--."
"msg" -&gt; "--...--."

There are 2 different transformations, "--...-." and "--...--.".
</pre>
<p> </p>
<p>Note:</p>
<ul>
<li>The length of <code>words</code> will be at most <code>100</code>.</li>
<li>Each <code>words[i]</code> will have length in range <code>[1, 12]</code>.</li>
<li><code>words[i]</code> will only consist of lowercase letters.</li>
</ul>
<p> </p>
<p>这道题说的就是大名鼎鼎的摩斯码了，给了我们所有字母的摩斯码的写法，然后给了我们一个单词数组，问我们表示这些单词的摩斯码有多少种。因为某些单词的摩斯码表示是相同的，比如gin和zen就是相同的。最简单直接的方法就是我们求出每一个单词的摩斯码，然后将其放入一个HashSet中，利用其去重复的特性，从而实现题目的要求，最终HashSet中元素的个数即为所求，参见代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> uniqueMorseRepresentations(vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp;<span style="color: #000000;"> words) {
        vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; morse{<span style="color: #800000;">"</span><span style="color: #800000;">.-</span><span style="color: #800000;">"</span>,<span style="color: #800000;">"</span><span style="color: #800000;">-...</span><span style="color: #800000;">"</span>,<span style="color: #800000;">"</span><span style="color: #800000;">-.-.</span><span style="color: #800000;">"</span>,<span style="color: #800000;">"</span><span style="color: #800000;">-..</span><span style="color: #800000;">"</span>,<span style="color: #800000;">"</span><span style="color: #800000;">.</span><span style="color: #800000;">"</span>,<span style="color: #800000;">"</span><span style="color: #800000;">..-.</span><span style="color: #800000;">"</span>,<span style="color: #800000;">"</span><span style="color: #800000;">--.</span><span style="color: #800000;">"</span>,<span style="color: #800000;">"</span><span style="color: #800000;">....</span><span style="color: #800000;">"</span>,<span style="color: #800000;">"</span><span style="color: #800000;">..</span><span style="color: #800000;">"</span>,<span style="color: #800000;">"</span><span style="color: #800000;">.---</span><span style="color: #800000;">"</span>,<span style="color: #800000;">"</span><span style="color: #800000;">-.-</span><span style="color: #800000;">"</span>,<span style="color: #800000;">"</span><span style="color: #800000;">.-..</span><span style="color: #800000;">"</span>,<span style="color: #800000;">"</span><span style="color: #800000;">--</span><span style="color: #800000;">"</span>,<span style="color: #800000;">"</span><span style="color: #800000;">-.</span><span style="color: #800000;">"</span>,<span style="color: #800000;">"</span><span style="color: #800000;">---</span><span style="color: #800000;">"</span>,<span style="color: #800000;">"</span><span style="color: #800000;">.--.</span><span style="color: #800000;">"</span>,<span style="color: #800000;">"</span><span style="color: #800000;">--.-</span><span style="color: #800000;">"</span>,<span style="color: #800000;">"</span><span style="color: #800000;">.-.</span><span style="color: #800000;">"</span>,<span style="color: #800000;">"</span><span style="color: #800000;">...</span><span style="color: #800000;">"</span>,<span style="color: #800000;">"</span><span style="color: #800000;">-</span><span style="color: #800000;">"</span>,<span style="color: #800000;">"</span><span style="color: #800000;">..-</span><span style="color: #800000;">"</span>,<span style="color: #800000;">"</span><span style="color: #800000;">...-</span><span style="color: #800000;">"</span>,<span style="color: #800000;">"</span><span style="color: #800000;">.--</span><span style="color: #800000;">"</span>,<span style="color: #800000;">"</span><span style="color: #800000;">-..-</span><span style="color: #800000;">"</span>,<span style="color: #800000;">"</span><span style="color: #800000;">-.--</span><span style="color: #800000;">"</span>,<span style="color: #800000;">"</span><span style="color: #800000;">--..</span><span style="color: #800000;">"</span><span style="color: #000000;">};
        unordered_set</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> s;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">string</span><span style="color: #000000;"> word : words) {
            </span><span style="color: #0000ff;">string</span> t = <span style="color: #800000;">""</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span> c : word) t += morse[c - <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span><span style="color: #000000;">];
            s.insert(t);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> s.size();
    }
};</span></pre>
</div>
<p> </p>
<p>讨论：这道题其实没有充分发挥其潜力，摩斯码的场景很好，只是作为一道Easy题未免有些可惜了。一个比较显而易见的follow up就是，给我们一个摩斯码，问其有几种可能的单词组，比如给我们一个"--...-."，那么我们知道至少有两种zen和gin，可能还有更多，这样是不是就更加有趣了呢？</p>
<p> </p>
<p>类似题目：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-07-19 23:04</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=9338988" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(9338988);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/9362777.html" id="cb_post_title_url">[LeetCode] Bricks Falling When Hit 碰撞时砖头掉落</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>We have a grid of 1s and 0s; the 1s in a cell represent bricks.  A brick will not drop if and only if it is directly connected to the top of the grid, or at least one of its (4-way) adjacent bricks will not drop.</p>
<p>We will do some erasures sequentially. Each time we want to do the erasure at the location (i, j), the brick (if it exists) on that location will disappear, and then some other bricks may drop because of that erasure.</p>
<p>Return an array representing the number of bricks that will drop after each erasure in sequence.</p>
<pre>Example 1:
Input: 
grid = [[1,0,0,0],[1,1,1,0]]
hits = [[1,0]]
Output: [2]
Explanation: 
If we erase the brick at (1, 0), the brick at (1, 1) and (1, 2) will drop. So we should return 2.</pre>
<pre>Example 2:
Input: 
grid = [[1,0,0,0],[1,1,0,0]]
hits = [[1,1],[1,0]]
Output: [0,0]
Explanation: 
When we erase the brick at (1, 0), the brick at (1, 1) has already disappeared due to the last move. So each erasure will cause no bricks dropping.  Note that the erased brick (1, 0) will not be counted as a dropped brick.</pre>
<p> </p>
<p>Note:</p>
<ul>
<li>The number of rows and columns in the grid will be in the range [1, 200].</li>
<li>The number of erasures will not exceed the area of the grid.</li>
<li>It is guaranteed that each erasure will be different from any other erasure, and located inside the grid.</li>
<li>An erasure may refer to a location with no brick - if it does, no bricks drop.</li>
</ul>
<p> </p>
<p>这道题给了我们一个由0和1组成的grid，说是1代表砖头，当砖头连着顶端的时候，就不会掉落，当某个砖头连着不会掉落的砖头时，其本身也不会掉落。然后我们要去掉一些砖头，当去掉某个砖头时，与其相连的砖头可能也会同时掉落。所以这里让我们求同时掉落的砖头个数。博主书读的不少，不会受骗，这尼玛不就是泡泡龙游戏么。其中泡泡龙的一大技巧就是挂葡萄，当关键节点处的泡泡被打掉后，这整个一串都可以直接掉下来。这里也是一样啊，grid的顶端就是游戏界面的顶端，然后砖头就是泡泡，去掉砖头就是消掉某个地方的泡泡，然后掉落的砖头就是掉下的泡泡啦。游戏玩的6，不代表题会做，其实这道题还是蛮有难度的，花了博主很长的时间。</p>
<p>首先我们来想，我们肯定要统计出当前没有掉落的砖头数量，当去掉某个砖头后，我们可以统计当前还连着的砖头数量，二者做差值就是掉落的砖头数量。那么如何来统计不会掉落的砖头数量呢，由于顶层的砖头时不会掉落的，那么跟顶层相连的所有砖头肯定也不会掉落，我们就可以使用DFS来遍历，我们可以把不会掉落的砖头位置存入一个HashSet中，这样通过比较不同状态下HashSet中元素的个数，我们就知道掉落了多少砖头。然后我们再来想一个问题，在没有去除任何砖头的时候，我们DFS查找会遍历所有的砖头，当某个砖头去除后，可能没有连带其他的砖头，那么如果我们再来遍历一遍所有相连的砖头，相当于又把整个数组搜索了一遍，这样并不是很高效。我们可以试着换一个思路，如果我们先把要去掉的所有砖头都先去掉，这样我们遍历所有相连的砖头就是最终还剩下的砖头，然后我们从最后一个砖头开始往回加，每加一个砖头，我们就以这个砖头为起点，DFS遍历其周围相连的砖头，加入HashSet中，那么只会遍历那些会掉的砖头，那么增加的这些砖头就是会掉的砖头数量了，然后再不停的在增加前面的砖头，直到把hits中所有的砖头都添加回来了，那么我们也就计算出了每次会掉的砖头的个数。</p>
<p>好，我们使用一个HashSet来保存不会掉落的砖头，然后先遍历hits数组，把要掉落的砖头位置的值都减去一个1，这里有个需要注意的地方，hits里的掉落位置实际上在grid中不一定有砖头，就是说可能是本身为0的位置，那么我们减1后，数组中也可能会有-1，没有太大的影响，不过需要注意一下，这里不能使用 if (grid[i][j]) 来直接判断其是否为1，因为非0值-1也会返回true。然后我们对第一行的砖头都调用递归函数，因为顶端的砖头不会掉落，跟顶端的砖头相连的砖头也不会掉落，所以要遍历所有相连的砖头，将位置都存入noDrop。然后就是从最后一个位置往前加砖头，先记录noDrop当前的元素个数，然后grid中对应的值自增1，之后增加后的值为1了，才说明这块之前是有砖头的，然后我们看其上下左右位置，若有砖头，则对当前位置调用递归，还有一种情况是当前是顶层的话，还是要调用递归。递归调用完成后二者的差值再减去1就是掉落的砖头数，减1的原因是去掉的砖头不算掉落的砖头数中，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; hitBricks(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> hits) {
        </span><span style="color: #0000ff;">int</span> m = grid.size(), n = grid[<span style="color: #800080;">0</span>].size(), k =<span style="color: #000000;"> hits.size();
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> res(k);
        unordered_set</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> noDrop;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; k; ++i) grid[hits[i][<span style="color: #800080;">0</span>]][hits[i][<span style="color: #800080;">1</span>]] -= <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (grid[<span style="color: #800080;">0</span>][i] == <span style="color: #800080;">1</span>) check(grid, <span style="color: #800080;">0</span><span style="color: #000000;">, i, noDrop);
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = k - <span style="color: #800080;">1</span>; i &gt;= <span style="color: #800080;">0</span>; --<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">int</span> oldSize = noDrop.size(), x = hits[i][<span style="color: #800080;">0</span>], y = hits[i][<span style="color: #800080;">1</span><span style="color: #000000;">];
            </span><span style="color: #0000ff;">if</span> (++grid[x][y] != <span style="color: #800080;">1</span>) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> ((x - <span style="color: #800080;">1</span> &gt;= <span style="color: #800080;">0</span> &amp;&amp; noDrop.count((x - <span style="color: #800080;">1</span>) * n +<span style="color: #000000;"> y)) 
                </span>|| (x + <span style="color: #800080;">1</span> &lt; m &amp;&amp; noDrop.count((x + <span style="color: #800080;">1</span>) * n +<span style="color: #000000;"> y))
                </span>|| (y - <span style="color: #800080;">1</span> &gt;= <span style="color: #800080;">0</span> &amp;&amp; noDrop.count(x * n + y - <span style="color: #800080;">1</span><span style="color: #000000;">))
                </span>|| (y + <span style="color: #800080;">1</span> &lt; n &amp;&amp; noDrop.count(x * n + y + <span style="color: #800080;">1</span><span style="color: #000000;">))
                </span>|| x == <span style="color: #800080;">0</span><span style="color: #000000;">) {
                check(grid, x, y, noDrop);
                res[i] </span>= noDrop.size() - oldSize - <span style="color: #800080;">1</span><span style="color: #000000;">;
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">void</span> check(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp; grid, <span style="color: #0000ff;">int</span> i, <span style="color: #0000ff;">int</span> j, unordered_set&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> noDrop) {
        </span><span style="color: #0000ff;">int</span> m = grid.size(), n = grid[<span style="color: #800080;">0</span><span style="color: #000000;">].size();
        </span><span style="color: #0000ff;">if</span> (i &lt; <span style="color: #800080;">0</span> || i &gt;= m || j &lt; <span style="color: #800080;">0</span> || j &gt;= n || grid[i][j] != <span style="color: #800080;">1</span> || noDrop.count(i * n + j)) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
        noDrop.insert(i </span>* n +<span style="color: #000000;"> j);
        check(grid, i </span>- <span style="color: #800080;">1</span><span style="color: #000000;">, j, noDrop);
        check(grid, i </span>+ <span style="color: #800080;">1</span><span style="color: #000000;">, j, noDrop);
        check(grid, i, j </span>- <span style="color: #800080;">1</span><span style="color: #000000;">, noDrop);
        check(grid, i, j </span>+ <span style="color: #800080;">1</span><span style="color: #000000;">, noDrop);
    }
};</span></pre>
</div>
<p> </p>
<p>我们再来看一种使用并查集Union Find的方法来做的，接触过并查集题目的童鞋应该有印象，是专门处理群组问题的一种算法。最典型的就是岛屿问题(例如<a href="http://www.cnblogs.com/grandyang/p/5190419.html" target="_blank">Number of Islands II</a>)，很适合使用Union Find来做，LeetCode中有很多道可以使用这个方法来做的题，比如<a href="http://www.cnblogs.com/grandyang/p/6686983.html">Friend Circles</a>，<a href="http://www.cnblogs.com/grandyang/p/5257919.html" target="_blank">Graph Valid Tree</a>，<a href="http://www.cnblogs.com/grandyang/p/5166356.html" target="_blank">Number of Connected Components in an Undirected Graph</a>，和<a href="http://www.cnblogs.com/grandyang/p/7628977.html">Redundant Connection</a>等等。都是要用一个root数组，每个点开始初始化为不同的值，如果两个点属于相同的组，就将其中一个点的root值赋值为另一个点的位置，这样只要是相同组里的两点，通过find函数得到相同的值。当然初始化的时候也不用都赋为不同的值，如果表示的是坐标的话，我们也可以都初始化为-1，在find函数稍稍改动一下，也是可以的，这里就把判断 root[x] == x 改为 root[x] == -1 即可。这道题要稍稍复杂一些，我们不光需要并查集数组root，还需要知道每个位置右方和下方跟其相连的砖头个数数组count，还有标记每个位置是否相连且不会坠落的状态数组t，第一行各个位置的t值初始化为1。跟上面的方法类似，我们还是从最后一个砖头开始往回加，那么我们还是要把hits中所有的位置在grid中对应的值减1。然后我们要建立并查集的关系，我们遍历每一个位置，如果是砖头，那么我们对其右边和下边的位置进行检测，如果是砖头，我们就进行经典的并查集的操作，分别对当前位置和右边位置调用find函数，如果两个值不同，说明目前属于两个不同的群组，我们要链接上这两个位置，这里有个小问题需要注意一下，一般来说，我们链接群组的时候，root[x] = y 或 root[y] = x 都是可以的，但是这里我们需要使用第二种，为了跟后面的 count[x] += count[y] 对应起来，因为这里的y是在x的右边，所以count[x]要大于count[y]，这里x和y我们都使用x的群组号，这样能保证后面加到正确的相连的砖头个数。还有我们的t[x] 和 t[y] 也需要更新，因为两个位置要相连，所以只有其中有一方是跟顶端相连的，那么二者的t值都应该为1。初始化完成后，我们就从hits数组末尾开始往回加砖头，跟之前的方法一样，首先要判断之前是有砖头的，然后遍历周围四个新位置，如果位置合法且有砖头的话，再调用并查集的经典操作，对老位置和新位置分别调用find函数，如果不在同一个群组的话，我们需要一个变量cnt来记录可以掉落的砖头个数，如果新位置的t值为0，说明其除了当前位置之外不跟其他位置相连，我们将其count值加入cnt。然后就是链接两个群组，通知更新老位置的count值，新老位置的t值等等。当周围位置遍历完成后，如果当前位置的t值为1，则将cnt值存入结果res的对应位置，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; hitBricks(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> hits) {
        </span><span style="color: #0000ff;">int</span> m = grid.size(), n = grid[<span style="color: #800080;">0</span>].size(), k =<span style="color: #000000;"> hits.size();
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; res(k), root(m * n, -<span style="color: #800080;">1</span>), count(m * n, <span style="color: #800080;">1</span>), t(m * n, <span style="color: #800080;">0</span><span style="color: #000000;">);
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; dirs{{-<span style="color: #800080;">1</span>, <span style="color: #800080;">0</span>}, {<span style="color: #800080;">0</span>, <span style="color: #800080;">1</span>}, {<span style="color: #800080;">1</span>, <span style="color: #800080;">0</span>}, {<span style="color: #800080;">0</span>, -<span style="color: #800080;">1</span><span style="color: #000000;">}};
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; k; ++i) grid[hits[i][<span style="color: #800080;">0</span>]][hits[i][<span style="color: #800080;">1</span>]] -= <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++i) t[i] = <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; m; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; n; ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> (grid[i][j] != <span style="color: #800080;">1</span>) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">if</span> (i + <span style="color: #800080;">1</span> &lt; m &amp;&amp; grid[i + <span style="color: #800080;">1</span>][j] == <span style="color: #800080;">1</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">int</span> x = find(root, i * n + j), y = find(root, (i + <span style="color: #800080;">1</span>) * n +<span style="color: #000000;"> j);
                    </span><span style="color: #0000ff;">if</span> (x != y) {root[y] = x; count[x] += count[y]; t[x] = t[y] = (t[x] |<span style="color: #000000;"> t[y]);}
                }
                </span><span style="color: #0000ff;">if</span> (j + <span style="color: #800080;">1</span> &lt; n &amp;&amp; grid[i][j + <span style="color: #800080;">1</span>] == <span style="color: #800080;">1</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">int</span> x = find(root, i * n + j), y = find(root, i * n + j + <span style="color: #800080;">1</span><span style="color: #000000;">);
                    </span><span style="color: #0000ff;">if</span> (x != y) {root[y] = x; count[x] += count[y]; t[x] = t[y] = (t[x] |<span style="color: #000000;"> t[y]);}
                }
            }
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = k - <span style="color: #800080;">1</span>; i &gt;= <span style="color: #800080;">0</span>; --<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">int</span> x = hits[i][<span style="color: #800080;">0</span>], y = hits[i][<span style="color: #800080;">1</span>], a = find(root, x * n + y), cnt = <span style="color: #800080;">0</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> (++grid[x][y] != <span style="color: #800080;">1</span>) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto dir : dirs) {
                </span><span style="color: #0000ff;">int</span> newX = x + dir[<span style="color: #800080;">0</span>], newY = y + dir[<span style="color: #800080;">1</span><span style="color: #000000;">];
                </span><span style="color: #0000ff;">if</span> (newX &lt; <span style="color: #800080;">0</span> || newX &gt;= m || newY &lt; <span style="color: #800080;">0</span> || newY &gt;= n || grid[newX][newY] != <span style="color: #800080;">1</span>) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">int</span> b = find(root, newX * n +<span style="color: #000000;"> newY);
                </span><span style="color: #0000ff;">if</span> (a == b) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">if</span> (!t[b]) cnt +=<span style="color: #000000;"> count[b];
                root[b] </span>= a; count[a] += count[b]; t[a] = t[b] = (t[a] |<span style="color: #000000;"> t[b]);
            }
            </span><span style="color: #0000ff;">if</span> (t[a]) res[i] =<span style="color: #000000;"> cnt;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">int</span> find(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; root, <span style="color: #0000ff;">int</span><span style="color: #000000;"> x) {
        </span><span style="color: #0000ff;">return</span> (root[x] == -<span style="color: #800080;">1</span>) ?<span style="color: #000000;"> x : find(root, root[x]);
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a href="http://www.cnblogs.com/grandyang/p/4606334.html" target="_blank">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-07-24 21:36</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=9362777" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(9362777);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/9319966.html" id="cb_post_title_url">[LeetCode] Find Eventual Safe States 找到最终的安全状态</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>In a directed graph, we start at some node and every turn, walk along a directed edge of the graph.  If we reach a node that is terminal (that is, it has no outgoing directed edges), we stop.</p>
<p>Now, say our starting node is <em>eventually safe </em>if and only if we must eventually walk to a terminal node.  More specifically, there exists a natural number <code>K</code> so that for any choice of where to walk, we must have stopped at a terminal node in less than <code>K</code> steps.</p>
<p>Which nodes are eventually safe?  Return them as an array in sorted order.</p>
<p>The directed graph has <code>N</code> nodes with labels <code>0, 1, ..., N-1</code>, where <code>N</code> is the length of <code>graph</code>.  The graph is given in the following form: <code>graph[i]</code> is a list of labels <code>j</code> such that <code>(i, j)</code> is a directed edge of the graph.</p>
<pre>Example:
Input: graph = [[1,2],[2,3],[5],[0],[5],[],[]]
Output: [2,4,5,6]
Here is a diagram of the above graph.

</pre>
<p><img alt="Illustration of graph" height="105" src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/03/17/picture1.png" width="368"/></p>
<p>Note:</p>
<ul>
<li><code>graph</code> will have length at most <code>10000</code>.</li>
<li>The number of edges in the graph will not exceed <code>32000</code>.</li>
<li>Each <code>graph[i]</code> will be a sorted list of different integers, chosen within the range <code>[0, graph.length - 1]</code>.</li>
</ul>
<p> </p>
<p>这道题给了我们一个有向图，然后定义了一种最终安全状态的结点，就是说该结点要在自然数K步内停止，所谓停止的意思，就是再没有向外的边，即没有出度，像上面例子中的结点5和6就是出度为0，因为graph[5]和graph[6]均为空。那么我们分析题目中的例子，除了没有出度的结点5和6之外，结点2和4也是安全状态结点，为啥呢，我们发现结点2和4都只能到达结点5，而结点5本身就是安全状态点，所以2和4也就是安全状态点了，所以我们可以得出的结论是，若某结点唯一能到达的结点是安全状态结点的话，那么该结点也同样是安全状态结点。那么我们就可以从没有出度的安全状态往回推，比如结点5，往回推可以到达结点4和2，先看结点4，此时我们先回推到结点4，然后将这条边断开，那么此时结点4出度为0，则标记结点4也为安全状态结点，同理，回推到结点2，断开边，此时结点2虽然入度仍为2，但是出度为0了，标记结点2也为安全状态结点。</p>
<p>分析到这里，思路应该比较明朗了，由于我们需要回推边，所以需要建立逆向边，用一个集合数组来存，由于题目要求返回的结点有序，我们可以利用集合TreeSet的自动排序的特性，由于需要断开边，为了不修改输入数据，所以我们干脆再建一个顺向边得了，即跟输入数据相同。还需要一个safe数组，布尔型的，来标记哪些结点是安全状态结点。在遍历结点的时候，直接先将出度为0的安全状态结点找出来，排入一个队列queue中，方便后续的处理。后续的处理就有些类似BFS的操作了，我们循环非空queue，取出队首元素，标记safe中该结点为安全状态结点，然后遍历其逆向边的结点，即可以到达当前队首结点的所有结点，我们在正向边集合中删除对应的边，如果此时结点出度为0了，将其加入队列queue中等待下一步处理，这样while循环退出后，所有的安全状态结点都已经标记好了，我们直接遍历safe数组，将其存入结果res中即可，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; eventualSafeNodes(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> graph) {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">int</span> n =<span style="color: #000000;"> graph.size();
        vector</span>&lt;<span style="color: #0000ff;">bool</span>&gt; safe(n, <span style="color: #0000ff;">false</span><span style="color: #000000;">);
        vector</span>&lt;<span style="color: #0000ff;">set</span>&lt;<span style="color: #0000ff;">int</span>&gt;&gt; g(n, <span style="color: #0000ff;">set</span>&lt;<span style="color: #0000ff;">int</span>&gt;()), revg =<span style="color: #000000;"> g;
        queue</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> q;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (graph[i].empty()) q.push(i);
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span><span style="color: #000000;"> j : graph[i]) {
                g[i].insert(j);
                revg[j].insert(i);
            }
        }
        </span><span style="color: #0000ff;">while</span> (!<span style="color: #000000;">q.empty()) {
            auto t </span>=<span style="color: #000000;"> q.front(); q.pop();
            safe[t] </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span><span style="color: #000000;"> i : revg[t]) {
                g[i].erase(t);
                </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (g[i].empty()) q.push(i);
            }
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (safe[i]) res.push_back(i);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>我们再来看一种DFS遍历有向图的解法。仔细分析题目中的例子，不难发现，之所以某些结点不是安全状态，因为有环的存在，而环经过的所有结点，一定不是安全状态结点，所以我们可以通过DFS遍历有向图来找出环即可。在大多数的算法中，经典的DFS遍历法对于结点都有三种状态标记，white，gray，和black，其中white表示结点还未遍历，gray表示正在遍历邻结点，black表示已经结束该结点的遍历。那么我们可以对每个结点都调用递归函数，在递归函数中，如果当前结点不是white，表示该结点已经访问过了，那么如果当前结点是black，直接返回true，如果是gray，直接返回false，因为遇到gray的结点，表示一定有环存在。否则我们给结点标记gray，然后开始遍历所有邻接结点，如果某个邻结点是black，直接跳过该结点。如果某个邻结点是gray，或者对该邻结点调用递归返回false了，说明当前结点是环结点，返回false。如果循环结束了，当前结点标记为black，并且返回true，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; eventualSafeNodes(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> graph) {
        </span><span style="color: #0000ff;">int</span> n =<span style="color: #000000;"> graph.size();
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; res, color(n); <span style="color: #008000;">//</span><span style="color: #008000;"> 0 white, 1 gray, 2 black</span>
        <span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (helper(graph, i, color)) res.push_back(i);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">bool</span> helper(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp; graph, <span style="color: #0000ff;">int</span> cur, vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> color) {
        </span><span style="color: #0000ff;">if</span> (color[cur] &gt; <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span> color[cur] == <span style="color: #800080;">2</span><span style="color: #000000;">;
        color[cur] </span>= <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span><span style="color: #000000;"> i : graph[cur]) {
            </span><span style="color: #0000ff;">if</span> (color[i] == <span style="color: #800080;">2</span>) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> (color[i] == <span style="color: #800080;">1</span> || !<span style="color: #000000;">helper(graph, i, color)) {
                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            }
        }
        color[cur] </span>= <span style="color: #800080;">2</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-07-16 20:36</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=9319966" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(9319966);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/9311385.html" id="cb_post_title_url">[LeetCode] Minimum Swaps To Make Sequences Increasing 使得序列递增的最小交换</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>We have two integer sequences <code>A</code> and <code>B</code> of the same non-zero length.</p>
<p>We are allowed to swap elements <code>A[i]</code> and <code>B[i]</code>.  Note that both elements are in the same index position in their respective sequences.</p>
<p>At the end of some number of swaps, <code>A</code> and <code>B</code> are both strictly increasing.  (A sequence is <em>strictly increasing</em> if and only if <code>A[0] &lt; A[1] &lt; A[2] &lt; ... &lt; A[A.length - 1]</code>.)</p>
<p>Given A and B, return the minimum number of swaps to make both sequences strictly increasing.  It is guaranteed that the given input always makes it possible.</p>
<pre>Example:
Input: A = [1,3,5,4], B = [1,2,3,7]
Output: 1
Explanation: 
Swap A[3] and B[3].  Then the sequences are:
A = [1, 3, 5, 7] and B = [1, 2, 3, 4]
which are both strictly increasing.
</pre>
<p>Note:</p>
<ul>
<li><code>A, B</code> are arrays with the same length, and that length will be in the range <code>[1, 1000]</code>.</li>
<li><code>A[i], B[i]</code> are integer values in the range <code>[0, 2000]</code>.</li>
</ul>
<p> </p>
<p>这道题给了我们两个长度相等的数组A和B，说是可以在任意位置i交换A[i]和B[i]的值，我们的目标是让数组A和B变成严格递增的数组，让我们求出最少需要交换的次数。博主最先尝试了贪婪算法，就是遍历数组，如果当前数字小于等于前面一个数字，那么就交换一下，但是问题就来了，到底是交换当前位置的数字，还是前一个位置的数字呢，比如下面这个例子：</p>
<p>0   4   4   5</p>
<p>0   1   6   8</p>
<p>我们到底是交换4和1呢，还是4和6呢，虽然两种方法都能让前三个数字严格递增，但是如果交换了4和6，那么第一个数组的最后一个5就又得交换了，那么就要多交换一次，所以这个例子是交换4和1，但是对于下面这个例子：</p>
<p>0   4   4   7</p>
<p>0   1   6   5</p>
<p>那么此时我们就要交换4和6了，这样只要交换一次就能使两个数组都变成严格递增的数组了。所以这道题用贪婪算法不work，我们必须使用别的方法，那么此时动态规划Dynamic Programming就闪亮登场了。</p>
<p>像这种求极值的题目，不是Greedy就是DP啊，一般难题偏DP的比较多。而DP解法的第一步就是要确定dp数组该怎么定义，如果我们定义一个一维数组dp，其中dp[i]表示使得范围[0, i]的子数组同时严格递增的最小交换次数，这样的话状态转移方程就会十分的难写，因为我们没有解耦合其内在的关联。当前位置i是否交换，只取决于和前面一位是否是严格递增的，而前一位也有交换或者不交换两种状态，那么前一位的不同状态也会影响到当前是否交换，这跟之前那道<a href="http://www.cnblogs.com/grandyang/p/7776979.html">Best Time to Buy and Sell Stock with Transaction Fee</a>就十分到类似了，那道题的股票也有保留或者卖出两种状态不停的切换。那么这里我们也需要维护两种状态，swap和noSwap，那么swap[i]表示范围[0, i]的子数组同时严格递增且当前位置i需要交换的最小交换次数，noSwap[i]表示范围[0, i]的子数组同时严格递增且当前位置i不交换的最小交换次数，两个数组里的值都初始化为n。由于需要跟前一个数字比较，所以我们从第二个数字开始遍历，那么就需要给swap和noSwap数组的第一个数字提前赋值，swap[0]赋值为1，因为其表示i位置需要交换，noSwap[0]赋值为0，因为其表示i位置不需要交换。</p>
<p>好，下面来分析最难的部分，状态转移方程。由于这道题限制了一定能通过交换生成两个同时严格递增的数组，那么两个数组当前位置和前一个位置之间的关系只有两种，一种是不用交换，当前位置的数字已经分别大于前一个位置，另一种是需要交换后，当前位置的数字才能分别大于前一个数字。那么我们来分别分析一下，如果当前位置已经分别大于前一位置的数了，那么讲道理我们是不需要再进行交换的，但是swap[i]限定了我们必须要交换当前位置i，那么既然当前位置要交换，那么前一个位置i-1也要交换，同时交换才能继续保证同时递增，这样我们的swap[i]就可以赋值为swap[i-1] + 1了。而noSwap[i]直接赋值为noSwap[i-1]即可，因为不需要交换了。第二种情况是需要交换当前位置，才能保证递增。那么swap[i]正好也是要交换当前位置，而前一个位置不能交换，那么即可以用noSwap[i-1] + 1来更新swap[i]，而noSwap[i]是不能交换当前位置，那么我们可以通过交换前一个位置来同样实现递增，即可以用swap[i-1]来更新noSwap[i]，当循环结束后，我们在swap[n-1]和noSwap[n-1]中返回较小值即可，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> minSwap(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; A, vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> B) {
        </span><span style="color: #0000ff;">int</span> n =<span style="color: #000000;"> A.size();
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> swap(n, n), noSwap(n, n);
        swap[</span><span style="color: #800080;">0</span>] = <span style="color: #800080;">1</span>; noSwap[<span style="color: #800080;">0</span>] = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (A[i] &gt; A[i - <span style="color: #800080;">1</span>] &amp;&amp; B[i] &gt; B[i - <span style="color: #800080;">1</span><span style="color: #000000;">]) {
                swap[i] </span>= swap[i - <span style="color: #800080;">1</span>] + <span style="color: #800080;">1</span><span style="color: #000000;">;
                noSwap[i] </span>= noSwap[i - <span style="color: #800080;">1</span><span style="color: #000000;">];
            }
            </span><span style="color: #0000ff;">if</span> (A[i] &gt; B[i - <span style="color: #800080;">1</span>] &amp;&amp; B[i] &gt; A[i - <span style="color: #800080;">1</span><span style="color: #000000;">]) {
                swap[i] </span>= min(swap[i], noSwap[i - <span style="color: #800080;">1</span>] + <span style="color: #800080;">1</span><span style="color: #000000;">);
                noSwap[i] </span>= min(noSwap[i], swap[i - <span style="color: #800080;">1</span><span style="color: #000000;">]);
            }
        }
        </span><span style="color: #0000ff;">return</span> min(swap[n - <span style="color: #800080;">1</span>], noSwap[n - <span style="color: #800080;">1</span><span style="color: #000000;">]);
    }
};</span></pre>
</div>
<p> </p>
<p>我们可以优化上面解法的空间复杂度，由于当前位置的值只跟前一个位置相关，所以我们并不需要保存整个数组，用四个变量来分别表示当前位置和前一个位置的各两种状态，可以实现同样的效果，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> minSwap(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; A, vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> B) {
        </span><span style="color: #0000ff;">int</span> n1 = <span style="color: #800080;">0</span>, s1 = <span style="color: #800080;">1</span>, n =<span style="color: #000000;"> A.size();
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">int</span> n2 = INT_MAX, s2 =<span style="color: #000000;"> INT_MAX;
            </span><span style="color: #0000ff;">if</span> (A[i - <span style="color: #800080;">1</span>] &lt; A[i] &amp;&amp; B[i - <span style="color: #800080;">1</span>] &lt;<span style="color: #000000;"> B[i]) {
                n2 </span>=<span style="color: #000000;"> min(n2, n1);
                s2 </span>= min(s2, s1 + <span style="color: #800080;">1</span><span style="color: #000000;">);
            }
            </span><span style="color: #0000ff;">if</span> (A[i - <span style="color: #800080;">1</span>] &lt; B[i] &amp;&amp; B[i - <span style="color: #800080;">1</span>] &lt;<span style="color: #000000;"> A[i]) {
                n2 </span>=<span style="color: #000000;"> min(n2, s1);
                s2 </span>= min(s2, n1 + <span style="color: #800080;">1</span><span style="color: #000000;">);
            }
            n1 </span>=<span style="color: #000000;"> n2;
            s1 </span>=<span style="color: #000000;"> s2;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> min(n1, s1);
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/7776979.html">Best Time to Buy and Sell Stock with Transaction Fee</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-07-14 23:56</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=9311385" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(9311385);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/9296602.html" id="cb_post_title_url">[LeetCode] Similar RGB Color 相似的红绿蓝颜色</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>In the following, every capital letter represents some hexadecimal digit from <code>0</code> to <code>f</code>.</p>
<p>The red-green-blue color <code>"#AABBCC"</code> can be written as <code>"#ABC"</code> in shorthand.  For example, <code>"#15c"</code> is shorthand for the color <code>"#1155cc"</code>.</p>
<p>Now, say the similarity between two colors <code>"#ABCDEF"</code> and <code>"#UVWXYZ"</code> is <code>-(AB - UV)^2 - (CD - WX)^2 - (EF - YZ)^2</code>.</p>
<p>Given the color <code>"#ABCDEF"</code>, return a 7 character color that is most similar to <code>#ABCDEF</code>, and has a shorthand (that is, it can be represented as some <code>"#XYZ"</code></p>
<pre>Example 1:
Input: color = "#09f166"
Output: "#11ee66"
Explanation:  
The similarity is -(0x09 - 0x11)^2 -(0xf1 - 0xee)^2 - (0x66 - 0x66)^2 = -64 -9 -0 = -73.
This is the highest among any shorthand color.
</pre>
<p>Note:</p>
<ul>
<li><code>color</code> is a string of length <code>7</code>.</li>
<li><code>color</code> is a valid RGB color: for <code>i &gt; 0</code>, <code>color[i]</code> is a hexadecimal digit from <code>0</code> to <code>f</code></li>
<li>Any answer which has the same (highest) similarity as the best answer will be accepted.</li>
<li>All inputs and outputs should use lowercase letters, and the output is 7 characters.</li>
</ul>
<p> </p>
<p>这道题定义了一种表示颜色的十六进制字符串，然后说是有一种两两字符相等的颜色可以缩写。然后又给了我们一个人一的字符串，让我们找出距离其最近的可以缩写的颜色串。题意不难理解，而且还是Easy标识符，所以我们要有信心可以将其拿下。那么通过分析题目中给的例子, 我们知道可以将给定的字符串拆成三个部分，每个部分分别来进行处理，比如对于字符串"#09f166"来说，我们就分别处理"09"，"f1"，"66"即可。我们的目标是要将每部分的两个字符变为相同，并且跟原来的距离最小，那么实际上我们并不需要遍历所有的组合，因为比较有参考价值的就是十位上的数字，因为如果十位上的数字不变，或者只是增减1，而让个位上的数字变动大一些，这样距离会最小，因为个位上的数字权重最小。就拿"09"来举例，这个数字可以变成"11"或者"00"，十六进制数"11"对应的十进制数是17，跟"09"相差了8，而十六进制数"00"对应的十进制数是0，跟"09"相差了9，显然我们选择"11"会好一些。所以我们的临界点是"8"，如果个位上的数字大于"8"，那么十位上的数就加1。</p>
<p>下面来看如何确定十位上的数字，比如拿"e1"来举例，其十进制数为225，其可能的选择有"ff"，"ee"，和"dd"，其十进制数分别为255，238，和221，我们目测很容易看出来是跟"dd"离得最近，但是怎么确定十位上的数字呢。我们发现"11"，"22"，"33"，"44"... 这些数字之间相差了一个"11"，十进制数为17，所以我们只要将原十六进制数除以一个"11"，就知道其能到达的位置，比如"e1"除以"11"，就只能到达"d"，那么十进制上就是"d"，至于个位数的处理情况跟上面一段讲解相同，我们对"11"取余，然后跟临界点"8"比较，如果个位上的数字大于"8"，那么十位上的数就加1。这样就可以确定正确的数字了，那么组成正确的十六进制字符串即可，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> similarRGB(<span style="color: #0000ff;">string</span><span style="color: #000000;"> color) {
        </span><span style="color: #0000ff;">return</span> <span style="color: #800000;">"</span><span style="color: #800000;">#</span><span style="color: #800000;">"</span> + helper(color.substr(<span style="color: #800080;">1</span>, <span style="color: #800080;">2</span>)) + helper(color.substr(<span style="color: #800080;">3</span>, <span style="color: #800080;">2</span>)) + helper(color.substr(<span style="color: #800080;">5</span>, <span style="color: #800080;">2</span><span style="color: #000000;">));
    }
    </span><span style="color: #0000ff;">string</span> helper(<span style="color: #0000ff;">string</span><span style="color: #000000;"> str) {
        </span><span style="color: #0000ff;">string</span> dict = <span style="color: #800000;">"</span><span style="color: #800000;">0123456789abcdef</span><span style="color: #800000;">"</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> num = stoi(str, nullptr, <span style="color: #800080;">16</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">int</span> idx = num / <span style="color: #800080;">17</span> + (num % <span style="color: #800080;">17</span> &gt; <span style="color: #800080;">8</span> ? <span style="color: #800080;">1</span> : <span style="color: #800080;">0</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">string</span>(<span style="color: #800080;">2</span><span style="color: #000000;">, dict[idx]);
    }
};</span></pre>
</div>
<p> </p>
<p>我们也可以不用helper函数，直接在一个函数中搞定即可，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> similarRGB(<span style="color: #0000ff;">string</span><span style="color: #000000;"> color) {
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt; color.size(); i += <span style="color: #800080;">2</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">int</span> num = stoi(color.substr(i, <span style="color: #800080;">2</span>), nullptr, <span style="color: #800080;">16</span><span style="color: #000000;">);
            </span><span style="color: #0000ff;">int</span> idx = num / <span style="color: #800080;">17</span> + (num % <span style="color: #800080;">17</span> &gt; <span style="color: #800080;">8</span> ? <span style="color: #800080;">1</span> : <span style="color: #800080;">0</span><span style="color: #000000;">);
            color[i] </span>= color[i + <span style="color: #800080;">1</span>] = (idx &gt; <span style="color: #800080;">9</span>) ? (idx - <span style="color: #800080;">10</span> + <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span>) : (idx + <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span><span style="color: #000000;">);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> color;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-07-11 20:46</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=9296602" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(9296602);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/9286537.html" id="cb_post_title_url">[LeetCode] Champagne Tower 香槟塔</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>We stack glasses in a pyramid, where the first row has 1 glass, the second row has 2 glasses, and so on until the 100th row.  Each glass holds one cup (250ml) of champagne.</p>
<p>Then, some champagne is poured in the first glass at the top.  When the top most glass is full, any excess liquid poured will fall equally to the glass immediately to the left and right of it.  When those glasses become full, any excess champagne will fall equally to the left and right of those glasses, and so on.  (A glass at the bottom row has it's excess champagne fall on the floor.)</p>
<p>For example, after one cup of champagne is poured, the top most glass is full.  After two cups of champagne are poured, the two glasses on the second row are half full.  After three cups of champagne are poured, those two cups become full - there are 3 full glasses total now.  After four cups of champagne are poured, the third row has the middle glass half full, and the two outside glasses are a quarter full, as pictured below.</p>
<p><img alt="" height="341" src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/03/09/tower.png" width="495"/></p>
<p>Now after pouring some non-negative integer cups of champagne, return how full the j-th glass in the i-th row is (both i and j are 0 indexed.)</p>
<p> </p>
<pre>Example 1:
Input: poured = 1, query_glass = 1, query_row = 1
Output: 0.0
Explanation: We poured 1 cup of champange to the top glass of the tower (which is indexed as (0, 0)). There will be no excess liquid so all the glasses under the top glass will remain empty.

Example 2:
Input: poured = 2, query_glass = 1, query_row = 1
Output: 0.5
Explanation: We poured 2 cups of champange to the top glass of the tower (which is indexed as (0, 0)). There is one cup of excess liquid. The glass indexed as (1, 0) and the glass indexed as (1, 1) will share the excess liquid equally, and each will get half cup of champange.
</pre>
<p> </p>
<p>Note:</p>
<ul>
<li><code>poured</code> will be in the range of <code>[0, 10 ^ 9]</code>.</li>
<li><code>query_glass</code> and <code>query_row</code> will be in the range of <code>[0, 99]</code>.</li>
</ul>
<p> </p>
<p>这道题用高脚杯摆了个金字塔，貌似在电影里见过这种酷炫的效果，不过好像还是3D的，组了个立体的酒杯金字塔。这道题中的金字塔是2D的，降低了一些难度。在我们最开始没有什么思路的时候，我们就从最简单的开始分析吧：</p>
<p>当只倒一杯酒的时候，只有最顶端的酒杯被填满。</p>
<p>当倒二杯酒的时候，最顶端的酒杯被填满，且第二层的两个酒杯各自装了一半。</p>
<p>当倒三杯酒的时候，最顶端的酒杯被填满，且第二层的两个酒杯也被填满。</p>
<p>当倒四杯酒的时候，最顶端的酒杯被填满，且第二层的两个酒杯也被填满，第三层的三个酒杯分别被填了四分之一，二分之一，和四分之一。</p>
<p>当倒五杯酒的时候，最顶端的酒杯被填满，且第二层的两个酒杯也被填满，第三层的三个酒杯分别被填了二分之一，填满，和二分之一。</p>
<p>...</p>
<p>如果酒是无限的，那么最终每个酒杯就会被填满，所以难点就是怎么知道在倒K杯酒后，当前的酒杯还剩多少。不管酒量又多大，当前酒杯最多只能装一杯，多余的酒都会流到下一行的两个酒杯。那么比如我们总共倒了五杯酒，那么最顶端的酒杯只能留住一杯，剩下的四杯全部均分到下行的酒杯中了，而离其最近的下一行的两个酒杯会平均分到其多出来的酒量。那么第二层的酒杯分别会得到(5-1)/2=2杯。而第二层的两个酒杯也分别只能留住一杯，各自多余的一杯还要往第三层流，那么第三层的第一个杯子接住了第二层的第一个杯子流下的半杯，而第三层的第二个杯子接住了第二层的两个杯子各自流下的半杯，于是填满了。第三层的第三个杯子接住了第二层的第二个杯子流下的半杯。那么我们的思路应该就是处理每一个杯子，将多余的酒量均分到其下一层对应的两个酒杯中，我们只需要处理到query_row那一行即可，如果地query_glass中的酒量超过一杯了，那么我们返回1就行了，因为多余的还会往下流，但我们不需要再考虑了。</p>
<p>我们建立一个二维的dp数组，其中dp[i][j]表示第i行第j列的杯子将要接住的酒量（可能大于1，因为此时还没有进行多余往下流的处理），那么我们就逐个遍历即可，将多余的酒量均分加入下一行的两个酒杯中即可，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">double</span> champagneTower(<span style="color: #0000ff;">int</span> poured, <span style="color: #0000ff;">int</span> query_row, <span style="color: #0000ff;">int</span><span style="color: #000000;"> query_glass) {
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">double</span>&gt;&gt; dp(<span style="color: #800080;">101</span>, vector&lt;<span style="color: #0000ff;">double</span>&gt;(<span style="color: #800080;">101</span>, <span style="color: #800080;">0</span><span style="color: #000000;">));
        dp[</span><span style="color: #800080;">0</span>][<span style="color: #800080;">0</span>] =<span style="color: #000000;"> poured;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt;= query_row; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt;= i; ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> (dp[i][j] &gt;= <span style="color: #800080;">1</span><span style="color: #000000;">) {
                    dp[i </span>+ <span style="color: #800080;">1</span>][j] += (dp[i][j] - <span style="color: #800080;">1</span>) / <span style="color: #800080;">2.0</span><span style="color: #000000;">;
                    dp[i </span>+ <span style="color: #800080;">1</span>][j + <span style="color: #800080;">1</span>] += (dp[i][j] - <span style="color: #800080;">1</span>) / <span style="color: #800080;">2.0</span><span style="color: #000000;">;
                }
            }
        }
        </span><span style="color: #0000ff;">return</span> min(<span style="color: #800080;">1.0</span><span style="color: #000000;">, dp[query_row][query_glass]);
    }
};</span></pre>
</div>
<p> </p>
<p>我们可以对上面的代码进行空间上的优化，只用一个一维数组即可，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">double</span> champagneTower(<span style="color: #0000ff;">int</span> poured, <span style="color: #0000ff;">int</span> query_row, <span style="color: #0000ff;">int</span><span style="color: #000000;"> query_glass) {
        vector</span>&lt;<span style="color: #0000ff;">double</span>&gt; dp(<span style="color: #800080;">101</span>, <span style="color: #800080;">0</span><span style="color: #000000;">);
        dp[</span><span style="color: #800080;">0</span>] =<span style="color: #000000;"> poured;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt;= query_row; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = i; j &gt;= <span style="color: #800080;">0</span>; --<span style="color: #000000;">j) {
                dp[j </span>+ <span style="color: #800080;">1</span>] += dp[j] = max(<span style="color: #800080;">0.0</span>, (dp[j] - <span style="color: #800080;">1</span>) / <span style="color: #800080;">2.0</span><span style="color: #000000;">);
            }
        }
        </span><span style="color: #0000ff;">return</span> min(<span style="color: #800080;">1.0</span><span style="color: #000000;">, dp[query_glass]);
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-07-09 22:44</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=9286537" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(9286537);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/9272921.html" id="cb_post_title_url">[LeetCode] Smallest Rotation with Highest Score 得到最高分的最小旋转</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given an array <code>A</code>, we may rotate it by a non-negative integer <code>K</code> so that the array becomes <code>A[K], A[K+1], A{K+2], ... A[A.length - 1], A[0], A[1], ..., A[K-1]</code>.  Afterward, any entries that are less than or equal to their index are worth 1 point. </p>
<p>For example, if we have <code>[2, 4, 1, 3, 0]</code>, and we rotate by <code>K = 2</code>, it becomes <code>[1, 3, 0, 2, 4]</code>.  This is worth 3 points because 1 &gt; 0 [no points], 3 &gt; 1 [no points], 0 &lt;= 2 [one point], 2 &lt;= 3 [one point], 4 &lt;= 4 [one point].</p>
<p>Over all possible rotations, return the rotation index K that corresponds to the highest score we could receive.  If there are multiple answers, return the smallest such index K.</p>
<pre>Example 1:
Input: [2, 3, 1, 4, 0]
Output: 3
Explanation:  
Scores for each K are listed below: 
K = 0,  A = [2,3,1,4,0],    score 2
K = 1,  A = [3,1,4,0,2],    score 3
K = 2,  A = [1,4,0,2,3],    score 3
K = 3,  A = [4,0,2,3,1],    score 4
K = 4,  A = [0,2,3,1,4],    score 3
</pre>
<p>So we should choose K = 3, which has the highest score.</p>
<p> </p>
<pre>Example 2:
Input: [1, 3, 0, 2, 4]
Output: 0
Explanation:  A will always have 3 points no matter how it shifts.
So we will choose the smallest K, which is 0.
</pre>
<p>Note:</p>
<ul>
<li><code>A</code> will have length at most <code>20000</code>.</li>
<li><code>A[i]</code> will be in the range <code>[0, A.length]</code>.</li>
</ul>
<p> </p>
<p>这道题博主感觉还是很有难度的，而且答案的思路也十分巧妙，并没有采用brute force那种直接求每一个K值的得分，而是反其道而行之，对于每个数字，探究其跟K值之间的联系。首先我们要讨论一下边界情况，那么就是当A[i] = 0 或 N 的情况，首先如果A[i] = 0的话，那么0这个数字在任何位置都会小于等于坐标值，所以在任何位置都会得分的，那么其实可以忽略之，因为其不会对最大值产生任何影响，同理，如果A[i] = N的时候，由于长度为N的数组的坐标值范围是[0, N-1]，所以数字N在任何位置都不得分，同样也不会对最大值产生任何影响，可以忽略之。那么我们关心的数字的范围其实是[1, N-1]。在这个范围内的数字在旋转数组的过程中，从位置0变到N-1位置的时候，一定会得分，因为此范围的数字最大就是N-1。这个一定得的分我们在最后统一加上，基于上面的发现，我们再来分析下题目中的例子 [2, 3, 1, 4, 0]，其中红色数字表示不得分的位置：</p>
<p>A:    <span style="color: #ff0000;">2</span>   <span style="color: #ff0000;">3</span>   1   <span style="color: #ff0000;">4</span>   0   (K = 0)</p>
<p>A:    <span style="color: #ff0000;">3</span>   1   <span style="color: #ff0000;">4</span>   0   2   (K = 1)</p>
<p>A:    <span style="color: #ff0000;">1</span>   <span style="color: #ff0000;">4</span>   0   2   3   (K = 2)</p>
<p>A:    <span style="color: #ff0000;">4</span>   0   2   <span style="color: #000000;">3</span>   1   (K = 3)</p>
<p>A:    0   <span style="color: #ff0000;">2</span>   <span style="color: #ff0000;">3</span>   1   4   (K = 4)</p>
<p>idx:  0   1   2   <span style="color: #000000;">3</span>   4</p>
<p>对于某个数字A[i]，我们想知道其什么时候能旋转到坐标位置为A[i]的地方，这样就可以得分了。比如上面博主标记了红色的数字3，最开始时的位置为1，此时是不得分的，我们想知道其什么时候能到位置3，答案是当K=3的时候，其刚好旋转到位置3，K再增加的时候，其又开始不得分了。所以这个最后能得分的临界位置是通过 (i - A[i] + N) % N 得到，那么此时如果K再增加1的话，A[i]就开始不得分了（如果我们suppose每个位置都可以得分，那么不得分的地方就可以当作是失分了），所以我们可以在这个刚好开始不得分的地方标记一下，通过-1进行标记，这个位置就是 (i - A[i] + 1 + N) % N。我们用一个长度为N的change数组，对于每个数字，我们都找到其刚好不得分的地方，进行-1操作，那么此时change[i]就表示数组中的数字在i位置会不得分的个数，如果我们仔细观察上面红色的数字，可以发现，由于是左移，坐标在不断减小，所以原先失分的地方，在K+1的时候还是失分，除非你从开头位置跑到末尾去了，那会得分，所以我们要累加change数组，并且K每增加1的时候，要加上额外的1，最后change数组中最大数字的位置就是要求的K值了，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> bestRotation(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> A) {
        </span><span style="color: #0000ff;">int</span> n =<span style="color: #000000;"> A.size();
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; change(n, <span style="color: #800080;">0</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++i) change[(i - A[i] + <span style="color: #800080;">1</span> + n) % n] -= <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt; n; ++i) change[i] += change[i - <span style="color: #800080;">1</span>] + <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span> max_element(change.begin(), change.end()) -<span style="color: #000000;"> change.begin();
    }
};</span></pre>
</div>
<p> </p>
<p>我们也可以不用STL自带的max_element函数，而是在遍历的过程中同时找最大值即可，参见代码如下： </p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> bestRotation(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> A) {
        </span><span style="color: #0000ff;">int</span> n = A.size(), res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; change(n, <span style="color: #800080;">0</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++i) change[(i - A[i] + <span style="color: #800080;">1</span> + n) % n] -= <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt; n; ++<span style="color: #000000;">i) {
            change[i] </span>+= change[i - <span style="color: #800080;">1</span>] + <span style="color: #800080;">1</span><span style="color: #000000;">;
            res </span>= (change[i] &gt; change[res]) ?<span style="color: #000000;"> i : res;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-07-06 12:13</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=9272921" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(9272921);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/9262159.html" id="cb_post_title_url">[LeetCode] All Paths From Source to Target 从起点到目标点到所有路径</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a directed, acyclic graph of <code>N</code> nodes.  Find all possible paths from node <code>0</code> to node <code>N-1</code>, and return them in any order.</p>
<p>The graph is given as follows:  the nodes are 0, 1, ..., graph.length - 1.  graph[i] is a list of all nodes j for which the edge (i, j) exists.</p>
<pre>Example:
Input: [[1,2], [3], [3], []] 
Output: [[0,1,3],[0,2,3]] 
Explanation: The graph looks like this:
0---&gt;1
|    |
v    v
2---&gt;3
There are two paths: 0 -&gt; 1 -&gt; 3 and 0 -&gt; 2 -&gt; 3.
</pre>
<p>Note:</p>
<ul>
<li>The number of nodes in the graph will be in the range <code>[2, 15]</code>.</li>
<li>You can print different paths in any order, but you should keep the order of nodes inside one path.</li>
</ul>
<p> </p>
<p>这道题给了我们一个无回路有向图，包含N个结点，然后让我们找出所有可能的从结点0到结点N-1的路径。这个图的数据是通过一个类似邻接链表的二维数组给的，最开始的时候博主没看懂输入数据的意思，其实很简单，我们来看例子中的input，[[1,2], [3], [3], []]，这是一个二维数组，最外层的数组里面有四个小数组，每个小数组其实就是和当前结点相通的邻结点，由于是有向图，所以只能是当前结点到邻结点，反过来不一定行。那么结点0的邻结点就是结点1和2，结点1的邻结点就是结点3，结点2的邻结点也是3，结点3没有邻结点。那么其实这道题的本质就是遍历邻接链表，由于要列出所有路径情况，那么递归就是不二之选了。我们用cur来表示当前遍历到的结点，初始化为0，然后在递归函数中，先将其加入路径path，如果cur等于N-1了，那么说明到达结点N-1了，将path加入结果res。否则我们再遍历cur的邻接结点，调用递归函数即可，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; allPathsSourceTarget(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> graph) {
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;<span style="color: #000000;"> res;
        helper(graph, </span><span style="color: #800080;">0</span><span style="color: #000000;">, {}, res);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">void</span> helper(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp; graph, <span style="color: #0000ff;">int</span> cur, vector&lt;<span style="color: #0000ff;">int</span>&gt; path, vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> res) {
        path.push_back(cur);
        </span><span style="color: #0000ff;">if</span> (cur == graph.size() - <span style="color: #800080;">1</span><span style="color: #000000;">) res.push_back(path);
        </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span><span style="color: #000000;"> neigh : graph[cur]) helper(graph, neigh, path, res);
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种解法也是递归，不过写法稍有不同，递归函数直接返回结果，这样参数就少了许多，但是思路还是一样的，如果cur等于N-1了，直接将cur先装入数组，再装入结果res中返回。否则就遍历cur的邻接结点，对于每个邻接结点，先调用递归函数，然后遍历其返回的结果，对于每个遍历到的path，将cur加到数组首位置，然后将path加入结果res中即可，这有点像是回溯的思路，路径是从后往前组成的，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; allPathsSourceTarget(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> graph) {
        </span><span style="color: #0000ff;">return</span> helper(graph, <span style="color: #800080;">0</span><span style="color: #000000;">);
    }
    vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; helper(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp; graph, <span style="color: #0000ff;">int</span><span style="color: #000000;"> cur) {
        </span><span style="color: #0000ff;">if</span> (cur == graph.size() - <span style="color: #800080;">1</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">return</span> {{graph.size() - <span style="color: #800080;">1</span><span style="color: #000000;">}};
        }
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;<span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span><span style="color: #000000;"> neigh : graph[cur]) {
            </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto path : helper(graph, neigh)) {
                path.insert(path.begin(), cur);
                res.push_back(path);
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-07-04 10:45</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=9262159" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(9262159);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/9251578.html" id="cb_post_title_url">[LeetCode] Rotate String 旋转字符串</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>We are given two strings, <code>A</code> and <code>B</code>.</p>
<p>A <em>shift on <code>A</code></em> consists of taking string <code>A</code> and moving the leftmost character to the rightmost position. For example, if <code>A = 'abcde'</code>, then it will be <code>'bcdea'</code> after one shift on <code>A</code>. Return <code>True</code> if and only if <code>A</code> can become <code>B</code> after some number of shifts on <code>A</code>.</p>
<pre>Example 1:
Input: A = 'abcde', B = 'cdeab'
Output: true

Example 2:
Input: A = 'abcde', B = 'abced'
Output: false
</pre>
<p>Note:</p>
<ul>
<li><code>A</code> and <code>B</code> will have length at most <code>100</code>.</li>
</ul>
<p> </p>
<p>这道题给了我们两个字符串A和B，定义了一种偏移操作，以某一个位置将字符串A分为两截，并将两段调换位置，如果此时跟字符串B相等了，就说明字符串A可以通过偏移得到B。现在就是让我们判断是否存在这种偏移，那么最简单最暴力的方法就是遍历所有能将A分为两截的位置，然后用取子串的方法将A断开，交换顺序，再去跟B比较，如果相等，返回true即可，遍历结束后，返回false，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> rotateString(<span style="color: #0000ff;">string</span> A, <span style="color: #0000ff;">string</span><span style="color: #000000;"> B) {
        </span><span style="color: #0000ff;">if</span> (A.size() != B.size()) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; A.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (A.substr(i, A.size() - i) + A.substr(<span style="color: #800080;">0</span>, i) == B) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        }      
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>还有一种一行完成碉堡了的方法，就是我们其实可以在A之后再加上一个A，这样如果新的字符串(A+A)中包含B的话，说明A一定能通过偏移得到B。就比如题目中的例子，A="abcde", B="bcdea"，那么A+A="a<span style="color: #ff0000;">bcdea</span>bcde"，里面是包括B的，所以返回true即可，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> rotateString(<span style="color: #0000ff;">string</span> A, <span style="color: #0000ff;">string</span><span style="color: #000000;"> B) {
        </span><span style="color: #0000ff;">return</span> A.size() == B.size() &amp;&amp; (A + A).find(B) != <span style="color: #0000ff;">string</span><span style="color: #000000;">::npos;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-07-01 22:13</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=9251578" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(9251578);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/9237967.html" id="cb_post_title_url">[LeetCode] Number of Subarrays with Bounded Maximum 有界限最大值的子数组数量</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>We are given an array <code>A</code> of positive integers, and two positive integers <code>L</code> and <code>R</code> (<code>L &lt;= R</code>).</p>
<p>Return the number of (contiguous, non-empty) subarrays such that the value of the maximum array element in that subarray is at least <code>L</code> and at most <code>R</code>.</p>
<pre>Example :
Input: 
A = [2, 1, 4, 3]
L = 2
R = 3
Output: 3
Explanation: There are three subarrays that meet the requirements: [2], [2, 1], [3].
</pre>
<p>Note:</p>
<ul>
<li>L, R  and <code>A[i]</code> will be an integer in the range <code>[0, 10^9]</code>.</li>
<li>The length of <code>A</code> will be in the range of <code>[1, 50000]</code>.</li>
</ul>
<p> </p>
<p>这道题给了我们一个数组，又给了我们两个数字L和R，表示一个区间范围，让我们求有多少个这样的子数组，使得其最大值在[L, R]区间的范围内。既然是求子数组的问题，那么最直接，最暴力的方法就是遍历所有的子数组，然后维护一个当前的最大值，只要这个最大值在[L, R]区间的范围内，结果res自增1即可。但是这种最原始，最粗犷的暴力搜索法，OJ不答应。但是其实我们略作优化，就可以通过了。优化的方法是，首先，如果当前数字大于R了，那么其实后面就不用再遍历了，不管当前这个数字是不是最大值，它都已经大于R了，那么最大值可能会更大，所以没有必要再继续遍历下去了。同样的剪枝也要加在内层循环中加，当curMax大于R时，直接break掉内层循环即可，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> numSubarrayBoundedMax(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; A, <span style="color: #0000ff;">int</span> L, <span style="color: #0000ff;">int</span><span style="color: #000000;"> R) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, n =<span style="color: #000000;"> A.size();
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (A[i] &gt; R) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">int</span> curMax =<span style="color: #000000;"> INT_MIN;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = i; j &lt; n; ++<span style="color: #000000;">j) {
                curMax </span>=<span style="color: #000000;"> max(curMax, A[j]);
                </span><span style="color: #0000ff;">if</span> (curMax &gt; R) <span style="color: #0000ff;">break</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">if</span> (curMax &gt;= L) ++<span style="color: #000000;">res;
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> numSubarrayBoundedMax(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; A, <span style="color: #0000ff;">int</span> L, <span style="color: #0000ff;">int</span><span style="color: #000000;"> R) {
        </span><span style="color: #0000ff;">return</span> count(A, R) - count(A, L - <span style="color: #800080;">1</span><span style="color: #000000;">);
    }
    </span><span style="color: #0000ff;">int</span> count(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; A, <span style="color: #0000ff;">int</span><span style="color: #000000;"> bound) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, cur = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span><span style="color: #000000;"> x : A) {
            cur </span>= (x &lt;= bound) ? cur + <span style="color: #800080;">1</span> : <span style="color: #800080;">0</span><span style="color: #000000;">;
            res </span>+=<span style="color: #000000;"> cur;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种解法也是线性时间复杂度的，跟上面解法的原理很类似，只不过没有写子函数而已。我们使用left和right来分别标记子数组的左右边界，使得其最大值在范围[L,R]内。那么当遍历到的数字大于等于L时，right赋值为当前位置i，那么每次res加上right - left，随着right的不停自增1，每次加上的right - left，实际上也是一个等差数列，跟上面解法中的子函数本质时一样的。当A[i]大于R的时候，left = i，那么此时A[i]肯定也大于等于L，于是rihgt=i，那么right - left为0，相当于上面的cur重置为0的操作，发现本质联系了吧，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> numSubarrayBoundedMax(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; A, <span style="color: #0000ff;">int</span> L, <span style="color: #0000ff;">int</span><span style="color: #000000;"> R) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, left = -<span style="color: #800080;">1</span>, right = -<span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; A.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (A[i] &gt; R) left =<span style="color: #000000;"> i;
            </span><span style="color: #0000ff;">if</span> (A[i] &gt;= L) right =<span style="color: #000000;"> i;
            res </span>+= right -<span style="color: #000000;"> left;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>我们可以对上面的解法稍稍做下优化，在A[i] &gt; R的时候，left和right都赋值为i，然后continue，这样省去了后面的用0来更新结果res的步骤，能提高一些运行效率，参见代码如下：</p>
<p> </p>
<p>解法四：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> numSubarrayBoundedMax(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; A, <span style="color: #0000ff;">int</span> L, <span style="color: #0000ff;">int</span><span style="color: #000000;"> R) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, left = -<span style="color: #800080;">1</span>, right = -<span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; A.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (A[i] &gt;<span style="color: #000000;"> R) {
                left </span>= right =<span style="color: #000000;"> i;
                </span><span style="color: #0000ff;">continue</span><span style="color: #000000;">;
            }
            </span><span style="color: #0000ff;">if</span> (A[i] &gt;= L) right =<span style="color: #000000;"> i;
            res </span>+= right -<span style="color: #000000;"> left;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-06-28 11:47</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=9237967" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(9237967);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/9223105.html" id="cb_post_title_url">[LeetCode] Valid Tic-Tac-Toe State 验证井字棋状态</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>A Tic-Tac-Toe board is given as a string array <code>board</code>. Return True if and only if it is possible to reach this board position during the course of a valid tic-tac-toe game.</p>
<p>The <code>board</code> is a 3 x 3 array, and consists of characters <code>" "</code>, <code>"X"</code>, and <code>"O"</code>.  The " " character represents an empty square.</p>
<p>Here are the rules of Tic-Tac-Toe:</p>
<ul>
<li>Players take turns placing characters into empty squares (" ").</li>
<li>The first player always places "X" characters, while the second player always places "O" characters.</li>
<li>"X" and "O" characters are always placed into empty squares, never filled ones.</li>
<li>The game ends when there are 3 of the same (non-empty) character filling any row, column, or diagonal.</li>
<li>The game also ends if all squares are non-empty.</li>
<li>No more moves can be played if the game is over.</li>
</ul>
<pre>Example 1:
Input: board = ["O  ", "   ", "   "]
Output: false
Explanation: The first player always plays "X".

Example 2:
Input: board = ["XOX", " X ", "   "]
Output: false
Explanation: Players take turns making moves.

Example 3:
Input: board = ["XXX", "   ", "OOO"]
Output: false

Example 4:
Input: board = ["XOX", "O O", "XOX"]
Output: true
</pre>
<p>Note:</p>
<ul>
<li><code>board</code> is a length-3 array of strings, where each string <code>board[i]</code> has length 3.</li>
<li>Each <code>board[i][j]</code> is a character in the set <code>{" ", "X", "O"}</code>.</li>
</ul>
<p> </p>
<p>这道题又是关于井字棋游戏的，之前也有一道类似的题<a href="http://www.cnblogs.com/grandyang/p/5467118.html">Design Tic-Tac-Toe</a>，不过那道题是模拟游戏进行的，而这道题是让我们验证当前井字棋的游戏状态是否正确。这题的例子给的比较好，cover了很多种情况：</p>
<p>情况一：</p>
<div class="cnblogs_code">
<pre><span style="color: #800080;">0</span><span style="color: #000000;"> _ _
_ _ _
_ _ _</span></pre>
</div>
<p>这是不正确的状态，因为先走的使用X，所以只出现一个O，是不对的。</p>
<p>情况二：</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">X O X
_ X _
_ _ _</span></pre>
</div>
<p>这个也是不正确的，因为两个player交替下棋，X最多只能比O多一个，这里多了两个，肯定是不对的。</p>
<p>情况三：</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">X X X
_ _ _ 
O O O</span></pre>
</div>
<p>这个也是不正确的，因为一旦第一个玩家的X连成了三个，那么游戏马上结束了，不会有另外一个O出现。</p>
<p>情况四：</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">X O X
O _ O
X O X</span></pre>
</div>
<p>这个状态没什么问题，是可以出现的状态。</p>
<p>好，那么根据给的这些例子，我们可以分析一下规律，根据例子1和例子2我们得出下棋顺序是有规律的，必须是先X后O，不能破坏这个顺序，那么我们可以使用一个turns变量，当是X时，turns自增1，反之若是O，则turns自减1，那么最终turns一定是0或者1，其他任何值都是错误的，比如例子1中，turns就是-1，例子2中，turns是2，都是不对的。根据例子3，我们得出结论，只能有一个玩家获胜，那么我们可以用两个变量xwin和owin，来记录两个玩家的获胜状态，由于井字棋的制胜规则是横竖斜任意一个方向有三个连续的就算赢，那么我们分别在各个方向查找3个连续的X，有的话xwin赋值为true，还要查找3个连续的O，有的话owin赋值为true，例子3中xwin和owin同时为true了，是错误的。还有一种情况，例子中没有cover到的是：</p>
<p>情况五：</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">X X X
O O _
O _ _</span></pre>
</div>
<p>我们看到虽然只有xwin为true，但是这种状态还是错误的，因为一旦第三个X放下后，游戏立即结束，不会有第三个O放下，这么检验这种情况呢？这是我们的turns变量就非常的重要了，当第三个O放下后，turns自减1，此时turns为0了，而正确的应该是当xwin为true的时候，第三个O不能放下，那么turns不减1，则还是1，这样就可以区分情况五了。当然，我们可以交换X和O的位置，即当owin为true时，turns一定要为0。现在我们已经覆盖了搜索的情况了，参见代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> validTicTacToe(vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp;<span style="color: #000000;"> board) {
        </span><span style="color: #0000ff;">bool</span> xwin = <span style="color: #0000ff;">false</span>, owin = <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; row(<span style="color: #800080;">3</span>), col(<span style="color: #800080;">3</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">int</span> diag = <span style="color: #800080;">0</span>, antidiag = <span style="color: #800080;">0</span>, turns = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; <span style="color: #800080;">3</span>; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; <span style="color: #800080;">3</span>; ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> (board[i][j] == <span style="color: #800000;">'</span><span style="color: #800000;">X</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                    </span>++row[i]; ++col[j]; ++<span style="color: #000000;">turns;
                    </span><span style="color: #0000ff;">if</span> (i == j) ++<span style="color: #000000;">diag;
                    </span><span style="color: #0000ff;">if</span> (i + j == <span style="color: #800080;">2</span>) ++<span style="color: #000000;">antidiag;
                } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (board[i][j] == <span style="color: #800000;">'</span><span style="color: #800000;">O</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                    </span>--row[i]; --col[j]; --<span style="color: #000000;">turns;
                    </span><span style="color: #0000ff;">if</span> (i == j) --<span style="color: #000000;">diag;
                    </span><span style="color: #0000ff;">if</span> (i + j == <span style="color: #800080;">2</span>) --<span style="color: #000000;">antidiag;
                }
            }
        }
        xwin </span>= row[<span style="color: #800080;">0</span>] == <span style="color: #800080;">3</span> || row[<span style="color: #800080;">1</span>] == <span style="color: #800080;">3</span> || row[<span style="color: #800080;">2</span>] == <span style="color: #800080;">3</span> ||<span style="color: #000000;">
               col[</span><span style="color: #800080;">0</span>] == <span style="color: #800080;">3</span> || col[<span style="color: #800080;">1</span>] == <span style="color: #800080;">3</span> || col[<span style="color: #800080;">2</span>] == <span style="color: #800080;">3</span> ||<span style="color: #000000;">
               diag </span>== <span style="color: #800080;">3</span> || antidiag == <span style="color: #800080;">3</span><span style="color: #000000;">;
        owin </span>= row[<span style="color: #800080;">0</span>] == -<span style="color: #800080;">3</span> || row[<span style="color: #800080;">1</span>] == -<span style="color: #800080;">3</span> || row[<span style="color: #800080;">2</span>] == -<span style="color: #800080;">3</span> ||<span style="color: #000000;">
               col[</span><span style="color: #800080;">0</span>] == -<span style="color: #800080;">3</span> || col[<span style="color: #800080;">1</span>] == -<span style="color: #800080;">3</span> || col[<span style="color: #800080;">2</span>] == -<span style="color: #800080;">3</span> ||<span style="color: #000000;">
               diag </span>== -<span style="color: #800080;">3</span> || antidiag == -<span style="color: #800080;">3</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> ((xwin &amp;&amp; turns == <span style="color: #800080;">0</span>) || (owin &amp;&amp; turns == <span style="color: #800080;">1</span>)) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span> (turns == <span style="color: #800080;">0</span> || turns == <span style="color: #800080;">1</span>) &amp;&amp; (!xwin || !<span style="color: #000000;">owin);
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/5467118.html">Design Tic-Tac-Toe</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-06-25 10:21</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=9223105" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(9223105);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/9214055.html" id="cb_post_title_url">[LeetCode] Preimage Size of Factorial Zeroes Function 阶乘零的原像个数函数</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Let <code>f(x)</code> be the number of zeroes at the end of <code>x!</code>. (Recall that <code>x! = 1 * 2 * 3 * ... * x</code>, and by convention, <code>0! = 1</code>.)</p>
<p>For example, <code>f(3) = 0</code> because 3! = 6 has no zeroes at the end, while <code>f(11) = 2</code> because 11! = 39916800 has 2 zeroes at the end. Given <code>K</code>, find how many non-negative integers <code>x</code> have the property that <code>f(x) = K</code>.</p>
<pre>Example 1:
Input: K = 0
Output: 5
Explanation: 0!, 1!, 2!, 3!, and 4! end with K = 0 zeroes.

Example 2:
Input: K = 5
Output: 0
Explanation: There is no x such that x! ends in K = 5 zeroes.
</pre>
<p>Note:</p>
<ul>
<li><code>K</code> will be an integer in the range <code>[0, 10^9]</code>.</li>
</ul>
<p> </p>
<p>这道题的题目名称非常的难懂，但是读了题目内容以后，就不难理解了，定义函数f(x)为x!的末尾0的个数，现在给了我们一个非负整数K，问使得f(x)=K成立的非负整数的个数。我们之前做过一道有关阶乘末尾零的个数的题<a href="http://www.cnblogs.com/grandyang/p/4219878.html" target="_blank">Factorial Trailing Zeroes</a>，从那道里我们知道了末尾0其实是由2和5相乘为10得到的，而阶乘中2的数量远多于5的个数，所以10的个数就只取决于5的个数。需要注意的一点就是，像25，125，这样的不只含有一个5的数字需要考虑进去。比如，24的阶乘末尾有4个0，分别是5，10，15，20中的四个5组成的，而25的阶乘末尾就有6个0，分别是5，10，15，20中的各一个5，还有25中的两个5，所以共有六个5，那么就不存在其阶乘数末尾有5个0的数。还有一个很重要的规律需要发现，我们知道20，21，22，23，24，这五个数的阶乘数末尾零的个数其实是相同的，都是有4个，因为它们包含的5的个数相同。而19，18，17，16，15，这五个数末尾零个数相同，均为3。那么我们其实可以发现，每五个数，必会至少多出1个5，有可能更多。所以阶乘末尾零个数均为K个的x值，只有两种情况，要么是5，要么是0，这个规律得出来后，我们继续向着正确的解题方向前进。</p>
<p>基于之前那道题<a href="http://www.cnblogs.com/grandyang/p/4219878.html" target="_blank">Factorial Trailing Zeroes</a>的解法，我们知道了如何快速求一个给定的数字阶乘末尾零的个数，那么我们只要找到了一个这样的数，其阶乘末尾零的个数等于K的话，那么就说明总共有5个这样的数，返回5，反之，如果找不到这样的数字，就返回0。那么像这种选一个candidate数字，再进行验证的操作，用二分搜索法就是极好的，属于博主的总结帖中<a class="entrylistItemTitle" href="http://www.cnblogs.com/grandyang/p/6854825.html" id="CategoryEntryList1_EntryStoryList_ctl00_Entries_TitleUrl_1">LeetCode Binary Search Summary 二分搜索法小结</a>的第四类，用子函数当作判断关系。我们首先要确定二分搜索法的范围，左边界很好确定，为0就行了，关键是来确定右边界，我们来分析一下，一个数字的阶乘末尾零个数为K，那么这个数字能有多大，就拿前面举的例子来说吧，末尾有4个0的最大数字是24，有六个0的最大是29，那么我们发现它们都不会超过5*(K+1)这个范围，所以这就是我们的右边界，注意右边界可能会超过整型数范围，所以要用长整型来表示。那么之后就是经典的二分搜索法的步骤了，确定一个中间值mid，然后调用子函数来计算mid的阶乘数末尾零的个数，用来和K比较大小，如果想等了，直接返回5，如果小于K，那么更新left为mid+1，反之，更新right为mid即可，最终没找到的话，返回0即可，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> preimageSizeFZF(<span style="color: #0000ff;">int</span><span style="color: #000000;"> K) {
        </span><span style="color: #0000ff;">long</span> left = <span style="color: #800080;">0</span>, right = <span style="color: #800080;">5L</span> * (K + <span style="color: #800080;">1</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">while</span> (left &lt;<span style="color: #000000;"> right) {
            </span><span style="color: #0000ff;">long</span> mid = left + (right - left) / <span style="color: #800080;">2</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">long</span> cnt =<span style="color: #000000;"> numOfTrailingZeros(mid);
            </span><span style="color: #0000ff;">if</span> (cnt == K) <span style="color: #0000ff;">return</span> <span style="color: #800080;">5</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (cnt &lt; K) left = mid + <span style="color: #800080;">1</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">else</span> right =<span style="color: #000000;"> mid;
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
    }
    </span><span style="color: #0000ff;">long</span> numOfTrailingZeros(<span style="color: #0000ff;">long</span><span style="color: #000000;"> x) {
        </span><span style="color: #0000ff;">long</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (; x &gt; <span style="color: #800080;">0</span>; x /= <span style="color: #800080;">5</span><span style="color: #000000;">) {
            res </span>+= x / <span style="color: #800080;">5</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种解法是把子函数融到了while循环内，使得看起来更加简洁一些，解题思路跟上面的解法一模一样，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> preimageSizeFZF(<span style="color: #0000ff;">int</span><span style="color: #000000;"> K) {
        </span><span style="color: #0000ff;">long</span> left = <span style="color: #800080;">0</span>, right = <span style="color: #800080;">5L</span> * (K + <span style="color: #800080;">1</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">while</span> (left &lt;<span style="color: #000000;"> right) {
            </span><span style="color: #0000ff;">long</span> mid = left + (right - left) / <span style="color: #800080;">2</span>, cnt = <span style="color: #800080;">0</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">long</span> i = <span style="color: #800080;">5</span>; mid / i &gt; <span style="color: #800080;">0</span>; i *= <span style="color: #800080;">5</span><span style="color: #000000;">) {
                cnt </span>+= mid /<span style="color: #000000;"> i;
            }
            </span><span style="color: #0000ff;">if</span> (cnt == K) <span style="color: #0000ff;">return</span> <span style="color: #800080;">5</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (cnt &lt; K) left = mid + <span style="color: #800080;">1</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">else</span> right =<span style="color: #000000;"> mid;
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种解法也挺巧妙的，也是根据观察规律推出来的，我们首先来x为1到25的情况：</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">x:    1 2 3 4 <span style="color: #ff0000;">5</span> 6 7 8 9 <span style="color: #ff0000;">10</span> 11 12 13 14 <span style="color: #ff0000;">15</span> 16 17 18 19 <span style="color: #ff0000;">20</span> 21 22 23 24 <span style="color: #ff0000;">25</span>
f(x): 0 0 0 0 <span style="color: #ff0000;">1</span> 1 1 1 1 <span style="color: #ff0000;">2</span>  2  2  2  2  <span style="color: #ff0000;">3</span>  3  3  3  3  <span style="color: #ff0000;">4</span>  4  4  4  4  <span style="color: #ff0000;">6</span>
g(x): 0 0 0 0 <span style="color: #ff0000;">1</span> 0 0 0 0 <span style="color: #ff0000;">1</span>  0  0  0  0  <span style="color: #ff0000;">1</span>  0  0  0  0  <span style="color: #ff0000;">1</span>  0  0  0  0  <span style="color: #ff0000;">2</span></span></pre>
</div>
<p>这里，f(x)是表示x!末尾零的个数，而g(x) = f(x) - f(x-1)，那么我们其实还可以通过观察发现，f(x) = sum(g(x)).</p>
<p>我们再仔细观察上面的数字，发现g(x)有正值的时候都是当x是5的倍数的时候，那么我们来专门看一下x是5的倍数时的情况吧：</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">x:    5 10 15 20 <span style="color: #ff0000;">25</span> 30 35 40 45 <span style="color: #ff0000;">50</span> 55 60 65 70 <span style="color: #ff0000;">75</span> 80 85 90 95 <span style="color: #ff0000;">100</span> 105 110 115 120 <span style="color: #ff0000;">125</span>
g(x): 1 1  1  1  <span style="color: #ff0000;">2</span>  1  1  1  1  <span style="color: #ff0000;">2</span>  1  1  1  1  <span style="color: #ff0000;">2</span>  1  1  1  1   <span style="color: #ff0000;">2</span>   1   1   1   1   <span style="color: #ff0000;">3</span></span></pre>
</div>
<p>仔细观察上面的红色数字，g(x)=1时，是5的倍数，g(x)=2时，都是25的倍数，g(x)=3时，是125的倍数，那么我们就有：</p>
<p>g(x) = 0     if x % 5 != 0,<br/>g(x) &gt;= 1    if x % 5 == 0,<br/>g(x) &gt;= 2   if x % 25 == 0.</p>
<p>如果我们继续将上面的数字写下去，我们可以发现规律，g(x)按照 1 1 1 1 x 的规律重复五次，第五次的时候x自增1。我们再继续观察:</p>
<p>当x=25时，g(x)=2，此时K=5被跳过了。</p>
<p>当x=50时，g(x)=2，此时K=11被跳过了。</p>
<p>当x=75时，g(x)=2，此时K=17被跳过了。</p>
<p>当x=100时，g(x)=2，此时K=23被跳过了。</p>
<p>当x=125时，g(x)=3，此时K=29，30被跳过了。</p>
<p>进一步，我们可以发现如下规律：</p>
<p>5(=1*5), 11(=6*1+5), 17(=6*2+5), 23(=6*3+5), 29(=6*4+5), 30(=6*5), 36(=31+5), 42(=31+6+5), 48(=31+6*2+5)</p>
<p>这些使得x不存在的K，出现都是有规律的，它们减去一个特定的基数base后，都是余5，而余1，2，3，4的，都是返回5。那么这个基数base，实际是1，6，31，156，...，是由 base = base * 5 + 1，不断构成的，通过这种不断对基数取余的操作，我们可以最终将K降为小于等于5的数，就可以直接返回结果了，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> preimageSizeFZF(<span style="color: #0000ff;">int</span><span style="color: #000000;"> K) {
        </span><span style="color: #0000ff;">if</span> (K &lt; <span style="color: #800080;">5</span>) <span style="color: #0000ff;">return</span> <span style="color: #800080;">5</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> <span style="color: #0000ff;">base</span> = <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (<span style="color: #0000ff;">base</span> * <span style="color: #800080;">5</span> + <span style="color: #800080;">1</span> &lt;=<span style="color: #000000;"> K) {
            </span><span style="color: #0000ff;">base</span> = <span style="color: #0000ff;">base</span> * <span style="color: #800080;">5</span> + <span style="color: #800080;">1</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">if</span> (K / <span style="color: #0000ff;">base</span> == <span style="color: #800080;">5</span>) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span> preimageSizeFZF(K % <span style="color: #0000ff;">base</span><span style="color: #000000;">);
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4219878.html" target="_blank">Factorial Trailing Zeroes</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-06-22 16:15</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=9214055" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(9214055);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/9201323.html" id="cb_post_title_url">[LeetCode] Number of Matching Subsequences 匹配的子序列的个数</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given string <code>S</code> and a dictionary of words <code>words</code>, find the number of <code>words[i]</code> that is a subsequence of <code>S</code>.</p>
<pre>Example :
Input: 
S = "abcde"
words = ["a", "bb", "acd", "ace"]
Output: 3
Explanation: There are three words in <code>words</code> that are a subsequence of <code>S</code>: "a", "acd", "ace".
</pre>
<p>Note:</p>
<ul>
<li>All words in <code>words</code> and <code>S</code> will only consists of lowercase letters.</li>
<li>The length of <code>S</code> will be in the range of <code>[1, 50000]</code>.</li>
<li>The length of <code>words</code> will be in the range of <code>[1, 5000]</code>.</li>
<li>The length of <code>words[i]</code> will be in the range of <code>[1, 50]</code>.</li>
</ul>
<p> </p>
<p>这道题给了我们一个字符串S，又给了一个单词数组，问我们数组有多少个单词是字符串S的子序列。注意这里是子序列，而不是子串，子序列并不需要连续。那么只要我们知道如何验证一个子序列的方法，那么就可以先尝试暴力搜索法，就是对数组中的每个单词都验证一下是否是字符串S的子序列。验证子序列的方法就是用两个指针，对于子序列的每个一个字符，都需要在母字符中找到相同的，在母字符串所有字符串遍历完之后或之前，只要子序列中的每个字符都在母字符串中按顺序找到了，那么就验证成功了。很不幸，这种暴力搜索的方法在C++的解法版本中会TLE，貌似Java版本的可以通过，感觉C++被dis了诶～ However，我们可以进行优化呀，在暴力搜索的基础上稍作些优化，就可以骗过OJ啦。下面这种优化的motivation是由于看了使暴力搜索跪了的那个test case，其实是words数组里有大量相同的单词，而且字符串S巨长无比，那么为了避免相同的单词被不停的重复检验，我们用两个HashSet来记录验证过的单词，为啥要用两个呢？因为验证的结果有两种，要么通过，要么失败，我们要分别存在两个HashSet中，这样再遇到每种情况的单词时，我们就知道要不要结果增1了。如果单词没有验证过的话，那么我们就用双指针的方法进行验证，然后根据结果的不同，存到相应的HashSet中去，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> numMatchingSubseq(<span style="color: #0000ff;">string</span> S, vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp;<span style="color: #000000;"> words) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, n =<span style="color: #000000;"> S.size();
        unordered_set</span>&lt;<span style="color: #0000ff;">string</span>&gt; pass, <span style="color: #0000ff;">out</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">string</span><span style="color: #000000;"> word : words) {
            </span><span style="color: #0000ff;">if</span> (pass.count(word) || <span style="color: #0000ff;">out</span><span style="color: #000000;">.count(word)) {
                </span><span style="color: #0000ff;">if</span> (pass.count(word)) ++<span style="color: #000000;">res; 
                </span><span style="color: #0000ff;">continue</span><span style="color: #000000;">;
            }
            </span><span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>, j = <span style="color: #800080;">0</span>, m =<span style="color: #000000;"> word.size();
            </span><span style="color: #0000ff;">while</span> (i &lt; n &amp;&amp; j &lt;<span style="color: #000000;"> m) {
                </span><span style="color: #0000ff;">if</span> (word[j] == S[i]) ++<span style="color: #000000;">j;
                </span>++<span style="color: #000000;">i;
            }
            </span><span style="color: #0000ff;">if</span> (j == m) {++<span style="color: #000000;">res; pass.insert(word);}
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">out</span><span style="color: #000000;">.insert(word);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>上面的解法已经优化的不错了，但是我们还有更叼的方法。这种解法按照每个单词的首字符进行群组，群组里面保存的是一个pair对，由当前字母和下一个位置组成的。然后在遍历字符串S的时候，根据当前遍历到的字母，进入该字母对应的群组中处理，如果群组中某个pair的下一个位置已经等于单词长度了，说明该单词已经验证完成，是子序列，结果自增1；否则的话就将下一个位置的字母提取出来，然后将pair中的下一个位置自增1后组成的新pair加入之前提取出的字母对应的群组中。是不是读到这里已然懵逼了，没关系，博主会举栗子来说明的，就拿题目中的那个例子来说吧：</p>
<p>S = "abcde"</p>
<p>words = ["a", "bb", "acd", "ace"]</p>
<p>那么首先我们将words数组中的单词按照其首字母的不同放入对应的群组中，得到：</p>
<p>a -&gt; {0, 1}, {2, 1}, {3, 1}</p>
<p>b -&gt; {1, 1}</p>
<p>这里，每个pair的第一个数字是该单词在words中的位置，第二个数字是下一个字母的位置。比如 {0, 1} 表示 "a" 在words数组中位置为0，且下一个位置为1（因为当前位置是首字母）。{2, 1} 表示 "acd" 在words数组中位置为2，且下一个位置为1。{3, 1} 表示 "ace" 在words数组中位置为3，且下一个位置为1。{1, 1} 表示 "bb" 在words数组中位置为1，且下一个位置为1。</p>
<p>好，下面我们来遍历字符串S，第一个遇到的字母是 'a'。</p>
<p>那么我们群组中a对应了三个pair，将其提取出来分别进行操作。首先处理 {0, 1}，此时我们发现下一个位置为1，和单词"a"的长度相同了，说明是子序列，结果res自增1。然后处理 {2, 1}，在"acd"中取下一个位置1的字母为'c'，则将下一位置自增1后的新pair {2, 2} 加入c对应的群组。然后处理 {3, 1}，在"ace"中取下一个位置1的字母为'c'，则将下一位置自增1后的新pair {3, 2} 加入c对应的群组。则此时的群组为：</p>
<p>b -&gt; {1, 1}</p>
<p>c -&gt; {2, 2}, {3, 2}</p>
<p>好，继续来遍历字符串S，第二个遇到的字母是 'b'。</p>
<p>那么我们群组中b对应了一个pair，处理 {1, 1}，在"bb"中取下一个位置1的字母为'b'，则将下一位置自增1后的新pair {1, 2} 加入b对应的群组。则此时的群组为：</p>
<p>b -&gt; {1, 2}</p>
<p>c -&gt; {2, 2}, {3, 2}</p>
<p>好，继续来遍历字符串S，第三个遇到的字母是 'c'。</p>
<p>那么我们群组中c对应了两个pair，将其提取出来分别进行操作。首先处理 {2, 2}，在"ace"中取下一个位置2的字母为'e'，则将下一位置自增1后的新pair {2, 3} 加入e对应的群组。然后处理 {3, 2}，在"acd"中取下一个位置2的字母为'd'，则将下一位置自增1后的新pair {3, 3} 加入d对应的群组。则此时的群组为：</p>
<p>b -&gt; {1, 2}</p>
<p>d -&gt; {3, 3}</p>
<p>e -&gt; {2, 3}</p>
<p>好，继续来遍历字符串S，第四个遇到的字母是 'd'。</p>
<p>那么我们群组中d对应了一个pair，处理 {3, 3}，此时我们发现下一个位置为3，和单词"acd"的长度相同了，说明是子序列，结果res自增1。则此时的群组为：</p>
<p>b -&gt; {1, 2}</p>
<p>e -&gt; {2, 3}</p>
<p>好，继续来遍历字符串S，第五个遇到的字母是 'e'。</p>
<p>那么我们群组中e对应了一个pair，处理 {2, 3}，此时我们发现下一个位置为3，和单词"ace"的长度相同了，说明是子序列，结果res自增1。则此时的群组为：</p>
<p>b -&gt; {1, 2}</p>
<p>此时S已经遍历完了，已经没有b了，说明"bb"不是子序列，这make sense，返回结果res即可，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> numMatchingSubseq(<span style="color: #0000ff;">string</span> S, vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp;<span style="color: #000000;"> words) {
        vector</span>&lt;pair&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;&gt; all[<span style="color: #800080;">128</span><span style="color: #000000;">];
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, n =<span style="color: #000000;"> words.size();
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; i++<span style="color: #000000;">) {
            all[words[i][</span><span style="color: #800080;">0</span>]].emplace_back(i, <span style="color: #800080;">1</span><span style="color: #000000;">);
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span><span style="color: #000000;"> c : S) {
            auto vect </span>=<span style="color: #000000;"> all[c];
            all[c].clear();
            </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto it : vect) {
                </span><span style="color: #0000ff;">if</span> (it.second == words[it.first].size()) ++<span style="color: #000000;">res;
                </span><span style="color: #0000ff;">else</span> all[words[it.first][it.second++<span style="color: #000000;">]].push_back(it);
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/5842033.html">Is Subsequence</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-06-19 21:53</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=9201323" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(9201323);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/9190143.html" id="cb_post_title_url">[LeetCode] Custom Sort String 自定义排序的字符串</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p><code>S</code> and <code>T</code> are strings composed of lowercase letters. In <code>S</code>, no letter occurs more than once.</p>
<p><code>S</code> was sorted in some custom order previously. We want to permute the characters of <code>T</code> so that they match the order that <code>S</code> was sorted. More specifically, if <code>x</code> occurs before <code>y</code> in <code>S</code>, then <code>x</code> should occur before <code>y</code> in the returned string.</p>
<p>Return any permutation of <code>T</code> (as a string) that satisfies this property.</p>
<pre>Example :
Input: 
S = "cba"
T = "abcd"
Output: "cbad"
Explanation: 
"a", "b", "c" appear in S, so the order of "a", "b", "c" should be "c", "b", and "a". 
Since "d" does not appear in S, it can be at any position in T. "dcba", "cdba", "cbda" are also valid outputs.
</pre>
<p> </p>
<p>Note:</p>
<ul>
<li><code>S</code> has length at most <code>26</code>, and no character is repeated in <code>S</code>.</li>
<li><code>T</code> has length at most <code>200</code>.</li>
<li><code>S</code> and <code>T</code> consist of lowercase letters only.</li>
</ul>
<p> </p>
<p>这道题给了我们两个字符串S和T，让我们将T按照S的顺序进行排序，就是说在S中如果字母x在字母y之前，那么排序后的T中字母x也要在y之前，其他S中未出现的字母位置无所谓。那么我们其实关心的是S中的字母，只要按S中的字母顺序遍历，对于遍历到的每个字母，如果T中有的话，就先排出来，这样等S中的字母遍历完了，再将T中剩下的字母加到后面即可。所以我们先用HashMap统计T中每个字母出现的次数，然后遍历S中的字母，只要T中有，就将该字母重复其出现次数个，加入结果res中，然后将该字母出现次数重置为0。之后再遍历一遍HashMap，将T中其他字母加入结果res中即可，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> customSortString(<span style="color: #0000ff;">string</span> S, <span style="color: #0000ff;">string</span><span style="color: #000000;"> T) {
        </span><span style="color: #0000ff;">string</span> res = <span style="color: #800000;">""</span><span style="color: #000000;">;
        unordered_map</span>&lt;<span style="color: #0000ff;">char</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> m;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span> c : T) ++<span style="color: #000000;">m[c];
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span><span style="color: #000000;"> c : S) {
            res </span>+= <span style="color: #0000ff;">string</span><span style="color: #000000;">(m[c], c);
            m[c] </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto a : m) {
            res </span>+= <span style="color: #0000ff;">string</span><span style="color: #000000;">(a.second, a.first);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种解法的思路和上面的一样，只不过这里没有使用HashMap，而是使用了一个长度为26的数组，因为题目中说了S和T中都是小写的字母，其他部分没有啥太大的区别，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> customSortString(<span style="color: #0000ff;">string</span> S, <span style="color: #0000ff;">string</span><span style="color: #000000;"> T) {
        </span><span style="color: #0000ff;">string</span> res = <span style="color: #800000;">""</span><span style="color: #000000;">;
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; cnt(<span style="color: #800080;">26</span>, <span style="color: #800080;">0</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span> c : T) ++cnt[c - <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span><span style="color: #000000;">];
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span><span style="color: #000000;"> c : S) {
            </span><span style="color: #0000ff;">while</span> (cnt[c - <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span>]-- &gt; <span style="color: #800080;">0</span><span style="color: #000000;">) res.push_back(c);
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span><span style="color: #000000;"> c : T) {
            </span><span style="color: #0000ff;">while</span> (cnt[c - <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span>]-- &gt; <span style="color: #800080;">0</span><span style="color: #000000;">) res.push_back(c);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种方法可以说是简洁的让人发指啊，就两行搞定碉堡了。我们自定义了sort的排序的排序方式，对于字符串T中的任意两个字母a和b，按照其在S中的顺序排序，在S中排前面的在T中也排前面，完全符合题意，所以就能很好的work，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> customSortString(<span style="color: #0000ff;">string</span> S, <span style="color: #0000ff;">string</span><span style="color: #000000;"> T) {
        sort(T.begin(), T.end(), [</span>&amp;](<span style="color: #0000ff;">char</span> a, <span style="color: #0000ff;">char</span> b) {<span style="color: #0000ff;">return</span> S.find(a) &lt;<span style="color: #000000;"> S.find(b);});
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> T;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种解法没有用到STL中内置的find函数，而是用了HashMap来建立S中每个字母和其出现位置之间的映射，这样在自定义排序方法的时候，就可以直接从HashMap中取位置了，参见代码如下：</p>
<p> </p>
<p>解法四：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> customSortString(<span style="color: #0000ff;">string</span> S, <span style="color: #0000ff;">string</span><span style="color: #000000;"> T) {
        unordered_map</span>&lt;<span style="color: #0000ff;">char</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> m;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; S.size(); ++<span style="color: #000000;">i) {
            m[S[i]] </span>= i + <span style="color: #800080;">1</span><span style="color: #000000;">;
        }
        sort(T.begin(), T.end(), [</span>&amp;](<span style="color: #0000ff;">char</span> a, <span style="color: #0000ff;">char</span> b) {<span style="color: #0000ff;">return</span> m[a] &lt;<span style="color: #000000;"> m[b];});
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> T;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-06-16 11:13</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=9190143" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(9190143);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/9190143.html" id="cb_post_title_url">[LeetCode] Custom Sort String 自定义排序的字符串</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p><code>S</code> and <code>T</code> are strings composed of lowercase letters. In <code>S</code>, no letter occurs more than once.</p>
<p><code>S</code> was sorted in some custom order previously. We want to permute the characters of <code>T</code> so that they match the order that <code>S</code> was sorted. More specifically, if <code>x</code> occurs before <code>y</code> in <code>S</code>, then <code>x</code> should occur before <code>y</code> in the returned string.</p>
<p>Return any permutation of <code>T</code> (as a string) that satisfies this property.</p>
<pre>Example :
Input: 
S = "cba"
T = "abcd"
Output: "cbad"
Explanation: 
"a", "b", "c" appear in S, so the order of "a", "b", "c" should be "c", "b", and "a". 
Since "d" does not appear in S, it can be at any position in T. "dcba", "cdba", "cbda" are also valid outputs.
</pre>
<p> </p>
<p>Note:</p>
<ul>
<li><code>S</code> has length at most <code>26</code>, and no character is repeated in <code>S</code>.</li>
<li><code>T</code> has length at most <code>200</code>.</li>
<li><code>S</code> and <code>T</code> consist of lowercase letters only.</li>
</ul>
<p> </p>
<p>这道题给了我们两个字符串S和T，让我们将T按照S的顺序进行排序，就是说在S中如果字母x在字母y之前，那么排序后的T中字母x也要在y之前，其他S中未出现的字母位置无所谓。那么我们其实关心的是S中的字母，只要按S中的字母顺序遍历，对于遍历到的每个字母，如果T中有的话，就先排出来，这样等S中的字母遍历完了，再将T中剩下的字母加到后面即可。所以我们先用HashMap统计T中每个字母出现的次数，然后遍历S中的字母，只要T中有，就将该字母重复其出现次数个，加入结果res中，然后将该字母出现次数重置为0。之后再遍历一遍HashMap，将T中其他字母加入结果res中即可，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> customSortString(<span style="color: #0000ff;">string</span> S, <span style="color: #0000ff;">string</span><span style="color: #000000;"> T) {
        </span><span style="color: #0000ff;">string</span> res = <span style="color: #800000;">""</span><span style="color: #000000;">;
        unordered_map</span>&lt;<span style="color: #0000ff;">char</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> m;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span> c : T) ++<span style="color: #000000;">m[c];
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span><span style="color: #000000;"> c : S) {
            res </span>+= <span style="color: #0000ff;">string</span><span style="color: #000000;">(m[c], c);
            m[c] </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto a : m) {
            res </span>+= <span style="color: #0000ff;">string</span><span style="color: #000000;">(a.second, a.first);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种解法的思路和上面的一样，只不过这里没有使用HashMap，而是使用了一个长度为26的数组，因为题目中说了S和T中都是小写的字母，其他部分没有啥太大的区别，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> customSortString(<span style="color: #0000ff;">string</span> S, <span style="color: #0000ff;">string</span><span style="color: #000000;"> T) {
        </span><span style="color: #0000ff;">string</span> res = <span style="color: #800000;">""</span><span style="color: #000000;">;
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; cnt(<span style="color: #800080;">26</span>, <span style="color: #800080;">0</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span> c : T) ++cnt[c - <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span><span style="color: #000000;">];
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span><span style="color: #000000;"> c : S) {
            </span><span style="color: #0000ff;">while</span> (cnt[c - <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span>]-- &gt; <span style="color: #800080;">0</span><span style="color: #000000;">) res.push_back(c);
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span><span style="color: #000000;"> c : T) {
            </span><span style="color: #0000ff;">while</span> (cnt[c - <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span>]-- &gt; <span style="color: #800080;">0</span><span style="color: #000000;">) res.push_back(c);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种方法可以说是简洁的让人发指啊，就两行搞定碉堡了。我们自定义了sort的排序的排序方式，对于字符串T中的任意两个字母a和b，按照其在S中的顺序排序，在S中排前面的在T中也排前面，完全符合题意，所以就能很好的work，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> customSortString(<span style="color: #0000ff;">string</span> S, <span style="color: #0000ff;">string</span><span style="color: #000000;"> T) {
        sort(T.begin(), T.end(), [</span>&amp;](<span style="color: #0000ff;">char</span> a, <span style="color: #0000ff;">char</span> b) {<span style="color: #0000ff;">return</span> S.find(a) &lt;<span style="color: #000000;"> S.find(b);});
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> T;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种解法没有用到STL中内置的find函数，而是用了HashMap来建立S中每个字母和其出现位置之间的映射，这样在自定义排序方法的时候，就可以直接从HashMap中取位置了，参见代码如下：</p>
<p> </p>
<p>解法四：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> customSortString(<span style="color: #0000ff;">string</span> S, <span style="color: #0000ff;">string</span><span style="color: #000000;"> T) {
        unordered_map</span>&lt;<span style="color: #0000ff;">char</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> m;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; S.size(); ++<span style="color: #000000;">i) {
            m[S[i]] </span>= i + <span style="color: #800080;">1</span><span style="color: #000000;">;
        }
        sort(T.begin(), T.end(), [</span>&amp;](<span style="color: #0000ff;">char</span> a, <span style="color: #0000ff;">char</span> b) {<span style="color: #0000ff;">return</span> m[a] &lt;<span style="color: #000000;"> m[b];});
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> T;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-06-16 11:13</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=9190143" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(9190143);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/9179556.html" id="cb_post_title_url">[LeetCode] Domino and Tromino Tiling 多米诺和三格骨牌</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>We have two types of tiles: a 2x1 domino shape, and an "L" tromino shape. These shapes may be rotated.</p>
<pre>XX  &lt;- domino

XX  &lt;- "L" tromino
X
</pre>
<p>Given N, how many ways are there to tile a 2 x N board? Return your answer modulo 10^9 + 7.</p>
<p>(In a tiling, every square must be covered by a tile. Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile.)</p>
<pre>Example:
Input: 3
Output: 5
Explanation: 
The five different ways are listed below, different letters indicates different tiles:
XYZ XXZ XYY XXY XYY
XYZ YYZ XZZ XYY XXY</pre>
<p>Note:</p>
<ul>
<li>N  will be in range <code>[1, 1000]</code>.</li>
</ul>
<p> </p>
<p>这道题是关于多米诺骨牌和三格骨牌的，其中由两个方形格子组成的是多米诺骨牌（音译，即为双格骨牌），而由三个方形格子组成的‘L’型的是三格骨牌，但其实本质还是个拼格子的问题，并没有利用到骨牌酷炫的连倒技能，倒反而更像是俄罗斯方块中的形状。说是有一个2xN大小的棋盘，我们需要用这些多米诺和三格骨牌来将棋盘填满，问有多少种不同的填充方法，结果需要对一个超大数取余。那么根据博主多年的经验，对于这种求极值，并且超大的情况下，只能使用动态规划Dynamic Programming来做，什么暴力递归神马的，等着爆栈吧。</p>
<p>既然决定了要用DP来做，那么首先就来设计dp数组吧，这里我们就用一个一维的dp数组就行了，其中dp[i]表示填满前i列的不同填法总数对超大数10e^9+7取余后的结果。那么DP解法的难点就是求状态转移方程了，没什么太好的思路的时候，就从最简单的情况开始罗列吧。题目中给了N的范围是[1, 1000]，那么我们来看：</p>
<p>当N=1时，那么就是一个2x1大小的棋盘，只能放一个多米诺骨牌，只有一种情况。</p>
<p>当N=2时，那么就是一个2x2大小的棋盘，如下图所示，我们有两种放置方法，可以将两个多米诺骨牌竖着并排放，或者是将其横着并排放。</p>
<p>当N=3时，那么就是一个3x2大小的棋盘，我们共用五种放置方法，如下图所示。仔细观察这五种情况，我们发现其时时跟上面的情况有联系的。前两种情况其实是N=2的两种情况后面加上了一个竖着的多米诺骨牌，第三种情况其实是N=1的那种情况后面加上了两个平行的横向的多米诺骨牌，后两种情况是N=0（空集）再加上两种三格骨牌对角摆开的情况。</p>
<p>当N=4时，那么就是一个4x2大小的棋盘，我们共用十一种放置方法，太多了就不一一画出来了，但是其也是由之前的情况组合而成的。首先是N=3的所有情况后面加上一个竖着多米诺骨牌，然后是N=2的所有情况加上两个平行的横向的多米诺骨牌，然后N=1再加上两种三格骨牌对角摆开的情况，然后N=0（空集）再加上两种三格骨牌和一个横向多米诺骨牌组成的情况。</p>
<p>根据目前的状况，我们可以总结一个很重要的规律，就是dp[n]是由之前的dp值组成的，其中 dp[n-1] 和 dp[n-2] 各自能贡献一种组成方式，而dp[n-3]，一直到dp[0]，都能各自贡献两种组成方式，所以状态转移方程呼之欲出：</p>
<p>dp[n] = dp[n-1] + dp[n-2] + 2 * (dp[n-3] + ... + dp[0])</p>
<p>        = dp[n-1] + dp[n-3] + dp[n-2] + dp[n-3] + 2 * (dp[n-4] + ... dp[0])</p>
<p>        = dp[n-1] + dp[n-3] + dp[n-1]</p>
<p>        = 2 * dp[n-1] + dp[n-3]</p>
<p>最后化简后的形式就是最终的状态转移方程了，是不是叼的飞起～</p>
<p> </p>
<p><img alt="" height="385" src="https://images2018.cnblogs.com/blog/391947/201806/391947-20180618065539694-679656041.png" width="679"/></p>
<p> </p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> numTilings(<span style="color: #0000ff;">int</span><span style="color: #000000;"> N) {
        </span><span style="color: #0000ff;">int</span> M = 1e9 + <span style="color: #800080;">7</span><span style="color: #000000;">;
        vector</span>&lt;<span style="color: #0000ff;">long</span>&gt; dp(N + <span style="color: #800080;">1</span><span style="color: #000000;">);
        dp[</span><span style="color: #800080;">0</span>] = <span style="color: #800080;">1</span>; dp[<span style="color: #800080;">1</span>] = <span style="color: #800080;">1</span>; dp[<span style="color: #800080;">2</span>] = <span style="color: #800080;">2</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">3</span>; i &lt;= N; ++<span style="color: #000000;">i) {
            dp[i] </span>= (dp[i - <span style="color: #800080;">1</span>] * <span style="color: #800080;">2</span> + dp[i - <span style="color: #800080;">3</span>]) %<span style="color: #000000;"> M;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> dp[N];
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-06-13 19:58</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=9179556" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(9179556);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/9165361.html" id="cb_post_title_url">[LeetCode] Escape The Ghosts 逃离鬼魂</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="question-description__3U1T">
<div>
<p>You are playing a simplified Pacman game. You start at the point <code>(0, 0)</code>, and your destination is<code> (target[0], target[1])</code>. There are several ghosts on the map, the i-th ghost starts at<code> (ghosts[i][0], ghosts[i][1])</code>.</p>
<p>Each turn, you and all ghosts simultaneously *may* move in one of 4 cardinal directions: north, east, west, or south, going from the previous point to a new point 1 unit of distance away.</p>
<p>You escape if and only if you can reach the target before any ghost reaches you (for any given moves the ghosts may take.)  If you reach any square (including the target) at the same time as a ghost, it doesn't count as an escape.</p>
<p>Return True if and only if it is possible to escape.</p>
<pre>Example 1:
Input: 
ghosts = [[1, 0], [0, 3]]
target = [0, 1]
Output: true
Explanation: 
You can directly reach the destination (0, 1) at time 1, while the ghosts located at (1, 0) or (0, 3) have no way to catch up with you.
</pre>
<pre>Example 2:
Input: 
ghosts = [[1, 0]]
target = [2, 0]
Output: false
Explanation: 
You need to reach the destination (2, 0), but the ghost at (1, 0) lies between you and the destination.
</pre>
<pre>Example 3:
Input: 
ghosts = [[2, 0]]
target = [1, 0]
Output: false
Explanation: 
The ghost can reach the target at the same time as you.
</pre>
<p>Note:</p>
<ul>
<li>All points have coordinates with absolute value &lt;= <code>10000</code>.</li>
<li>The number of ghosts will not exceed <code>100</code>.</li>
</ul>
</div>
</div>
<p> </p>
<p>这道题就是经典的吃豆人游戏啦，不过是简化版，小人只能躲开鬼魂，并不能吃大力丸，反干鬼魂。小人在原点，有若干个鬼魂在不同的位置，给了一个目标点，问小人能不能安全到达目标点。这里的鬼魂的设定跟游戏中的一样，都是很智能的，会朝着你移动，而且这里设定了如果跟鬼魂同时到达目标点也算输。那么实际上这道题就是要求出小人到目标点的最短距离，注意这里的距离不是两点之间的Euclidean距离，而应该是曼哈顿距离，即横纵坐标分别求差的绝对值再相加。求出小人到目标点到最短距离后，我们还要求每个鬼魂到目标点的最短距离，如果有一个鬼魂到目标带你的最短距离小于等于小人到目标点到最短距的话，那么就返回false，否则返回true，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> escapeGhosts(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp; ghosts, vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> target) {
        </span><span style="color: #0000ff;">int</span> dist = abs(target[<span style="color: #800080;">0</span>]) + abs(target[<span style="color: #800080;">1</span>]), mn =<span style="color: #000000;"> INT_MAX;
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto ghost : ghosts) {
            </span><span style="color: #0000ff;">int</span> t = abs(ghost[<span style="color: #800080;">0</span>] - target[<span style="color: #800080;">0</span>]) + abs(ghost[<span style="color: #800080;">1</span>] - target[<span style="color: #800080;">1</span><span style="color: #000000;">]);
            mn </span>=<span style="color: #000000;"> min(mn, t);
        }
        </span><span style="color: #0000ff;">return</span> dist &lt;<span style="color: #000000;"> mn;
    }
};</span></pre>
</div>
<p> </p>
<p>我们可以对上面的解法进行一个小优化，就是我们其实并不需要算完每一个鬼魂到目标点到最短距离，而是每算一个就进行比较，只要小于等于小人到目标点的最短距离了，就直接返回false。循环退出后返回true，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> escapeGhosts(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp; ghosts, vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> target) {
        </span><span style="color: #0000ff;">int</span> dist = abs(target[<span style="color: #800080;">0</span>]) + abs(target[<span style="color: #800080;">1</span><span style="color: #000000;">]);
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto ghost : ghosts) {
            </span><span style="color: #0000ff;">int</span> t = abs(ghost[<span style="color: #800080;">0</span>] - target[<span style="color: #800080;">0</span>]) + abs(ghost[<span style="color: #800080;">1</span>] - target[<span style="color: #800080;">1</span><span style="color: #000000;">]);
            </span><span style="color: #0000ff;">if</span> (t &lt;= dist) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-06-11 08:00</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=9165361" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(9165361);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/9154892.html" id="cb_post_title_url">[LeetCode] Rotated Digits 旋转数字</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>X is a good number if after rotating each digit individually by 180 degrees, we get a valid number that is different from X.  Each digit must be rotated - we cannot choose to leave it alone.</p>
<p>A number is valid if each digit remains a digit after rotation. 0, 1, and 8 rotate to themselves; 2 and 5 rotate to each other; 6 and 9 rotate to each other, and the rest of the numbers do not rotate to any other number and become invalid.</p>
<p>Now given a positive number <code>N</code>, how many numbers X from <code>1</code> to <code>N</code> are good?</p>
<pre>Example:
Input: 10
Output: 4
Explanation: 
There are four good numbers in the range [1, 10] : 2, 5, 6, 9.
Note that 1 and 10 are not good numbers, since they remain unchanged after rotating.
</pre>
<p>Note:</p>
<ul>
<li>N  will be in range <code>[1, 10000]</code>.</li>
</ul>
<p> </p>
<p>这道题定义了一种好数字，就是把每位上的数字翻转一下，能得到一个不同的数字。翻转规则定义为，0，1，和8翻转后还为其本身，2和5，6和9可以互相翻转。然后给了我们一个数字N，问我们 [1, N] 区间内共有多少个这样的好数字。这道题大家踩👎的个数远超顶👍的个数，貌似很多人不太喜欢这道给数字发好人卡的题，博主倒觉得这道题还不错，感觉没有太多的技巧，就是一个数字一个数字的验证呗，对于每个数字，再一位一位的验证呗。我们将验证某个数字是否Good的操作写到一个子函数中，遍历数字的每一位的方法，可以通过不停的除以10来获得，也可以像博主这样通过转变为字符串，再遍历字符即可。翻转规则中没有提到的数字有三个，3，4，和7，说明这三个数字无法翻转，若一旦被翻转，则无法形成valid的数字，所以我们只要一旦遇到这三个数字中的一个，直接返回false即可。还有要注意的是，0，1，和8这三个数字翻转后还是其本身，由于好数字的需要翻转一个不同的数字，所以若都是由这三个数字组成，翻转后不会产生不同的数字，也不符合题意。所以我们需要2，5，6，和9这四个数字中至少出现一个，我们用一个flag来标记出现过这些数字，最后只要check这个flag变量即可，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> rotatedDigits(<span style="color: #0000ff;">int</span><span style="color: #000000;"> N) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt;= N; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (check(i)) ++<span style="color: #000000;">res;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">bool</span> check(<span style="color: #0000ff;">int</span><span style="color: #000000;"> k) {
        </span><span style="color: #0000ff;">string</span> str =<span style="color: #000000;"> to_string(k);
        </span><span style="color: #0000ff;">bool</span> flag = <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span><span style="color: #000000;"> c : str) {
            </span><span style="color: #0000ff;">if</span> (c == <span style="color: #800000;">'</span><span style="color: #800000;">3</span><span style="color: #800000;">'</span> || c == <span style="color: #800000;">'</span><span style="color: #800000;">4</span><span style="color: #800000;">'</span> || c == <span style="color: #800000;">'</span><span style="color: #800000;">7</span><span style="color: #800000;">'</span>) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> (c == <span style="color: #800000;">'</span><span style="color: #800000;">2</span><span style="color: #800000;">'</span> || c == <span style="color: #800000;">'</span><span style="color: #800000;">5</span><span style="color: #800000;">'</span> || c == <span style="color: #800000;">'</span><span style="color: #800000;">6</span><span style="color: #800000;">'</span> || c == <span style="color: #800000;">'</span><span style="color: #800000;">9</span><span style="color: #800000;">'</span>) flag = <span style="color: #0000ff;">true</span><span style="color: #000000;">;;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> flag;
    }
};</span></pre>
</div>
<p> </p>
<p>其实这道题还有更好的解法呢，使用动态规划Dynamic Programming来做的，思路非常巧妙，博主深为叹服。定义了一个长度为N+1的一维布尔型DP数组，其中dp[i]表示数字i的三种状态，0表示数字i翻转后不合法，1表示数字i翻转后和原数相同，2表示数字i翻转后形成一个不同的数字。那么根据题目中的定义可知，只有当dp[i]=2的时候才是好数字。那么下面来看状态转移方程吧，我们知道如果数字只有1位的话，那么判断起来很简单，如果是0，1，和8中的一个，那么dp[i]=1，如果是2，5，6，和9中的一个，那么dp[i]=2，并且结果res自增1。如果是剩下的三个数字3，4，7中的一个不用更新，因为dp数组初始化就为0。下面来看数字i大于10的情况，非常的经典，dp[i] 的值其实可以从 dp[i/10] 和 dp[i%10] 这两个状态值转移而来，由于我们更新的顺序是从小到大，所以当要更新dp[i]的时候，dp[i/10] 和 dp[i%10] 这两个状态值已经算过了。为啥dp[i] 的值是由这两个状态值决定的呢？因为每个数字都是相互独立的翻转，比如四位数字abcd，可以拆分为三位数abc，和个位数d，如果abc翻转后仍是abc，d翻转后仍是d，说明abcd翻转后仍是abcd，所以dp[i]=1，只要其中有一个大于1了，另外一个至少是1的话，那么说明可以翻转成不同的数字，dp[i]=2，并且结果res自增1，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> rotatedDigits(<span style="color: #0000ff;">int</span><span style="color: #000000;"> N) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; dp(N + <span style="color: #800080;">1</span><span style="color: #000000;">);   
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt;= N; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (i &lt; <span style="color: #800080;">10</span><span style="color: #000000;">) {
                </span><span style="color: #0000ff;">if</span> (i == <span style="color: #800080;">0</span> || i == <span style="color: #800080;">1</span> || i == <span style="color: #800080;">8</span>) dp[i] = <span style="color: #800080;">1</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (i == <span style="color: #800080;">2</span> || i == <span style="color: #800080;">5</span> || i == <span style="color: #800080;">6</span> || i == <span style="color: #800080;">9</span><span style="color: #000000;">) {
                    dp[i] </span>= <span style="color: #800080;">2</span>; ++<span style="color: #000000;">res;
                }
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                </span><span style="color: #0000ff;">int</span> a = dp[i / <span style="color: #800080;">10</span>], b = dp[i % <span style="color: #800080;">10</span><span style="color: #000000;">];
                </span><span style="color: #0000ff;">if</span> (a == <span style="color: #800080;">1</span> &amp;&amp; b == <span style="color: #800080;">1</span>) dp[i] = <span style="color: #800080;">1</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (a &gt;= <span style="color: #800080;">1</span> &amp;&amp; b &gt;= <span style="color: #800080;">1</span><span style="color: #000000;">) {
                    dp[i] </span>= <span style="color: #800080;">2</span>; ++<span style="color: #000000;">res;
                }
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-06-08 11:56</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=9154892" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(9154892);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/9109981.html" id="cb_post_title_url">[LeetCode] Cheapest Flights Within K Stops K次转机内的最便宜的航班</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>There are <code>n</code> cities connected by <code>m</code> flights. Each fight starts from city <code>u </code>and arrives at <code>v</code> with a price <code>w</code>.</p>
<p>Now given all the cities and fights, together with starting city <code>src</code> and the destination <code>dst</code>, your task is to find the cheapest price from <code>src</code> to <code>dst</code> with up to <code>k</code> stops. If there is no such route, output <code>-1</code>.</p>
<pre>Example 1:
Input: 
n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]
src = 0, dst = 2, k = 1
Output: 200
Explanation: 
The graph looks like this:
</pre>
<p><img alt="" src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/02/16/995.png"/></p>
<pre>The cheapest price from city <code>0</code> to city <code>2</code> with at most 1 stop costs 200, as marked red in the picture.</pre>
<pre>Example 2:
Input: 
n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]
src = 0, dst = 2, k = 0
Output: 500
Explanation: 
The graph looks like this:
</pre>
<p><img alt="" src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/02/16/995.png"/></p>
<pre>The cheapest price from city <code>0</code> to city <code>2</code> with at most 0 stop costs 500, as marked blue in the picture.</pre>
<p>Note:</p>
<ul>
<li>The number of nodes <code>n</code> will be in range <code>[1, 100]</code>, with nodes labeled from <code>0</code> to <code>n</code><code> - 1</code>.</li>
<li>The size of <code>flights</code> will be in range <code>[0, n * (n - 1) / 2]</code>.</li>
<li>The format of each flight will be <code>(src, </code><code>dst</code><code>, price)</code>.</li>
<li>The price of each flight will be in the range <code>[1, 10000]</code>.</li>
<li><code>k</code> is in the range of <code>[0, n - 1]</code>.</li>
<li>There will not be any duplicated flights or self cycles.</li>
</ul>
<p> </p>
<p>这道题给了我们一些航班信息，包括出发地，目的地，和价格，然后又给了我们起始位置和终止位置，说是最多能转K次机，让我们求出最便宜的航班价格。那么实际上这道题就是一个有序图的遍历问题，博主最先尝试的递归解法由于没有做优化，TLE了，实际上我们可以通过剪枝处理，从而压线过OJ。首先我们要建立这个图，选取的数据结构就是邻接链表的形式，具体来说就是建立每个结点和其所有能到达的结点的集合之间的映射，然后就是用DFS来遍历这个图了，用变量cur表示当前遍历到的结点序号，还是当前剩余的转机次数K，访问过的结点集合visited，当前累计的价格out，已经全局的最便宜价格res。在递归函数中，首先判断如果当前cur为目标结点dst，那么结果res赋值为out，并直接返回。你可能会纳闷为啥不是取二者中较小值更新结果res，而是直接赋值呢？原因是我们之后做了剪枝处理，使得out一定会小于结果res。然后判断如果K小于0，说明超过转机次数了，直接返回。然后就是遍历当前结点cur能到达的所有结点了，对于遍历到的结点，首先判断如果当前结点已经访问过了，直接跳过。或者是当前价格out加上到达这个结点需要的价格之和大于结果res的话，那么直接跳过。这个剪枝能极大的提高效率，是压线过OJ的首要功臣。之后就是标记结点访问，调用递归函数，以及还原结点状态的常规操作了，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> findCheapestPrice(<span style="color: #0000ff;">int</span> n, vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp; flights, <span style="color: #0000ff;">int</span> src, <span style="color: #0000ff;">int</span> dst, <span style="color: #0000ff;">int</span><span style="color: #000000;"> K) {
        </span><span style="color: #0000ff;">int</span> res =<span style="color: #000000;"> INT_MAX;
        unordered_map</span>&lt;<span style="color: #0000ff;">int</span>, vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&gt;<span style="color: #000000;"> m;
        unordered_set</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> visited{{src}};
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto flight : flights) {
            m[flight[</span><span style="color: #800080;">0</span>]].push_back({flight[<span style="color: #800080;">1</span>], flight[<span style="color: #800080;">2</span><span style="color: #000000;">]});
        }
        helper(m, src, dst, K, visited, </span><span style="color: #800080;">0</span><span style="color: #000000;">, res);
        </span><span style="color: #0000ff;">return</span> (res == INT_MAX) ? -<span style="color: #800080;">1</span><span style="color: #000000;"> : res;
    }
    </span><span style="color: #0000ff;">void</span> helper(unordered_map&lt;<span style="color: #0000ff;">int</span>, vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&gt;&amp; m, <span style="color: #0000ff;">int</span> cur, <span style="color: #0000ff;">int</span> dst, <span style="color: #0000ff;">int</span> K, unordered_set&lt;<span style="color: #0000ff;">int</span>&gt;&amp; visited, <span style="color: #0000ff;">int</span> <span style="color: #0000ff;">out</span>, <span style="color: #0000ff;">int</span>&amp;<span style="color: #000000;"> res) {
        </span><span style="color: #0000ff;">if</span> (cur == dst) {res = <span style="color: #0000ff;">out</span>; <span style="color: #0000ff;">return</span><span style="color: #000000;">;}
        </span><span style="color: #0000ff;">if</span> (K &lt; <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto a : m[cur]) {
            </span><span style="color: #0000ff;">if</span> (visited.count(a[<span style="color: #800080;">0</span>]) || <span style="color: #0000ff;">out</span> + a[<span style="color: #800080;">1</span>] &gt; res) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
            visited.insert(a[</span><span style="color: #800080;">0</span><span style="color: #000000;">]);
            helper(m, a[</span><span style="color: #800080;">0</span>], dst, K - <span style="color: #800080;">1</span>, visited, <span style="color: #0000ff;">out</span> + a[<span style="color: #800080;">1</span><span style="color: #000000;">], res);
            visited.erase(a[</span><span style="color: #800080;">0</span><span style="color: #000000;">]);
        }
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种解法是用BFS来做的，还是来遍历图，不过这次是一层一层的遍历，需要使用queue来辅助。前面建立图的数据结构的操作和之前相同，BFS的写法还是经典的写法，但需要注意的是这里也同样的做了剪枝优化，当当前价格加上新到达位置的价格之和大于结果res的话直接跳过。最后注意如果超过了转机次数就直接break，参见代码如下： </p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> findCheapestPrice(<span style="color: #0000ff;">int</span> n, vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp; flights, <span style="color: #0000ff;">int</span> src, <span style="color: #0000ff;">int</span> dst, <span style="color: #0000ff;">int</span><span style="color: #000000;"> K) {
        </span><span style="color: #0000ff;">int</span> res = INT_MAX, cnt = <span style="color: #800080;">0</span><span style="color: #000000;">;
        unordered_map</span>&lt;<span style="color: #0000ff;">int</span>, vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&gt;<span style="color: #000000;"> m;
        queue</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; q{{{src, <span style="color: #800080;">0</span><span style="color: #000000;">}}};
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto flight : flights) {
            m[flight[</span><span style="color: #800080;">0</span>]].push_back({flight[<span style="color: #800080;">1</span>], flight[<span style="color: #800080;">2</span><span style="color: #000000;">]});
        }
        </span><span style="color: #0000ff;">while</span> (!<span style="color: #000000;">q.empty()) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = q.size(); i &gt; <span style="color: #800080;">0</span>; --<span style="color: #000000;">i) {
                auto t </span>=<span style="color: #000000;"> q.front(); q.pop();
                </span><span style="color: #0000ff;">if</span> (t[<span style="color: #800080;">0</span>] == dst) res = min(res, t[<span style="color: #800080;">1</span><span style="color: #000000;">]);
                </span><span style="color: #0000ff;">for</span> (auto a : m[t[<span style="color: #800080;">0</span><span style="color: #000000;">]]) {
                    </span><span style="color: #0000ff;">if</span> (t[<span style="color: #800080;">1</span>] + a[<span style="color: #800080;">1</span>] &gt; res) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                    q.push({a[</span><span style="color: #800080;">0</span>], t[<span style="color: #800080;">1</span>] + a[<span style="color: #800080;">1</span><span style="color: #000000;">]});
                }
            }
            </span><span style="color: #0000ff;">if</span> (cnt++ &gt; K) <span style="color: #0000ff;">break</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> (res == INT_MAX) ? -<span style="color: #800080;">1</span><span style="color: #000000;"> : res;
    }
};</span></pre>
</div>
<p> </p>
<p>再来看使用Bellman Ford算法的解法，关于此算法的detail可以上网搜帖子看看。核心思想还是用的动态规划Dynamic Programming，最核心的部分就是松弛操作Relaxation，也就是DP的状态转移方程。这里我们使用一个二维DP数组，其中dp[i][j]表示最多飞i次航班到达j位置时的最少价格，那么dp[0][src]初始化为0，因为飞0次航班的价格都为0，转机K次，其实就是飞K+1次航班，我们开始遍历，i从1到K+1，每次dp[i][src]都初始化为0，因为在起点的价格也为0，然后即使遍历所有的航班x，更新dp[i][x[1]]，表示最多飞i次航班到达航班x的目的地的最低价格，用最多飞i-1次航班，到达航班x的起点的价格加上航班x的价格之和，二者中取较小值更新即可，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> findCheapestPrice(<span style="color: #0000ff;">int</span> n, vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp; flights, <span style="color: #0000ff;">int</span> src, <span style="color: #0000ff;">int</span> dst, <span style="color: #0000ff;">int</span><span style="color: #000000;"> K) {
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; dp(K + <span style="color: #800080;">2</span>, vector&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;">(n, 1e9));
        dp[</span><span style="color: #800080;">0</span>][src] = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt;= K + <span style="color: #800080;">1</span>; ++<span style="color: #000000;">i) {
            dp[i][src] </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto x : flights) {
                dp[i][x[</span><span style="color: #800080;">1</span>]] = min(dp[i][x[<span style="color: #800080;">1</span>]], dp[i - <span style="color: #800080;">1</span>][x[<span style="color: #800080;">0</span>]] + x[<span style="color: #800080;">2</span><span style="color: #000000;">]);
            }
        }
        </span><span style="color: #0000ff;">return</span> (dp[K + <span style="color: #800080;">1</span>][dst] &gt;= 1e9) ? -<span style="color: #800080;">1</span> : dp[K + <span style="color: #800080;">1</span><span style="color: #000000;">][dst];
    }
};</span></pre>
</div>
<p> </p>
<p>我们可以稍稍优化下上面解法的空间复杂度，使用一个一维的DP数组即可，具体思路没有啥太大的区别，参见代码如下：</p>
<p> </p>
<p>解法四：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> findCheapestPrice(<span style="color: #0000ff;">int</span> n, vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp; flights, <span style="color: #0000ff;">int</span> src, <span style="color: #0000ff;">int</span> dst, <span style="color: #0000ff;">int</span><span style="color: #000000;"> K) {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> dp(n, 1e9);
        dp[src] </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt;= K; ++<span style="color: #000000;">i) {
            vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; t =<span style="color: #000000;"> dp;
            </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto x : flights) {
                t[x[</span><span style="color: #800080;">1</span>]] = min(t[x[<span style="color: #800080;">1</span>]], dp[x[<span style="color: #800080;">0</span>]] + x[<span style="color: #800080;">2</span><span style="color: #000000;">]);
            }
            dp </span>=<span style="color: #000000;"> t;
        }
        </span><span style="color: #0000ff;">return</span> (dp[dst] &gt;= 1e9) ? -<span style="color: #800080;">1</span><span style="color: #000000;"> : dp[dst];
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/6919389.html">Maximum Vacation Days</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-05-30 11:31</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=9109981" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(9109981);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/9135156.html" id="cb_post_title_url">[LeetCode] K-th Smallest Prime Fraction 第K小的质分数</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="question-description__3U1T">
<div>
<p>A sorted list <code>A</code> contains 1, plus some number of primes.  Then, for every p &lt; q in the list, we consider the fraction p/q.</p>
<p>What is the <code>K</code>-th smallest fraction considered?  Return your answer as an array of ints, where <code>answer[0] = p</code>and <code>answer[1] = q</code>.</p>
<pre>Examples:
Input: A = [1, 2, 3, 5], K = 3
Output: [2, 5]
Explanation:
The fractions to be considered in sorted order are:
1/5, 1/3, 2/5, 1/2, 3/5, 2/3.
The third fraction is 2/5.

Input: A = [1, 7], K = 1
Output: [1, 7]
</pre>
<p>Note:</p>
<ul>
<li><code>A</code> will have length between <code>2</code> and <code>2000</code>.</li>
<li>Each <code>A[i]</code> will be between <code>1</code> and <code>30000</code>.</li>
<li><code>K</code> will be between <code>1</code> and <code>A.length * (A.length - 1) / 2</code>.</li>
</ul>
</div>
</div>
<p> </p>
<p>这道题给了我们一个有序数组，里面是1和一些质数，说是对于任意两个数，都可以组成一个 [0, 1] 之间分数，让我们求第K小的分数是什么，题目中给的例子也很好的说明了题意。那么最直接暴力的解法就是遍历出所有的分数，然后再进行排序，返回第K小的即可。但是这种无脑暴力搜索的方法OJ是不答应的，无奈，只能想其他的解法。我们想，由于数组是有序的，所以最小的分数肯定是由第一个数字和最后一个数字组成的，而接下来第二小的分数我们就不确定是由第二个数字和最后一个数字组成的，还是由第一个数字跟倒数第二个数字组成的。我们的想法是用一个最小堆来存分数，那么每次取的时候就可以将最小的分数取出来，由于前面说了，我们不能遍历所有的分数都存入最小堆，那么我们怎么办呢，我们可以先存n个，哪n个呢？其实就是数组中的每个数字都和最后一个数字组成的分数。由于我们需要取出第K小的分数，那么我们在最小堆中取K个分数就可以了，第一个取出的分数就是那个由第一个数字和最后一个数字组成的最小的分数，然后就是精髓所在了，我们此时将分母所在的位置前移一位，还是和当前的分子组成新的分数，这里即为第一个数字和倒数第二个数字组成的分数，存入最小堆中，那么由于之前我们已经将第二个数字和倒数第一个数字组成的分数存入了最小堆，所以不用担心第二小的分数不在堆中，这样每取出一个分数，我们都新加一个稍稍比取出的大一点的分数，这样我们取出了第K个分数即为所求，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; kthSmallestPrimeFraction(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; A, <span style="color: #0000ff;">int</span><span style="color: #000000;"> K) {
        priority_queue</span>&lt;pair&lt;<span style="color: #0000ff;">double</span>, pair&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;&gt;&gt;<span style="color: #000000;"> q;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; A.size(); ++<span style="color: #000000;">i) {
            q.push({</span>-<span style="color: #800080;">1.0</span> * A[i] / A.back(), {i, A.size() - <span style="color: #800080;">1</span><span style="color: #000000;">}});
        }
        </span><span style="color: #0000ff;">while</span> (--<span style="color: #000000;">K) {
            auto t </span>=<span style="color: #000000;"> q.top().second; q.pop();
            </span>--<span style="color: #000000;">t.second;
            q.push({</span>-<span style="color: #800080;">1.0</span> * A[t.first] /<span style="color: #000000;"> A[t.second], {t.first, t.second}});
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> {A[q.top().second.first], A[q.top().second.second]};
    }
};</span></pre>
</div>
<p> </p>
<p>其实这道题比较经典的解法是用二分搜索法Binary Search，这道题使用的二分搜索法是博主归纳总结帖<a class="entrylistItemTitle" href="http://www.cnblogs.com/grandyang/p/6854825.html" id="CategoryEntryList1_EntryStoryList_ctl00_Entries_TitleUrl_1">LeetCode Binary Search Summary 二分搜索法小结</a>中的第四种，即二分法的判定条件不是简单的大小关系，而是可以抽离出子函数的情况，下面我们来看具体怎么弄。这种高级的二分搜索法在求第K小的数的时候经常使用，比如 <a href="http://www.cnblogs.com/grandyang/p/5727892.html">Kth Smallest Element in a Sorted Matrix</a>，<a href="http://www.cnblogs.com/grandyang/p/8367505.html" target="_blank">Kth Smallest Number in Multiplication Table</a>，和 <a href="http://www.cnblogs.com/grandyang/p/8627783.html" target="_blank">Find K-th Smallest Pair Distance</a> 等。思路都是用mid当作candidate，然后统计小于mid的个数cnt，和K进行比较，从而确定折半的方向。这道题也是如此，mid为候选的分数值，刚开始时是0.5，然后我们需要统计出不大于mid的分数都个数cnt，同时也需要找出最接近mid的分数，当作返回的候选值，因为一旦cnt等于K了，直接将这个候选值返回即可，否则如果cnt小于K，说明我们应该增大一些mid，将left赋值为mid，反之如果cnt大于K，我们需要减小mid，将right赋值为mid，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; kthSmallestPrimeFraction(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; A, <span style="color: #0000ff;">int</span><span style="color: #000000;"> K) {
        </span><span style="color: #0000ff;">double</span> left = <span style="color: #800080;">0</span>, right = <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> p = <span style="color: #800080;">0</span>, q = <span style="color: #800080;">1</span>, cnt = <span style="color: #800080;">0</span>, n =<span style="color: #000000;"> A.size();
        </span><span style="color: #0000ff;">while</span> (<span style="color: #0000ff;">true</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">double</span> mid = left + (right - left) / <span style="color: #800080;">2.0</span><span style="color: #000000;">;
            cnt </span>= <span style="color: #800080;">0</span>; p = <span style="color: #800080;">0</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>, j = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
                </span><span style="color: #0000ff;">while</span> (j &lt; n &amp;&amp; A[i] &gt; mid * A[j]) ++<span style="color: #000000;">j;
                cnt </span>+= n -<span style="color: #000000;"> j;
                </span><span style="color: #0000ff;">if</span> (j &lt; n &amp;&amp; p * A[j] &lt; q *<span style="color: #000000;"> A[i]) {
                    p </span>=<span style="color: #000000;"> A[i];
                    q </span>=<span style="color: #000000;"> A[j];
                }
            }
            </span><span style="color: #0000ff;">if</span> (cnt == K) <span style="color: #0000ff;">return</span><span style="color: #000000;"> {p, q};
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (cnt &lt; K) left =<span style="color: #000000;"> mid;
            </span><span style="color: #0000ff;">else</span> right =<span style="color: #000000;"> mid;
        }
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/5653127.html">Find K Pairs with Smallest Sums</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/5727892.html">Kth Smallest Element in a Sorted Matrix</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/8367505.html" target="_blank">Kth Smallest Number in Multiplication Table</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/8627783.html" target="_blank">Find K-th Smallest Pair Distance</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a> </p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-06-04 19:59</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=9135156" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(9135156);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/8519566.html" id="cb_post_title_url">[LeetCode] Is Graph Bipartite? 是二分图么？</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given an undirected <code>graph</code>, return <code>true</code> if and only if it is bipartite.</p>
<p>Recall that a graph is <em>bipartite</em> if we can split it's set of nodes into two independent subsets A and B such that every edge in the graph has one node in A and another node in B.</p>
<p>The graph is given in the following form: <code>graph[i]</code> is a list of indexes <code>j</code> for which the edge between nodes <code>i</code> and <code>j</code> exists.  Each node is an integer between <code>0</code> and <code>graph.length - 1</code>.  There are no self edges or parallel edges: <code>graph[i]</code> does not contain <code>i</code>, and it doesn't contain any element twice.</p>
<pre>Example 1:
Input: [[1,3], [0,2], [1,3], [0,2]]
Output: true
Explanation: 
The graph looks like this:
0----1
|    |
|    |
3----2
We can divide the vertices into two groups: {0, 2} and {1, 3}.
</pre>
<pre>Example 2:
Input: [[1,2,3], [0,2], [0,1,3], [0,2]]
Output: false
Explanation: 
The graph looks like this:
0----1
| \  |
|  \ |
3----2
We cannot find a way to divide the set of nodes into two independent subsets.
</pre>
<p> </p>
<p>Note:</p>
<ul>
<li><code>graph</code> will have length in range <code>[1, 100]</code>.</li>
<li><code>graph[i]</code> will contain integers in range <code>[0, graph.length - 1]</code>.</li>
<li><code>graph[i]</code> will not contain <code>i</code> or duplicate values.</li>
<li>The graph is undirected: if any element <code>j</code> is in <code>graph[i]</code>, then <code>i</code> will be in <code>graph[j]</code>.</li>
</ul>
<p> </p>
<p>这道题博主在最开始做的时候，看了半天，愣是没弄懂输出数据的意思，博主开始以为给的是边，后来发现跟图对应不上，就懵逼了，后来是通过研究论坛上大神们的解法，才总算搞懂了题目的意思，原来输入数组中的graph[i]，表示顶点i所有相邻的顶点，比如对于例子1来说，顶点0和顶点1，3相连，顶点1和顶点0，2相连，顶点2和结点1，3相连，顶点3和顶点0，2相连。这道题让我们验证给定的图是否是二分图，所谓<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%88%86%E5%9B%BE" target="_blank">二分图</a>，就是可以将图中的所有顶点分成两个不相交的集合，使得同一个集合的顶点不相连。为了验证是否有这样的两个不相交的集合存在，我们采用一种很机智的染色法，大体上的思路是要将相连的两个顶点染成不同的颜色，一旦在染的过程中发现有两连的两个顶点已经被染成相同的颜色，说明不是二分图。这里我们使用两种颜色，分别用1和-1来表示，初始时每个顶点用0表示未染色，然后遍历每一个顶点，如果该顶点未被访问过，则调用递归函数，如果返回false，那么说明不是二分图，则直接返回false。如果循环退出后没有返回false，则返回true。在递归函数中，如果当前顶点已经染色，如果该顶点的颜色和将要染的颜色相同，则返回true，否则返回false。如果没被染色，则将当前顶点染色，然后再遍历与该顶点相连的所有的顶点，调用递归函数，如果返回false了，则当前递归函数的返回false，循环结束返回true，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> isBipartite(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> graph) {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> colors(graph.size());
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; graph.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (colors[i] == <span style="color: #800080;">0</span> &amp;&amp; !valid(graph, <span style="color: #800080;">1</span><span style="color: #000000;">, i, colors)) {
                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            }
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
    </span><span style="color: #0000ff;">bool</span> valid(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp; graph, <span style="color: #0000ff;">int</span> color, <span style="color: #0000ff;">int</span> cur, vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> colors) {
        </span><span style="color: #0000ff;">if</span> (colors[cur] != <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span> colors[cur] ==<span style="color: #000000;"> color;
        colors[cur] </span>=<span style="color: #000000;"> color;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span><span style="color: #000000;"> i : graph[cur]) {
            </span><span style="color: #0000ff;">if</span> (!valid(graph, -<span style="color: #800080;">1</span> *<span style="color: #000000;"> color, i, colors)) {
                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            }
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>我们再来看一种迭代的解法，整体思路还是一样的，还是遍历整个顶点，如果未被染色，则先染色为1，然后使用BFS进行遍历，将当前顶点放入队列queue中，然后while循环queue不为空，取出队首元素，遍历其所有相邻的顶点，如果相邻顶点未被染色，则染成和当前顶点相反的颜色，然后把相邻顶点加入queue中，否则如果当前顶点和相邻顶点颜色相同，直接返回false，循环退出后返回true，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> isBipartite(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> graph) {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> colors(graph.size());
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; graph.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (colors[i] != <span style="color: #800080;">0</span>) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
            colors[i] </span>= <span style="color: #800080;">1</span><span style="color: #000000;">;
            queue</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> q{{i}};
            </span><span style="color: #0000ff;">while</span> (!<span style="color: #000000;">q.empty()) {
                </span><span style="color: #0000ff;">int</span> t =<span style="color: #000000;"> q.front(); q.pop();
                </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto a : graph[t]) {
                    </span><span style="color: #0000ff;">if</span> (colors[a] == <span style="color: #800080;">0</span><span style="color: #000000;">) {
                        colors[a] </span>= -<span style="color: #800080;">1</span> *<span style="color: #000000;"> colors[t];
                        q.push(a);
                    } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                        </span><span style="color: #0000ff;">if</span> (colors[a] == colors[t]) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
                    }
                }
            }
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-03-06 22:26</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=8519566" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(8519566);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/9065702.html" id="cb_post_title_url">[LeetCode] Letter Case Permutation 字母大小写全排列</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a string S, we can transform every letter individually to be lowercase or uppercase to create another string.  Return a list of all possible strings we could create.</p>
<pre>Examples:
Input: S = "a1b2"
Output: ["a1b2", "a1B2", "A1b2", "A1B2"]

Input: S = "3z4"
Output: ["3z4", "3Z4"]

Input: S = "12345"
Output: ["12345"]
</pre>
<p>Note:</p>
<ul>
<li><code>S</code> will be a string with length at most <code>12</code>.</li>
<li><code>S</code> will consist only of letters or digits.</li>
</ul>
<p> </p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; letterCasePermutation(<span style="color: #0000ff;">string</span><span style="color: #000000;"> S) {
        vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; res{<span style="color: #800000;">""</span><span style="color: #000000;">};
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span><span style="color: #000000;"> c : S) {
            </span><span style="color: #0000ff;">int</span> len =<span style="color: #000000;"> res.size();
            </span><span style="color: #0000ff;">if</span> (c &gt;= <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span> &amp;&amp; c &lt;= <span style="color: #800000;">'</span><span style="color: #800000;">9</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">string</span> &amp;<span style="color: #000000;">str : res) str.push_back(c);
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; len; ++<span style="color: #000000;">i) {
                    res.push_back(res[i]);
                    res[i].push_back(tolower(c));
                    res[len </span>+<span style="color: #000000;"> i].push_back(toupper(c));
                }
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种解法跟上面的解法没有太大的区别，只不过没有用到tolower()和toupper()这两个built-in函数，而是使用了一个trick来flip大小写字母，通过亦或32实现，为什么呢？因为我们知道 'A' = 65, 'B' = 66, 和 'a' = 97, 'b' = 98, 小写字母的ASCII码比大写字母多32，刚好是(1 &lt;&lt; 5)，那么我们只要flip第五位上的1，就可以实现大小写的交替了，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; letterCasePermutation(<span style="color: #0000ff;">string</span><span style="color: #000000;"> S) {
        vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; res{<span style="color: #800000;">""</span><span style="color: #000000;">};
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span><span style="color: #000000;"> c : S) {
            </span><span style="color: #0000ff;">int</span> len =<span style="color: #000000;"> res.size();
            </span><span style="color: #0000ff;">if</span> (c &gt;= <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span> &amp;&amp; c &lt;= <span style="color: #800000;">'</span><span style="color: #800000;">9</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">string</span> &amp;<span style="color: #000000;">str : res) str.push_back(c);
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; len; ++<span style="color: #000000;">i) {
                    res.push_back(res[i]);
                    res[i].push_back(c);
                    res[len </span>+ i].push_back(c ^ <span style="color: #800080;">32</span><span style="color: #000000;">);
                }
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>我们再来看一种递归的写法，是一种回溯的思路，比如说S = "abc"，用一个pos指向当前处理的位置，初始化带入0，然后再递归函数中，如果pos等于s的长度了，那么将s存入结果res再返回；否则调用递归函数，此时带入pos+1，那么递归函数就会一直深入，直到pos等于s的长度了，那么此时就把"abc"存入结果res了，返回后此时pos=2，发现s[pos]是字母，则用上面解法中的flip方法来翻转字母，并且调用递归函数，这样"abC"就会存入结果res中，然后回溯到pos=1的位置，s[pos]是字符，可以flip，并且调用递归函数，这样"aBC"就会存入结果res中，然后pos继续往后遍历，这样"aBc"就会存入结果res中，然后回溯到pos=0的位置，s[pos]是字符，可以flip，并且调用递归函数，这样"ABc"就会存入结果res中，然后继续回溯，这样"ABC"就会存入结果res中，pos又回溯到1的位置，s[pos]是字符，可以flip，并且调用递归函数，这样"AbC"就会存入结果res中，然后pos继续往后遍历，这样"Abc"就会存入结果res中，整个的顺序为：[abc abC aBC aBc ABc ABC AbC Abc]，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; letterCasePermutation(<span style="color: #0000ff;">string</span><span style="color: #000000;"> S) {
        vector</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> res;
        helper(S, </span><span style="color: #800080;">0</span><span style="color: #000000;">, res);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">void</span> helper(<span style="color: #0000ff;">string</span>&amp; s, <span style="color: #0000ff;">int</span> pos, vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp;<span style="color: #000000;"> res) {
        </span><span style="color: #0000ff;">if</span> (pos ==<span style="color: #000000;"> s.size()) {
            res.push_back(s);
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;">;
        }
        helper(s, pos </span>+ <span style="color: #800080;">1</span><span style="color: #000000;">, res);
        </span><span style="color: #0000ff;">if</span> (s[pos] &gt; <span style="color: #800000;">'</span><span style="color: #800000;">9</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
            s[pos] </span>^= <span style="color: #800080;">32</span><span style="color: #000000;">;
            helper(s, pos </span>+ <span style="color: #800080;">1</span><span style="color: #000000;">, res);
        }
    }
};</span></pre>
</div>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #800080;">000</span> -&gt;<span style="color: #000000;"> ABC
</span><span style="color: #800080;">001</span> -&gt;<span style="color: #000000;"> ABc
</span><span style="color: #800080;">010</span> -&gt;<span style="color: #000000;"> AbC
</span><span style="color: #800080;">011</span> -&gt;<span style="color: #000000;"> Abc
</span><span style="color: #800080;">100</span> -&gt;<span style="color: #000000;"> aBC
</span><span style="color: #800080;">101</span> -&gt;<span style="color: #000000;"> aBc
</span><span style="color: #800080;">110</span> -&gt;<span style="color: #000000;"> abC
</span><span style="color: #800080;">111</span> -&gt; abc</pre>
</div>
<p>这样的话，我们只需要先统计出S中字母的个数cnt，然后遍历 [0, 2^cnt) 中的每个数字，对于每个数字，再遍历S中的每个字符，如果是字母，那么如果当前位是1，则加入小写字母，反之加入大写字母；如果是数字，则直接加入即可。我们用j指向位，每次处理完一位后j自增1，表示对下一位进行处理，参见代码如下：</p>
<p> </p>
<p>解法四：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; letterCasePermutation(<span style="color: #0000ff;">string</span><span style="color: #000000;"> S) {
        vector</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">int</span> cnt = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span><span style="color: #000000;"> c : S) {
            </span><span style="color: #0000ff;">if</span> (c &gt; <span style="color: #800000;">'</span><span style="color: #800000;">9</span><span style="color: #800000;">'</span>) ++<span style="color: #000000;">cnt;
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; (<span style="color: #800080;">1</span> &lt;&lt; cnt); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">string</span> word = <span style="color: #800000;">""</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span><span style="color: #000000;"> c : S) {
                </span><span style="color: #0000ff;">if</span> (c &gt; <span style="color: #800000;">'</span><span style="color: #800000;">9</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">if</span> (((i &gt;&gt; j++) &amp; <span style="color: #800080;">1</span>) == <span style="color: #800080;">1</span><span style="color: #000000;">) {
                        word.push_back(tolower(c));
                    } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                        word.push_back(toupper(c));
                    }
                } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    word.push_back(c);
                }
            }
            res.push_back(word);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4309345.html" target="_blank">Subsets</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-05-21 09:21</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=9065702" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(9065702);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/9062143.html" id="cb_post_title_url">[LeetCode] Minimum Distance Between BST Nodes 二叉搜索树中结点的最小距离</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a Binary Search Tree (BST) with the root node <code>root</code>, return the minimum difference between the values of any two different nodes in the tree.</p>
<p>Example :</p>
<pre>Input: root = [4,2,6,1,3,null,null]
Output: 1
Explanation:
Note that root is a TreeNode object, not an array.

The given tree [4,2,6,1,3,null,null] is represented by the following diagram:

          4
        /   \
      2      6
     / \    
    1   3  

while the minimum difference in this tree is 1, it occurs between node 1 and node 2, also between node 3 and node 2.
</pre>
<p>Note:</p>
<ol>
<li>The size of the BST will be between 2 and <code>100</code>.</li>
<li>The BST is always valid, each node's value is an integer, and each node's value is different.</li>
</ol>
<p> </p>
<p>这道题跟之前那道<a href="http://www.cnblogs.com/grandyang/p/6540165.html">Minimum Absolute Difference in BST</a>没有任何区别，解法完全可以共用，讲解也可以参见之前的帖子，这里就简略的说一下。第一种方法很直接，通过中序遍历按顺序从小到大将所有的结点值都存入到一个数组中，然后就遍历这个数组，找相邻的两个的差值最小的返回即可，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> minDiffInBST(TreeNode*<span style="color: #000000;"> root) {
        </span><span style="color: #0000ff;">int</span> res =<span style="color: #000000;"> INT_MAX;
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> v;
        helper(root, v);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt; v.size(); ++<span style="color: #000000;">i) {
            res </span>= min(res, v[i] - v[i - <span style="color: #800080;">1</span><span style="color: #000000;">]);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">void</span> helper(TreeNode* node, vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> vals) {
        </span><span style="color: #0000ff;">if</span> (!node) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
        helper(node</span>-&gt;<span style="color: #000000;">left, vals);
        vals.push_back(node</span>-&gt;<span style="color: #000000;">val);
        helper(node</span>-&gt;<span style="color: #000000;">right, vals);
    }
};</span></pre>
</div>
<p> </p>
<p>我们可以优化上面解法的空间复杂度，并不记录所有的结点值，而是只记录之前的结点值，然后做差值更新结果res即可。</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> minDiffInBST(TreeNode*<span style="color: #000000;"> root) {
        </span><span style="color: #0000ff;">int</span> res = INT_MAX, pre = -<span style="color: #800080;">1</span><span style="color: #000000;">;
        helper(root, pre, res);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">void</span> helper(TreeNode* node, <span style="color: #0000ff;">int</span>&amp; pre, <span style="color: #0000ff;">int</span>&amp;<span style="color: #000000;"> res) {
        </span><span style="color: #0000ff;">if</span> (!node) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
        helper(node</span>-&gt;<span style="color: #000000;">left, pre, res);
        </span><span style="color: #0000ff;">if</span> (pre != -<span style="color: #800080;">1</span>) res = min(res, node-&gt;val -<span style="color: #000000;"> pre);
        pre </span>= node-&gt;<span style="color: #000000;">val;
        helper(node</span>-&gt;<span style="color: #000000;">right, pre, res);
    }
};</span></pre>
</div>
<p> </p>
<p>其实我们也不必非要用中序遍历不可，用先序遍历同样可以利用到BST的性质，我们带两个变量low和high来分别表示上下界，初始化为int的极值，然后我们在递归函数中，分别用上下界和当前节点值的绝对差来更新结果res，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> minDiffInBST(TreeNode*<span style="color: #000000;"> root) {
        </span><span style="color: #0000ff;">int</span> res =<span style="color: #000000;"> INT_MAX;
        helper(root, INT_MIN, INT_MAX, res);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">void</span> helper(TreeNode* node, <span style="color: #0000ff;">int</span> low, <span style="color: #0000ff;">int</span> high, <span style="color: #0000ff;">int</span>&amp;<span style="color: #000000;"> res) {
        </span><span style="color: #0000ff;">if</span> (!node) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (low != INT_MIN) res = min(res, node-&gt;val -<span style="color: #000000;"> low);
        </span><span style="color: #0000ff;">if</span> (high != INT_MAX) res = min(res, high - node-&gt;<span style="color: #000000;">val);
        helper(node</span>-&gt;left, low, node-&gt;<span style="color: #000000;">val, res);
        helper(node</span>-&gt;right, node-&gt;<span style="color: #000000;">val, high, res);
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种方法是解法一的迭代的写法，思路跟之前的解法没有什么区别，参见代码如下：</p>
<p> </p>
<p>解法四：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> minDiffInBST(TreeNode*<span style="color: #000000;"> root) {
        </span><span style="color: #0000ff;">int</span> res = INT_MAX, pre = -<span style="color: #800080;">1</span><span style="color: #000000;">;
        stack</span>&lt;TreeNode*&gt;<span style="color: #000000;"> st;
        TreeNode</span>* p =<span style="color: #000000;"> root;
        </span><span style="color: #0000ff;">while</span> (!st.empty() ||<span style="color: #000000;"> p) {
            </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (p) {
                st.push(p);
                p </span>= p-&gt;<span style="color: #000000;">left;
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                p </span>=<span style="color: #000000;"> st.top(); st.pop();
                </span><span style="color: #0000ff;">if</span> (pre != -<span style="color: #800080;">1</span>) res = min(res, p-&gt;val -<span style="color: #000000;"> pre);
                pre </span>= p-&gt;<span style="color: #000000;">val;
                p </span>= p-&gt;<span style="color: #000000;">right;
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/6540165.html">Minimum Absolute Difference in BST</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4297300.html" target="_blank">Binary Tree Inorder Traversal</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-05-19 23:46</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=9062143" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(9062143);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/9053705.html" id="cb_post_title_url">[LeetCode] Transform to Chessboard 转为棋盘</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>An N x N <code>board</code> contains only <code>0</code>s and <code>1</code>s. In each move, you can swap any 2 rows with each other, or any 2 columns with each other.</p>
<p>What is the minimum number of moves to transform the board into a "chessboard" - a board where no <code>0</code>s and no <code>1</code>s are 4-directionally adjacent? If the task is impossible, return -1.</p>
<pre>Examples:
Input: board = [[0,1,1,0],[0,1,1,0],[1,0,0,1],[1,0,0,1]]
Output: 2
Explanation:
One potential sequence of moves is shown below, from left to right:

0110     1010     1010
0110 --&gt; 1010 --&gt; 0101
1001     0101     1010
1001     0101     0101

The first move swaps the first and second column.
The second move swaps the second and third row.


Input: board = [[0, 1], [1, 0]]
Output: 0
Explanation:
Also note that the board with 0 in the top left corner,
01
10

is also a valid chessboard.

Input: board = [[1, 0], [1, 0]]
Output: -1
Explanation:
No matter what sequence of moves you make, you cannot end with a valid chessboard.
</pre>
<p>Note:</p>
<ul>
<li><code>board</code> will have the same number of rows and columns, a number in the range <code>[2, 30]</code>.</li>
<li><code>board[i][j]</code> will be only <code>0</code>s or <code>1</code>s.</li>
</ul>
<p> </p>
<p>这道题给了我们一个二维数组，里面都是由0和1组成的，让我们通过交换行或者列来形成一个棋盘。棋盘我们都见过吧，就是国际象棋的那种棋盘，黑白相间的那种，用数组表示就是0和1交替出现，相邻位置上的数字必定不是一样的。这道题默认的棋盘的起始位置可以是1或者0，然后依次类推可得到所有位置上的值。这道题最大的难点是在于判断给定的数组最终能否组成棋盘，因为能通过交换组成棋盘的数组其实是有很多苛刻条件需要满足的，只有这些条件都满足了，才能到计算交换数到那一步。首先我们先来看长度为4的棋盘：</p>
<p>1 0 1 0</p>
<p>0 1 0 1</p>
<p>1 0 1 0</p>
<p>0 1 0 1</p>
<p>或者：</p>
<p>0 1 0 1</p>
<p>1 0 1 0</p>
<p>0 1 0 1</p>
<p>1 0 1 0</p>
<p>我们发现对于长度为偶数的棋盘，每一行0和1的个数都是相等的，不管我们如何交换行和列，0和1的个数都是不会变化的，再看看长度为奇数的棋盘，比如3:</p>
<p>1 0 1</p>
<p>0 1 0</p>
<p>1 0 1</p>
<p>或者：</p>
<p>0 1 0</p>
<p>1 0 1</p>
<p>0 1 0</p>
<p>我们发现对于长度为奇数的棋盘，各行的0和1个数不同，但是还是有规律的，每行的1的个数要么为 n/2，要么为 (n+1)/2，这个规律一定要保证，不然无法形成棋盘。</p>
<p>还有一个很重要的规律，我们观察题目给的第一个例子，如果我们只看行，我们发现只有两种情况 0110 和 1001，如果只看列，只有 0011 和 1100，我们发现不管棋盘有多长，都只有两种情况，而这两种情况上各位上是相反的，只有这样的矩阵才有可能转换为棋盘。那么这个规律可以衍生出一个规律，就是任意一个矩形的四个顶点只有三种情况，要么四个0，要么四个1，要么两个0两个1，不会有其他的情况。那么四个顶点亦或在一起一定是0，所以我们判断只要亦或出了1，一定是不对的，直接返回-1。之后我们来统计首行和首列中的1个数，因为我们要让其满足之前提到的规律。统计完了首行首列1的个数，我们判断如果其小于 n/2 或者大于 (n+1) / 2，那么一定无法转为棋盘。我们还需要算下首行和首列跟棋盘位置的错位的个数，虽然 01010 和 10101 都可以是正确的棋盘，我们先默认跟 10101 比较好了，之后再做优化处理。</p>
<p>最后的难点就是计算最小的交换步数了，这里要分n的奇偶来讨论。如果n是奇数，我们必须得到偶数个，为啥呢，因为我们之前统计的是跟棋盘位置的错位的个数，而每次交换行或者列，会修改两个错位，所以如果是奇数就无法还原为棋盘。举个例子，比如首行是 10001，如果我们跟棋盘 10101 比较，只有一个错位，但是我们是无法通过交换得到 10101的，所以我们必须要交换得到 01010，此时的错位是4个，而我们通过 n - rowDiff 正好也能得到4，这就是为啥我们需要偶数个错位。如果n是偶数，那么就不会出现这种问题，但是会出现另一个问题，比如我们是 0101，这本身就是正确的棋盘排列了，但是由于我们默认是跟 1010 比较，那么我们会得到4个错位，所以我们应该跟 n - rowDiff 比较取较小值。列的处理跟行的处理完全一样。最终我们把行错位个数跟列错位个数相加，再除以2，就可以得到最小的交换次数了，之前说过了每交换一次，可以修复两个错位，参见代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> movesToChessboard(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> board) {
        </span><span style="color: #0000ff;">int</span> n = board.size(), rowSum = <span style="color: #800080;">0</span>, colSum = <span style="color: #800080;">0</span>, rowDiff = <span style="color: #800080;">0</span>, colDiff = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; n; ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> (board[<span style="color: #800080;">0</span>][<span style="color: #800080;">0</span>] ^ board[i][<span style="color: #800080;">0</span>] ^ board[<span style="color: #800080;">0</span>][j] ^ board[i][j]) <span style="color: #0000ff;">return</span> -<span style="color: #800080;">1</span><span style="color: #000000;">;
            }
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            rowSum </span>+= board[<span style="color: #800080;">0</span><span style="color: #000000;">][i];
            colSum </span>+= board[i][<span style="color: #800080;">0</span><span style="color: #000000;">];
            rowDiff </span>+= (board[i][<span style="color: #800080;">0</span>] == i % <span style="color: #800080;">2</span><span style="color: #000000;">);
            colDiff </span>+= (board[<span style="color: #800080;">0</span>][i] == i % <span style="color: #800080;">2</span><span style="color: #000000;">);
        }
        </span><span style="color: #0000ff;">if</span> (n / <span style="color: #800080;">2</span> &gt; rowSum || rowSum &gt; (n + <span style="color: #800080;">1</span>) / <span style="color: #800080;">2</span>) <span style="color: #0000ff;">return</span> -<span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (n / <span style="color: #800080;">2</span> &gt; colSum || colSum &gt; (n + <span style="color: #800080;">1</span>) / <span style="color: #800080;">2</span>) <span style="color: #0000ff;">return</span> -<span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (n % <span style="color: #800080;">2</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">if</span> (rowDiff % <span style="color: #800080;">2</span>) rowDiff = n -<span style="color: #000000;"> rowDiff;
            </span><span style="color: #0000ff;">if</span> (colDiff % <span style="color: #800080;">2</span>) colDiff = n -<span style="color: #000000;"> colDiff;
        } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            rowDiff </span>= min(n -<span style="color: #000000;"> rowDiff, rowDiff);
            colDiff </span>= min(n -<span style="color: #000000;"> colDiff, colDiff);
        }
        </span><span style="color: #0000ff;">return</span> (rowDiff + colDiff) / <span style="color: #800080;">2</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a href="http://www.cnblogs.com/grandyang/p/4606334.html" target="_blank">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-05-17 22:32</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=9053705" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(9053705);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/9043761.html" id="cb_post_title_url">[LeetCode] Rabbits in Forest 森林里的兔子</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>In a forest, each rabbit has some color. Some subset of rabbits (possibly all of them) tell you how many other rabbits have the same color as them. Those <code>answers</code> are placed in an array.</p>
<p>Return the minimum number of rabbits that could be in the forest.</p>
<pre>Examples:
Input: answers = [1, 1, 2]
Output: 5
Explanation:
The two rabbits that answered "1" could both be the same color, say red.
The rabbit than answered "2" can't be red or the answers would be inconsistent.
Say the rabbit that answered "2" was blue.
Then there should be 2 other blue rabbits in the forest that didn't answer into the array.
The smallest possible number of rabbits in the forest is therefore 5: 3 that answered plus 2 that didn't.

Input: answers = [10, 10, 10]
Output: 11

Input: answers = []
Output: 0
</pre>
<p>Note:</p>
<ol>
<li><code>answers</code> will have length at most <code>1000</code>.</li>
<li>Each <code>answers[i]</code> will be an integer in the range <code>[0, 999]</code>.</li>
</ol>
<p> </p>
<p>这道题说的是大森林中有一堆成了精的兔子，有着不同的颜色，还会回答问题。每个兔子会告诉你森林中还有多少个和其颜色相同的兔子，当然并不是所有的兔子多出现在数组中，所以我们要根据兔子们的回答，来估计森林中最少有多少只能确定的兔子。例子1给的数字是 [1, 1, 2]，第一只兔子说森林里还有另一只兔子跟其颜色一样，第二只兔子也说还有另一只兔子和其颜色一样，那么为了使兔子总数最少，我们可以让前两只兔子是相同的颜色，可以使其回答不会矛盾。第三只兔子说森林里还有两只兔子和其颜色一样，那么这只兔的颜色就不能和前两只兔子的颜色相同了，否则就会跟前面两只兔子的回答矛盾了，因为根据第三只兔子的描述，森林里共有三只这种颜色的兔子，所有总共可以推断出最少有五只兔子。对于例子2，[10, 10, 10] 来说，这三只兔子都说森林里还有10只跟其颜色相同的兔子，那么这三只兔子颜色可以相同，所以总共有11只兔子。</p>
<p>来看一个比较tricky的例子，[0, 0, 1, 1, 1]，前两只兔子都说森林里没有兔子和其颜色相同了，那么这两只兔子就是森林里独一无二的兔子，且颜色并不相同，所以目前已经确定了两只。然后后面三只都说森林里还有一只兔子和其颜色相同，那么这三只兔子就不可能颜色都相同了，但我们可以让两只颜色相同，另外一只颜色不同，那么就是说还有一只兔子并没有在数组中，所以森林中最少有6只兔子。分析完了这几个例子，我们可以发现，如果某个兔子回答的数字是x，那么说明森林里共有x+1个相同颜色的兔子，我们最多允许x+1个兔子同时回答x个，一旦超过了x+1个兔子，那么就得再增加了x+1个新兔子了。所以我们可以使用一个HashMap来建立某种颜色兔子的总个数和在数组中还允许出现的个数之间的映射，然后我们遍历数组中的每个兔子，如果该兔子回答了x个，若该颜色兔子的总个数x+1不在HashMap中，或者映射为0了，我们将这x+1个兔子加入结果res中，然后将其映射值设为x，表示在数组中还允许出现x个也回答x的兔子；否则的话，将映射值自减1即可，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> numRabbits(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> answers) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        unordered_map</span>&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> m;      
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span><span style="color: #000000;"> ans : answers) {
            </span><span style="color: #0000ff;">if</span> (!m.count(ans + <span style="color: #800080;">1</span>) || m[ans + <span style="color: #800080;">1</span>] == <span style="color: #800080;">0</span><span style="color: #000000;">) {
                res </span>+= ans + <span style="color: #800080;">1</span><span style="color: #000000;">;
                m[ans </span>+ <span style="color: #800080;">1</span>] =<span style="color: #000000;"> ans;
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                </span>--m[ans + <span style="color: #800080;">1</span><span style="color: #000000;">];
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种方法换了个角度，核心还是当某个兔子回答x的时候，那么数组中最多允许x+1个兔子同时回答x，那么我们统计数组中所有回答x的兔子的数量n：</p>
<p>若 n%(x+1)==0，说明我们此时只需要 n/(x+1) 组个数为x+1的兔子。</p>
<p>若 n%(x+1)!=0，说明我们此时只需要 n/(x+1) + 1 组个数为x+1的兔子。</p>
<p>那么这两种情况可以通过 ceil(n/(x+1)) 来整合，而这个值也等于 (n + x) / (x + 1)，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> numRabbits(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> answers) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        unordered_map</span>&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> m;  
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> ans : answers) ++<span style="color: #000000;">m[ans];
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto a : m) {
            res </span>+= (a.second + a.first) / (a.first + <span style="color: #800080;">1</span>) * (a.first + <span style="color: #800080;">1</span><span style="color: #000000;">);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种思路也很巧妙，是先统计出不在数组中的兔子的个数，然后再加上回答问题的兔子数。我们使用一个长度为1000的数字代替HashMap，因为题目中限定了最多1000个兔子回答问题，然后我们对于每个回答x的兔子，将 cnt[x] 的值自增1，然后对 x+1 取余，那么余数就是总数为 x+1 的兔子中在数组中出现的个数，所以我们之后用 x+1 减去这个余数，就是不在数组中的兔子的个数。那么你可能会怀疑，当余数为0了，会不会漏掉了兔子啊，答案是不会的，因为我们最终要加上数组中的兔子个数，如果对 x+1 取余为0了，说明这 x+1 个兔子都在数组中出现了，所以我们不会漏掉任何兔子，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> numRabbits(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> answers) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; cnt(<span style="color: #800080;">1000</span>, <span style="color: #800080;">0</span><span style="color: #000000;">); 
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> ans : answers) cnt[ans] = (cnt[ans] + <span style="color: #800080;">1</span>) % (ans + <span style="color: #800080;">1</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; <span style="color: #800080;">1000</span>; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (cnt[i] != <span style="color: #800080;">0</span>) res += i + <span style="color: #800080;">1</span> -<span style="color: #000000;"> cnt[i];
        }
        </span><span style="color: #0000ff;">return</span> res +<span style="color: #000000;"> answers.size();
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-05-15 23:39</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=9043761" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(9043761);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/9033955.html" id="cb_post_title_url">[LeetCode] Reaching Points 到达指定点</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>A move consists of taking a point <code>(x, y)</code> and transforming it to either <code>(x, x+y)</code> or <code>(x+y, y)</code>.</p>
<p>Given a starting point <code>(sx, sy)</code> and a target point <code>(tx, ty)</code>, return <code>True</code> if and only if a sequence of moves exists to transform the point <code>(sx, sy)</code> to <code>(tx, ty)</code>. Otherwise, return <code>False</code>.</p>
<pre>Examples:
Input: sx = 1, sy = 1, tx = 3, ty = 5
Output: True
Explanation:
One series of moves that transforms the starting point to the target is:
(1, 1) -&gt; (1, 2)
(1, 2) -&gt; (3, 2)
(3, 2) -&gt; (3, 5)

Input: sx = 1, sy = 1, tx = 2, ty = 2
Output: False

Input: sx = 1, sy = 1, tx = 1, ty = 1
Output: True

</pre>
<p>Note:</p>
<ul>
<li><code>sx, sy, tx, ty</code> will all be integers in the range <code>[1, 10^9]</code>.</li>
</ul>
<p> </p>
<p>我们的目标是将tx和ty分别缩小到sx和sy，不可能一步就缩小到位，那么这肯定是一个循环，终止条件是tx和ty中任意一个小于了sx和sy，那么在循环内部，我们想要缩小tx或ty，先缩小两者中较大的那个，若tx大于ty，我们可以尝试缩小tx，但是如果此时ty等于sy了话，我们可以迅速判断出结果，通过计算此时tx和sx的差值是否是ty的倍数，因为此时ty不能改变了，只能缩小tx，若能通过减去整数倍数个ty得到sx的，就表示可以到达。如果ty不等于sy的话，那么直接tx对ty取余即可。同理，若ty大于tx，我们可以尝试缩小ty，但是如果此时tx等于sx了话，我们可以迅速判断出结果，通过计算此时ty和sy的差值是否是tx的倍数，如果tx不等于sx的话，那么直接ty对tx取余即可。循环退出后检测起始点和目标点是否相等，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> reachingPoints(<span style="color: #0000ff;">int</span> sx, <span style="color: #0000ff;">int</span> sy, <span style="color: #0000ff;">int</span> tx, <span style="color: #0000ff;">int</span><span style="color: #000000;"> ty) {
        </span><span style="color: #0000ff;">while</span> (tx &gt;= sx &amp;&amp; ty &gt;=<span style="color: #000000;"> sy) {
            </span><span style="color: #0000ff;">if</span> (tx &gt;<span style="color: #000000;"> ty) {
                </span><span style="color: #0000ff;">if</span> (ty == sy) <span style="color: #0000ff;">return</span> (tx - sx) % ty == <span style="color: #800080;">0</span><span style="color: #000000;">;
                tx </span>%=<span style="color: #000000;"> ty;
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                </span><span style="color: #0000ff;">if</span> (tx == sx) <span style="color: #0000ff;">return</span> (ty - sy) % tx == <span style="color: #800080;">0</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">else</span> ty %=<span style="color: #000000;"> tx;
            }
        }
        </span><span style="color: #0000ff;">return</span> tx == sx &amp;&amp; ty ==<span style="color: #000000;"> sy;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种解法将没有在循环内部处理相等的情况，而是无脑缩小tx和ty，最后循环退出后，再来判断tx和ty的关系，然后快速的判断，由于取余运算缩小的太快了，所以博主不认为二者的运行效率能差多少，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> reachingPoints(<span style="color: #0000ff;">int</span> sx, <span style="color: #0000ff;">int</span> sy, <span style="color: #0000ff;">int</span> tx, <span style="color: #0000ff;">int</span><span style="color: #000000;"> ty) {
        </span><span style="color: #0000ff;">while</span> (tx &gt;= sx &amp;&amp; ty &gt;=<span style="color: #000000;"> sy) {
            </span><span style="color: #0000ff;">if</span> (tx &gt; ty) tx %=<span style="color: #000000;"> ty;
            </span><span style="color: #0000ff;">else</span> ty %=<span style="color: #000000;"> tx;
        }
        </span><span style="color: #0000ff;">if</span> (tx &gt; ty) <span style="color: #0000ff;">return</span> tx == sx &amp;&amp; ty == sy %<span style="color: #000000;"> sx;
        </span><span style="color: #0000ff;">return</span> ty == sy &amp;&amp; tx == sx %<span style="color: #000000;"> sy;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种写法跟上面的没有太大的区别，就看起来更加整齐一些，博主有强迫症吗？？？</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> reachingPoints(<span style="color: #0000ff;">int</span> sx, <span style="color: #0000ff;">int</span> sy, <span style="color: #0000ff;">int</span> tx, <span style="color: #0000ff;">int</span><span style="color: #000000;"> ty) {
        </span><span style="color: #0000ff;">while</span> (tx &gt;= sx &amp;&amp; ty &gt;=<span style="color: #000000;"> sy) {
            </span><span style="color: #0000ff;">if</span> (tx &gt; ty) tx %=<span style="color: #000000;"> ty;
            </span><span style="color: #0000ff;">else</span> ty %=<span style="color: #000000;"> tx;
        }
        </span><span style="color: #0000ff;">if</span> (tx == sx) <span style="color: #0000ff;">return</span> (ty - sy) % sx == <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (ty == sy) <span style="color: #0000ff;">return</span> (tx - sx) % sy == <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>再来看一种递归的写法，就四行啊，其实就是用取余运算代替加法优化了brute force的解法，参见代码如下：</p>
<p> </p>
<p>解法四：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> reachingPoints(<span style="color: #0000ff;">int</span> sx, <span style="color: #0000ff;">int</span> sy, <span style="color: #0000ff;">int</span> tx, <span style="color: #0000ff;">int</span><span style="color: #000000;"> ty) {
        </span><span style="color: #0000ff;">if</span> (tx &lt; sx || ty &lt; sy) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (tx == sx &amp;&amp; (ty - sy) % sx == <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (ty == sy &amp;&amp; (tx - sx) % sy == <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span> reachingPoints(sx, sy, tx % ty, ty %<span style="color: #000000;"> tx);
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-05-13 23:22</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=9033955" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(9033955);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/9027098.html" id="cb_post_title_url">[LeetCode] K-th Symbol in Grammar 语法中的第K个符号</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>On the first row, we write a <code>0</code>. Now in every subsequent row, we look at the previous row and replace each occurrence of <code>0</code> with <code>01</code>, and each occurrence of <code>1</code> with <code>10</code>.</p>
<p>Given row <code>N</code> and index <code>K</code>, return the <code>K</code>-th indexed symbol in row <code>N</code>. (The values of <code>K</code> are 1-indexed.) (1 indexed).</p>
<pre>Examples:
Input: N = 1, K = 1
Output: 0

Input: N = 2, K = 1
Output: 0

Input: N = 2, K = 2
Output: 1

Input: N = 4, K = 5
Output: 1

Explanation:
row 1: 0
row 2: 01
row 3: 0110
row 4: 01101001
</pre>
<p>Note:</p>
<ol>
<li><code>N</code> will be an integer in the range <code>[1, 30]</code>.</li>
<li><code>K</code> will be an integer in the range <code>[1, 2^(N-1)]</code>.</li>
</ol>
<p> </p>
<p>这道题说第一行写上了一个0，然后从第二行开始，遇到0，就变为01，遇到1，则变为10，问我们第N行的第K个数字是啥。这是一道蛮有意思的题目，首先如果没啥思路的话，按照给定的方法，一行行generate出来，直到生成第N行，那么第K个数字也就知道了。但是这种brute force的方法无法通过OJ，这里就不多说了，需要想一些更高端的解法。我们想啊，遇到0变为01，那么可不可以把0和1看作上一层0的左右子结点呢，同时，把1和0看作上一层1的左右子结点，这样的话，我们整个结构就可以转为二叉树了，那么前四层的二叉树结构如下所示：</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;"><span style="color: #008080;">              0</span>
       /             \
      <span style="color: #ff0000;">0</span>               <span style="color: #0000ff;">1</span>
   /     \         /     \
  0       <span style="color: #ff0000;">1</span>       <span style="color: #0000ff;">1</span>       0
 / \     / \     / \     / \
0   1   <span style="color: #ff0000;">1</span>   0   1   <span style="color: #0000ff;">0</span>   0   1</span></pre>
</div>
<p>我们仔细观察上面这棵二叉树，第四层K=3的那个红色的左子结点，其父结点的位置是第三层的第 (K+1)/2 = 2个红色结点，而第四层K=6的那个蓝色幽子结点，其父节点的位置是第三层的第 K/2 = 3个蓝色结点。那么我们就可以一层一层的往上推，直到到达第一层的那个0。所以我们的思路是根据当前层K的奇偶性来确定上一层中父节点的位置，然后继续往上一层推，直到推倒第一层的0，然后再返回确定路径上每一个位置的值，这天然就是递归的运行机制啊。我们可以根据K的奇偶性知道其是左结点还是右结点，由于K是从1开始的，所以当K是奇数时，其是左结点，当K是偶数时，其是右结点。而且还能观察出来的是，左子结点和其父节点的值相同，右子结点和其父节点值相反，这是因为0换成了01，1换成了10，左子结点保持不变，右子结点flip了一下。想通了这些，那么我们的递归解法就不难写出来了，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> kthGrammar(<span style="color: #0000ff;">int</span> N, <span style="color: #0000ff;">int</span><span style="color: #000000;"> K) {
        </span><span style="color: #0000ff;">if</span> (N == <span style="color: #800080;">1</span>) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (K % <span style="color: #800080;">2</span> == <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span> (kthGrammar(N - <span style="color: #800080;">1</span>, K / <span style="color: #800080;">2</span>) == <span style="color: #800080;">0</span>) ? <span style="color: #800080;">1</span> : <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">return</span> (kthGrammar(N - <span style="color: #800080;">1</span>, (K + <span style="color: #800080;">1</span>) / <span style="color: #800080;">2</span>) == <span style="color: #800080;">0</span>) ? <span style="color: #800080;">0</span> : <span style="color: #800080;">1</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>我们可以简化下上面的解法，你们可能会说，纳尼？已经三行了还要简化？没错，博主就是这样一个精益求精的人（此处应有掌声👏）。我们知道偶数加1除以2，和其本身除以2的值是相同的，那么其实不论K是奇是偶，其父节点的位置都可以用 (K+1)/2 来表示，问题在于K本身的奇偶决定了其左右结点的位置，从而决定要不要flip父节点的值，这才是上面解法中我们要使用 if...else 结构的原因。实际上我们可以通过‘亦或’操作来实现一行搞定，叼不叼。我们来看下变换规则，0换成了01，1换成了10。</p>
<p>0 -&gt; 01</p>
<p>左子结点(0) = 父节点(0) ^ 0 </p>
<p>右子结点(1) = 父节点(0) ^ 1 </p>
<p>1 -&gt; 10</p>
<p>左子结点(1) = 父节点(1) ^ 0 </p>
<p>右子结点(0) = 父节点(1) ^ 1 </p>
<p>那么只要我们知道了父结点的值和当前K的奇偶性就可以知道K的值了，因为左子结点就是父结点值‘亦或’0，右子结点就是父结点值‘亦或’1，由于左子结点的K是奇数，我们可以对其取反再‘与’1，所以就是 (~K &amp; 1)，再‘亦或’上递归函数的返回值即可，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> kthGrammar(<span style="color: #0000ff;">int</span> N, <span style="color: #0000ff;">int</span><span style="color: #000000;"> K) {
        </span><span style="color: #0000ff;">if</span> (N == <span style="color: #800080;">1</span>) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span> (~K &amp; <span style="color: #800080;">1</span>) ^ kthGrammar(N - <span style="color: #800080;">1</span>, (K + <span style="color: #800080;">1</span>) / <span style="color: #800080;">2</span><span style="color: #000000;">);
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种解法的思路也十分巧妙，还是从变换规则入手，0换成了01，1换成了10。我们来看解法一讲解中的二叉树示例图中的蓝色路径，第四层K=6，第三层K=3，第二层K=2，第一层K=1，所以路径就是 6-&gt;3-&gt;2-&gt;1，如果我们换成0开头的计数方法，那么路径就是 5-&gt;2-&gt;1-&gt;0，再换成二进制的表达方式就是 101-&gt;10-&gt;1-&gt;0，我们发现其实就是每次右移一位，直到移动到0，而当最低位是1的时候，表示当前是右子结点，需要flip一下，那么只要我们知道总共flip了多少次，就能推算出第K个位置的值。比如 101-&gt;10-&gt;1-&gt;0，总共flip了两次变成了0，那么说明K=6的位置值为0。于是问题就转化为了统计K-1这个数的二进制表示中位1的个数，使用一个while循环统计出来就可以了，然后根据个数的奇偶性返回1或0即可，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> kthGrammar(<span style="color: #0000ff;">int</span> N, <span style="color: #0000ff;">int</span><span style="color: #000000;"> K) {
        </span><span style="color: #0000ff;">int</span> cnt = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span>--<span style="color: #000000;">K;
        </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> (K) {
            cnt </span>+= K &amp; <span style="color: #800080;">1</span><span style="color: #000000;">;
            K </span>&gt;&gt;= <span style="color: #800080;">1</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> cnt % <span style="color: #800080;">2</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种解法的思路也很清新脱俗啊，一切的一切都是从变换规则入手，0换成了01，1换成了10。那么当K是奇数的时候，我们之前分析了，其一定是左子结点，那么其是01或者10的第一个数字，因为只有这两种组合方式，所以如果第K个数是0的话，那么第K+1个数就是1，同样，如果第K个数是1的话，那么第K+1个数就是0，所以此时第K个数和第K+1个数一定相反，那么我们就可以通过‘亦或’1来实现这个一定相反的操作。</p>
<p>当K是偶数的时候，那么其是01或者10的第二个数字，那么根据之前的分析，其是由上一层的第 K/2 位置的数字生成的，上一层的第 K/2 个数字和当前层的第 K/2 个数字是一样的，如果你仔细观察题目中的例子或者博主画的那个二叉树图，只要K不越界，每一层的第K个数字都是相等的。所以如果第K个数是0的话，那么第 K/2 个数就是1，同样，如果第K个数是1的话，那么第 K/2 个数就是0，所以此时第K个数和第 K/2 个数一定相反，那么我们也可以通过‘亦或’1来实现这个一定相反的操作。</p>
<p>于是乎，我们的操作就是，当K是奇数的时候，我们就将其换成K+1，当K是偶数的时候，我们将其换为K/2。然后每次都对结果res（初始化为0）进行‘亦或’1操作，循环的终止条件是当K等于1时，参见代码如下：</p>
<p> </p>
<p>解法四：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> kthGrammar(<span style="color: #0000ff;">int</span> N, <span style="color: #0000ff;">int</span><span style="color: #000000;"> K) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (K &gt; <span style="color: #800080;">1</span><span style="color: #000000;">) {
            K </span>= (K % <span style="color: #800080;">2</span> == <span style="color: #800080;">1</span>) ? K + <span style="color: #800080;">1</span> : K / <span style="color: #800080;">2</span><span style="color: #000000;">;
            res </span>^= <span style="color: #800080;">1</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种解法跟解法三的思路完全相同，只不过使用了bitset这个内置的数据结构来快速的求出了K-1的二进制表达数中的位1的个数，Java中可以直接使用Integer.bitCount()函数，参见代码如下：</p>
<p> </p>
<p>解法五：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> kthGrammar(<span style="color: #0000ff;">int</span> N, <span style="color: #0000ff;">int</span><span style="color: #000000;"> K) {
        </span><span style="color: #0000ff;">return</span> bitset&lt;<span style="color: #800080;">32</span>&gt;(K - <span style="color: #800080;">1</span>).count() % <span style="color: #800080;">2</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-05-11 23:55</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=9027098" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(9027098);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/9017300.html" id="cb_post_title_url">[LeetCode] Swim in Rising Water 在上升的水中游泳</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>On an N x N <code>grid</code>, each square <code>grid[i][j]</code> represents the elevation at that point <code>(i,j)</code>.</p>
<p>Now rain starts to fall. At time <code>t</code>, the depth of the water everywhere is <code>t</code>. You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most <code>t</code>. You can swim infinite distance in zero time. Of course, you must stay within the boundaries of the grid during your swim.</p>
<p>You start at the top left square <code>(0, 0)</code>. What is the least time until you can reach the bottom right square <code>(N-1, N-1)</code>?</p>
<p>Example 1:</p>
<pre>Input: [[0,2],[1,3]]
Output: 3
Explanation:
At time <code>0</code>, you are in grid location <code>(0, 0)</code>.
You cannot go anywhere else because 4-directionally adjacent neighbors have a higher elevation than t = 0.

You cannot reach point <code>(1, 1)</code> until time <code>3</code>.
When the depth of water is <code>3</code>, we can swim anywhere inside the grid.
</pre>
<p>Example 2:</p>
<pre>Input: [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]
Output: 16
Explanation:
<strong> 0  1  2  3  4</strong>
24 23 22 21  <strong>5</strong>
<strong>12 13 14 15 16</strong>
<strong>11</strong> 17 18 19 20
<strong>10  9  8  7  6</strong>

The final route is marked in bold.
We need to wait until time 16 so that (0, 0) and (4, 4) are connected.
</pre>
<p>Note:</p>
<ol>
<li><code>2 &lt;= N &lt;= 50</code>.</li>
<li>grid[i][j] is a permutation of [0, ..., N*N - 1].</li>
</ol>
<p> </p>
<p>这道题给了我们一个二维数组，可以看作一个水池，这里不同数字的高度可以看作台阶的高度，只有当水面升高到台阶的高度时，我们才能到达该台阶，起始点在左上角位置，问我们水面最低升到啥高度就可以到达右下角的位置。这是一道蛮有意思的题目。对于这种类似迷宫遍历的题，一般都是DFS或者BFS。而如果有极值问题存在的时候，一般都是优先考虑BFS的，但是这道题比较特别，有一个上升水面的设定，我们可以想象一下，比如洪水爆发了，大坝垮了，那么愤怒汹涌的水流冲了出来，地势低洼处就会被淹没，而地势高的地方，比如山峰啥的，就会绕道而过。这里也是一样，随着水面不断的上升，低于水平面的地方就可以到达，直到水流到了右下角的位置停止。因为水流要向周围低洼处蔓延，所以BFS仍是一个不错的选择，由于水是向低洼处蔓延的，而低洼处的位置又是不定的，所以我们希望每次取出最低位置进行遍历，那么使用最小堆就是一个很好的选择，这样高度低的就会被先处理。在每次取出高度最小的数字时，我们用此高度来更新结果res，如果当前位置已经是右下角了，则我们直接返回结果res，否则就遍历当前位置的周围位置，如果未越界且未被访问过，则标记已经访问过，并且加入队列，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> swimInWater(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> grid) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, n =<span style="color: #000000;"> grid.size();
        unordered_set</span>&lt;<span style="color: #0000ff;">int</span>&gt; visited{<span style="color: #800080;">0</span><span style="color: #000000;">};
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; dirs{{<span style="color: #800080;">0</span>, -<span style="color: #800080;">1</span>}, {-<span style="color: #800080;">1</span>, <span style="color: #800080;">0</span>}, {<span style="color: #800080;">0</span>, <span style="color: #800080;">1</span>}, {<span style="color: #800080;">1</span>, <span style="color: #800080;">0</span><span style="color: #000000;">}};
        auto cmp </span>= [](pair&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;&amp; a, pair&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;&amp; b) {<span style="color: #0000ff;">return</span> a.first &gt;<span style="color: #000000;"> b.first;};
        priority_queue</span>&lt;pair&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;, vector&lt;pair&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;&gt;, decltype(cmp) &gt;<span style="color: #000000;"> q(cmp);
        q.push({grid[</span><span style="color: #800080;">0</span>][<span style="color: #800080;">0</span>], <span style="color: #800080;">0</span><span style="color: #000000;">});
        </span><span style="color: #0000ff;">while</span> (!<span style="color: #000000;">q.empty()) {
            </span><span style="color: #0000ff;">int</span> i = q.top().second / n, j = q.top().second %<span style="color: #000000;"> n; q.pop();
            res </span>=<span style="color: #000000;"> max(res, grid[i][j]);
            </span><span style="color: #0000ff;">if</span> (i == n - <span style="color: #800080;">1</span> &amp;&amp; j == n - <span style="color: #800080;">1</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
            </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto dir : dirs) {
                </span><span style="color: #0000ff;">int</span> x = i + dir[<span style="color: #800080;">0</span>], y = j + dir[<span style="color: #800080;">1</span><span style="color: #000000;">];
                </span><span style="color: #0000ff;">if</span> (x &lt; <span style="color: #800080;">0</span> || x &gt;= n || y &lt; <span style="color: #800080;">0</span> || y &gt;= n || visited.count(x * n + y)) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                visited.insert(x </span>* n +<span style="color: #000000;"> y);
                q.push({grid[x][y], x </span>* n +<span style="color: #000000;"> y});
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>我们也可以使用DP+DFS来做，这里使用一个二维dp数组，其中 dp[i][j] 表示到达 (i, j) 位置所需要的最低水面高度，均初始化为整型数最大值，我们的递归函数函数需要知道当前的位置 (x, y)，还有当前的水高cur，同时传入grid数组和需要不停更新的dp数组，如果当前位置越界了，或者是当前水高和 grid[x][y] 中的较大值大于等于 dp[x][y] 了，直接跳过，因为此时的dp值更小，不需要被更新了。否则 dp[x][y] 更新为较大值，然后对周围四个位置调用递归函数继续更新dp数组，最终返回右下位置的dp值即可，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; dirs{{<span style="color: #800080;">0</span>, -<span style="color: #800080;">1</span>}, {-<span style="color: #800080;">1</span>, <span style="color: #800080;">0</span>}, {<span style="color: #800080;">0</span>, <span style="color: #800080;">1</span>}, {<span style="color: #800080;">1</span>, <span style="color: #800080;">0</span><span style="color: #000000;">}};
    </span><span style="color: #0000ff;">int</span> swimInWater(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> grid) {
        </span><span style="color: #0000ff;">int</span> n =<span style="color: #000000;"> grid.size();
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; dp(n, vector&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;">(n, INT_MAX));
        helper(grid, </span><span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>, grid[<span style="color: #800080;">0</span>][<span style="color: #800080;">0</span><span style="color: #000000;">], dp);
        </span><span style="color: #0000ff;">return</span> dp[n - <span style="color: #800080;">1</span>][n - <span style="color: #800080;">1</span><span style="color: #000000;">];
    }
    </span><span style="color: #0000ff;">void</span> helper(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp; grid, <span style="color: #0000ff;">int</span> x, <span style="color: #0000ff;">int</span> y, <span style="color: #0000ff;">int</span> cur, vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> dp) {
        </span><span style="color: #0000ff;">int</span> n =<span style="color: #000000;"> grid.size();
        </span><span style="color: #0000ff;">if</span> (x &lt; <span style="color: #800080;">0</span> || x &gt;= n || y &lt; <span style="color: #800080;">0</span> || y &gt;= n || max(cur, grid[x][y]) &gt;= dp[x][y]) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
        dp[x][y] </span>=<span style="color: #000000;"> max(cur, grid[x][y]);
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto dir : dirs) {
            helper(grid, x </span>+ dir[<span style="color: #800080;">0</span>], y + dir[<span style="color: #800080;">1</span><span style="color: #000000;">], dp[x][y], dp);
        }
    }
};</span></pre>
</div>
<p> </p>
<p>其实这道题还可以使用二分搜索法来做，属于博主的总结帖中<a class="entrylistItemTitle" href="http://www.cnblogs.com/grandyang/p/6854825.html" id="CategoryEntryList1_EntryStoryList_ctl00_Entries_TitleUrl_1">LeetCode Binary Search Summary 二分搜索法小结</a>的第四类，用子函数当作判断关系。由于题目中给定了数字的范围，那么二分搜索法的左右边界就有了，然后我们计算一个中间值mid，调用子函数来看这个水面高度下能否到达右下角，如果不能的话，说明水面高度不够，则 left = mid+1，如果能到达的话，有可能水面高度过高了，则right = mid，最终会到达的临界点就是能到达右下角的最低水面高度。那么来看子函数怎么写，其实就是个迷宫遍历问题，我们可以使用BFS或者DFS，这里使用了stack辅助的迭代形式的DFS来遍历，当然我们也可以使用queue辅助的迭代形式的BFS来遍历，都一样，如果在mid的水面高度下，遍历到了右下角，则返回true，否则返回false，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> swimInWater(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> grid) {
        </span><span style="color: #0000ff;">int</span> n =<span style="color: #000000;"> grid.size();
        </span><span style="color: #0000ff;">int</span> left = grid[<span style="color: #800080;">0</span>][<span style="color: #800080;">0</span>], right = n *<span style="color: #000000;"> n;
        </span><span style="color: #0000ff;">while</span> (left &lt;<span style="color: #000000;"> right) {
            </span><span style="color: #0000ff;">int</span> mid = left + (right - left) / <span style="color: #800080;">2</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> (!helper(grid, mid)) left = mid + <span style="color: #800080;">1</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">else</span> right =<span style="color: #000000;"> mid;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> left;
    }
    </span><span style="color: #0000ff;">bool</span> helper(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp; grid, <span style="color: #0000ff;">int</span><span style="color: #000000;"> mid) {
        </span><span style="color: #0000ff;">int</span> n =<span style="color: #000000;"> grid.size();
        unordered_set</span>&lt;<span style="color: #0000ff;">int</span>&gt; visited{<span style="color: #800080;">0</span><span style="color: #000000;">};
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; dirs{{<span style="color: #800080;">0</span>, -<span style="color: #800080;">1</span>}, {-<span style="color: #800080;">1</span>, <span style="color: #800080;">0</span>}, {<span style="color: #800080;">0</span>, <span style="color: #800080;">1</span>}, {<span style="color: #800080;">1</span>, <span style="color: #800080;">0</span><span style="color: #000000;">}};
        stack</span>&lt;<span style="color: #0000ff;">int</span>&gt; st{{<span style="color: #800080;">0</span><span style="color: #000000;">}};
        </span><span style="color: #0000ff;">while</span> (!<span style="color: #000000;">st.empty()) {
            </span><span style="color: #0000ff;">int</span> i = st.top() / n, j = st.top() %<span style="color: #000000;"> n; st.pop();
            </span><span style="color: #0000ff;">if</span> (i == n - <span style="color: #800080;">1</span> &amp;&amp; j == n - <span style="color: #800080;">1</span>) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto dir : dirs) {
                </span><span style="color: #0000ff;">int</span> x = i + dir[<span style="color: #800080;">0</span>], y = j + dir[<span style="color: #800080;">1</span><span style="color: #000000;">];
                </span><span style="color: #0000ff;">if</span> (x &lt; <span style="color: #800080;">0</span> || x &gt;= n || y &lt; <span style="color: #800080;">0</span> || y &gt;= n || visited.count(x * n + y) || grid[x][y] &gt; mid) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                st.push(x </span>* n +<span style="color: #000000;"> y);
                visited.insert(x </span>* n +<span style="color: #000000;"> y);
            }
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-05-09 23:26</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=9017300" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(9017300);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/9001474.html" id="cb_post_title_url">[LeetCode] Swap Adjacent in LR String 交换LR字符串中的相邻项</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>In a string composed of <code>'L'</code>, <code>'R'</code>, and <code>'X'</code> characters, like <code>"RXXLRXRXL"</code>, a move consists of either replacing one occurrence of <code>"XL"</code> with <code>"LX"</code>, or replacing one occurrence of <code>"RX"</code> with <code>"XR"</code>. Given the starting string <code>start</code> and the ending string <code>end</code>, return <code>True</code> if and only if there exists a sequence of moves to transform one string to the other.</p>
<p>Example:</p>
<pre>Input: start = "RXXLRXRXL", end = "XRLXXRRLX"
Output: True
Explanation:
We can transform start to end following these steps:
RXXLRXRXL -&gt;
XRXLRXRXL -&gt;
XRLXRXRXL -&gt;
XRLXXRRXL -&gt;
XRLXXRRLX
</pre>
<p>Note:</p>
<ol>
<li><code>1 &lt;= len(start) = len(end) &lt;= 10000</code>.</li>
<li>Both start and end will only consist of characters in <code>{'L', 'R', 'X'}</code>.</li>
</ol>
<p> </p>
<p>这道题给了我们一个只含有L，R，X三个字符的字符串，然后说有两种操作，一种是把 "XL" 变成 "LX"，另一种是把 "RX" 变成 "XR"。博主刚开始没有读题意，以为二者是可以互换的，错误的认为认为 "LX" 也能变成 "XL"，其实题目这种变换是单向，这种单向关系就是解题的关键，具体来说，就是要把start字符串变成end字符串的话，L只能往前移动，因为是把 "XL" 变成 "LX"，同样，R只能往后移动，因为是把 "RX" 变成 "XR"。题目给的那个例子并不能很好的说明问题，博主之前那种双向变换的错误认知会跪在这个例子：</p>
<p>start = "XX<span style="color: #ff0000;">R</span>XX<span style="color: #339966;">L</span>XXXX"<br/>end  = "XXXX<span style="color: #ff0000;">R</span>XX<span style="color: #339966;">L</span>XX"</p>
<p>我们观察这个test case，可以发现start中的R可以往后移动，没有问题，但是start中的L永远无法变到end中L的位置，因为L只能往前移。这道题被归类为brainteaser，估计就是因为要观察出这个规律吧。那么搞明白这个以后，我们其实可以用双指针来解题，思路是，我们每次分别找到start和end中非X的字符，如果二者不相同的话，直接返回false，想想问什么？这是因为不论是L还是R，其只能跟X交换位置，L和R之间是不能改变相对顺序的，所以如果分别将start和end中所有的X去掉后的字符串不相等的话，那么就永远无法让start和end相等了。这个判断完之后，就来验证L只能前移，R只能后移这个限制条件吧，当i指向start中的L时，那么j指向end中的L必须要在前面，所以如果i小于j的话，就不对了，同理，当i指向start中的R，那么j指向end中的R必须在后面，所以i大于j就是错的，最后别忘了i和j同时要自增1，不然死循环了，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> canTransform(<span style="color: #0000ff;">string</span> start, <span style="color: #0000ff;">string</span><span style="color: #000000;"> end) {
        </span><span style="color: #0000ff;">int</span> n = start.size(), i = <span style="color: #800080;">0</span>, j = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (i &lt; n &amp;&amp; j &lt;<span style="color: #000000;"> n) {
            </span><span style="color: #0000ff;">while</span> (i &lt; n &amp;&amp; start[i] == <span style="color: #800000;">'</span><span style="color: #800000;">X</span><span style="color: #800000;">'</span>) ++<span style="color: #000000;">i;
            </span><span style="color: #0000ff;">while</span> (j &lt; n &amp;&amp; end[j] == <span style="color: #800000;">'</span><span style="color: #800000;">X</span><span style="color: #800000;">'</span>) ++<span style="color: #000000;">j;
            </span><span style="color: #0000ff;">if</span> (start[i] != end[j]) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> ((start[i] == <span style="color: #800000;">'</span><span style="color: #800000;">L</span><span style="color: #800000;">'</span> &amp;&amp; i &lt; j) || (start[i] == <span style="color: #800000;">'</span><span style="color: #800000;">R</span><span style="color: #800000;">'</span> &amp;&amp; i &gt; j)) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            </span>++i; ++<span style="color: #000000;">j;
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种解法也挺巧妙的，这里我们使用两个计数器cntL和cntR，分别来统计L和R出现的次数，统计方法时，start中出现了L或R，计数器自增1，end中出现了L或R，计数器自减1。注意我们检测的顺序很重要，由于start中的R必须在end中的R前面，所以我们要先检测start中的R，同理，由于end中的L必须要在start中的L前面，所以我们要先检测end中的L，那么四个if写完后，如果cntL或者cntR中有任何一个小于0了，说明限制条件被打破了，返回false，或者当二者都大于0的时候，说明此时不匹配了，参见上面解法中对于去掉所有的X的解释，一个道理，说明L和R的相对顺序不同了，那么也是false。最终for循环退出后，如果cntL和cntR均为0的时候，才返回true，否则就是false，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> canTransform(<span style="color: #0000ff;">string</span> start, <span style="color: #0000ff;">string</span><span style="color: #000000;"> end) {
        </span><span style="color: #0000ff;">int</span> n = start.size(), cntL = <span style="color: #800080;">0</span>, cntR = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (start[i] == <span style="color: #800000;">'</span><span style="color: #800000;">R</span><span style="color: #800000;">'</span>) ++<span style="color: #000000;">cntR;
            </span><span style="color: #0000ff;">if</span> (end[i] == <span style="color: #800000;">'</span><span style="color: #800000;">L</span><span style="color: #800000;">'</span>) ++<span style="color: #000000;">cntL;
            </span><span style="color: #0000ff;">if</span> (start[i] == <span style="color: #800000;">'</span><span style="color: #800000;">L</span><span style="color: #800000;">'</span>) --<span style="color: #000000;">cntL;
            </span><span style="color: #0000ff;">if</span> (end[i] == <span style="color: #800000;">'</span><span style="color: #800000;">R</span><span style="color: #800000;">'</span>) --<span style="color: #000000;">cntR;
            </span><span style="color: #0000ff;">if</span> (cntL &lt; <span style="color: #800080;">0</span> || cntR &lt; <span style="color: #800080;">0</span> || cntL * cntR != <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> cntL == <span style="color: #800080;">0</span> &amp;&amp; cntR == <span style="color: #800080;">0</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-05-07 10:54</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=9001474" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(9001474);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/8993143.html" id="cb_post_title_url">[LeetCode] Split BST 分割二叉搜索树</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a Binary Search Tree (BST) with root node <code>root</code>, and a target value <code>V</code>, split the tree into two subtrees where one subtree has nodes that are all smaller or equal to the target value, while the other subtree has all nodes that are greater than the target value.  It's not necessarily the case that the tree contains a node with value <code>V</code>.</p>
<p>Additionally, most of the structure of the original tree should remain.  Formally, for any child C with parent P in the original tree, if they are both in the same subtree after the split, then node C should still have the parent P.</p>
<p>You should output the root TreeNode of both subtrees after splitting, in any order.</p>
<p>Example 1:</p>
<pre>Input: root = [4,2,6,1,3,5,7], V = 2
Output: [[2,1],[4,3,6,null,null,5,7]]
Explanation:
Note that root, output[0], and output[1] are TreeNode objects, not arrays.

The given tree [4,2,6,1,3,5,7] is represented by the following diagram:

          4
        /   \
      2      6
     / \    / \
    1   3  5   7

while the diagrams for the outputs are:

          4
        /   \
      3      6      and    2
            / \           /
           5   7         1
</pre>
<p>Note:</p>
<ol>
<li>The size of the BST will not exceed <code>50</code>.</li>
<li>The BST is always valid and each node's value is different.</li>
</ol>
<p> </p>
<p><img alt="" height="304" src="https://images2018.cnblogs.com/blog/391947/201805/391947-20180507061018472-1251965735.png" width="486"/></p>
<p> </p>
<p>比如对于上图，假如root结点小于V，而root.right大于V的话，那么这条边是要断开的，但是如果root.right的左子结点（结点A）是小于V的，那么其边也应该断开，如果如果root.right的左子结点的右子结点（结点B）大于V，则这条边也应该断开，所以总共有三条边需要断开，如图中蓝色虚线所示，三条粗灰边需要断开，粉细边和绿细边是需要重新连上的边。那么我们应该如何知道连上哪条边呢？不要急，听博主慢慢道来。</p>
<p>博主告诉你们个秘密（一般人我不告诉他），对于树的题目，二话别说，直接上递归啊，除非是有啥特别要求，否则递归都可以解。而递归的精髓就是不断的DFS进入递归函数，直到递归到叶结点，然后回溯，我们递归函数的返回值是两个子树的根结点，比如对结点A调用递归，返回的第一个是A的左子结点，第二个是结点B，这个不需要重新连接，那么当回溯到root.right的时候，我们就需要让root.right结点连接上结点B，而这个结点B是对结点A调用递归的返回值中的第二个。如果是在左边，其实是对称的，root.left连接上调用递归返回值中的第一个，这两个想通了后，代码就不难谢啦，参见代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;TreeNode*&gt; splitBST(TreeNode* root, <span style="color: #0000ff;">int</span><span style="color: #000000;"> V) {
        vector</span>&lt;TreeNode*&gt;<span style="color: #000000;"> res{NULL, NULL};
        </span><span style="color: #0000ff;">if</span> (!root) <span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">if</span> (root-&gt;val &lt;=<span style="color: #000000;"> V) {
            res </span>= splitBST(root-&gt;<span style="color: #000000;">right, V);
            root</span>-&gt;right = res[<span style="color: #800080;">0</span><span style="color: #000000;">];
            res[</span><span style="color: #800080;">0</span>] =<span style="color: #000000;"> root;
        } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            res </span>= splitBST(root-&gt;<span style="color: #000000;">left, V);
            root</span>-&gt;left = res[<span style="color: #800080;">1</span><span style="color: #000000;">];
            res[</span><span style="color: #800080;">1</span>] =<span style="color: #000000;"> root;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/6228252.html">Delete Node in a BST</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-05-04 23:40</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=8993143" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(8993143);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/8983098.html" id="cb_post_title_url">[LeetCode] Global and Local Inversions 全局与局部的倒置</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>We have some permutation <code>A</code> of <code>[0, 1, ..., N - 1]</code>, where <code>N</code> is the length of <code>A</code>.</p>
<p>The number of (global) inversions is the number of <code>i &lt; j</code> with <code>0 &lt;= i &lt; j &lt; N</code> and <code>A[i] &gt; A[j]</code>.</p>
<p>The number of local inversions is the number of <code>i</code> with <code>0 &lt;= i &lt; N</code> and <code>A[i] &gt; A[i+1]</code>.</p>
<p>Return <code>true</code> if and only if the number of global inversions is equal to the number of local inversions.</p>
<p>Example 1:</p>
<pre>Input: A = [1,0,2]
Output: true
Explanation: There is 1 global inversion, and 1 local inversion.
</pre>
<p>Example 2:</p>
<pre>Input: A = [1,2,0]
Output: false
Explanation: There are 2 global inversions, and 1 local inversion.
</pre>
<p>Note:</p>
<ul>
<li><code>A</code> will be a permutation of <code>[0, 1, ..., A.length - 1]</code>.</li>
<li><code>A</code> will have length in range <code>[1, 5000]</code>.</li>
<li>The time limit for this problem has been reduced.</li>
</ul>
<p> </p>
<p>这道题给了一个长度为n的数组，里面是0到n-1数字的任意排序。又定义了两种倒置方法，全局倒置和局部倒置。其中全局倒置说的是坐标小的值大，局部倒置说的是相邻的两个数，坐标小的值大。那么我们可以发现，其实局部倒置是全局倒置的一种特殊情况，即局部倒置一定是全局倒置，而全局倒置不一定是局部倒置，这是解这道题的关键点。题目让我们判断该数组的全局倒置和局部倒置的个数是否相同，那么我们想，什么情况下会不相同？如果所有的倒置都是局部倒置，那么由于局部倒置一定是全局倒置，则二者个数一定相等。如果出现某个全局倒置不是局部倒置的情况，那么二者的个数一定不会相等。所以问题的焦点就变成了是否能找出不是局部倒置的全局倒置。所以为了和局部倒置区别开来，我们不能比较相邻的两个，而是至少要隔一个来比较。我们可以从后往前遍历数组，遍历到第三个数字停止，然后维护一个 [i, n-1] 范围内的最小值，每次和 A[i - 2] 比较，如果小于 A[i - 2]，说明这是个全局的倒置，并且不是局部倒置，那么我们直接返回false即可，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> isIdealPermutation(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> A) {
        </span><span style="color: #0000ff;">int</span> n = A.size(), mn =<span style="color: #000000;"> INT_MAX;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = n - <span style="color: #800080;">1</span>; i &gt;= <span style="color: #800080;">2</span>; --<span style="color: #000000;">i) {
            mn </span>=<span style="color: #000000;"> min(mn, A[i]);
            </span><span style="color: #0000ff;">if</span> (A[i - <span style="color: #800080;">2</span>] &gt; mn) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>同理，我们可以反其道行之，我们可以从前往后遍历数组，遍历到倒数第三个数字停止，然后维护一个 [0, i] 范围内的最大值，每次和 A[i + 2] 比较，如果大于 A[i + 2]，说明这是个全局的倒置，并且不是局部倒置，那么我们直接返回false即可，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> isIdealPermutation(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> A) {
        </span><span style="color: #0000ff;">int</span> n = A.size(), mx =<span style="color: #000000;"> INT_MIN;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n - <span style="color: #800080;">2</span>; ++<span style="color: #000000;">i) {
            mx </span>=<span style="color: #000000;"> max(mx, A[i]);
            </span><span style="color: #0000ff;">if</span> (A[i + <span style="color: #800080;">2</span>] &lt; mx) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> isIdealPermutation(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> A) {
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; A.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (abs(A[i] - i) &gt; <span style="color: #800080;">1</span>) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-05-02 23:07</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=8983098" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(8983098);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/8970057.html" id="cb_post_title_url">[LeetCode] Minimize Max Distance to Gas Station 最小化去加油站的最大距离</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="question-description">
<div>
<p>On a horizontal number line, we have gas stations at positions <code>stations[0], stations[1], ..., stations[N-1]</code>, where <code>N = stations.length</code>.</p>
<p>Now, we add <code>K</code> more gas stations so that D, the maximum distance between adjacent gas stations, is minimized.</p>
<p>Return the smallest possible value of D.</p>
<p>Example:</p>
<pre>Input: stations = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], K = 9
Output: 0.500000
</pre>
<p>Note:</p>
<ol>
<li><code>stations.length</code> will be an integer in range <code>[10, 2000]</code>.</li>
<li><code>stations[i]</code> will be an integer in range <code>[0, 10^8]</code>.</li>
<li><code>K</code> will be an integer in range <code>[1, 10^6]</code>.</li>
<li>Answers within <code>10^-6</code> of the true value will be accepted as correct.</li>
</ol></div>
</div>
<p> </p>
<p>这道题说给了我们n个加油站，两两之间相距不同的距离，然后我们可以在任意地方新加K个加油站，问能使得任意两个加油站之间的最大距离的最小值是多少。乍眼一看，感觉很绕，一会儿最大，一会儿最小的。其实我们可以换个场景，比如n个人站一队，每两个人之间距离不同，有的人之间距离可能很大，有的人可能挨得很近。我们现在需要再加入K个人到队列中，我们希望人与人之间的距离尽可能小，所以新人就应该加入到距离大的地方，然后问我们加入K个人后，求人与人之间的最大距离。这么一说，是不是清晰一点了呢。博主最开始看到这个加油站的题，以为跟之前那道<a href="http://www.cnblogs.com/grandyang/p/4266812.html" target="_blank">Gas Station</a>有关联，结果发现二者并没有什么关系，只不过公用了加油站这个场景而已。对于这道题，我们还是抽离出本质，就是数组插数问题。博主最先考虑的是用贪婪算法，就是先算出每两个数字之间的距离，然后我们每次往距离最大的那两个数字之间插入一个数字，这种想法看似正确，但是会跪在这样一个test case：</p>
<p>[10, 19, 25, 27, 56, 63, 70, 87, 96, 97]，K = 3</p>
<p>其两两之间的距离为：</p>
<p>9，6，2，29，7，7，17，9，1</p>
<p>如果按照博主前面所说的方法，会先将29分开，变成两个14.5，然后会将17分开，变成两个8.5，还剩一个加油站，会将其中一个14.5分开，变成两个7.25。但是这样弄下来，最大的距离还是14.5，而实际上我们有更好的办法，我们用两个加油站将29三等分，会变成三个9.67，然后用剩下的一个去分17，得到两个8.5，此时最大距离就变成了9.67，这才是最优的解法。这说明了博主那种图样图森破的贪婪算法并不work，缺乏对Hard题目的尊重。</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">double</span> minmaxGasDist(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; stations, <span style="color: #0000ff;">int</span><span style="color: #000000;"> K) {
        </span><span style="color: #0000ff;">double</span> left = <span style="color: #800080;">0</span>, right =<span style="color: #000000;"> 1e8;
        </span><span style="color: #0000ff;">while</span> (right - left &gt; 1e-<span style="color: #800080;">6</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">double</span> mid = left + (right - left) / <span style="color: #800080;">2</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> (helper(stations, K, mid)) right =<span style="color: #000000;"> mid;
            </span><span style="color: #0000ff;">else</span> left =<span style="color: #000000;"> mid;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> left;
    }
    </span><span style="color: #0000ff;">bool</span> helper(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; stations, <span style="color: #0000ff;">int</span> K, <span style="color: #0000ff;">double</span><span style="color: #000000;"> mid) {
        </span><span style="color: #0000ff;">int</span> cnt = <span style="color: #800080;">0</span>, n =<span style="color: #000000;"> stations.size();
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n - <span style="color: #800080;">1</span>; ++<span style="color: #000000;">i) {
            cnt </span>+= (stations[i + <span style="color: #800080;">1</span>] - stations[i]) /<span style="color: #000000;"> mid;
        }
        </span><span style="color: #0000ff;">return</span> cnt &lt;=<span style="color: #000000;"> K;
    }
};</span></pre>
</div>
<p> </p>
<p>我们也可以把上面解法中的子函数揉到主函数里面，这样可以是的代码更加的简洁，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">double</span> minmaxGasDist(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; stations, <span style="color: #0000ff;">int</span><span style="color: #000000;"> K) {
        </span><span style="color: #0000ff;">double</span> left = <span style="color: #800080;">0</span>, right =<span style="color: #000000;"> 1e8;
        </span><span style="color: #0000ff;">while</span> (right - left &gt; 1e-<span style="color: #800080;">6</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">double</span> mid = left + (right - left) / <span style="color: #800080;">2</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">int</span> cnt = <span style="color: #800080;">0</span>, n =<span style="color: #000000;"> stations.size();
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n - <span style="color: #800080;">1</span>; ++<span style="color: #000000;">i) {
                cnt </span>+= (stations[i + <span style="color: #800080;">1</span>] - stations[i]) /<span style="color: #000000;"> mid;
            }
            </span><span style="color: #0000ff;">if</span> (cnt &lt;= K) right =<span style="color: #000000;"> mid;
            </span><span style="color: #0000ff;">else</span> left =<span style="color: #000000;"> mid;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> left;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/8627783.html" target="_blank">Find K-th Smallest Pair Distance</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/8367505.html" target="_blank">Kth Smallest Number in Multiplication Table</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/8021421.html" target="_blank">Maximum Average Subarray II</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/5727892.html">Kth Smallest Element in a Sorted Matrix</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-04-28 23:59</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=8970057" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(8970057);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/8955735.html" id="cb_post_title_url">[LeetCode] Sliding Puzzle 滑动拼图</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>On a 2x3 <code>board</code>, there are 5 tiles represented by the integers 1 through 5, and an empty square represented by 0.</p>
<p>A move consists of choosing <code>0</code> and a 4-directionally adjacent number and swapping it.</p>
<p>The state of the board is <em>solved</em> if and only if the <code>board</code> is <code>[[1,2,3],[4,5,0]].</code></p>
<p>Given a puzzle board, return the least number of moves required so that the state of the board is solved. If it is impossible for the state of the board to be solved, return -1.</p>
<p>Examples:</p>
<pre>Input: board = [[1,2,3],[4,0,5]]
Output: 1
Explanation: Swap the 0 and the 5 in one move.
</pre>
<pre>Input: board = [[1,2,3],[5,4,0]]
Output: -1
Explanation: No number of moves will make the board solved.
</pre>
<pre>Input: board = [[4,1,2],[5,0,3]]
Output: 5
Explanation: 5 is the smallest number of moves that solves the board.
An example path:
After move 0: [[4,1,2],[5,0,3]]
After move 1: [[4,1,2],[0,5,3]]
After move 2: [[0,1,2],[4,5,3]]
After move 3: [[1,0,2],[4,5,3]]
After move 4: [[1,2,0],[4,5,3]]
After move 5: [[1,2,3],[4,5,0]]
</pre>
<pre>Input: board = [[3,2,4],[1,5,0]]
Output: 14
</pre>
<p>Note:</p>
<ul>
<li><code>board</code> will be a 2 x 3 array as described above.</li>
<li><code>board[i][j]</code> will be a permutation of <code>[0, 1, 2, 3, 4, 5]</code>.</li>
</ul>
<p> </p>
<p>看到这道题不禁让博主想起了文曲星上的游戏-华容道，好吧，又暴露年龄了|||-.-，貌似文曲星这种电子辞典神马的已经是很古老的东西了，但是上面的一些经典游戏，什么英雄坛说啊，华容道啊，虽然像素分辨率低的可怜，画面效果连小霸王学习机其乐无穷都比不上，更不要说跟现在的什么撸啊撸，吃鸡之类的画面相比了，但是却给初高中时代的博主学习之余带来了无限的乐趣。不过这题跟华容道还是有些不同的，因为那个游戏各块的大小不同，而这道题的拼图大小都是一样的。那么像这种类似迷宫遍历的问题，又要求最小值的问题，要有强烈的BFS的感觉，没错，这道题正是用BFS来解的。这道题好就好在限定了棋盘的大小，是2x3的，这就让题目简单了许多，由于0的位置只有6个，我们可以列举出所有其下一步可能移动到的位置。为了知道每次移动后拼图是否已经恢复了正确的位置，我们肯定需要用个常量表示出正确位置以作为比较，那么对于这个正确的位置，我们还用二维数组表示吗？也不是不行，但我们可以更加简洁一些，就用一个字符串 "123450"来表示就行了，注意这里我们是把第二行直接拼接到第一行后面的，数字3和4起始并不是相连的。好，下面来看0在不同位置上能去的地方，字符串长度为6，则其坐标为 012345，转回二维数组为：</p>
<div class="cnblogs_code">
<pre><span style="color: #800080;">0</span>  <span style="color: #800080;">1</span>  <span style="color: #800080;">2</span>
<span style="color: #800080;">3</span>  <span style="color: #800080;">4</span>  <span style="color: #800080;">5</span></pre>
</div>
<p>那么当0在位置0时，其可以移动到右边和下边，即{1, 3}位置；在位置1时，其可以移动到左边，右边和下边，即{0, 2, 4}位置；在位置2时，其可以移动到左边和下边，即{1, 5}位置；在位置3时，其可以移动到上边和右边，即{0, 4}位置；在位置4时，其可以移动到左边，右边和上边，即{1, 3, 5}位置；在位置5时，其可以移动到上边和左边，即{2, 4}位置。</p>
<p>然后就是标准的BFS的流程了，使用一个HashSet来记录访问过的状态，将初始状态start放入，使用一个queue开始遍历，将初始状态start放入。然后就是按层遍历，取出队首状态，先和target比较，相同就直接返回步数，否则就找出当前状态中0的位置，到dirs中去找下一个能去的位置，赋值一个临时变量cand，去交换0和其下一个位置，生成一个新的状态，如果这个状态不在visited中，则加入visited，并且压入队列queue，步数自增1。如果while循环退出后都没有回到正确状态，则返回-1，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> slidingPuzzle(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> board) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, m = board.size(), n = board[<span style="color: #800080;">0</span><span style="color: #000000;">].size();
        </span><span style="color: #0000ff;">string</span> target = <span style="color: #800000;">"</span><span style="color: #800000;">123450</span><span style="color: #800000;">"</span>, start = <span style="color: #800000;">""</span><span style="color: #000000;">;
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; dirs{{<span style="color: #800080;">1</span>,<span style="color: #800080;">3</span>}, {<span style="color: #800080;">0</span>,<span style="color: #800080;">2</span>,<span style="color: #800080;">4</span>}, {<span style="color: #800080;">1</span>,<span style="color: #800080;">5</span>}, {<span style="color: #800080;">0</span>,<span style="color: #800080;">4</span>}, {<span style="color: #800080;">1</span>,<span style="color: #800080;">3</span>,<span style="color: #800080;">5</span>}, {<span style="color: #800080;">2</span>,<span style="color: #800080;">4</span><span style="color: #000000;">}};
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; m; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; n; ++<span style="color: #000000;">j) {
                start </span>+=<span style="color: #000000;"> to_string(board[i][j]);
            }
        }
        unordered_set</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> visited{start};
        queue</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> q{{start}};
        </span><span style="color: #0000ff;">while</span> (!<span style="color: #000000;">q.empty()) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = q.size() - <span style="color: #800080;">1</span>; i &gt;= <span style="color: #800080;">0</span>; --<span style="color: #000000;">i) {
                </span><span style="color: #0000ff;">string</span> cur =<span style="color: #000000;"> q.front(); q.pop();
                </span><span style="color: #0000ff;">if</span> (cur == target) <span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
                </span><span style="color: #0000ff;">int</span> zero_idx = cur.find(<span style="color: #800000;">"</span><span style="color: #800000;">0</span><span style="color: #800000;">"</span><span style="color: #000000;">);
                </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span><span style="color: #000000;"> dir : dirs[zero_idx]) {
                    </span><span style="color: #0000ff;">string</span> cand =<span style="color: #000000;"> cur;
                    swap(cand[dir], cand[zero_idx]);
                    </span><span style="color: #0000ff;">if</span> (visited.count(cand)) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                    visited.insert(cand);
                    q.push(cand);
                }
            }
            </span>++<span style="color: #000000;">res;
        }
        </span><span style="color: #0000ff;">return</span> -<span style="color: #800080;">1</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>上面的解法虽然很炫，但是有局限性，比如若棋盘很大的话，难道我们还手动列出所有0能去的位置么？其实我们可以使用最普通的BFS遍历方式，就检查上下左右四个方向，那么这样我们就不能压缩二维数组成一个字符串了，我们visited数组中只能放二维数组了，同样的，queue 中也只能放二维数组，由于二维数组要找0的位置的话，还需要遍历，为了节省遍历时间，我们将0的位置也放入queue中，那么queue中的放的就是一个pair对儿，保存当前状态，已经0的位置，初始时将棋盘以及0的位置排入queue中。之后的操作就跟之前的解法没啥区别了，只不过这里我们的心位置就是上下左右，如果未越界的话，那么和0交换位置，看新状态是否已经出现过，如果这个状态不在visited中，则加入visited，并且压入队列queue，步数自增1。如果while循环退出后都没有回到正确状态，则返回-1，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> slidingPuzzle(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> board) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">set</span>&lt;vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&gt;<span style="color: #000000;"> visited;
        queue</span>&lt;pair&lt;vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;, vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&gt;<span style="color: #000000;"> q;
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; correct{{<span style="color: #800080;">1</span>, <span style="color: #800080;">2</span>, <span style="color: #800080;">3</span>}, {<span style="color: #800080;">4</span>, <span style="color: #800080;">5</span>, <span style="color: #800080;">0</span><span style="color: #000000;">}};
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; dirs{{<span style="color: #800080;">0</span>, -<span style="color: #800080;">1</span>}, {-<span style="color: #800080;">1</span>, <span style="color: #800080;">0</span>}, {<span style="color: #800080;">0</span>, <span style="color: #800080;">1</span>}, {<span style="color: #800080;">1</span>, <span style="color: #800080;">0</span><span style="color: #000000;">}};
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; <span style="color: #800080;">2</span>; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; <span style="color: #800080;">3</span>; ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> (board[i][j] == <span style="color: #800080;">0</span><span style="color: #000000;">) q.push({board, {i, j}});
            }
        }
        </span><span style="color: #0000ff;">while</span> (!<span style="color: #000000;">q.empty()) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = q.size() - <span style="color: #800080;">1</span>; i &gt;= <span style="color: #800080;">0</span>; --<span style="color: #000000;">i) {
                auto t </span>=<span style="color: #000000;"> q.front().first; 
                auto zero </span>=<span style="color: #000000;"> q.front().second; q.pop();
                </span><span style="color: #0000ff;">if</span> (t == correct) <span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
                visited.insert(t);
                </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto dir : dirs) {
                    </span><span style="color: #0000ff;">int</span> x = zero[<span style="color: #800080;">0</span>] + dir[<span style="color: #800080;">0</span>], y = zero[<span style="color: #800080;">1</span>] + dir[<span style="color: #800080;">1</span><span style="color: #000000;">];
                    </span><span style="color: #0000ff;">if</span> (x &lt; <span style="color: #800080;">0</span> || x &gt;= <span style="color: #800080;">2</span> || y &lt; <span style="color: #800080;">0</span> || y &gt;= <span style="color: #800080;">3</span>) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                    vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; cand =<span style="color: #000000;"> t;
                    swap(cand[zero[</span><span style="color: #800080;">0</span>]][zero[<span style="color: #800080;">1</span><span style="color: #000000;">]], cand[x][y]);
                    </span><span style="color: #0000ff;">if</span> (visited.count(cand)) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                    q.push({cand, {x, y}});
                }
            }
            </span>++<span style="color: #000000;">res;
        }
        </span><span style="color: #0000ff;">return</span> -<span style="color: #800080;">1</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-04-26 23:31</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=8955735" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(8955735);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/8873471.html" id="cb_post_title_url">[LeetCode] Basic Calculator III 基本计算器之三</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Implement a basic calculator to evaluate a simple expression string.</p>
<p>The expression string may contain open <code>(</code> and closing parentheses <code>)</code>, the plus <code>+</code> or minus sign <code>-</code>, non-negative integers and empty spaces <code></code>.</p>
<p>The expression string contains only non-negative integers, <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> operators , open <code>(</code> and closing parentheses <code>)</code> and empty spaces <code></code>. The integer division should truncate toward zero.</p>
<p>You may assume that the given expression is always valid. All intermediate results will be in the range of <code>[-2147483648, 2147483647]</code>.</p>
<p>Some examples:</p>
<pre>"1 + 1" = 2
" 6-4 / 2 " = 4
"2*(5+5*2)/3+(6/2+8)" = 21
"(2+6* 3+5- (3*14/7+2)*5)+3"=-12
</pre>
<p> </p>
<p>Note: Do not use the <code>eval</code> built-in library function.</p>
<p> </p>
<p>这道题是基本计算器系列的第三道，前两道分别为<a href="http://www.cnblogs.com/grandyang/p/4570699.html" target="_blank">Basic Calculator</a>和<a href="http://www.cnblogs.com/grandyang/p/4601208.html" target="_blank">Basic Calculator II</a>，区别是，第一道只有加减法跟括号，第二道只有加减乘除法，而这第三道既有加减乘除法又有括号运算。其实做过前两道题的话，那么这道题也就没什么问题，因为把前两道题的解法综合一下就是这道题的解法啦。由于此题既有括号，又有乘除法，我们知道括号是优先级最高的，但是好就好在我们可以将括号里的内容当作一个整体调用递归函数来处理。而其他部分，就跟第二道一模一样了。我们还是分情况来处理遍历，我们需要几个变量，num表示当前的数字，curRes表示当前的结果，res为最终的结果，op为操作符号，初始化为'+'。当遇到数字的时候，我们将num自乘以10并加上这个数字，这是由于可能遇到多位数，所以每次要乘以10。当遇到括号的时候，这里就有一个小trick，由于表示可能会有括号嵌套括号，所以我们如果搜索右括号的话，就有可能使得括号没有正确的匹配上，所以我们用一个变量cnt，遇到左括号自增1，遇到右括号自减1，当cnt为0的时候，说明括号正好完全匹配，这个trick在验证括号是否valid的时候经常使用到。然后我们就是根据左右括号的位置提取出中间的子字符串调用递归函数，返回值赋给num。如果遇到符号，或者是最后一个位置的字符时，我们根据op的值对num进行分别的加减乘除的处理，结果保存到curRes中。然后再次判读如果op是加或减，或者是最后一个位置的字符时，将curRes加到结果res中，并且curRes重置为0。最后将当前字符c赋值给op（注意这里只有当时最后一个位置的字符时，才有可能不是运算符号，不过也不要紧了，因为遍历已经结束了），num也要重置为0，参见代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> calculate(<span style="color: #0000ff;">string</span><span style="color: #000000;"> s) {
        </span><span style="color: #0000ff;">int</span> n = s.size(), num = <span style="color: #800080;">0</span>, curRes = <span style="color: #800080;">0</span>, res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">char</span> op = <span style="color: #800000;">'</span><span style="color: #800000;">+</span><span style="color: #800000;">'</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">char</span> c =<span style="color: #000000;"> s[i];
            </span><span style="color: #0000ff;">if</span> (c &gt;= <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span> &amp;&amp; c &lt;= <span style="color: #800000;">'</span><span style="color: #800000;">9</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                num </span>= num * <span style="color: #800080;">10</span> + c - <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span><span style="color: #000000;">;
            } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (c == <span style="color: #800000;">'</span><span style="color: #800000;">(</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                </span><span style="color: #0000ff;">int</span> j = i, cnt = <span style="color: #800080;">0</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">for</span> (; i &lt; n; ++<span style="color: #000000;">i) {
                    </span><span style="color: #0000ff;">if</span> (s[i] == <span style="color: #800000;">'</span><span style="color: #800000;">(</span><span style="color: #800000;">'</span>) ++<span style="color: #000000;">cnt;
                    </span><span style="color: #0000ff;">if</span> (s[i] == <span style="color: #800000;">'</span><span style="color: #800000;">)</span><span style="color: #800000;">'</span>) --<span style="color: #000000;">cnt;
                    </span><span style="color: #0000ff;">if</span> (cnt == <span style="color: #800080;">0</span>) <span style="color: #0000ff;">break</span><span style="color: #000000;">;
                }
                num </span>= calculate(s.substr(j + <span style="color: #800080;">1</span>, i - j - <span style="color: #800080;">1</span><span style="color: #000000;">));
            }
            </span><span style="color: #0000ff;">if</span> (c == <span style="color: #800000;">'</span><span style="color: #800000;">+</span><span style="color: #800000;">'</span> || c == <span style="color: #800000;">'</span><span style="color: #800000;">-</span><span style="color: #800000;">'</span> || c == <span style="color: #800000;">'</span><span style="color: #800000;">*</span><span style="color: #800000;">'</span> || c == <span style="color: #800000;">'</span><span style="color: #800000;">/</span><span style="color: #800000;">'</span> || i == n - <span style="color: #800080;">1</span><span style="color: #000000;">) {
                </span><span style="color: #0000ff;">switch</span><span style="color: #000000;"> (op) {
                    </span><span style="color: #0000ff;">case</span> <span style="color: #800000;">'</span><span style="color: #800000;">+</span><span style="color: #800000;">'</span>: curRes += num; <span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">case</span> <span style="color: #800000;">'</span><span style="color: #800000;">-</span><span style="color: #800000;">'</span>: curRes -= num; <span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">case</span> <span style="color: #800000;">'</span><span style="color: #800000;">*</span><span style="color: #800000;">'</span>: curRes *= num; <span style="color: #0000ff;">break</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">case</span> <span style="color: #800000;">'</span><span style="color: #800000;">/</span><span style="color: #800000;">'</span>: curRes /= num; <span style="color: #0000ff;">break</span><span style="color: #000000;">;
                }
                </span><span style="color: #0000ff;">if</span> (c == <span style="color: #800000;">'</span><span style="color: #800000;">+</span><span style="color: #800000;">'</span> || c == <span style="color: #800000;">'</span><span style="color: #800000;">-</span><span style="color: #800000;">'</span> || i == n - <span style="color: #800080;">1</span><span style="color: #000000;">) {
                    res </span>+=<span style="color: #000000;"> curRes;
                    curRes </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
                }
                op </span>=<span style="color: #000000;"> c;
                num </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/8934427.html" id="homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0">Basic Calculator IV</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4601208.html" target="_blank">Basic Calculator II</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4570699.html" target="_blank">Basic Calculator</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-04-18 11:58</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=8873471" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(8873471);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/8910994.html" id="cb_post_title_url">[LeetCode] Jewels and Stones 珠宝和石头</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="question-description">
<div>
<p>You're given strings <code>J</code> representing the types of stones that are jewels, and <code>S</code> representing the stones you have.  Each character in <code>S</code>is a type of stone you have.  You want to know how many of the stones you have are also jewels.</p>
<p>The letters in <code>J</code> are guaranteed distinct, and all characters in <code>J</code> and <code>S</code> are letters. Letters are case sensitive, so <code>"a"</code> is considered a different type of stone from <code>"A"</code>.</p>
<p>Example 1:</p>
<pre>Input: J = "aA", S = "aAAbbbb"
Output: 3
</pre>
<p>Example 2:</p>
<pre>Input: J = "z", S = "ZZ"
Output: 0
</pre>
<p>Note:</p>
<ul>
<li><code>S</code> and <code>J</code> will consist of letters and have length at most 50.</li>
<li>The characters in <code>J</code> are distinct.</li>
</ul>
</div>
</div>
<p> </p>
<p>这道题给了我们两个字符串，珠宝字符串J和石头字符串S，其中J中的每个字符都是珠宝，S中的每个字符都是石头，问我们S中有多少个珠宝。这道题没什么难度，高于八成的Accept率也应证了其Easy难度实至名归。那么先来暴力搜索吧，就将S中的每个字符都在J中搜索一遍，搜索到了就break掉，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> numJewelsInStones(<span style="color: #0000ff;">string</span> J, <span style="color: #0000ff;">string</span><span style="color: #000000;"> S) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span><span style="color: #000000;"> s : S) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span><span style="color: #000000;"> j : J) {
                </span><span style="color: #0000ff;">if</span> (s ==<span style="color: #000000;"> j) {
                    </span>++res; <span style="color: #0000ff;">break</span><span style="color: #000000;">;
                }
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>我们用HashSet来优化时间复杂度，将珠宝字符串J中的所有字符都放入HashSet中，然后遍历石头字符串中的每个字符，到HashSet中查找是否存在，存在的话计数器自增1即可，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> numJewelsInStones(<span style="color: #0000ff;">string</span> J, <span style="color: #0000ff;">string</span><span style="color: #000000;"> S) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        unordered_set</span>&lt;<span style="color: #0000ff;">char</span>&gt;<span style="color: #000000;"> s;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span><span style="color: #000000;"> c : J) s.insert(c);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span><span style="color: #000000;"> c : S) {
            </span><span style="color: #0000ff;">if</span> (s.count(c)) ++<span style="color: #000000;">res;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-04-22 23:37</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=8910994" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(8910994);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/8910994.html" id="cb_post_title_url">[LeetCode] Jewels and Stones 珠宝和石头</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="question-description">
<div>
<p>You're given strings <code>J</code> representing the types of stones that are jewels, and <code>S</code> representing the stones you have.  Each character in <code>S</code>is a type of stone you have.  You want to know how many of the stones you have are also jewels.</p>
<p>The letters in <code>J</code> are guaranteed distinct, and all characters in <code>J</code> and <code>S</code> are letters. Letters are case sensitive, so <code>"a"</code> is considered a different type of stone from <code>"A"</code>.</p>
<p>Example 1:</p>
<pre>Input: J = "aA", S = "aAAbbbb"
Output: 3
</pre>
<p>Example 2:</p>
<pre>Input: J = "z", S = "ZZ"
Output: 0
</pre>
<p>Note:</p>
<ul>
<li><code>S</code> and <code>J</code> will consist of letters and have length at most 50.</li>
<li>The characters in <code>J</code> are distinct.</li>
</ul>
</div>
</div>
<p> </p>
<p>这道题给了我们两个字符串，珠宝字符串J和石头字符串S，其中J中的每个字符都是珠宝，S中的每个字符都是石头，问我们S中有多少个珠宝。这道题没什么难度，高于八成的Accept率也应证了其Easy难度实至名归。那么先来暴力搜索吧，就将S中的每个字符都在J中搜索一遍，搜索到了就break掉，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> numJewelsInStones(<span style="color: #0000ff;">string</span> J, <span style="color: #0000ff;">string</span><span style="color: #000000;"> S) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span><span style="color: #000000;"> s : S) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span><span style="color: #000000;"> j : J) {
                </span><span style="color: #0000ff;">if</span> (s ==<span style="color: #000000;"> j) {
                    </span>++res; <span style="color: #0000ff;">break</span><span style="color: #000000;">;
                }
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>我们用HashSet来优化时间复杂度，将珠宝字符串J中的所有字符都放入HashSet中，然后遍历石头字符串中的每个字符，到HashSet中查找是否存在，存在的话计数器自增1即可，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> numJewelsInStones(<span style="color: #0000ff;">string</span> J, <span style="color: #0000ff;">string</span><span style="color: #000000;"> S) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        unordered_set</span>&lt;<span style="color: #0000ff;">char</span>&gt;<span style="color: #000000;"> s;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span><span style="color: #000000;"> c : J) s.insert(c);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span><span style="color: #000000;"> c : S) {
            </span><span style="color: #0000ff;">if</span> (s.count(c)) ++<span style="color: #000000;">res;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-04-22 23:37</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=8910994" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(8910994);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/8823944.html" id="cb_post_title_url">[LeetCode] Max Chunks To Make Sorted 可排序的最大块数</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given an array <code>arr</code> that is a permutation of <code>[0, 1, ..., arr.length - 1]</code>, we split the array into some number of "chunks" (partitions), and individually sort each chunk.  After concatenating them, the result equals the sorted array.</p>
<p>What is the most number of chunks we could have made?</p>
<p>Example 1:</p>
<pre>Input: arr = [4,3,2,1,0]
Output: 1
Explanation:
Splitting into two or more chunks will not return the required result.
For example, splitting into [4, 3], [2, 1, 0] will result in [3, 4, 0, 1, 2], which isn't sorted.
</pre>
<p>Example 2:</p>
<pre>Input: arr = [1,0,2,3,4]
Output: 4
Explanation:
We can split into two chunks, such as [1, 0], [2, 3, 4].
However, splitting into [1, 0], [2], [3], [4] is the highest number of chunks possible.
</pre>
<p>Note:</p>
<ul>
<li><code>arr</code> will have length in range <code>[1, 10]</code>.</li>
<li><code>arr[i]</code> will be a permutation of <code>[0, 1, ..., arr.length - 1]</code>.</li>
</ul>
<p> </p>
<p>这道题给了我们一个长度为n的数组，里面的数字是[0, n-1]范围内的所有数字，无序的。现在让我们分成若干块儿，然后给每一小块儿分别排序，再组合到一起，使原数组变得有序，问我们最多能分多少块，题目中的两个例子很好的解释了题意。我们首先来分析例子1，这是一个倒序的数组，第一个数字是最大的，为4，那么我们想，这个数字4原本是应该位于数组的最后一个位置，所以中间不可能断开成新的块了，要不然数字4就没法跑到末尾去了。分析到这里，我们应该隐约有点感觉了，当前数字所在的块至少要到达坐标为当前数字大小的地方，比如数字4所在的块至少要包括i=4的那个位置。那么带着这个发现，来分析例子2。第一个数字是1，那么当前数字1所在的块至少要到 i=1 的位置，然后我们去 i=1 的位置上看，发现是数字0，并没有超过 i=1 的范围，那么前两个数就可以断开成一个新的块儿。再往后看，i=2 的位置是2，可以单独断开，后面的3和4也可以分别断开。所以其实这道题跟<a href="http://www.cnblogs.com/grandyang/p/4373533.html" target="_blank">Jump Game II</a>那题很像，我们需要维护一个最远能到达的位置，这里的每个数字相当于那道题中的跳力，只有当我们刚好到达最远点的时候，就可以把之前断成一个新的块儿了。</p>
<p>我们遍历原数组，用cur表示能到达的最远点，然后我们遍历当前位置到cur之间的所有点，遍历的同时如果遇到更大的数字就更新cur，当cur大于等于末尾数字的时候，此时不能再拆分新块儿了，返回结果res加1。否则的话说明到达了最远点，更新第一个for循环的变量i，并且结果res自增1。来看个例子:</p>
<p>[2 0 1 4 3]</p>
<p>当 i=0 时，cur=2，j=1，然后我们发现 j=1 和 j=2 的数字都不会更新cur，且cur也没有大于等于3，所以此时 j=3 的时候退出了内部的for循环，i赋值为2，结果res为1。然后此时 i=3，cur=4，4已经大于末尾的3了，直接返回res加1，即2，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> maxChunksToSorted(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> arr) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, n =<span style="color: #000000;"> arr.size();
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">int</span> cur = arr[i], j = i + <span style="color: #800080;">1</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">for</span> (; j &lt;= cur; ++<span style="color: #000000;">j) {
                cur </span>=<span style="color: #000000;"> max(cur, arr[j]);
                </span><span style="color: #0000ff;">if</span> (cur &gt;= arr.back()) <span style="color: #0000ff;">return</span> res + <span style="color: #800080;">1</span><span style="color: #000000;">;
            }
            i </span>= j - <span style="color: #800080;">1</span><span style="color: #000000;">;
            </span>++<span style="color: #000000;">res;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>其实这道题有更霸道的解法，我们仔细观察一些例子，可以发现断开为新块儿的地方都是当之前出现的最大值正好和当前位置坐标相等的地方，比如例子2中，当 i=1 时，之前最大的数字是1，所以可以断开。而在例子1中，当 i=4 时，才和之前出现过的最大数字4相等，此时断开也没啥意义了，因为后面已经没有数字了，所以还只是一个块儿，参见代码如下： </p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> maxChunksToSorted(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> arr) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, n = arr.size(), mx = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            mx </span>=<span style="color: #000000;"> max(mx, arr[i]);
            </span><span style="color: #0000ff;">if</span> (mx == i) ++<span style="color: #000000;">res;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>讨论：由于本题是其拓展题<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/8850299.html" id="homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0">Max Chunks To Make Sorted II</a>的特殊情况，所以其拓展题的四种解法都可以用在本题，这里就不一一列举了，具体的代码和讲解可以参见这个帖子<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/8850299.html" id="homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0">Max Chunks To Make Sorted II</a>。</p>
<p> </p>
<p>类似题目：</p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/8850299.html" id="homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0">Max Chunks To Make Sorted II</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4373533.html" target="_blank">Jump Game II</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-04-13 21:05</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=8823944" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(8823944);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/8850299.html" id="cb_post_title_url">[LeetCode] Max Chunks To Make Sorted II 可排序的最大块数之二</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p><em>This question is the same as "Max Chunks to Make Sorted" except the integers of the given array are not necessarily distinct, the input array could be up to length <code>2000</code>, and the elements could be up to <code>10**8</code>.</em></p>
<hr/>
<p>Given an array <code>arr</code> of integers (not necessarily distinct), we split the array into some number of "chunks" (partitions), and individually sort each chunk.  After concatenating them, the result equals the sorted array.</p>
<p>What is the most number of chunks we could have made?</p>
<p>Example 1:</p>
<pre>Input: arr = [5,4,3,2,1]
Output: 1
Explanation:
Splitting into two or more chunks will not return the required result.
For example, splitting into [5, 4], [3, 2, 1] will result in [4, 5, 1, 2, 3], which isn't sorted.
</pre>
<p>Example 2:</p>
<pre>Input: arr = [2,1,3,4,4]
Output: 4
Explanation:
We can split into two chunks, such as [2, 1], [3, 4, 4].
However, splitting into [2, 1], [3], [4], [4] is the highest number of chunks possible.
</pre>
<p>Note:</p>
<ul>
<li><code>arr</code> will have length in range <code>[1, 2000]</code>.</li>
<li><code>arr[i]</code> will be an integer in range <code>[0, 10**8]</code>.</li>
</ul>
<p> </p>
<p>这道题是之前那道<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/8823944.html" id="homepage1_HomePageDays_DaysList_ctl01_DayList_TitleUrl_0">Max Chunks To Make Sorted</a>的拓展，那道题说了数组是[0, n-1]中所有数字的一种全排列，n为数组的长度。而这道题的数字就没有这种限制，可以是大于n的数字，也可以有重复的数字。由于数字和坐标不再有太多的关联，所以之前那题中比较数字和坐标的大小的解法肯定行不通了。我们来看一种十分巧妙的解法，首先我们需要明确的一点是，拆分后的块儿排序后拼在一起会跟原数组相同，我们用一个例子来说明：</p>
<p>2  1  4  3  4</p>
<p><span style="color: #ff0000;">1  2</span>  <span style="color: #0000ff;">3</span>  <span style="color: #0000ff;">4</span>  <span style="color: #008000;">4</span></p>
<p>1  2  3  4  4</p>
<p>我们看到第一行是原数组，第二行是排序后并拼接在了一起的块儿，不同的颜色代表不同的块儿，而第三行是直接对原数组排序后的结果。仔细观察可以发现，能形成块儿的数字之和跟排序后的数组的相同长度的子数组的数字之和是相同的。比如第一个块儿是数字2和1，和为3，而排序后的前两个数字为1和2，和也是3，那么我们就知道原数组的前两个数字可以拆成一个块儿。同理，原数组中的第三个和第四个数字分别为4和3，和为7，而排序后的数组对应位置的数字之和也是7，说明可以拆分出块儿。就是这么简单而暴力的思路，时间复杂度为O(nlgn)，主要花在给数组排序上了。由于本题是<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/8823944.html" id="homepage1_HomePageDays_DaysList_ctl01_DayList_TitleUrl_0">Max Chunks To Make Sorted</a>的generalized的情况，所以这种解法自然也可以解决之前那道题了，不过就是时间复杂度稍高了一些，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> maxChunksToSorted(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> arr) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, sum1 = <span style="color: #800080;">0</span>, sum2 = <span style="color: #800080;">0</span><span style="color: #000000;">;
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; expect =<span style="color: #000000;"> arr;
        sort(expect.begin(), expect.end());
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; arr.size(); ++<span style="color: #000000;">i) {
            sum1 </span>+=<span style="color: #000000;"> arr[i];
            sum2 </span>+=<span style="color: #000000;"> expect[i];
            </span><span style="color: #0000ff;">if</span> (sum1 == sum2) ++<span style="color: #000000;">res;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>这道题的时间复杂度可以优化到线性，不过就是需要花点空间。下面这种解法也相当的巧妙，我们需要两个数组forward和backward，其中 foward[i] 表示 [0, i] 范围内最大的数字，而 backward[i] 表示 [i, n-1] 范围内最小的数字，实际上就是要知道已经遍历过的最大值，和还未遍历的到的最小值。为啥我们对这两个值感兴趣呢？这是本解法的精髓所在，我们知道可以拆分为块儿的前提是之后的数字不能比当前块儿中的任何数字小，不然那个较小的数字就无法排到前面。就像例子1，为啥不能拆出新块儿，就因为最小的数字在末尾。那么这里我们能拆出新块儿的条件就是，当前位置出现过的最大值小于等于之后还未遍历到的最小值时，就能拆出新块儿。比如例子2中，当 i=1 时，此时出现过的最大数字为2，未遍历到的数字中最小值为3，所以可以拆出新块儿，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> maxChunksToSorted(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> arr) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">1</span>, n =<span style="color: #000000;"> arr.size();
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; f = arr, b =<span style="color: #000000;"> arr;   
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt; n; ++i) f[i] = max(arr[i], f[i - <span style="color: #800080;">1</span><span style="color: #000000;">]);   
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = n - <span style="color: #800080;">2</span>; i &gt;= <span style="color: #800080;">0</span>; --i) b[i] = min(arr[i], b[i + <span style="color: #800080;">1</span><span style="color: #000000;">]);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n - <span style="color: #800080;">1</span>; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (f[i] &lt;= b[i + <span style="color: #800080;">1</span>]) ++<span style="color: #000000;">res;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>我们可以优化一下空间复杂度，因为我们可以在遍历的过程中维护一个当前最大值curMax，所以就不用一个专门的forward数组了，但是backward数组还是要的，参见代码如下： </p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> maxChunksToSorted(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> arr) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">1</span>, n = arr.size(), curMax =<span style="color: #000000;"> INT_MIN;
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; b =<span style="color: #000000;"> arr;    
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = n - <span style="color: #800080;">2</span>; i &gt;= <span style="color: #800080;">0</span>; --i) b[i] = min(arr[i], b[i + <span style="color: #800080;">1</span><span style="color: #000000;">]);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n - <span style="color: #800080;">1</span>; ++<span style="color: #000000;">i) {
            curMax </span>=<span style="color: #000000;"> max(curMax, arr[i]);
            </span><span style="color: #0000ff;">if</span> (curMax &lt;= b[i + <span style="color: #800080;">1</span>]) ++<span style="color: #000000;">res;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种使用单调栈Monotonous Stack的解法的题也十分的巧妙，我们维护一个单调递增的栈，遇到大于等于栈顶元素的数字就压入栈，当遇到小于栈顶元素的数字后，处理的方法很是巧妙啊：首先取出栈顶元素，这个是当前最大值，因为我们维护的就是单调递增栈啊，然后我们再进行循环，如果栈不为空，且新的栈顶元素大于当前数字，则移除栈顶元素。这步简直绝了，这里我们单调栈的元素个数实际上是遍历到当前数字之前可以拆分成的块儿的个数，我们遇到一个大于栈顶的元素，就将其压入栈，suppose其是一个新块儿的开头，但是一旦后面遇到小的数字了，我们就要反过来检查前面的数字，有可能我们之前认为的可以拆分成块儿的地方，现在就不能拆了，举个栗子来说吧：</p>
<p>比如数组为 [1 0 3 3 2]，我们先把第一个数字1压入栈，此时栈为：</p>
<p>stack：1</p>
<p>然后遍历到第二个数字0，发现小于栈顶元素，将栈顶元素1取出存入curMax，此时栈为空了，不做任何操作，将curMax压回栈，此时栈为：</p>
<p>stack：1</p>
<p>然后遍历到第三个数字3，大于栈顶元素，压入栈，此时栈为：</p>
<p>stack：1，3</p>
<p>然后遍历到第四个数字3，等于栈顶元素，压入栈，此时栈为：</p>
<p>stack：1，3，3</p>
<p>然后遍历到第五个数字2，小于栈顶元素，将栈顶元素3取出存入curMax，此时新的栈顶元素3，大于当前数字2，移除此栈顶元素3，然后新的栈顶元素1，小于当前数字2，循环结束，将curMax压回栈，此时栈为：</p>
<p>stack：1，3</p>
<p>所以最终能拆为两个块儿，即stack中数字的个数，参见代码如下：</p>
<p> </p>
<p>解法四：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> maxChunksToSorted(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> arr) {
        stack</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> st;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; arr.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (st.empty() || st.top() &lt;=<span style="color: #000000;"> arr[i]) {
                st.push(arr[i]);
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                </span><span style="color: #0000ff;">int</span> curMax =<span style="color: #000000;"> st.top(); st.pop();
                </span><span style="color: #0000ff;">while</span> (!st.empty() &amp;&amp; st.top() &gt;<span style="color: #000000;"> arr[i]) st.pop();
                st.push(curMax);
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> st.size();
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/8823944.html" id="homepage1_HomePageDays_DaysList_ctl01_DayList_TitleUrl_0">Max Chunks To Make Sorted</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-04-15 23:51</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=8850299" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(8850299);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/8799483.html" id="cb_post_title_url">[LeetCode] Reorganize String 重构字符串</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a string <code>S</code>, check if the letters can be rearranged so that two characters that are adjacent to each other are not the same.</p>
<p>If possible, output any possible result.  If not possible, return the empty string.</p>
<p>Example 1:</p>
<pre>Input: S = "aab"
Output: "aba"
</pre>
<p>Example 2:</p>
<pre>Input: S = "aaab"
Output: ""
</pre>
<p>Note:</p>
<ul>
<li><code>S</code> will consist of lowercase letters and have length in range <code>[1, 500]</code>.</li>
</ul>
<p> </p>
<p>这道题给了我们一个字符串，让我们重构这个字符串，使得相同的字符不会相邻，如果无法做到，那么就返回空串，题目中的例子很好的说明了这一点。那么，如果先不考虑代码实现，让你来手动重构的话，该怎么做呢？我们要做的就是把相同的字符分开。比如例子1中，两个a相邻了，所以我们把第二个a和后面的b交换位置，这样分开了相同的字符，就是最终答案了。我们再来看一个例子，比如"aaabbc"，那么其实我们发现第二个字符也是‘a’的时候，就需要往后遍历找到第一个不是‘a’的字符，即‘b’，然后交换‘a’和‘b’即可，然后继续往后面进行同样的处理，当无法找到不同的字符后就返回空串。这种方法对有序的字符串S是可以的，虽然题目给的两个例子中字符串S都是有序的，实际上不一定是有序的。所以博主最先的想法是给数组排序呗，但是博主的这个解法跪在了这个例子上"vvvlo"，我们发现排序后就变成"lovvv"，这样上面提到的解法就跪了。我们希望次数出现多的字符串再前面，这样才好交换嘛。那么我们还是要统计每个字符串出现的次数啊，这里使用HashMap来建立字母和其出现次数之间的映射。由于我们希望次数多的字符排前面，可以使用一个最大堆，C++中就是优先队列Priority Queue，将次数当做排序的key，那么就把次数和其对应的字母组成一个pair，放进最大堆中自动排序。这里其实有个剪枝的trick，如果某个字母出现的频率大于总长度的一半了，那么必然会有两个相邻的字母出现。这里博主就不证明了，感觉有点像抽屉原理。所以我们在将映射对加入优先队列时，先判断下次数，超过总长度一半了的话直接返回空串就行了。</p>
<p>好，我们的最大堆建立好以后，我们想，此时难道还是应该使用上面所说的交换的方法吗？其实直接构建新的字符串要更加简单一些。接下来，我们每次从优先队列中取队首的两个映射对儿处理，因为我们要拆开相同的字母，这两个映射对儿肯定是不同的字母，我们可以将其放在一起，之后我们需要将两个映射对儿中的次数自减1，如果还有多余的字母，即减1后的次数仍大于0的话，将其再放回最大堆。由于我们是两个两个取的，所以最后while循环退出后，有可能优先队列中还剩下了一个映射对儿，此时将其加入结果res即可。而且这个多余的映射对儿一定只有一个字母了，因为我们提前判断过各个字母的出现次数是否小于等于总长度的一半，按这种机制来取字母，不可能会剩下多余一个的相同的字母，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> reorganizeString(<span style="color: #0000ff;">string</span><span style="color: #000000;"> S) {
        </span><span style="color: #0000ff;">string</span> res = <span style="color: #800000;">""</span><span style="color: #000000;">;
        unordered_map</span>&lt;<span style="color: #0000ff;">char</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> m;
        priority_queue</span>&lt;pair&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">char</span>&gt;&gt;<span style="color: #000000;"> q;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span> c : S) ++<span style="color: #000000;">m[c];
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto a : m) {
            </span><span style="color: #0000ff;">if</span> (a.second &gt; (S.size() + <span style="color: #800080;">1</span>) / <span style="color: #800080;">2</span>) <span style="color: #0000ff;">return</span> <span style="color: #800000;">""</span><span style="color: #000000;">;
            q.push({a.second, a.first});
        }
        </span><span style="color: #0000ff;">while</span> (q.size() &gt;= <span style="color: #800080;">2</span><span style="color: #000000;">) {
            auto t1 </span>=<span style="color: #000000;"> q.top(); q.pop();
            auto t2 </span>=<span style="color: #000000;"> q.top(); q.pop();
            res.push_back(t1.second);
            res.push_back(t2.second);
            </span><span style="color: #0000ff;">if</span> (--t1.first &gt; <span style="color: #800080;">0</span><span style="color: #000000;">) q.push(t1);
            </span><span style="color: #0000ff;">if</span> (--t2.first &gt; <span style="color: #800080;">0</span><span style="color: #000000;">) q.push(t2);
        }
        </span><span style="color: #0000ff;">if</span> (q.size() &gt; <span style="color: #800080;">0</span><span style="color: #000000;">) res.push_back(q.top().second);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种解法的原理和上面的很类似，就是写法上很秀，堪比陈独秀。这里使用了一个长度为26的一位数组cnt来代替上面的HashMap进行统计字母的出现次数，然后比较秀的一点是，把上面的映射对儿压缩成了一个整数，做法是将次数乘以了100，再加上当前字母在一位数字中的位置坐标i，这样一个整数就同时encode了次数和对应字母的信息了，而且之后decode也很方便。数组cnt更新好了后，需要排个序，这一步就是模拟上面解法中最大堆的自动排序功能。不过这里是数字小的在前面，即先处理出现次数少的字母。这里除了和上面一样检测次数不能大于总长度的一半的操作外，还有一个小trick，就是构建字符串的时候，是从第二个位置开始的。这里我们构建的字符串是直接对原字符串S进行修改的，因为cnt数组建立了之后，字符串S就没啥用了。我们用一个变量idx来表示当前更新字母的位置，初始化为1，表示我们要从第二个位置开始更新。因为出现次数最多的字母一定要占据第一个位置才行，这就是我们留出第一个位置的原因。这里很叼的一点，就是隔位更新，这样能保证相同的字母不相邻，而且当idx越界后，拉回到起始位置0，这就有点遍历循环数组的感觉。举个栗子来说吧，比如"aaabbc"，我们的更新顺序为：</p>
<p>_ c _ _ _ _</p>
<p>_ c _ b _ _</p>
<p>_ c _ b _ b</p>
<p>a c _ b _ b</p>
<p>a c a b _ b</p>
<p>a c a b a b</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> reorganizeString(<span style="color: #0000ff;">string</span><span style="color: #000000;"> S) {
        </span><span style="color: #0000ff;">int</span> n = S.size(), idx = <span style="color: #800080;">1</span><span style="color: #000000;">;
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; cnt(<span style="color: #800080;">26</span>, <span style="color: #800080;">0</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span> c : S) cnt[c - <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span>] += <span style="color: #800080;">100</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; <span style="color: #800080;">26</span>; ++i) cnt[i] +=<span style="color: #000000;"> i;
        sort(cnt.begin(), cnt.end());
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span><span style="color: #000000;"> num : cnt) {
            </span><span style="color: #0000ff;">int</span> t = num / <span style="color: #800080;">100</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">char</span> ch = <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span> + (num % <span style="color: #800080;">100</span><span style="color: #000000;">);
            </span><span style="color: #0000ff;">if</span> (t &gt; (n + <span style="color: #800080;">1</span>) / <span style="color: #800080;">2</span>) <span style="color: #0000ff;">return</span> <span style="color: #800000;">""</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; t; ++<span style="color: #000000;">i) {
                </span><span style="color: #0000ff;">if</span> (idx &gt;= n) idx = <span style="color: #800080;">0</span><span style="color: #000000;">;
                S[idx] </span>=<span style="color: #000000;"> ch;
                idx </span>+= <span style="color: #800080;">2</span><span style="color: #000000;">;
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> S;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/5586009.html">Rearrange String k Distance Apart</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/7098764.html">Task Scheduler</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-04-11 23:40</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=8799483" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(8799483);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/8729459.html" id="cb_post_title_url">[LeetCode] Toeplitz Matrix 托普利兹矩阵</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>A matrix is <em>Toeplitz</em> if every diagonal from top-left to bottom-right has the same element.</p>
<p>Now given an <code>M x N</code> matrix, return <code>True</code> if and only if the matrix is <em>Toeplitz</em>.<br/> </p>
<p>Example 1:</p>
<pre>Input: matrix = [[1,2,3,4],[5,1,2,3],[9,5,1,2]]
Output: True
Explanation:
1234
5123
9512

In the above grid, the diagonals are "[9]", "[5, 5]", "[1, 1, 1]", "[2, 2, 2]", "[3, 3]", "[4]", and in each diagonal all elements are the same, so the answer is True.
</pre>
<p>Example 2:</p>
<pre>Input: matrix = [[1,2],[2,2]]
Output: False
Explanation:
The diagonal "[1, 2]" has different elements.
</pre>
<p>Note:</p>
<ol>
<li><code>matrix</code> will be a 2D array of integers.</li>
<li><code>matrix</code> will have a number of rows and columns in range <code>[1, 20]</code>.</li>
<li><code>matrix[i][j]</code> will be integers in range <code>[0, 99]</code>.</li>
</ol>
<p> </p>
<p>这道题让我们验证一个矩阵是否是托普利兹矩阵Toeplitz Matrix，所谓的这个托普利兹矩阵，就是看每条从左上到右下的对角线是否是值都相等。注意矩阵的行数列数不一定相等，要验证所有的对角线。那么其实这道题的本质是让我们斜向遍历矩阵，就是按对角线来。那么博主最先想到的方法就是按照对角线来遍历矩阵，起点是最左下的数字，对于mxn的矩阵，最左下角数字的坐标为(m-1, 0)，然后我们开始往右下角遍历，我们先记录每条对角线左上角的数字为val，然后再往右下角遍历的时候，如果同一条对角线上的数字不等于val，直接返回false。当我们遍历完一条对角线的时候，切换一条对角线的时候，是根据起点数字的坐标移动的，如果细心观察会发现，起点位置是先从第一列往上移动，然后在第一行往右移动，那么只要根据起点位置的行坐标是否为0来判断移动的方向即可，比如对于题目中的例子1:</p>
<p><span style="color: #ff0000;">1</span> <span style="color: #0000ff;">2 3 4</span><br/><span style="color: #ff0000;">5</span>  1  2  3<br/><span style="color: #ff0000;">9</span>  5  1  2</p>
<p>起点移动的方向是9 -&gt; 5 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> isToeplitzMatrix(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> matrix) {
        </span><span style="color: #0000ff;">int</span> m = matrix.size(), n = matrix[<span style="color: #800080;">0</span>].size(), p = m - <span style="color: #800080;">1</span>, q = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (p &gt;= <span style="color: #800080;">0</span> &amp;&amp; q &lt;<span style="color: #000000;"> n) {
            </span><span style="color: #0000ff;">int</span> val = matrix[p][q], i = p, j =<span style="color: #000000;"> q;
            </span><span style="color: #0000ff;">while</span> (i + <span style="color: #800080;">1</span> &lt; m &amp;&amp; j + <span style="color: #800080;">1</span> &lt;<span style="color: #000000;"> n) {
                </span><span style="color: #0000ff;">if</span> (matrix[++i][++j] != val) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            }
            (p </span>&gt; <span style="color: #800080;">0</span>) ? --p : ++<span style="color: #000000;">q;
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>其实并不需要像上面解法写的那么复杂，我们还可以按正常顺序来遍历数组，对于每个遍历到的数字，都跟其右下方的数字对比，如果不相同，直接返回false即可。为了防止越界，我们不遍历最后一行和最后一列，遍历完成后，返回true，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> isToeplitzMatrix(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> matrix) {
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; matrix.size() - <span style="color: #800080;">1</span>; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; matrix[i].size() - <span style="color: #800080;">1</span>; ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> (matrix[i][j] != matrix[i + <span style="color: #800080;">1</span>][j + <span style="color: #800080;">1</span>]) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            }
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/5991673.html">Valid Word Square</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a href="http://www.cnblogs.com/grandyang/p/4606334.html" target="_blank">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-04-06 23:42</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=8729459" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(8729459);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/8716597.html" id="cb_post_title_url">[LeetCode] Couples Holding Hands 两两握手</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>N couples sit in 2N seats arranged in a row and want to hold hands. We want to know the minimum number of swaps so that every couple is sitting side by side. A <em>swap</em> consists of choosing any two people, then they stand up and switch seats.</p>
<p>The people and seats are represented by an integer from <code>0</code> to <code>2N-1</code>, the couples are numbered in order, the first couple being <code>(0, 1)</code>, the second couple being <code>(2, 3)</code>, and so on with the last couple being <code>(2N-2, 2N-1)</code>.</p>
<p>The couples' initial seating is given by <code>row[i]</code> being the value of the person who is initially sitting in the i-th seat.</p>
<p>Example 1:</p>
<pre>Input: row = [0, 2, 1, 3]
Output: 1
Explanation: We only need to swap the second (row[1]) and third (row[2]) person.
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input: row = [3, 2, 0, 1]
Output: 0
Explanation: All couples are already seated side by side.
</pre>
<p> </p>
<p>Note:</p>
<ol>
<li><code>len(row)</code> is even and in the range of <code>[4, 60]</code>.</li>
<li><code>row</code> is guaranteed to be a permutation of <code>0...len(row)-1</code>.</li>
</ol>
<p> </p>
<p>这道题给了我们一个长度为n的数组，里面包含的数字是 [0, n-1] 范围内的数字各一个，让我们通过调换任意两个数字的位置，使得相邻的奇偶数靠在一起。因为要两两成对，所以题目限定了输入数组必须是偶数个。我们要明确的是，组成对儿的两个是从0开始，每两个一对儿的。比如0和1，2和3，像1和2就不行。而且检测的时候也是两个数两个数的检测，左右顺序无所谓，比如2和3，或者3和2都行。当我们暂时对如何用代码来解决问题没啥头绪的时候，一个很好的办法是，先手动解决问题，意思是，假设这道题不要求你写代码，就让你按照要求排好序怎么做。我们随便举个例子来说吧，比如：</p>
<p>[3   1   4   0   2   5]</p>
<p>我们如何将其重新排序呢？首先明确，我们交换数字位置的动机是要凑对儿，如果我们交换的两个数字无法组成新对儿，那么这个交换就毫无意义。来手动交换吧，我们两个两个的来看数字，前两个数是3和1，我们知道其不成对儿，数字3的老相好是2，不是1，那么怎么办呢？我们就把1和2交换位置呗。好，那么现在3和2牵手成功，度假去了，再来看后面的：</p>
<p>[<span style="color: #339966;">3   2</span>   4   0   1   5]</p>
<p>我们再取两数字，4和0，互不认识！4跟5有一腿儿，不是0，那么就把0和5，交换一下吧，得到：</p>
<p>[<span style="color: #339966;">3   2   4   5</span>   1   0]</p>
<p>好了，再取最后两个数字，1和0，两口子，不用动！前面都成对的话，最后两个数字一定成对。而且这种方法所用的交换次数一定是最少的，不要问博主怎么证明，博主也不会|||-.-～明眼人应该已经看出来了，这就是一种贪婪算法Greedy Algorithm。思路有了，代码就很容易写了，注意这里在找老伴儿时用了一个trick，一个数‘异或’上1就是其另一个位，这个不难理解，如果是偶数的话，最后位是0，‘异或’上1等于加了1，变成了可以的成对奇数。如果是奇数的话，最后位是1，‘异或’上1后变为了0，变成了可以的成对偶数。参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> minSwapsCouples(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> row) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, n =<span style="color: #000000;"> row.size();
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; i += <span style="color: #800080;">2</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">if</span> (row[i + <span style="color: #800080;">1</span>] == (row[i] ^ <span style="color: #800080;">1</span>)) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
            </span>++<span style="color: #000000;">res;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = i + <span style="color: #800080;">1</span>; j &lt; n; ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> (row[j] == (row[i] ^ <span style="color: #800080;">1</span><span style="color: #000000;">)) {
                    row[j] </span>= row[i + <span style="color: #800080;">1</span><span style="color: #000000;">];
                    row[i </span>+ <span style="color: #800080;">1</span>] = row[i] ^ <span style="color: #800080;">1</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                }
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>下面我们来看一种使用联合查找Union Find的解法。该解法对于处理群组问题时非常有效，比如岛屿数量有关的题就经常使用UF解法。核心思想是用一个root数组，每个点开始初始化为不同的值，如果两个点属于相同的组，就将其中一个点的root值赋值为另一个点的位置，这样只要是相同组里的两点，通过find函数会得到相同的值。 那么如果总共有n个数字，则共有 n/2 对儿，所以我们初始化 n/2 个群组，我们还是每次处理两个数字。每个数字除以2就是其群组号，那么属于同一组的两个数的群组号是相同的，比如2和3，其分别除以2均得到1，所以其组号均为1。那么这对解题有啥作用呢？作用忒大了，由于我们每次取的是两个数，且计算其群组号，并调用find函数，那么如果这两个数的群组号相同，那么find函数必然会返回同样的值，我们不用做什么额外动作，因为本身就是一对儿。如果两个数不是一对儿，那么其群组号必然不同，在二者没有归为一组之前，调用find函数返回的值就不同，此时我们将二者归为一组，并且cnt自减1，忘说了，cnt初始化为总群组数，即 n/2。那么最终cnt减少的个数就是交换的步数，还是用上面讲解中的例子来说明吧：</p>
<p>[3   1   4   0   2   5]</p>
<p>最开始的群组关系是：</p>
<p>群组0：0，1</p>
<p>群组1：2，3</p>
<p>群组2：4，5</p>
<p>取出前两个数字3和1，其群组号分别为1和0，带入find函数返回不同值，则此时将群组0和群组1链接起来，变成一个群组，则此时只有两个群组了，cnt自减1，变为了2。</p>
<p>群组0 &amp; 1：0，1，2，3</p>
<p>群组2：4，5</p>
<p>此时取出4和0，其群组号分别为2和0，带入find函数返回不同值，则此时将群组0&amp;1和群组2链接起来，变成一个超大群组，cnt自减1，变为了1。</p>
<p>群组0 &amp; 1 &amp; 2：0，1，2，3，4，5</p>
<p>此时取出最后两个数2和5，其群组号分别为1和2，因为此时都是一个大组内的了，带入find函数返回相同的值，不做任何处理。最终交换的步数就是cnt减少值，为2，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> minSwapsCouples(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> row) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, n = row.size(), cnt = n / <span style="color: #800080;">2</span><span style="color: #000000;">;
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; root(n, <span style="color: #800080;">0</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++i) root[i] =<span style="color: #000000;"> i;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; i += <span style="color: #800080;">2</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">int</span> x = find(root, row[i] / <span style="color: #800080;">2</span><span style="color: #000000;">);
            </span><span style="color: #0000ff;">int</span> y = find(root, row[i + <span style="color: #800080;">1</span>] / <span style="color: #800080;">2</span><span style="color: #000000;">);
            </span><span style="color: #0000ff;">if</span> (x !=<span style="color: #000000;"> y) {
                root[x] </span>=<span style="color: #000000;"> y;
                </span>--<span style="color: #000000;">cnt;
            }
        }
        </span><span style="color: #0000ff;">return</span> n / <span style="color: #800080;">2</span> -<span style="color: #000000;"> cnt;
    }
    </span><span style="color: #0000ff;">int</span> find(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; root, <span style="color: #0000ff;">int</span><span style="color: #000000;"> i) {
        </span><span style="color: #0000ff;">return</span> (i == root[i]) ?<span style="color: #000000;"> i : find(root, root[i]);
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种使用HashMap的解法，本质其实也是联合查找Union Find。我们知道只有群组里面是数字，才能使用root数组，有些非数字的情况，比如字符串，就要使用HashMap了，当然数字也是可以使用HashMap的。我们这里的helper子函数相当于同时包括了链接群组和find查找两部分，在主函数中，我们还是两个两个处理，并且把群组号带入helper函数，在helper函数中，我们将较小数和较大数区分出来，如果二者相同，表明是同一个群组的，不做任何处理，直接返回。否则的话，建立二者的映射，这就是上面解法中的链接群组操作，这样看出来了吧，二者的本质其实是一样的，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> minSwapsCouples(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> row) {
        unordered_map</span>&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> m;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; row.size(); i += <span style="color: #800080;">2</span><span style="color: #000000;">) {
            helper(m, row[i] </span>/ <span style="color: #800080;">2</span>, row[i + <span style="color: #800080;">1</span>] / <span style="color: #800080;">2</span><span style="color: #000000;">);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> m.size();
    }
    </span><span style="color: #0000ff;">void</span> helper(unordered_map&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;&amp; m, <span style="color: #0000ff;">int</span> x, <span style="color: #0000ff;">int</span><span style="color: #000000;"> y) {
        </span><span style="color: #0000ff;">int</span> c1 = min(x, y), c2 =<span style="color: #000000;"> max(x, y);
        </span><span style="color: #0000ff;">if</span> (c1 == c2) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (m.count(c1)) helper(m, m[c1], c2);
        </span><span style="color: #0000ff;">else</span> m[c1] =<span style="color: #000000;"> c2;
    }
};</span></pre>
</div>
<p> </p>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4756677.html" target="_blank">Missing Number</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4395963.html" target="_blank">First Missing Positive</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-04-04 12:31</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=8716597" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(8716597);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/8679286.html" id="cb_post_title_url">[LeetCode] Largest Plus Sign 最大的加型符号</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="question-description">
<div>
<p>In a 2D <code>grid</code> from (0, 0) to (N-1, N-1), every cell contains a <code>1</code>, except those cells in the given list <code>mines</code> which are <code>0</code>. What is the largest axis-aligned plus sign of <code>1</code>s contained in the grid? Return the order of the plus sign. If there is none, return 0.</p>
<p>An "<em>axis-aligned plus sign of <code>1</code>s</em> of order k" has some center <code>grid[x][y] = 1</code> along with 4 arms of length <code>k-1</code>going up, down, left, and right, and made of <code>1</code>s. This is demonstrated in the diagrams below. Note that there could be <code>0</code>s or <code>1</code>s beyond the arms of the plus sign, only the relevant area of the plus sign is checked for 1s.</p>
<p> </p>
<p>Examples of Axis-Aligned Plus Signs of Order k:</p>
<pre>Order 1:
000
010
000

Order 2:
00000
00100
01110
00100
00000

Order 3:
0000000
0001000
0001000
0111110
0001000
0001000
0000000
</pre>
<p> </p>
<p>Example 1:</p>
<pre>Input: N = 5, mines = [[4, 2]]
Output: 2
Explanation:
11111
11111
11111
11111
11011
In the above grid, the largest plus sign can only be order 2.  One of them is marked in bold.
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input: N = 2, mines = []
Output: 1
Explanation:
There is no plus sign of order 2, but there is of order 1.
</pre>
<p> </p>
<p>Example 3:</p>
<pre>Input: N = 1, mines = [[0, 0]]
Output: 0
Explanation:
There is no plus sign, so return 0.
</pre>
<p> </p>
<p>Note:</p>
<ol>
<li><code>N</code> will be an integer in the range <code>[1, 500]</code>.</li>
<li><code>mines</code> will have length at most <code>5000</code>.</li>
<li><code>mines[i]</code> will be length 2 and consist of integers in the range <code>[0, N-1]</code>.</li>
<li><em>(Additionally, programs submitted in C, C++, or C# will be judged with a slightly smaller time limit.)</em></li>
</ol>
<p> </p>
</div>
</div>
<p>这道题给了我们一个数字N，表示一个NxN的二位数字，初始化均为1，又给了一个mines数组，里面是一些坐标，表示数组中这些位置都为0，然后让我们找最大的加型符号。所谓的加型符号是有数字1组成的一个十字型的加号，题目中也给出了长度分别为1，2，3的加型符号的样子。好，理解了题意以后，我们来想想该如何破题。首先，最简单的就是考虑暴力搜索啦，以每个1为中心，向四个方向分别去找，只要任何一个方向遇到了0就停止，然后更新结果res。令博主感到惊讶的是，此题的OJ居然允许Brute Force的解法通过，还是比较大度的，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> orderOfLargestPlusSign(<span style="color: #0000ff;">int</span> N, vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> mines) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; mat(N, vector&lt;<span style="color: #0000ff;">int</span>&gt;(N, <span style="color: #800080;">1</span><span style="color: #000000;">));
        </span><span style="color: #0000ff;">for</span> (auto mine : mines) mat[mine[<span style="color: #800080;">0</span>]][mine[<span style="color: #800080;">1</span>]] = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; N; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; N; ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">int</span> k = <span style="color: #800080;">0</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">while</span> (canExpand(mat, N, i, j, k)) ++<span style="color: #000000;">k;
                res </span>=<span style="color: #000000;"> max(res, k);
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">bool</span> canExpand(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp; mat, <span style="color: #0000ff;">int</span> N, <span style="color: #0000ff;">int</span> x, <span style="color: #0000ff;">int</span> y, <span style="color: #0000ff;">int</span><span style="color: #000000;"> k) {
        </span><span style="color: #0000ff;">if</span> (x - k &lt; <span style="color: #800080;">0</span> || y - k &lt; <span style="color: #800080;">0</span> || x + k &gt;= N || y + k &gt;= N) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span> mat[x - k][y] &amp;&amp; mat[x][y + k] &amp;&amp; mat[x + k][y] &amp;&amp; mat[x][y -<span style="color: #000000;"> k];
    }
};</span></pre>
</div>
<p> </p>
<p>如果我们只想出暴力搜索的解法，就不再管这道题了的话，那在面试的时候就比较悬了。毕竟立方级的时间复杂度实在是太高了，我们必须要进行优化。暴力搜索的时间复杂度之所以高的原因是因为对于每一个1都要遍历其上下左右四个方向，有大量的重复计算，我们为了提高效率，可以对于每一个点，都计算好其上下左右连续1的个数。博主最先用的方法是建立四个方向的dp数组，dp[i][j]表示 (i, j) 位置上该特定方向连续1的个数，那么就需要4个二维dp数组，举个栗子，比如：</p>
<p>原数组：</p>
<div class="cnblogs_code">
<pre><span style="color: #800080;">1</span>  <span style="color: #800080;">0</span>  <span style="color: #800080;">1</span>  <span style="color: #800080;">0</span>
<span style="color: #800080;">1</span>  <span style="color: #800080;">1</span>  <span style="color: #800080;">1</span>  <span style="color: #800080;">1</span>
<span style="color: #800080;">1</span>  <span style="color: #800080;">0</span>  <span style="color: #800080;">1</span>  <span style="color: #800080;">1</span></pre>
</div>
<p>那么我们建立left数组是当前及其左边连续1的个数，如下所示：</p>
<div class="cnblogs_code">
<pre><span style="color: #800080;">1</span>  <span style="color: #800080;">0</span>  <span style="color: #800080;">1</span>  <span style="color: #800080;">0</span>
<span style="color: #800080;">1</span>  <span style="color: #800080;">2</span>  <span style="color: #800080;">3</span>  <span style="color: #800080;">4</span>
<span style="color: #800080;">1</span>  <span style="color: #800080;">0</span>  <span style="color: #800080;">1</span>  <span style="color: #800080;">2</span></pre>
</div>
<p>right数组是当前及其右边连续1的个数，如下所示：</p>
<div class="cnblogs_code">
<pre><span style="color: #800080;">1</span>  <span style="color: #800080;">0</span>  <span style="color: #800080;">1</span>  <span style="color: #800080;">0</span>
<span style="color: #800080;">4</span>  <span style="color: #800080;">3</span>  <span style="color: #800080;">2</span>  <span style="color: #800080;">1</span>
<span style="color: #800080;">1</span>  <span style="color: #800080;">0</span>  <span style="color: #800080;">2</span>  <span style="color: #800080;">1</span></pre>
</div>
<p>up数组是当前及其上边连续1的个数，如下所示：</p>
<div class="cnblogs_code">
<pre><span style="color: #800080;">1</span>  <span style="color: #800080;">0</span>  <span style="color: #800080;">1</span>  <span style="color: #800080;">0</span>
<span style="color: #800080;">2</span>  <span style="color: #800080;">1</span>  <span style="color: #800080;">2</span>  <span style="color: #800080;">1</span>
<span style="color: #800080;">3</span>  <span style="color: #800080;">0</span>  <span style="color: #800080;">3</span>  <span style="color: #800080;">2</span></pre>
</div>
<p>down数组是当前及其下边连续1的个数，如下所示：</p>
<div class="cnblogs_code">
<pre><span style="color: #800080;">3</span>  <span style="color: #800080;">0</span>  <span style="color: #800080;">3</span>  <span style="color: #800080;">0</span>
<span style="color: #800080;">2</span>  <span style="color: #800080;">1</span>  <span style="color: #800080;">2</span>  <span style="color: #800080;">2</span>
<span style="color: #800080;">1</span>  <span style="color: #800080;">0</span>  <span style="color: #800080;">1</span>  <span style="color: #800080;">1</span></pre>
</div>
<p>我们需要做的是在这四个dp数组中的相同位置的四个值中取最小的一个，然后在所有的这些去除的最小值中选最大一个返回即可。为了节省空间，我们不用四个二维dp数组，而只用一个就可以了，因为对于每一个特定位置，我们只需要保留较小值，所以在更新的时候，只需要跟原来值相比取较小值即可。在计算down数组的时候，我们就可以直接更新结果res了，因为四个值都已经计算过了，我们就不用再重新在外面开for循环了，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> orderOfLargestPlusSign(<span style="color: #0000ff;">int</span> N, vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> mines) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, cnt = <span style="color: #800080;">0</span><span style="color: #000000;">;
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; dp(N, vector&lt;<span style="color: #0000ff;">int</span>&gt;(N, <span style="color: #800080;">0</span><span style="color: #000000;">));
        unordered_set</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> s;
        </span><span style="color: #0000ff;">for</span> (auto mine : mines) s.insert(mine[<span style="color: #800080;">0</span>] * N + mine[<span style="color: #800080;">1</span><span style="color: #000000;">]);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; N; ++<span style="color: #000000;">j) {
            cnt </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; N; ++i) { <span style="color: #008000;">//</span><span style="color: #008000;"> up</span>
                cnt = s.count(i * N + j) ? <span style="color: #800080;">0</span> : cnt + <span style="color: #800080;">1</span><span style="color: #000000;">;
                dp[i][j] </span>=<span style="color: #000000;"> cnt;
            }
            cnt </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = N - <span style="color: #800080;">1</span>; i &gt;= <span style="color: #800080;">0</span>; --i) { <span style="color: #008000;">//</span><span style="color: #008000;"> down</span>
                cnt = s.count(i * N + j) ? <span style="color: #800080;">0</span> : cnt + <span style="color: #800080;">1</span><span style="color: #000000;">;
                dp[i][j] </span>=<span style="color: #000000;"> min(dp[i][j], cnt);
            }
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; N; ++<span style="color: #000000;">i) {
            cnt </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; N; ++j) { <span style="color: #008000;">//</span><span style="color: #008000;"> left</span>
                cnt = s.count(i * N + j) ? <span style="color: #800080;">0</span> : cnt + <span style="color: #800080;">1</span><span style="color: #000000;">;
                dp[i][j] </span>=<span style="color: #000000;"> min(dp[i][j], cnt);
            }
            cnt </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = N - <span style="color: #800080;">1</span>; j &gt;= <span style="color: #800080;">0</span>; --j) { <span style="color: #008000;">//</span><span style="color: #008000;"> right</span>
                cnt = s.count(i * N + j) ? <span style="color: #800080;">0</span> : cnt + <span style="color: #800080;">1</span><span style="color: #000000;">;
                dp[i][j] </span>=<span style="color: #000000;"> min(dp[i][j], cnt);
                res </span>=<span style="color: #000000;"> max(res, dp[i][j]);
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>我们可以进一步的压缩代码，使其更加简洁，我们发现其实只要分别用四个变量l，r，u，d来表示四个方向连续1的个数，既可以将for循环糅合在一起。注意里面内嵌的for循环其实是两个for循环，由j和k分别控制，那么只要弄清i，j，k坐标的位置，就可以同时更新四个方向的dp值了，最后dp数组更新好了之后，我们再秀一波，只用一个for循环来遍历二维数组，其实就是把二维坐标压缩成了一个数字，再解压缩，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> orderOfLargestPlusSign(<span style="color: #0000ff;">int</span> N, vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> mines) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; dp(N, vector&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;">(N, N));
        </span><span style="color: #0000ff;">for</span> (auto mine : mines) dp[mine[<span style="color: #800080;">0</span>]][mine[<span style="color: #800080;">1</span>]] = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; N; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">int</span> l = <span style="color: #800080;">0</span>, r = <span style="color: #800080;">0</span>, u = <span style="color: #800080;">0</span>, d = <span style="color: #800080;">0</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>, k = N - <span style="color: #800080;">1</span>; j &lt; N; ++j, --<span style="color: #000000;">k) {
                dp[i][j] </span>= min(dp[i][j], l = (dp[i][j] ? l + <span style="color: #800080;">1</span> : <span style="color: #800080;">0</span><span style="color: #000000;">));
                dp[j][i] </span>= min(dp[j][i], u = (dp[j][i] ? u + <span style="color: #800080;">1</span> : <span style="color: #800080;">0</span><span style="color: #000000;">));
                dp[i][k] </span>= min(dp[i][k], r = (dp[i][k] ? r + <span style="color: #800080;">1</span> : <span style="color: #800080;">0</span><span style="color: #000000;">));
                dp[k][i] </span>= min(dp[k][i], d = (dp[k][i] ? d + <span style="color: #800080;">1</span> : <span style="color: #800080;">0</span><span style="color: #000000;">));
            }
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> k = <span style="color: #800080;">0</span>; k &lt; N * N; ++k) res = max(res, dp[k / N][k %<span style="color: #000000;"> N]);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p>Cheapest Flights Within K Stops</p>
<p>Minimum Swaps To Make Sequences Increasing</p>
<p>Soup Servings</p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-03-30 23:28</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=8679286" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(8679286);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/8654822.html" id="cb_post_title_url">[LeetCode] Partition Labels 分割标签</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>A string <code>S</code> of lowercase letters is given. We want to partition this string into as many parts as possible so that each letter appears in at most one part, and return a list of integers representing the size of these parts.</p>
<p> </p>
<p>Example 1:</p>
<pre>Input: S = "ababcbacadefegdehijhklij"
Output: [9,7,8]
Explanation:
The partition is "ababcbaca", "defegde", "hijhklij".
This is a partition so that each letter appears in at most one part.
A partition like "ababcbacadefegde", "hijhklij" is incorrect, because it splits S into less parts.
</pre>
<p> </p>
<p>Note:</p>
<ol>
<li><code>S</code> will have length in range <code>[1, 500]</code>.</li>
<li><code>S</code> will consist of lowercase letters (<code>'a'</code> to <code>'z'</code>) only.</li>
</ol>
<p> </p>
<p>这道题给了我们一个字符串S，然我们将其尽可能多的分割为子字符串，条件是每种字符最多只能出现在一个子串中。比如题目汇总的例子，字符串S中有多个a，这些a必须只能在第一个子串中，再比如所有的字母e值出现在了第二个子串中。那么这道题的难点就是如何找到字符串的断点，即拆分成为子串的位置。我们仔细观察题目中的例子，可以发现一旦某个字母多次出现了，那么其最后一个出现位置必须要在当前子串中，字母a，e，和j，分别是三个子串中的结束字母。所以我们关注的是每个字母最后的出现位置，我们可以使用一个HashMap来建立字母和其最后出现位置之间的映射，那么对于题目中的例子来说，我们可以得到如下映射：</p>
<p>a -&gt; 8<br/>b  -&gt;  5<br/>c  -&gt;  7<br/>d  -&gt;  14<br/>e  -&gt;  15<br/>f  -&gt;  11<br/>g  -&gt;  13<br/>h  -&gt;  19<br/>i  -&gt;  22<br/>j  -&gt;  23<br/>k  -&gt;  20<br/>l  -&gt;  21</p>
<p>建立好映射之后，就需要开始遍历字符串S了，我们维护一个start变量，是当前子串的起始位置，还有一个last变量，是当前子串的结束位置，每当我们遍历到一个字母，我们需要在HashMap中提取出其最后一个位置，因为一旦当前子串包含了一个字母，其必须包含所有的相同字母，所以我们要不停的用当前字母的最后一个位置来更新last变量，只有当i和last相同了，即当i = 8时，当前子串包含了所有已出现过的字母的最后一个位置，即之后的字符串里不会有之前出现过的字母了，此时就应该是断开的位置，我们将长度9加入结果res中，同理类推，我们可以找出之后的断开的位置，参见代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; partitionLabels(<span style="color: #0000ff;">string</span><span style="color: #000000;"> S) {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">int</span> n = S.size(), start = <span style="color: #800080;">0</span>, last = <span style="color: #800080;">0</span><span style="color: #000000;">;
        unordered_map</span>&lt;<span style="color: #0000ff;">char</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> m;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++i) m[S[i]] =<span style="color: #000000;"> i;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            last </span>=<span style="color: #000000;"> max(last, m[S[i]]);
            </span><span style="color: #0000ff;">if</span> (i ==<span style="color: #000000;"> last) {
                res.push_back(i </span>- start + <span style="color: #800080;">1</span><span style="color: #000000;">);
                start </span>= i + <span style="color: #800080;">1</span><span style="color: #000000;">;
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4370601.html" target="_blank">Merge Intervals</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-03-26 23:25</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=8654822" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(8654822);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/8642157.html" id="cb_post_title_url">[LeetCode] Prime Number of Set Bits in Binary Representation 二进制表示中的非零位个数为质数</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="question-description">
<p>Given two integers <code>L</code> and <code>R</code>, find the count of numbers in the range <code>[L, R]</code> (inclusive) having a prime number of set bits in their binary representation.</p>
<p>(Recall that the number of set bits an integer has is the number of <code>1</code>s present when written in binary. For example, <code>21</code> written in binary is <code>10101</code> which has 3 set bits. Also, 1 is not a prime.)</p>
<p> </p>
<p>Example 1:</p>
<pre>Input: L = 6, R = 10
Output: 4
Explanation:
6 -&gt; 110 (2 set bits, 2 is prime)
7 -&gt; 111 (3 set bits, 3 is prime)
9 -&gt; 1001 (2 set bits , 2 is prime)
10-&gt;1010 (2 set bits , 2 is prime)
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input: L = 10, R = 15
Output: 5
Explanation:
10 -&gt; 1010 (2 set bits, 2 is prime)
11 -&gt; 1011 (3 set bits, 3 is prime)
12 -&gt; 1100 (2 set bits, 2 is prime)
13 -&gt; 1101 (3 set bits, 3 is prime)
14 -&gt; 1110 (3 set bits, 3 is prime)
15 -&gt; 1111 (4 set bits, 4 is not prime)
</pre>
<p> </p>
<p>Note:</p>
<ol>
<li><code>L, R</code> will be integers <code>L &lt;= R</code> in the range <code>[1, 10^6]</code>.</li>
<li><code>R - L</code> will be at most 10000.</li>
</ol>
<p> </p>
</div>
<p>这道题给了我们一个整数范围[L, R]，让我们统计其中有多个整数，其二进制表示中非零位个数为质数。参考题目中的例子不难理解题意，那么博主最先想到的就是暴力搜索啊，毕竟是到Easy题嘛，可能不需要太多的技巧。我们遍历整数范围[L, R]中的每一个数字，然后先统计出所有非零位个数cnt，通过和1相与，再右移一位的方式。然后就是来判断这个cnt是否是质数，判断的方法就是就是从其平方开始，一个一个的除，如果一直到2都没有约数，那么就是质数啦，结果res累加1，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> countPrimeSetBits(<span style="color: #0000ff;">int</span> L, <span style="color: #0000ff;">int</span><span style="color: #000000;"> R) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = L; i &lt;= R; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">int</span> t = i, cnt = <span style="color: #800080;">0</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">while</span> (t &gt; <span style="color: #800080;">0</span><span style="color: #000000;">) {
                </span><span style="color: #0000ff;">if</span> (t &amp; <span style="color: #800080;">1</span> == <span style="color: #800080;">1</span>) ++<span style="color: #000000;">cnt;
                t </span>&gt;&gt;= <span style="color: #800080;">1</span><span style="color: #000000;">;
            }
            </span><span style="color: #0000ff;">bool</span> succ = <span style="color: #0000ff;">true</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = sqrt(cnt); j &gt; <span style="color: #800080;">1</span>; --<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> (cnt % j == <span style="color: #800080;">0</span><span style="color: #000000;">) {
                    succ </span>= <span style="color: #0000ff;">false</span>; <span style="color: #0000ff;">break</span><span style="color: #000000;">;
                }
            }
            </span><span style="color: #0000ff;">if</span> (succ &amp;&amp; cnt != <span style="color: #800080;">1</span>) ++<span style="color: #000000;">res;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>好，下面我们来优化一下上面的解法，由于题目中给了数的大小范围 R &lt;= 10<sup>6</sup> &lt; 2<sup>20</sup>，那么我们统计出来的非零位个数cnt只需要检测是否是20以内的质数即可，所以我们将20以内的质数都放入一个HashSet中，然后统计出来cnt后，直接在HashSet中查找有没有即可，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> countPrimeSetBits(<span style="color: #0000ff;">int</span> L, <span style="color: #0000ff;">int</span><span style="color: #000000;"> R) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        unordered_set</span>&lt;<span style="color: #0000ff;">int</span>&gt; primes{<span style="color: #800080;">2</span>, <span style="color: #800080;">3</span>, <span style="color: #800080;">5</span>, <span style="color: #800080;">7</span>, <span style="color: #800080;">11</span>, <span style="color: #800080;">13</span>, <span style="color: #800080;">17</span>, <span style="color: #800080;">19</span><span style="color: #000000;">};
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = L; i &lt;= R; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">int</span> cnt = <span style="color: #800080;">0</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = i; j &gt; <span style="color: #800080;">0</span>; j &gt;&gt;= <span style="color: #800080;">1</span><span style="color: #000000;">) {
                cnt </span>+= j &amp; <span style="color: #800080;">1</span><span style="color: #000000;">;
            }
            res </span>+=<span style="color: #000000;"> primes.count(cnt);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种写法就更简洁啦，直接使用了C++的内置函数__builtin_popcount来快速的求出非零位的个数cnt，然后又利用到了20以内的数，只要不能被2和3的一定是质数，又可以快速判断了质数了，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> countPrimeSetBits(<span style="color: #0000ff;">int</span> L, <span style="color: #0000ff;">int</span><span style="color: #000000;"> R) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = L; i &lt;= R; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">int</span> cnt =<span style="color: #000000;"> __builtin_popcount(i);
            res </span>+= cnt &lt; <span style="color: #800080;">4</span> ? cnt &gt; <span style="color: #800080;">1</span> : (cnt % <span style="color: #800080;">2</span> &amp;&amp; cnt % <span style="color: #800080;">3</span><span style="color: #000000;">);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4325432.html" target="_blank">Number of 1 Bits</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-03-24 23:55</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=8642157" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(8642157);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/8606024.html" id="cb_post_title_url">[LeetCode] Special Binary String 特殊的二进制字符串</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p><em>Special</em> binary strings are binary strings with the following two properties:</p>
<p> </p>
<ul>
<li>The number of 0's is equal to the number of 1's.</li>
<li>Every prefix of the binary string has at least as many 1's as 0's.</li>
</ul>
<p> </p>
<p>Given a special string <code>S</code>, a <em>move</em> consists of choosing two consecutive, non-empty, special substrings of <code>S</code>, and swapping them. <em>(Two strings are consecutive if the last character of the first string is exactly one index before the first character of the second string.)</em></p>
<p>At the end of any number of moves, what is the lexicographically largest resulting string possible?</p>
<p>Example 1:</p>
<pre>Input: S = "11011000"
Output: "11100100"
Explanation:
The strings "10" [occuring at S[1]] and "1100" [at S[3]] are swapped.
This is the lexicographically largest string possible after some number of swaps.
</pre>
<p> </p>
<p>Note:</p>
<ol>
<li><code>S</code> has length at most <code>50</code>.</li>
<li><code>S</code> is guaranteed to be a <em>special</em> binary string as defined above.</li>
</ol>
<p> </p>
<p>11011000    -&gt;    (<span style="color: #ff0000;">()</span><span style="color: #0000ff;">(())</span>)</p>
<p>11100100    -&gt;    (<span style="color: #0000ff;">(())</span><span style="color: #ff0000;">()</span>)</p>
<p>我们发现，题目中的例子中的交换操作其实是将上面的红色部分和蓝色部分交换了，因为蓝色的部分嵌套的括号多，那么左括号就多，在前面的1就多，所以字母顺序大。所以我们要做的就是将中间的子串分别提取出来，然后排序，再放回即可。上面的这个例子相对简单一些，实际上上面的红色和蓝色部分完全可以更复杂，所以再给它们排序之前，其自身的顺序应该已经按字母顺序排好了才行，这种特点天然适合递归的思路，先递归到最里层，然后一层一层向外扩展，直至完成所有的排序。</p>
<p>好，下面我们来看递归函数的具体写法，由于我们移动的子字符串也必须是合法的，那么我们利用检测括号字符串合法性的一个最常用的方法，就是遇到左括号加1，遇到右括号-1，这样得到0的时候，就是一个合法的子字符串了。我们用变量i来统计这个合法子字符串的起始位置，字符串数组v来保存这些合法的子字符串。好了，我们开始遍历字符串S，遇到1，cnt自增1，否则自减1。当cnt为0时，我们将这个字串加入v，注意前面说过，我们需要给这个字串自身也排序，所以我们要对自身调用递归函数，我们不用对整个子串调用递归，因为字串的起始位置和结束位置是确定的，一定是1和0，我们只需对中间的调用递归即可，然后更新i为j+1。当我们将所有排序后的合法字串存入v中后，我们对v进行排序，将字母顺序大的放前面，最后将其连为一个字符串即可，参见代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> makeLargestSpecial(<span style="color: #0000ff;">string</span><span style="color: #000000;"> S) {
        </span><span style="color: #0000ff;">int</span> cnt = <span style="color: #800080;">0</span>, i = <span style="color: #800080;">0</span><span style="color: #000000;">;
        vector</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> v;
        </span><span style="color: #0000ff;">string</span> res = <span style="color: #800000;">""</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; S.size(); ++<span style="color: #000000;">j) {
            cnt </span>+= (S[j] == <span style="color: #800000;">'</span><span style="color: #800000;">1</span><span style="color: #800000;">'</span>) ? <span style="color: #800080;">1</span> : -<span style="color: #800080;">1</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> (cnt == <span style="color: #800080;">0</span><span style="color: #000000;">) {
                v.push_back(</span><span style="color: #800000;">'</span><span style="color: #800000;">1</span><span style="color: #800000;">'</span> + makeLargestSpecial(S.substr(i + <span style="color: #800080;">1</span>, j - i - <span style="color: #800080;">1</span>)) + <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span><span style="color: #000000;">);
                i </span>= j + <span style="color: #800080;">1</span><span style="color: #000000;">;
            }
        }
        sort(v.begin(), v.end(), greater</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;">());
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; v.size(); ++i) res +=<span style="color: #000000;"> v[i];
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/7617017.html">Valid Parenthesis String</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-03-19 23:56</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=8606024" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(8606024);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/8570939.html" id="cb_post_title_url">[LeetCode] Find Anagram Mappings 寻找异构映射</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given two lists <code>A </code>and <code>B</code>, and <code>B</code> is an anagram of <code>A</code>. <code>B</code> is an anagram of <code>A</code> means <code>B</code> is made by randomizing the order of the elements in <code>A</code>.</p>
<p>We want to find an <em>index mapping</em> <code>P</code>, from <code>A</code> to <code>B</code>. A mapping <code>P[i] = j</code> means the <code>i</code>th element in <code>A</code> appears in <code>B</code> at index <code>j</code>.</p>
<p>These lists <code>A</code> and <code>B</code> may contain duplicates. If there are multiple answers, output any of them.</p>
<p>For example, given</p>
<pre>A = [12, 28, 46, 32, 50]
B = [50, 12, 32, 46, 28]
</pre>
<p> </p>
<p>We should return</p>
<pre>[1, 4, 3, 2, 0]
</pre>
<p>as <code>P[0] = 1</code> because the <code>0</code>th element of <code>A</code> appears at <code>B[1]</code>, and <code>P[1] = 4</code> because the <code>1</code>st element of <code>A</code>appears at <code>B[4]</code>, and so on.</p>
<p> </p>
<p>Note:</p>
<ol>
<li><code>A, B</code> have equal lengths in range <code>[1, 100]</code>.</li>
<li><code>A[i], B[i]</code> are integers in range <code>[0, 10^5]</code>.</li>
</ol>
<p> </p>
<p>这道题给了我们两个数组A和B，说是A和B中的数字都相同，但是顺序不同，有点类似错位词的感觉。让我们找出数组A中的每个数字在数组B中的位置。这道题没有太大的难度，用个HashMap建立数组B中的每个数字和其位置之间的映射，然后遍历数组A，在HashMap中查找每个数字的位置即可，参见代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; anagramMappings(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; A, vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> B) {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> res;
        unordered_map</span>&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> m;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; B.size(); ++i) m[B[i]] =<span style="color: #000000;"> i;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span><span style="color: #000000;"> num : A) res.push_back(m[num]);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/6014408.html">Find All Anagrams in a String</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4694988.html">Valid Anagram</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4385822.html" target="_blank">Anagrams</a></p>
<p> </p>
<div class="blogpost-body" id="cnblogs_post_body">
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p>
</div></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-03-14 23:53</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=8570939" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(8570939);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/8552586.html" id="cb_post_title_url">[LeetCode] Employee Free Time 职员的空闲时间</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="question-description">
<p>We are given a list <code>schedule</code> of employees, which represents the working time for each employee.</p>
<p>Each employee has a list of non-overlapping <code>Intervals</code>, and these intervals are in sorted order.</p>
<p>Return the list of finite intervals representing common, positive-length free time for <em>all</em> employees, also in sorted order.</p>
<p>Example 1:</p>
<pre>Input: schedule = [[[1,2],[5,6]],[[1,3]],[[4,10]]]
Output: [[3,4]]
Explanation:
There are a total of three employees, and all common
free time intervals would be [-inf, 1], [3, 4], [10, inf].
We discard any intervals that contain inf as they aren't finite.
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input: schedule = [[[1,3],[6,7]],[[2,4]],[[2,5],[9,12]]]
Output: [[5,6],[7,9]]
</pre>
<p> </p>
<p>(Even though we are representing <code>Intervals</code> in the form <code>[x, y]</code>, the objects inside are <code>Intervals</code>, not lists or arrays. For example, <code>schedule[0][0].start = 1, schedule[0][0].end = 2</code>, and <code>schedule[0][0][0]</code> is not defined.)</p>
<p>Also, we wouldn't include intervals like [5, 5] in our answer, as they have zero length.</p>
<p>Note:</p>
<ol>
<li><code>schedule</code> and <code>schedule[i]</code> are lists with lengths in range <code>[1, 50]</code>.</li>
<li><code>0 &lt;= schedule[i].start &lt; schedule[i].end &lt;= 10^8</code>.</li>
</ol>
<p> </p>
</div>
<p>这道题和之前那道<a href="http://www.cnblogs.com/grandyang/p/4370601.html" target="_blank">Merge Intervals</a>基本没有太大的区别，那道题是求合并后的区间，这道题求合并后区间中间不相连的区间。那么只要我们合并好了区间，就很容易做了。那么我么首先应该给所有的区间排个序，按照起始位置从小到大来排。因为我们总不可能一会处理前面的，一会处理后面的区间。排好序以后，我们先取出第一个区间赋给t，然后开始遍历所有的区间内所有的区间，如果t的结束位置小于当前遍历到的区间i的起始位置，说明二者没有交集，那么把不相交的部分加入结果res中，然后把当前区间i赋值给t；否则如果区间t和区间i有交集，那么我们更新t的结束位置为二者中的较大值，因为按顺序遍历区间的时候，区间t的结束位置是比较的基准，越大越容易和后面的区间进行合并，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;Interval&gt; employeeFreeTime(vector&lt;vector&lt;Interval&gt;&gt;&amp;<span style="color: #000000;"> schedule) {
        vector</span>&lt;Interval&gt;<span style="color: #000000;"> res, v;
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto a : schedule) {
            v.insert(v.end(), a.begin(), a.end());
        }
        sort(v.begin(), v.end(), [](Interval </span>&amp;a, Interval &amp;b) {<span style="color: #0000ff;">return</span> a.start &lt;<span style="color: #000000;"> b.start;});
        Interval t </span>= v[<span style="color: #800080;">0</span><span style="color: #000000;">];
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (Interval i : v) {
            </span><span style="color: #0000ff;">if</span> (t.end &lt;<span style="color: #000000;"> i.start) {
                res.push_back(Interval(t.end, i.start));
                t </span>=<span style="color: #000000;"> i;
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                t </span>= (t.end &lt; i.end) ?<span style="color: #000000;"> i : t;
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>我们再来看一种解法，这种解法挺巧妙的，我们使用TreeMap建立一个位置和其出现次数之间的映射，对于起始位置，进行正累加，对于结束位置，进行负累加。由于TreeMap具有自动排序的功能，所以我们进行遍历的时候，就是从小到大进行遍历的。定义一个变量cnt，初始化为0，我们对于每个遍历到的数，都加上其在TreeMap中的映射值，即该数字出现的次数，起始位置的话就会加正数，结束位置就是加负数。开始的时候，第一个数字一定是个起始位置，那么cnt就是正数，那么接下来cnt就有可能加上正数，或者减去一个负数，我们想，如果第一个区间和第二个区间没有交集的话，那么接下来遇到的数字就是第一个区间的结束位置，所以会减去1，这样此时cnt就为0了，这说明一定会有中间区域存在，所以我们首先把第一个区间当前起始位置，结束位置暂时放上0，组成一个区间放到结果res中，这样我们在遍历到下一个区间的时候更新结果res中最后一个区间的结束位置。语言描述难免太干巴巴的，我们拿题目中的例1来说明，建立好的TreeMap如下所示：</p>
<p>1 -&gt; 2<br/>2 -&gt; -1<br/>3 -&gt; -1<br/>4 -&gt; 1<br/>5 -&gt; 1<br/>6 -&gt; -1<br/>10 -&gt; -1</p>
<p>那么开始遍历这所有的映射对，cnt首先为2，然后往后遍历下一个映射对2 -&gt; -1，此时cnt为1了，不进行其他操作，再往下遍历，下一个映射对3 -&gt; -1，此时cnt为0了，说明后面将会出现断层了，我们将(3, 0)先存入结果res中。然后遍历到4 -&gt; 1时，cnt为1，此时将结果res中的(3, 0)更新为 (3, 4)。然后到5 -&gt; 1，此时cnt为2，不进行其他操作，然后到6 -&gt; -1，此时cnt为1，不进行其他操作，然后到10 -&gt; -1，此时cnt为0，将(10, 0)加入结果res中。由于后面再没有任何区间了，所以res最后一个区间不会再被更新了，我们应该将其移出结果res，因为题目中限定了区间不能为无穷，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;Interval&gt; employeeFreeTime(vector&lt;vector&lt;Interval&gt;&gt;&amp;<span style="color: #000000;"> schedule) {
        vector</span>&lt;Interval&gt;<span style="color: #000000;"> res;
        map</span>&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> m;
        </span><span style="color: #0000ff;">int</span> cnt = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto employee : schedule) {
            </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (Interval i : employee) {
                </span>++<span style="color: #000000;">m[i.start];
                </span>--<span style="color: #000000;">m[i.end];
            }
        }
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto a : m) {
            cnt </span>+=<span style="color: #000000;"> a.second;
            </span><span style="color: #0000ff;">if</span> (!cnt) res.push_back(Interval(a.first, <span style="color: #800080;">0</span><span style="color: #000000;">));
            </span><span style="color: #0000ff;">if</span> (cnt &amp;&amp; !res.empty() &amp;&amp; !res.back().end) res.back().end =<span style="color: #000000;"> a.first;
        }
        </span><span style="color: #0000ff;">if</span> (!<span style="color: #000000;">res.empty()) res.pop_back();
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4370601.html" target="_blank">Merge Intervals</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-03-12 22:49</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=8552586" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(8552586);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/8531642.html" id="cb_post_title_url">[LeetCode] Bold Words in String 字符串中的加粗单词</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a set of keywords <code>words</code> and a string <code>S</code>, make all appearances of all keywords in <code>S</code> bold. Any letters between <code>&lt;b&gt;</code> and <code>&lt;/b&gt;</code> tags become bold.</p>
<p>The returned string should use the least number of tags possible, and of course the tags should form a valid combination.</p>
<p>For example, given that <code>words = ["ab", "bc"]</code> and <code>S = "aabcd"</code>, we should return <code>"a&lt;b&gt;abc&lt;/b&gt;d"</code>. Note that returning <code>"a&lt;b&gt;a&lt;b&gt;b&lt;/b&gt;c&lt;/b&gt;d"</code> would use more tags, so it is incorrect.</p>
<p>Note:</p>
<ol>
<li><code>words</code> has length in range <code>[0, 50]</code>.</li>
<li><code>words[i]</code> has length in range <code>[1, 10]</code>.</li>
<li><code>S</code> has length in range <code>[0, 500]</code>.</li>
<li>All characters in <code>words[i]</code> and <code>S</code> are lowercase letters.</li>
</ol>
<p> </p>
<p>这道题跟之前的那道<a href="http://www.cnblogs.com/grandyang/p/7043394.html">Add Bold Tag in String</a>是一模一样的，之前还换个马甲，这次连场景都不换了，直接照搬啊？！我也是服气的～这道题应该没有太多的技巧，就是照题目意思来就行了，我们使用一个数组bold，标记所有需要加粗的位置为true，初始化所有为false。我们首先要判断每个单词word是否是S的子串，判断的方法就是逐个字符比较，遍历字符串S，找到和word首字符相等的位置，并且比较随后和word等长的子串，如果完全相同，则将子串所有的位置在bold上比较为true。等我们知道了所有需要加粗的位置后，我们就可以来生成结果res了，我们遍历bold数组，如果当前位置是true的话，表示需要加粗，那么我们首先看如果是第一个字符，或者其前面的字符不用加粗，我们加上一个左标签&lt;b&gt;，然后我们将当前字符加入结果res中，然后再判断，如果当前是末尾字符，或者后面一个字符不用加粗，则需要加上一个右标签&lt;/b&gt;；如果当前位置是false，我们直接将字符加入结果res中即可，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> boldWords(vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp; words, <span style="color: #0000ff;">string</span><span style="color: #000000;"> S) {
        </span><span style="color: #0000ff;">int</span> n =<span style="color: #000000;"> S.size();
        </span><span style="color: #0000ff;">string</span> res = <span style="color: #800000;">""</span><span style="color: #000000;">;
        vector</span>&lt;<span style="color: #0000ff;">bool</span>&gt; bold(n, <span style="color: #0000ff;">false</span><span style="color: #000000;">);      
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">string</span><span style="color: #000000;"> word : words) {
            </span><span style="color: #0000ff;">int</span> len =<span style="color: #000000;"> word.size();
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt;= n - len; ++<span style="color: #000000;">i) {
                </span><span style="color: #0000ff;">if</span> (S[i] == word[<span style="color: #800080;">0</span>] &amp;&amp; S.substr(i, len) ==<span style="color: #000000;"> word) {
                    </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = i; j &lt; i + len; ++j) bold[j] = <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                }
            }
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (bold[i]) {
                </span><span style="color: #0000ff;">if</span> (i == <span style="color: #800080;">0</span> || !bold[i - <span style="color: #800080;">1</span>]) res += <span style="color: #800000;">"</span><span style="color: #800000;">&lt;b&gt;</span><span style="color: #800000;">"</span><span style="color: #000000;">;
                res.push_back(S[i]);
                </span><span style="color: #0000ff;">if</span> (i == n - <span style="color: #800080;">1</span> || !bold[i + <span style="color: #800080;">1</span>]) res += <span style="color: #800000;">"</span><span style="color: #800000;">&lt;/b&gt;</span><span style="color: #800000;">"</span><span style="color: #000000;">;
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                res.push_back(S[i]);
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>我们可以用HashSet来代替数组，只是将需要加粗的位置放入HashSet，然后我们在生成结果res的时候，先检测当前位置是否加粗，如果加粗了，并且前一个位置不在HashSet中，这样就不用判断是否是第一个元素了，因为i-1肯定不再HashSet中，也不像数组那样存在越界的可能，我们给结果res加上左标签，然后将当前的字符加入结果res中，然后再判断如果当前位置如果加粗了，并且下一个位置不在HashSet中，我们给结果res加上右标签，参见代码如下： </p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> boldWords(vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp; words, <span style="color: #0000ff;">string</span><span style="color: #000000;"> S) {
        </span><span style="color: #0000ff;">int</span> n =<span style="color: #000000;"> S.size();
        </span><span style="color: #0000ff;">string</span> res = <span style="color: #800000;">""</span><span style="color: #000000;">;
        unordered_set</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> bold;      
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">string</span><span style="color: #000000;"> word : words) {
            </span><span style="color: #0000ff;">int</span> len =<span style="color: #000000;"> word.size();
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt;= n - len; ++<span style="color: #000000;">i) {
                </span><span style="color: #0000ff;">if</span> (S[i] == word[<span style="color: #800080;">0</span>] &amp;&amp; S.substr(i, len) ==<span style="color: #000000;"> word) {
                    </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = i; j &lt; i + len; ++<span style="color: #000000;">j) bold.insert(j);
                }
            }
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (bold.count(i) &amp;&amp; !bold.count(i - <span style="color: #800080;">1</span>)) res += <span style="color: #800000;">"</span><span style="color: #800000;">&lt;b&gt;</span><span style="color: #800000;">"</span><span style="color: #000000;">;
            res.push_back(S[i]);
            </span><span style="color: #0000ff;">if</span> (bold.count(i) &amp;&amp; !bold.count(i + <span style="color: #800080;">1</span>)) res += <span style="color: #800000;">"</span><span style="color: #800000;">&lt;/b&gt;</span><span style="color: #800000;">"</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>前面提到了这道题跟<a href="http://www.cnblogs.com/grandyang/p/7043394.html">Add Bold Tag in String</a>是完全一样，那么当然二者的解法是互通的，下面的解法是之前那道题中的解法，其实整体思路是一样的，只不过在构建的bold数组的时候，是先遍历的字符串S，而不是先遍历的单词。对于字符串S中的每个字符为起点，我们都遍历下所有单词，如果某个单词是以当前字符为起点的子串的话，那么我们用i+len来更新end，所以遍历完所有单词后，只要当前位置需要加粗，那么end一定大于i，通过这种方法同样也可以生成正确的bold数组。然后在创建结果res字符串的时候也跟上面的方法有些不同，首先判断，如果当前未被加粗，那么将当前字符存入结果res中并且continue，否则开始找相连的需要加粗的位置，用j来指向下一个不用加粗的位置，这样中间的子串就可以放入标签中整体加到res中，然后继续在后面查找连续加粗的子串，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> boldWords(vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp; words, <span style="color: #0000ff;">string</span><span style="color: #000000;"> S) {
        </span><span style="color: #0000ff;">int</span> n = S.size(), end = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">string</span> res = <span style="color: #800000;">""</span><span style="color: #000000;">;
        vector</span>&lt;<span style="color: #0000ff;">bool</span>&gt; bold(n, <span style="color: #0000ff;">false</span><span style="color: #000000;">);      
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">string</span><span style="color: #000000;"> word : words) {
                </span><span style="color: #0000ff;">int</span> len =<span style="color: #000000;"> word.size();
                </span><span style="color: #0000ff;">if</span> (i + len &lt;= n &amp;&amp; S.substr(i, len) ==<span style="color: #000000;"> word) {
                    end </span>= max(end, i +<span style="color: #000000;"> len);
                }
            }
            bold[i] </span>= end &gt;<span style="color: #000000;"> i;
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (!<span style="color: #000000;">bold[i]) {
                res.push_back(S[i]);
                </span><span style="color: #0000ff;">continue</span><span style="color: #000000;">;
            }
            </span><span style="color: #0000ff;">int</span> j =<span style="color: #000000;"> i;
            </span><span style="color: #0000ff;">while</span> (j &lt; n &amp;&amp; bold[j]) ++<span style="color: #000000;">j;
            res </span>+= <span style="color: #800000;">"</span><span style="color: #800000;">&lt;b&gt;</span><span style="color: #800000;">"</span> + S.substr(i, j - i) + <span style="color: #800000;">"</span><span style="color: #800000;">&lt;/b&gt;</span><span style="color: #800000;">"</span><span style="color: #000000;">;
            i </span>= j - <span style="color: #800080;">1</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/7043394.html">Add Bold Tag in String</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a> </p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-03-08 23:54</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=8531642" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(8531642);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/8503476.html" id="cb_post_title_url">[LeetCode] Set Intersection Size At Least Two 设置交集大小至少为2</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>An integer interval <code>[a, b]</code> (for integers <code>a &lt; b</code>) is a set of all consecutive integers from <code>a</code> to <code>b</code>, including <code>a</code> and <code>b</code>.</p>
<p>Find the minimum size of a set S such that for every integer interval A in <code>intervals</code>, the intersection of S with A has size at least 2.</p>
<p>Example 1:</p>
<pre>Input: intervals = [[1, 3], [1, 4], [2, 5], [3, 5]]
Output: 3
Explanation:
Consider the set S = {2, 3, 4}.  For each interval, there are at least 2 elements from S in the interval.
Also, there isn't a smaller size set that fulfills the above condition.
Thus, we output the size of this set, which is 3.
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input: intervals = [[1, 2], [2, 3], [2, 4], [4, 5]]
Output: 5
Explanation:
An example of a minimum sized set is {1, 2, 3, 4, 5}.
</pre>
<p> </p>
<p>Note:</p>
<ol>
<li><code>intervals</code> will have length in range <code>[1, 3000]</code>.</li>
<li><code>intervals[i]</code> will have length <code>2</code>, representing some integer interval.</li>
<li><code>intervals[i][j]</code> will be an integer in <code>[0, 10^8]</code>.</li>
</ol>
<p> </p>
<p>这道题给了我们一些区间，让我们求一个集合S，使得S和每个区间的交集至少为2，即至少有两个相同的数字。博主最开始分析题目中的例子的时候，以为要求的集合S也必须是一个连续的区间，其实不需要的，离散的数字就可以了。比如如果区间是[1,3], [5,6]的话，那么返回的集合长度是4，而不是5。这道题可以是用贪婪算法来解，一般来说Hard的题目能用贪婪算法而不是DP解的是少之又少，这道题为我大Greedy算法正名了～！为了使得集合S中的数字尽可能的小，我们希望处理区间的时候从小区间开始，如果区间b完全覆盖了区间a，那么和区间a有两个相同数字的集合，一定和区间b也有两个相同数字。同样，我们不希望一会处理一个前面的区间，一会又处理一个很后面的区间，我们希望区间是有序的。那么如何给区间排序呢，是按起始位置排，还是按结束位置排，这里我们按结束位置从小往大排，当两个结束位置相同时，起始位置大的排前面先处理，这也符合我们先处理小区间的原则。那么遍历区间的时候，当前区间就和我们维护的集合S有三种情况：</p>
<p>1. 二者完全没有交集，这时候我们就需要从当前区间中取出两个数字加入集合S，取哪两个数呢？为了尽可能少使用数字，我们取当前区间中的最大两个数字，因为我们区间位置不断变大，所以取大的数字有更高的概率能和后面的区间有交集。</p>
<p>2. 二者有一个数字的交集，那么这个交集数字一定是区间的起始位置，那么我们需要从当前区间中再取一个数字加入集合S，根据上面的分析，我们取最大的那个数，即区间的结束位置。</p>
<p>3. 二者有两个及两个以上数字的交集，那么不用做任何处理。</p>
<p>好，分析到这里，代码也就不难写出来了，我们用个数组v来表示集合S，初始化放两个-1进去，因为题目中说明了区间都是大于0的，所以我们放这两个数组进去是为了防止越界的，不会有任何影响，最后统计长度的时候减去这个两个数字就可以了。先给区间排序，然后遍历每个区间，如果区间的起始位置小于等于数组的倒数第二个数字，说明此时已经有两个相同的数字了，直接跳过当前区间。否则如果区间的起始位置大于数组的最后一个位置，说明二者没有任何交集，我们此时先把区间的倒数第二小的数字加入数组v中。然后统一再把区间的结束位置加入数组v中，因为不管区间和数组有一个交集还是没有任何交集，结束位置都要加入数组中，所以不用放在if..else..中。最后循环结束，返回数组的大小减2，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> intersectionSizeTwo(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> intervals) {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; v{-<span style="color: #800080;">1</span>, -<span style="color: #800080;">1</span><span style="color: #000000;">};
        sort(intervals.begin(), intervals.end(), [](vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;&amp; a, vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> b){
            </span><span style="color: #0000ff;">return</span> a[<span style="color: #800080;">1</span>] &lt; b[<span style="color: #800080;">1</span>] || (a[<span style="color: #800080;">1</span>] == b[<span style="color: #800080;">1</span>] &amp;&amp; a[<span style="color: #800080;">0</span>] &gt; b[<span style="color: #800080;">0</span><span style="color: #000000;">]);
        });
        </span><span style="color: #0000ff;">for</span> (auto &amp;<span style="color: #000000;">interval : intervals) {
            </span><span style="color: #0000ff;">int</span> len =<span style="color: #000000;"> v.size();
            </span><span style="color: #0000ff;">if</span> (interval[<span style="color: #800080;">0</span>] &lt;= v[len - <span style="color: #800080;">2</span>]) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> (interval[<span style="color: #800080;">0</span>] &gt; v.back()) v.push_back(interval[<span style="color: #800080;">1</span>] - <span style="color: #800080;">1</span><span style="color: #000000;">);
            v.push_back(interval[</span><span style="color: #800080;">1</span><span style="color: #000000;">]);
        }
        </span><span style="color: #0000ff;">return</span> v.size() - <span style="color: #800080;">2</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>我们可以对空间复杂度进行优化，我们不用保存整个集合S，因为结果只让我们返回长度即可，所以我们用两个变量p1和p2，其中p1表示集合S中倒数第二大的数字，p2为集合S中最大的数字。我们的整个逻辑跟上面的解法是相同的。遍历区间的时候，如果区间的起始位置小于等于p1，则跳过当前区间。否则如果起始位置大于p2，说明没有交集，需要加上两个数字，结果res自增2，然后p2赋值为当前区间的结束位置，p1赋值为第二大的数字。否则说明只有一个交集，结果res自增1，然后p1赋值为p2，p2赋值为当前区间的结束位置即可，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> intersectionSizeTwo(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> intervals) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, p1 = -<span style="color: #800080;">1</span>, p2 = -<span style="color: #800080;">1</span><span style="color: #000000;">;
        sort(intervals.begin(), intervals.end(), [](vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;&amp; a, vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> b){
            </span><span style="color: #0000ff;">return</span> a[<span style="color: #800080;">1</span>] &lt; b[<span style="color: #800080;">1</span>] || (a[<span style="color: #800080;">1</span>] == b[<span style="color: #800080;">1</span>] &amp;&amp; a[<span style="color: #800080;">0</span>] &gt; b[<span style="color: #800080;">0</span><span style="color: #000000;">]);
        });
        </span><span style="color: #0000ff;">for</span> (auto &amp;<span style="color: #000000;">interval : intervals) {
            </span><span style="color: #0000ff;">if</span> (interval[<span style="color: #800080;">0</span>] &lt;= p1) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> (interval[<span style="color: #800080;">0</span>] &gt;<span style="color: #000000;"> p2) {
                res </span>+= <span style="color: #800080;">2</span><span style="color: #000000;">;
                p2 </span>= interval[<span style="color: #800080;">1</span><span style="color: #000000;">];
                p1 </span>= p2 - <span style="color: #800080;">1</span><span style="color: #000000;">;
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                </span>++<span style="color: #000000;">res;
                p1 </span>=<span style="color: #000000;"> p2;
                p2 </span>= interval[<span style="color: #800080;">1</span><span style="color: #000000;">];
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>讨论：这道题的一个拓展就是一般化，改为交集大小至少为k，那么我们该怎么做呢？其实也不是很难，我们可以在解法一的基础上进行修改，我们还是用数组v来表示集合S，只不过我们初始化加入k个-1。然后还是要给区间排序，之后进行遍历，如果起始位置小于等于倒数第k个数，跳过当前区间。然后就是重点部分了，我们还是用起始位置跟数组v的最后面的数字比较，总共比到倒数第k-1个数就行了，因为小于等于倒数第k个数已经跳过了。如果大于最后一个数，则将区间后k个数加入数组；否则如果大于倒数第二个数，则将区间后k-1个数加入数组；否则如果大于倒数第三个数，则将数组后k-2个数加入数组，以此类推，直到比完倒数第k-1个数就行了，最后返回的是数组v的长度减去k。</p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-03-03 23:20</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=8503476" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(8503476);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/8476646.html" id="cb_post_title_url">[LeetCode] Pyramid Transition Matrix 金字塔转变矩阵</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>We are stacking blocks to form a pyramid. Each block has a color which is a one letter string, like `'Z'`.</p>
<p>For every block of color `C` we place not in the bottom row, we are placing it on top of a left block of color `A` and right block of color `B`. We are allowed to place the block there only if `(A, B, C)` is an allowed triple.</p>
<p>We start with a bottom row of <code>bottom</code>, represented as a single string. We also start with a list of allowed triples <code>allowed</code>. Each allowed triple is represented as a string of length 3.</p>
<p>Return true if we can build the pyramid all the way to the top, otherwise false.</p>
<p>Example 1:</p>
<pre>Input: bottom = "XYZ", allowed = ["XYD", "YZE", "DEA", "FFF"]
Output: true
Explanation:
We can stack the pyramid like this:
    A
   / \
  D   E
 / \ / \
X   Y   Z

This works because ('X', 'Y', 'D'), ('Y', 'Z', 'E'), and ('D', 'E', 'A') are allowed triples.
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input: bottom = "XXYX", allowed = ["XXX", "XXY", "XYX", "XYY", "YXZ"]
Output: false
Explanation:
We can't stack the pyramid to the top.
Note that there could be allowed triples (A, B, C) and (A, B, D) with C != D.
</pre>
<p> </p>
<p>Note:</p>
<ol>
<li><code>bottom</code> will be a string with length in range <code>[2, 8]</code>.</li>
<li><code>allowed</code> will have length in range <code>[0, 200]</code>.</li>
<li>Letters in all strings will be chosen from the set <code>{'A', 'B', 'C', 'D', 'E', 'F', 'G'}</code>.</li>
</ol>
<p> </p>
<p>这道题让我们累一个金字塔，用字母来代表每块砖的颜色，给了一个allowed数组，里面都是长度为三的字符串，比如“ABC”表示C可以放在A和B的上方，注意AB上面也可以放其他的，比如“ABD”也可以同时出现，不过搭积木的时候只能选择一种。给了我们一个bottom字符串，是金字塔的底层，问我们能不能搭出一个完整的金字塔。那么实际上我们就是从底层开始，一层一层的向上来累加，直到搭出整个金字塔。我们先来看递归的解法，首先由于我们想快速知道两个字母上方可以放的字母，需要建立基座字符串和上方字符集合之间的映射，由于上方字符可以不唯一，所以用个HashSet来放字符。我们的递归函数有三个参数，当前层字符串cur，上层字符串above，还有我们的HashMap。如果cur的大小为2，above的大小为1，那么说明当前已经达到金字塔的顶端了，已经搭出来了，直接返回true。否则看，如果上一层的长度比当前层的长度正好小一个，说明上一层也搭好了，我们现在去搭上上层，于是调用递归函数，将above当作当前层，空字符串为上一层，将调用的递归函数结果直接返回。否则表示我们还需要继续去搭above层，我们先算出above层的长度pos，然后从当前层的pos位置开始取两个字符，就是above层接下来需要搭的字符的基座字符，举个例子如下：</p>
<pre>  D   
 / \ / \
A   B   C</pre>
<p>我们看到现在above层只有一个D，那么pos为1，在cur层1位置开始取两个字符，得到"BC"，即是D的下一个位置的字符的基座字符串base。取出了base后，如果HashMap中有映射，则我们遍历其映射的字符集合中的所有字符，对每个字符都调用递归函数，此时above字符串需要加上这个遍历到的字符，因为我们在尝试填充这个位置，如果有返回true的，那么当前递归函数就返回true了，否则最终返回false，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> pyramidTransition(<span style="color: #0000ff;">string</span> bottom, vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp;<span style="color: #000000;"> allowed) {   
        unordered_map</span>&lt;<span style="color: #0000ff;">string</span>, unordered_set&lt;<span style="color: #0000ff;">char</span>&gt;&gt;<span style="color: #000000;"> m;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">string</span><span style="color: #000000;"> str : allowed) {
            m[str.substr(</span><span style="color: #800080;">0</span>, <span style="color: #800080;">2</span>)].insert(str[<span style="color: #800080;">2</span><span style="color: #000000;">]);
        }
        </span><span style="color: #0000ff;">return</span> helper(bottom, <span style="color: #800000;">""</span><span style="color: #000000;">, m);
    }
    </span><span style="color: #0000ff;">bool</span> helper(<span style="color: #0000ff;">string</span> cur, <span style="color: #0000ff;">string</span> above, unordered_map&lt;<span style="color: #0000ff;">string</span>, unordered_set&lt;<span style="color: #0000ff;">char</span>&gt;&gt;&amp;<span style="color: #000000;"> m) {
        </span><span style="color: #0000ff;">if</span> (cur.size() == <span style="color: #800080;">2</span> &amp;&amp; above.size() == <span style="color: #800080;">1</span>) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (above.size() == cur.size() - <span style="color: #800080;">1</span>) <span style="color: #0000ff;">return</span> helper(above, <span style="color: #800000;">""</span><span style="color: #000000;">, m);
        </span><span style="color: #0000ff;">int</span> pos =<span style="color: #000000;"> above.size();
        </span><span style="color: #0000ff;">string</span> <span style="color: #0000ff;">base</span> = cur.substr(pos, <span style="color: #800080;">2</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">if</span> (m.count(<span style="color: #0000ff;">base</span><span style="color: #000000;">)) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span> ch : m[<span style="color: #0000ff;">base</span><span style="color: #000000;">]) {
                </span><span style="color: #0000ff;">if</span> (helper(cur, above + <span style="color: #0000ff;">string</span>(<span style="color: #800080;">1</span><span style="color: #000000;">, ch), m)) {
                    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                }
            }
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>下面来看一种迭代的写法，这是一种DP的解法，建立一个三维的dp数组，其中dp[i][j][ch]表示在金字塔(i, j)位置上是否可以放字符ch，金字塔的宽和高已经确定了，都是n。每个位置对应着nxn的数组的左半边，如下所示：</p>
<p>F _ _<br/>D E _<br/>A B C</p>
<p>除了底层，每个位置可能可以放多个字符，所以这里dp数组是一个三维数组，第三维的长度为7，因为题目中限定了字母只有A到G共7个，如果dp值为true，表示该位置放该字母，我们根据bottom字符串来初始化dp数组的底层。这里还是需要一个HashMap，不过跟上面的解法略有不同的是，我们建立上方字母跟其能放的基座字符串集合的映射，因为一个字母可能可以放多个位置，所以用个集合来表示。然后我们就开始从倒数第二层开始往顶部更新啦，对于金字塔的每个位置，我们都遍历A到G中所有的字母，如果当前字母在HashMap中有映射，则我们遍历对应的基座字符串集合中的所有字符串，基座字符串共有两个字母，左边的字母对应的金字塔中的位置是(i + 1, j)，右边的字母对应的位置是(i + 1, j + 1)，我们只要在这两个位置上分别查询对应的字母的dp值是否为true，是的话，说明当前位置有字母可以放，我们将当前位置的字母对应的dp值赋值为true。这样，当我们整个更新完成了之后，我们只要看金字塔顶端位置(0, 0)是否有字母可以放，有的话，说明可以搭出金字塔，返回true，否则返回false，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> pyramidTransition(<span style="color: #0000ff;">string</span> bottom, vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp;<span style="color: #000000;"> allowed) {
        </span><span style="color: #0000ff;">int</span> n =<span style="color: #000000;"> bottom.size();
        vector</span>&lt;vector&lt;vector&lt;<span style="color: #0000ff;">bool</span>&gt;&gt;&gt; dp(n, vector&lt;vector&lt;<span style="color: #0000ff;">bool</span>&gt;&gt;(n, vector&lt;<span style="color: #0000ff;">bool</span>&gt;(<span style="color: #800080;">7</span>, <span style="color: #0000ff;">false</span><span style="color: #000000;">)));
        unordered_map</span>&lt;<span style="color: #0000ff;">char</span>, unordered_set&lt;<span style="color: #0000ff;">string</span>&gt;&gt;<span style="color: #000000;"> m;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">string</span><span style="color: #000000;"> str : allowed) {
            m[str[</span><span style="color: #800080;">2</span>]].insert(str.substr(<span style="color: #800080;">0</span>, <span style="color: #800080;">2</span><span style="color: #000000;">));
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            dp[n </span>- <span style="color: #800080;">1</span>][i][bottom[i] - <span style="color: #800000;">'</span><span style="color: #800000;">A</span><span style="color: #800000;">'</span>] = <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = n - <span style="color: #800080;">2</span>; i &gt;= <span style="color: #800080;">0</span>; --<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt;= i; ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span> ch = <span style="color: #800000;">'</span><span style="color: #800000;">A</span><span style="color: #800000;">'</span>; ch &lt;= <span style="color: #800000;">'</span><span style="color: #800000;">G</span><span style="color: #800000;">'</span>; ++<span style="color: #000000;">ch) {
                    </span><span style="color: #0000ff;">if</span> (!m.count(ch)) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">string</span><span style="color: #000000;"> str : m[ch]) {
                        </span><span style="color: #0000ff;">if</span> (dp[i + <span style="color: #800080;">1</span>][j][str[<span style="color: #800080;">0</span>] - <span style="color: #800000;">'</span><span style="color: #800000;">A</span><span style="color: #800000;">'</span>] &amp;&amp; dp[i + <span style="color: #800080;">1</span>][j + <span style="color: #800080;">1</span>][str[<span style="color: #800080;">1</span>] - <span style="color: #800000;">'</span><span style="color: #800000;">A</span><span style="color: #800000;">'</span><span style="color: #000000;">]) {
                            dp[i][j][ch </span>- <span style="color: #800000;">'</span><span style="color: #800000;">A</span><span style="color: #800000;">'</span>] = <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                        }
                    }
                }
            }
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; <span style="color: #800080;">7</span>; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (dp[<span style="color: #800080;">0</span>][<span style="color: #800080;">0</span>][i]) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-02-26 23:19</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=8476646" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(8476646);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/8460541.html" id="cb_post_title_url">[LeetCode] Pour Water 倒水</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>We are given an elevation map, <code>heights[i]</code> representing the height of the terrain at that index. The width at each index is 1. After <code>V</code> units of water fall at index <code>K</code>, how much water is at each index?</p>
<p>Water first drops at index <code>K</code> and rests on top of the highest terrain or water at that index. Then, it flows according to the following rules:</p>
<ul>
<li>If the droplet would eventually fall by moving left, then move left.</li>
<li>Otherwise, if the droplet would eventually fall by moving right, then move right.</li>
<li>Otherwise, rise at it's current position.</li>
</ul>
<p>Here, "eventually fall" means that the droplet will eventually be at a lower level if it moves in that direction. Also, "level" means the height of the terrain plus any water in that column.</p>
<p> </p>
<p>We can assume there's infinitely high terrain on the two sides out of bounds of the array. Also, there could not be partial water being spread out evenly on more than 1 grid block - each unit of water has to be in exactly one block.</p>
<p> </p>
<p>Example 1:</p>
<pre>Input: heights = [2,1,1,2,1,2,2], V = 4, K = 3
Output: [2,2,2,3,2,2,2]
Explanation:
#       #
#       #
##  # ###
#########
 0123456    &lt;- index

The first drop of water lands at index K = 3:

#       #
#   w   #
##  # ###
#########
 0123456    

When moving left or right, the water can only move to the same level or a lower level.
(By level, we mean the total height of the terrain plus any water in that column.)
Since moving left will eventually make it fall, it moves left.
(A droplet "made to fall" means go to a lower height than it was at previously.)

#       #
#       #
## w# ###
#########
 0123456    

Since moving left will not make it fall, it stays in place.  The next droplet falls:

#       #
#   w   #
## w# ###
#########
 0123456  

Since the new droplet moving left will eventually make it fall, it moves left.
Notice that the droplet still preferred to move left,
even though it could move right (and moving right makes it fall quicker.)

#       #
#  w    #
## w# ###
#########
 0123456  

#       #
#       #
##ww# ###
#########
 0123456  

After those steps, the third droplet falls.
Since moving left would not eventually make it fall, it tries to move right.
Since moving right would eventually make it fall, it moves right.

#       #
#   w   #
##ww# ###
#########
 0123456  

#       #
#       #
##ww#w###
#########
 0123456  

Finally, the fourth droplet falls.
Since moving left would not eventually make it fall, it tries to move right.
Since moving right would not eventually make it fall, it stays in place:

#       #
#   w   #
##ww#w###
#########
 0123456  

The final answer is [2,2,2,3,2,2,2]:

    #    
 ####### 
 ####### 
 0123456 
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input: heights = [1,2,3,4], V = 2, K = 2
Output: [2,3,3,4]
Explanation:
The last droplet settles at index 1, since moving further left would not cause it to eventually fall to a lower height.
</pre>
<p> </p>
<p>Example 3:</p>
<pre>Input: heights = [3,1,3], V = 5, K = 1
Output: [4,4,4]
</pre>
<p> </p>
<p>Note:</p>
<ol>
<li><code>heights</code> will have length in <code>[1, 100]</code> and contain integers in <code>[0, 99]</code>.</li>
<li><code>V</code> will be in range <code>[0, 2000]</code>.</li>
<li><code>K</code> will be in range <code>[0, heights.length - 1]</code>.</li>
</ol>
<p> </p>
<p>这道题说有不同高度的地面，每次都位置K有水滴落下，水滴落下后移动的方向有如下的规则：</p>
<p>1. 如果水滴向左移动后最终停止的位置低于落下的位置，则向左移动。</p>
<p>2. 否则若水滴向右移动后最终停止的位置低于落下的位置，则向右移动。</p>
<p>3. 否则停在原来的位置。</p>
<p>水滴停止后，原来的位置高度就增加1，让我们返回最后地面的高度。我们首先来分析题目中的例子1:</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">#       #
#   </span><span style="color: #800080;">4</span><span style="color: #000000;">   #
##</span><span style="color: #800080;">21</span><span style="color: #ff0000;">#</span><span style="color: #800080;">3</span><span style="color: #000000;">###
###<span style="color: #ff0000;"><span style="color: #000000;">#</span>#</span>####</span></pre>
</div>
<p>我们可以观察出，如果左边到的位置低的话，就先去左边，即便右边能到同样低的位置，也还是左边优先。但是这个例子没能说明，如果右边的位置更低的话，是去右边呢，还是左边，看下面这个例子：</p>
<div class="cnblogs_code">
<pre> <span style="color: #800080;">54</span><span style="color: #000000;">#     #
</span><span style="color: #800080;">32</span><span style="color: #000000;"><span style="color: #ff0000;">#</span>##   ###
</span><span style="color: #800080;">1</span><span style="color: #000000;">#<span style="color: #ff0000;">#</span>### #####
##<span style="color: #ff0000;">#</span>##########</span></pre>
</div>
<p>红色表示水滴落下的位置，我们可以看到第五滴水没有去右边更低的地方，而是去了左边的位置，这说明，左边有至高优先权，只要左边的最终位置低于水滴落下的位置，一定会去左边。</p>
<p>还有就是，去一个方向最终要落到一个局部最低点，请看下面这个例子：</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;"><span style="color: #ff0000;">#</span>
<span style="color: #ff0000;">#</span>##</span><span style="color: #800080;">1</span><span style="color: #000000;"># #
<span style="color: #ff0000;">#</span>#### #
<span style="color: #ff0000;">#</span>######</span></pre>
</div>
<p>我们可以看到，水滴去了右边第一个局部最低点，而再右边的全局最低点是无法到达的。如果都是一样的高度的话，落在离水滴落下起始位置最近的点，请看下下面这两个例子：</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;"><span style="color: #ff0000;">#</span>
<span style="color: #ff0000;">#</span>##</span><span style="color: #800080;">1</span><span style="color: #000000;">#
<span style="color: #ff0000;">#</span>####</span></pre>
</div>
<div class="cnblogs_code">
<pre><span style="color: #ff0000;">#</span><span style="color: #800080;">1</span><span style="color: #000000;"><span style="color: #ff0000;">
#</span>####
<span style="color: #ff0000;">#</span>####</span></pre>
</div>
<p>第一个例子中水滴去了局部最低点，第二个例子中由于右边的高度都相同，水滴去了最靠近起始位置的点。</p>
<p>那么分析到这里，我想思路应该比较明晰了吧。首先我们尝试向左走，找到第一个局部最低点，停止条件是左边的高度大于当前高度，但是为了防止出现大家高度都一样而需要停止在靠近起始点位置的情况，我们来一个回滚操作，就是只要和右边的高度一样，就一直往右滚。同样，在尝试向右走，找第一个局部最低点，停止条件是右边的高度大于当前高度，但是为了防止出现大家高度都一样而需要停止在靠近起始点位置的情况，我们也来一个回滚操作，就是只要和左边的高度一样，就一直往左滚。那么此时我们来做比较，如果左边的局部最低点小于雨滴落下位置的高度，那么左边局部最低点高度自增1。否则如果右边的局部最低点高度小于雨滴落下位置的高度，则右边局部最低点高度自增1。如果左右高度都一样，则雨滴落下位置的高度自增1，参见代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; pourWater(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; heights, <span style="color: #0000ff;">int</span> V, <span style="color: #0000ff;">int</span><span style="color: #000000;"> K) {
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; V; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">int</span> l = K, r = K, n =<span style="color: #000000;"> heights.size();
            </span><span style="color: #0000ff;">while</span> (l &gt; <span style="color: #800080;">0</span> &amp;&amp; heights[l] &gt;= heights[l - <span style="color: #800080;">1</span>]) --<span style="color: #000000;">l;
            </span><span style="color: #0000ff;">while</span> (l &lt; K &amp;&amp; heights[l] == heights[l + <span style="color: #800080;">1</span>]) ++<span style="color: #000000;">l;
            </span><span style="color: #0000ff;">while</span> (r &lt; n - <span style="color: #800080;">1</span> &amp;&amp; heights[r] &gt;= heights[r + <span style="color: #800080;">1</span>]) ++<span style="color: #000000;">r;
            </span><span style="color: #0000ff;">while</span> (r &gt; K &amp;&amp; heights[r] == heights[r - <span style="color: #800080;">1</span>]) --<span style="color: #000000;">r;
            (heights[l] </span>&lt; heights[K]) ? ++heights[l] : ++<span style="color: #000000;">heights[r];
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> heights;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4402392.html" target="_blank">Trapping Rain Water</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-02-22 23:36</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=8460541" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(8460541);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/8456022.html" id="cb_post_title_url">[LeetCode] Reach a Number 达到一个数字</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>You are standing at position <code>0</code> on an infinite number line. There is a goal at position <code>target</code>.</p>
<p>On each move, you can either go left or right. During the <em>n</em>-th move (starting from 1), you take <em>n</em> steps.</p>
<p>Return the minimum number of steps required to reach the destination.</p>
<p>Example 1:</p>
<pre>Input: target = 3
Output: 2
Explanation:
On the first move we step from 0 to 1.
On the second step we step from 1 to 3.
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input: target = 2
Output: 3
Explanation:
On the first move we step from 0 to 1.
On the second move we step  from 1 to -1.
On the third move we step from -1 to 2.
</pre>
<p> </p>
<p>Note:</p>
<ul>
<li><code>target</code> will be a non-zero integer in the range <code>[-10^9, 10^9]</code>.</li>
</ul>
<p> </p>
<p>这道题让我们从起点0开始，每次可以向数轴的左右两个方向中的任意一个走，第一步走距离1，第二步走距离2，以此类推，第n步走距离n，然后给了我们一个目标值target，问我们最少用多少步可以到达这个值。博主分析了给的两个例子后，开始想的是用贪婪算法来做，就是如果加上距离大于目标值的话，就减去这个距离，到是当目标值是4的话，贪婪算法会fail。后来博主尝试用BFS来做，就是每次都把当前能到大的所有的点，都加上和减去当前距离，形成新的位置，加入数组中，当某个新的位置达到目标值时返回，但是这种解法会TLE，当目标值很大的话，相当的不高效。其实这道题的正确解法用到了些数学知识，还有一些小trick，首先来说说小trick，第一个trick是到达target和-target的步数相同，因为数轴是对称的，只要将到达target的没步的距离都取反，就能到达-target。下面来说第二个trick，这个是解题的关键，比如说目标值是4，那么如果我们一直累加步数，直到其正好大于等于target时，有：</p>
<p>0 + 1 = 1</p>
<p>1 + 2 = 3</p>
<p>3 + 3 = 6</p>
<p>第三步加上3，得到了6，超过了目标值4，超过了的距离为2，是偶数，那么实际上我们只要将加上距离为1的时候，不加1，而是加-1，那么此时累加和就损失了2，那么正好能到目标值4，如下：</p>
<p>0 - 1 = -1</p>
<p>-1 + 2 = 1</p>
<p>1 + 3 = 4</p>
<p>那么，我们的第二个trick就是，当超过目标值的差值d为偶数时，只要将第d/2步的距离取反，就能得到目标值，此时的步数即为到达目标值的步数。那么，如果d为奇数时，且当前为第n步，那么我们看下一步n+1的奇偶，如果n+1为奇数，那么加上n+1再做差，得到的差值就为偶数了，问题解决，如果n+1为偶数，那么还得加上n+2这个奇数，才能让差值为偶数，这样就多加了两步。分析到这里，我们的解题思路也就明晰了吧：</p>
<p>我们先对target取绝对值，因为正负不影响最小步数。然后我们求出第n步，使得从1累加到n刚好大于等于target，我们可以反向利用求和公式，来求解出n，然后算出当前n的累加和sum，如果此时sum和target正好相等，perfect！直接返回n，否则就是计算差值，如果差值时偶数，那么也直接返回n，如果是奇数，判断此时n的奇偶，如果n是奇数，则返回n+2，若n是偶数，返回n+1，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> reachNumber(<span style="color: #0000ff;">int</span><span style="color: #000000;"> target) {
        target </span>=<span style="color: #000000;"> abs(target);
        </span><span style="color: #0000ff;">long</span> n = ceil((-<span style="color: #800080;">1.0</span> + sqrt(<span style="color: #800080;">1</span> + <span style="color: #800080;">8.0</span> * target)) / <span style="color: #800080;">2</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">long</span> sum = n * (n + <span style="color: #800080;">1</span>) / <span style="color: #800080;">2</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (sum == target) <span style="color: #0000ff;">return</span><span style="color: #000000;"> n;
        </span><span style="color: #0000ff;">long</span> res = sum -<span style="color: #000000;"> target;
        </span><span style="color: #0000ff;">if</span> ((res &amp; <span style="color: #800080;">1</span>) == <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;"> n;
        </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">return</span> n + ((n &amp; <span style="color: #800080;">1</span>) ? <span style="color: #800080;">2</span> : <span style="color: #800080;">1</span><span style="color: #000000;">);
    }
};</span></pre>
</div>
<p> </p>
<p>我们也可以不用求和公式来快速定位n，而是通过累加来做，res为我们的当前步数，也是最终需要返回的结果，sum是加上每步距离的累加值，如果sum小于target，或者sum减去target的差值为奇数，我们进行循环，步数res自增1，然后sum加上步数res，最后跳出循环的条件就是差值为偶数，也符合我们上的分析，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> reachNumber(<span style="color: #0000ff;">int</span><span style="color: #000000;"> target) {
        target </span>=<span style="color: #000000;"> abs(target);
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, sum = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (sum &lt; target || (sum - target) % <span style="color: #800080;">2</span> == <span style="color: #800080;">1</span><span style="color: #000000;">) {
            </span>++<span style="color: #000000;">res;
            sum </span>+=<span style="color: #000000;"> res;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种解法是解法一的精简版，两行搞定碉堡了！</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> reachNumber(<span style="color: #0000ff;">int</span><span style="color: #000000;"> target) {
        </span><span style="color: #0000ff;">int</span> n = ceil((sqrt(<span style="color: #800080;">1</span> + <span style="color: #800080;">8.0</span> * abs(target)) - <span style="color: #800080;">1</span>) / <span style="color: #800080;">2</span>), d = n * (n + <span style="color: #800080;">1</span>) / <span style="color: #800080;">2</span> -<span style="color: #000000;"> target;
        </span><span style="color: #0000ff;">return</span> n + (d % <span style="color: #800080;">2</span>) * (n % <span style="color: #800080;">2</span> + <span style="color: #800080;">1</span><span style="color: #000000;">);
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-02-20 23:44</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=8456022" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(8456022);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/8452361.html" id="cb_post_title_url">[LeetCode] Cracking the Safe 破解密码</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>There is a box protected by a password. The password is <code>n</code> digits, where each letter can be one of the first <code>k</code> digits <code>0, 1, ..., k-1</code>.</p>
<p>You can keep inputting the password, the password will automatically be matched against the last <code>n</code> digits entered.</p>
<p>For example, assuming the password is <code>"345"</code>, I can open it when I type <code>"012345"</code>, but I enter a total of 6 digits.</p>
<p>Please return any string of minimum length that is guaranteed to open the box after the entire string is inputted.</p>
<p>Example 1:</p>
<pre>Input: n = 1, k = 2
Output: "01"
Note: "10" will be accepted too.
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input: n = 2, k = 2
Output: "00110"
Note: "01100", "10011", "11001" will be accepted too.
</pre>
<p> </p>
<p>Note:</p>
<ol>
<li><code>n</code> will be in the range <code>[1, 4]</code>.</li>
<li><code>k</code> will be in the range <code>[1, 10]</code>.</li>
<li><code>k^n</code> will be at most <code>4096</code>.</li>
</ol>
<p> </p>
<p>这道题说的是给了k个数字，值为0到k-1，让我们组成n位密码。让我们找一个万能钥匙串，能破解任意的n位密码组合，这里对于破解的定义为只要密码是钥匙串的子串就可以破解了，然我们求出最短的一个万能钥匙串。来看一个例子，n=2，k=2，那么密码的组合有四种，</p>
<p><span style="color: #ff0000;">00</span>，<span style="color: #008000;">01</span>，<span style="color: #0000ff;">10</span>，<span style="color: #ff6600;">11</span></p>
<p>所以 00110 就是一种钥匙串，因为密码 <span style="color: #ff0000;">00</span> (<span style="color: #ff0000;">00</span>110), <span style="color: #008000;">01</span> (0<span style="color: #008000;">01</span>10), <span style="color: #0000ff;">10</span> (001<span style="color: #0000ff;">10</span>), <span style="color: #ff6600;">11</span> (00<span style="color: #ff6600;">11</span>0), 分别都包括在钥匙串中。我们可以发现，为了尽可能的使钥匙串变短，所以我们的密码之间尽可能要相互重叠，比如00和01，就共享一个0，如果是3个数，012和120共享两个数"12"，那么我们可以发现，两个长度为n的密码最好能共享n-1个数字，这样累加出来的钥匙串肯定是最短的。</p>
<p>密码共有n位，每一个位可以有k个数字，那么总共不同的密码总数就有k的n次方个。我们的思路是先从n位都是0的密码开始，取出钥匙串的最后n个数字，然后将最后一个数字依次换成其他数字，我们用一个HashSet来记录所有遍历过的密码，这样如果不在集合中，说明是一个新密码，而生成这个新密码也只是多加了一个数字，这样能保证我们的钥匙串最短，这是一种贪婪的解法，相当的巧妙，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> crackSafe(<span style="color: #0000ff;">int</span> n, <span style="color: #0000ff;">int</span><span style="color: #000000;"> k) {
        </span><span style="color: #0000ff;">string</span> res = <span style="color: #0000ff;">string</span>(n, <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span><span style="color: #000000;">);
        unordered_set</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> visited{{res}};
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; pow(k, n); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">string</span> pre = res.substr(res.size() - n + <span style="color: #800080;">1</span>, n - <span style="color: #800080;">1</span><span style="color: #000000;">);
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = k - <span style="color: #800080;">1</span>; j &gt;= <span style="color: #800080;">0</span>; --<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">string</span> cur = pre +<span style="color: #000000;"> to_string(j);
                </span><span style="color: #0000ff;">if</span> (!<span style="color: #000000;">visited.count(cur)) {
                    visited.insert(cur);
                    res </span>+=<span style="color: #000000;"> to_string(j);
                    </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
                }
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>来看同一种解法的递归写法，思路和迭代的写法一模一样，写法略有不同而已，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> crackSafe(<span style="color: #0000ff;">int</span> n, <span style="color: #0000ff;">int</span><span style="color: #000000;"> k) {
        </span><span style="color: #0000ff;">string</span> res = <span style="color: #0000ff;">string</span>(n, <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span><span style="color: #000000;">);
        unordered_set</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> visited{{res}};
        helper(n, k, pow(k, n), visited, res);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">void</span> helper(<span style="color: #0000ff;">int</span> n, <span style="color: #0000ff;">int</span> k, <span style="color: #0000ff;">int</span> total, unordered_set&lt;<span style="color: #0000ff;">string</span>&gt;&amp; visited, <span style="color: #0000ff;">string</span>&amp;<span style="color: #000000;"> res) {
        </span><span style="color: #0000ff;">if</span> (visited.size() == total) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">string</span> pre = res.substr(res.size() - n + <span style="color: #800080;">1</span>, n - <span style="color: #800080;">1</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = k - <span style="color: #800080;">1</span>; i &gt;= <span style="color: #800080;">0</span>; --<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">string</span> cur = pre +<span style="color: #000000;"> to_string(i);
            </span><span style="color: #0000ff;">if</span> (visited.count(cur)) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
            visited.insert(cur);
            res </span>+=<span style="color: #000000;"> to_string(i);
            helper(n, k, total, visited, res);
        }
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-02-17 23:54</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=8452361" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(8452361);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/8449211.html" id="cb_post_title_url">[LeetCode] Open the Lock 开锁</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="question-description">
<p>You have a lock in front of you with 4 circular wheels. Each wheel has 10 slots: <code>'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'</code>. The wheels can rotate freely and wrap around: for example we can turn <code>'9'</code> to be <code>'0'</code>, or <code>'0'</code> to be <code>'9'</code>. Each move consists of turning one wheel one slot.</p>
<p>The lock initially starts at <code>'0000'</code>, a string representing the state of the 4 wheels.</p>
<p>You are given a list of <code>deadends</code> dead ends, meaning if the lock displays any of these codes, the wheels of the lock will stop turning and you will be unable to open it.</p>
<p>Given a <code>target</code> representing the value of the wheels that will unlock the lock, return the minimum total number of turns required to open the lock, or -1 if it is impossible.</p>
<p>Example 1:</p>
<pre>Input: deadends = ["0201","0101","0102","1212","2002"], target = "0202"
Output: 6
Explanation:
A sequence of valid moves would be "0000" -&gt; "1000" -&gt; "1100" -&gt; "1200" -&gt; "1201" -&gt; "1202" -&gt; "0202".
Note that a sequence like "0000" -&gt; "0001" -&gt; "0002" -&gt; "0102" -&gt; "0202" would be invalid,
because the wheels of the lock become stuck after the display becomes the dead end "0102".
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input: deadends = ["8888"], target = "0009"
Output: 1
Explanation:
We can turn the last wheel in reverse to move from "0000" -&gt; "0009".
</pre>
<p> </p>
<p>Example 3:</p>
<pre>Input: deadends = ["8887","8889","8878","8898","8788","8988","7888","9888"], target = "8888"
Output: -1
Explanation:
We can't reach the target without getting stuck.
</pre>
<p> </p>
<p>Example 4:</p>
<pre>Input: deadends = ["0000"], target = "8888"
Output: -1
</pre>
<p> </p>
<p>Note:</p>
<ol>
<li>The length of <code>deadends</code> will be in the range <code>[1, 500]</code>.</li>
<li><code>target</code> will not be in the list <code>deadends</code>.</li>
<li>Every string in <code>deadends</code> and the string <code>target</code> will be a string of 4 digits from the 10,000 possibilities <code>'0000'</code> to <code>'9999'</code>.</li>
</ol>
<p> </p>
</div>
<p>这道题说有一种可滑动的四位数的锁，貌似行李箱上比较常见这种锁。给了我们一个目标值，还有一些死锁的情况，就是说如果到达这些死锁的位置，就不能再动了，相当于迷宫中的障碍物。然后问我们最少多少步可以从初始的0000位置滑动到给定的target位置。如果各位足够老辣的话，应该能发现其实本质就是个迷宫遍历的问题，只不过相邻位置不再是上下左右四个位置，而是四位数字每个都加一减一，总共有八个相邻的位置。遍历迷宫问题中求最短路径要用BFS来做，那么这道题也就是用BFS来解啦，和经典BFS遍历迷宫解法唯一不同的就是找下一个位置的地方，这里我们要遍历四位数字的每一位，然后分别加1减1，我们用j从-1遍历到1，遇到0跳过，也就是实现了加1减1的过程。然后我们要计算要更新位上的数字，为了处理9加1变0，和0减1变9的情况，我们统一给该位数字加上个10，然后再加或减1，最后再对10取余即可，注意字符和整型数之间通过加或减'0'来转换。我们用结果res来记录BFS遍历的层数，如果此时新生成的字符串等于target了，直接返回结果res，否则我们看如果该字符串不在死锁集合里，且之前没有遍历过，那么加入队列queue中，之后将该字符串加入visited集合中即可。注意这里在while循环中，由于要一层一层的往外扩展，一般的做法是会用一个变量len来记录当前的q.size()，博主为了简洁，使用了一个trick，就是从q.size()往0遍历，千万不能反回来，因为在计算的过程中q的大小会变化，如果让k &lt; q.size() 为终止条件，绝b会出错，而我们初始化为q.size()就没事，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> openLock(vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp; deadends, <span style="color: #0000ff;">string</span><span style="color: #000000;"> target) {
        unordered_set</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> deadlock(deadends.begin(), deadends.end());
        </span><span style="color: #0000ff;">if</span> (deadlock.count(<span style="color: #800000;">"</span><span style="color: #800000;">0000</span><span style="color: #800000;">"</span>)) <span style="color: #0000ff;">return</span> -<span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        unordered_set</span>&lt;<span style="color: #0000ff;">string</span>&gt; visited{{<span style="color: #800000;">"</span><span style="color: #800000;">0000</span><span style="color: #800000;">"</span><span style="color: #000000;">}};
        queue</span>&lt;<span style="color: #0000ff;">string</span>&gt; q{{<span style="color: #800000;">"</span><span style="color: #800000;">0000</span><span style="color: #800000;">"</span><span style="color: #000000;">}};
        </span><span style="color: #0000ff;">while</span> (!<span style="color: #000000;">q.empty()) {
            </span>++<span style="color: #000000;">res;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> k = q.size(); k &gt; <span style="color: #800080;">0</span>; --<span style="color: #000000;">k) {
                auto t </span>=<span style="color: #000000;"> q.front(); q.pop();
                </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; t.size(); ++<span style="color: #000000;">i) {
                    </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = -<span style="color: #800080;">1</span>; j &lt;= <span style="color: #800080;">1</span>; ++<span style="color: #000000;">j) {
                        </span><span style="color: #0000ff;">if</span> (j == <span style="color: #800080;">0</span>) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                        </span><span style="color: #0000ff;">string</span> str =<span style="color: #000000;"> t;
                        str[i] </span>= ((t[i] - <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span>) + <span style="color: #800080;">10</span> + j) % <span style="color: #800080;">10</span> + <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span><span style="color: #000000;">;
                        </span><span style="color: #0000ff;">if</span> (str == target) <span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
                        </span><span style="color: #0000ff;">if</span> (!visited.count(str) &amp;&amp; !<span style="color: #000000;">deadlock.count(str)) q.push(str);        
                        visited.insert(str);
                    }
                }
            }
        }
        </span><span style="color: #0000ff;">return</span> -<span style="color: #800080;">1</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种方法也是用的BFS遍历，不同之处在于生成新字符串的方法，这里我们采用拼接法来生成新字符串，而不是像上面那样使用置换字符串的方法。我们对于加一和减一分别进行拼接，注意处理9加1变0，和0减1变9的情况。然后剩下的部分就和经典的BFS遍历写法没有什么太大的区别了，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> openLock(vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp; deadends, <span style="color: #0000ff;">string</span><span style="color: #000000;"> target) {
        unordered_set</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> deadlock(deadends.begin(), deadends.end());
        </span><span style="color: #0000ff;">if</span> (deadlock.count(<span style="color: #800000;">"</span><span style="color: #800000;">0000</span><span style="color: #800000;">"</span>)) <span style="color: #0000ff;">return</span> -<span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        unordered_set</span>&lt;<span style="color: #0000ff;">string</span>&gt; visited{{<span style="color: #800000;">"</span><span style="color: #800000;">0000</span><span style="color: #800000;">"</span><span style="color: #000000;">}};
        queue</span>&lt;<span style="color: #0000ff;">string</span>&gt; q{{<span style="color: #800000;">"</span><span style="color: #800000;">0000</span><span style="color: #800000;">"</span><span style="color: #000000;">}};
        </span><span style="color: #0000ff;">while</span> (!<span style="color: #000000;">q.empty()) {
            </span>++<span style="color: #000000;">res;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> k = q.size(); k &gt; <span style="color: #800080;">0</span>; --<span style="color: #000000;">k) {
                auto t </span>=<span style="color: #000000;"> q.front(); q.pop();
                </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; t.size(); ++<span style="color: #000000;">i) {
                    </span><span style="color: #0000ff;">char</span> c =<span style="color: #000000;"> t[i];
                    </span><span style="color: #0000ff;">string</span> str1 = t.substr(<span style="color: #800080;">0</span>, i) + to_string(c == <span style="color: #800000;">'</span><span style="color: #800000;">9</span><span style="color: #800000;">'</span> ? <span style="color: #800080;">0</span> : c - <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span> + <span style="color: #800080;">1</span>) + t.substr(i + <span style="color: #800080;">1</span><span style="color: #000000;">);
                    </span><span style="color: #0000ff;">string</span> str2 = t.substr(<span style="color: #800080;">0</span>, i) + to_string(c == <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span> ? <span style="color: #800080;">9</span> : c - <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span> - <span style="color: #800080;">1</span>) + t.substr(i + <span style="color: #800080;">1</span><span style="color: #000000;">);
                    </span><span style="color: #0000ff;">if</span> (str1 == target || str2 == target) <span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
                    </span><span style="color: #0000ff;">if</span> (!visited.count(str1) &amp;&amp; !<span style="color: #000000;">deadlock.count(str1)) q.push(str1);
                    </span><span style="color: #0000ff;">if</span> (!visited.count(str2) &amp;&amp; !<span style="color: #000000;">deadlock.count(str2)) q.push(str2);
                    visited.insert(str1);
                    visited.insert(str2);
                }
            }
        }
        </span><span style="color: #0000ff;">return</span> -<span style="color: #800080;">1</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-02-15 05:45</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=8449211" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(8449211);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/8440087.html" id="cb_post_title_url">[LeetCode] IP to CIDR 将IP地址转为CIDR无类别域间路由</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a start IP address <code>ip</code> and a number of ips we need to cover <code>n</code>, return a representation of the range as a list (of smallest possible length) of CIDR blocks.</p>
<p>A CIDR block is a string consisting of an IP, followed by a slash, and then the prefix length. For example: "123.45.67.89/20". That prefix length "20" represents the number of common prefix bits in the specified range.</p>
<p><strong>Example 1:</strong><br/>
</p>
<pre><strong>Input:</strong> ip = "255.0.0.7", n = 10
<strong>Output:</strong> ["255.0.0.7/32","255.0.0.8/29","255.0.0.16/32"]
<strong>Explanation:</strong>
The initial ip address, when converted to binary, looks like this (spaces added for clarity):
255.0.0.7 -&gt; 11111111 00000000 00000000 00000111
The address "255.0.0.7/32" specifies all addresses with a common prefix of 32 bits to the given address,
ie. just this one address.

The address "255.0.0.8/29" specifies all addresses with a common prefix of 29 bits to the given address:
255.0.0.8 -&gt; 11111111 00000000 00000000 00001000
Addresses with common prefix of 29 bits are:
11111111 00000000 00000000 00001000
11111111 00000000 00000000 00001001
11111111 00000000 00000000 00001010
11111111 00000000 00000000 00001011
11111111 00000000 00000000 00001100
11111111 00000000 00000000 00001101
11111111 00000000 00000000 00001110
11111111 00000000 00000000 00001111

The address "255.0.0.16/32" specifies all addresses with a common prefix of 32 bits to the given address,
ie. just 11111111 00000000 00000000 00010000.

In total, the answer specifies the range of 10 ips starting with the address 255.0.0.7 .

There were other representations, such as:
["255.0.0.7/32","255.0.0.8/30", "255.0.0.12/30", "255.0.0.16/32"],
but our answer was the shortest possible.

Also note that a representation beginning with say, "255.0.0.7/30" would be incorrect,
because it includes addresses like 255.0.0.4 = 11111111 00000000 00000000 00000100 
that are outside the specified range.
</pre>
<p><strong>Note:</strong><br/>
</p>
<ol><ol>
<li><code>ip</code> will be a valid IPv4 address.</li>
<li>Every implied address <code>ip + x</code> (for <code>x &lt; n</code>) will be a valid IPv4 address.</li>
<li><code>n</code> will be an integer in the range <code>[1, 1000]</code>.</li>
</ol></ol>
<p> </p>
<p>这道题博主刚开始做的时候，看了半天，读不懂题目的意思，结果一看是一道Easy的题，直接？？？尼克杨问号脸？？？后来通过研究论坛上大家的解法，才总算明白了这道题让我们做什么。此题给了我们一个用字符串表示的ip地址，还有一个整数n，让我们以给定的ip地址为起点，需要覆盖n个ip地址。而这n个ip地址的写法使用无类别域间路由CIDR块来写，所谓的CIDR块，是由一个正常的ip地址，加上斜杠数字，斜杠后面的数字表示这些ip地址具有相同的前缀的个数，比如"255.0.0.7/32"，如果有32个相同的前缀，说明只有唯一的一个ip地址，因为IPv4总共就只有32位。再比如"255.0.0.8/29"，表示有29个相同的前缀，那么最后3位可以自由发挥，2的3次方为8，所以就共有8个ip地址。同理，"255.0.0.16/32"只表示一个地址，那么这三个CIDR块总共覆盖了10个地址，就是我们要求的结果。</p>
<p>由于题目中要求尽可能少的使用CIDR块，那么在n确定的情况下，CIDR块能覆盖的越多越好。根据我们前面的分析，当CIDR块斜杠后面的数字越小，该块覆盖的ip地址越多。那么就是说相同前缀的个数越少越好，但是我们的ip地址又不能小于给定的ip地址，所以我们只能将0变为1，而不能将1变为0。所以我们的选择就是有将最低位1后面的0进行变换，比如"255.0.0.8"末尾有3个0，可以变换出8个不同的地址。那么我们只要找出末尾1的位置，就知道能覆盖多少个地址了。找末尾1有个trick，就是利用 x &amp; -x 来快速找到，这个trick在之前做的题中也有应用。知道了最多能覆盖地址的数量，还要考虑到n的大小，不能超过n，因为题目只要求覆盖n个。确定了覆盖的个数，我们就可以进行生成CIDR块的操作了，之前我们为了求 x &amp; -x，将ip地址转为了一个十进制的数，现在我们要把每一块拆分出来，直接按对应位数量进行右移并与上255即可，斜杠后的数字计算通过覆盖的个数进行log2运算，再被32减去即可，参见代码如下： </p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; ipToCIDR(<span style="color: #0000ff;">string</span> ip, <span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        vector</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">long</span> x = <span style="color: #800080;">0</span><span style="color: #000000;">;
        istringstream </span><span style="color: #0000ff;">is</span><span style="color: #000000;">(ip);
        </span><span style="color: #0000ff;">string</span><span style="color: #000000;"> t;
        </span><span style="color: #0000ff;">while</span> (getline(<span style="color: #0000ff;">is</span>, t, <span style="color: #800000;">'</span><span style="color: #800000;">.</span><span style="color: #800000;">'</span><span style="color: #000000;">)) {
            x </span>= x * <span style="color: #800080;">256</span> +<span style="color: #000000;"> stoi(t);
        }
        </span><span style="color: #0000ff;">while</span> (n &gt; <span style="color: #800080;">0</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">long</span> step = x &amp; -<span style="color: #000000;">x;
            </span><span style="color: #0000ff;">while</span> (step &gt; n) step /= <span style="color: #800080;">2</span><span style="color: #000000;">;
            res.push_back(convert(x, step));
            x </span>+=<span style="color: #000000;"> step;
            n </span>-=<span style="color: #000000;"> step;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">string</span> convert(<span style="color: #0000ff;">long</span> x, <span style="color: #0000ff;">int</span><span style="color: #000000;"> step) {
        </span><span style="color: #0000ff;">return</span> to_string((x &gt;&gt; <span style="color: #800080;">24</span>) &amp; <span style="color: #800080;">255</span>) + <span style="color: #800000;">"</span><span style="color: #800000;">.</span><span style="color: #800000;">"</span> + to_string((x &gt;&gt; <span style="color: #800080;">16</span>) &amp; <span style="color: #800080;">255</span>) + <span style="color: #800000;">"</span><span style="color: #800000;">.</span><span style="color: #800000;">"</span> + to_string((x &gt;&gt; <span style="color: #800080;">8</span>) &amp; <span style="color: #800080;">255</span>) + <span style="color: #800000;">"</span><span style="color: #800000;">.</span><span style="color: #800000;">"</span> + to_string(x &amp; <span style="color: #800080;">255</span>) + <span style="color: #800000;">"</span><span style="color: #800000;">/</span><span style="color: #800000;">"</span> + to_string(<span style="color: #800080;">32</span> - (<span style="color: #0000ff;">int</span><span style="color: #000000;">)log2(step));
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/6185339.html">Validate IP Address</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4305572.html" target="_blank">Restore IP Addresses</a> </p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/115127/10-lines-java-solution">https://discuss.leetcode.com/topic/115127/10-lines-java-solution</a></p>
<p><a href="https://discuss.leetcode.com/topic/114848/very-simple-java-solution-beat-100">https://discuss.leetcode.com/topic/114848/very-simple-java-solution-beat-100</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a> </p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-02-10 23:50</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=8440087" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(8440087);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/8440087.html" id="cb_post_title_url">[LeetCode] IP to CIDR 将IP地址转为CIDR无类别域间路由</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a start IP address <code>ip</code> and a number of ips we need to cover <code>n</code>, return a representation of the range as a list (of smallest possible length) of CIDR blocks.</p>
<p>A CIDR block is a string consisting of an IP, followed by a slash, and then the prefix length. For example: "123.45.67.89/20". That prefix length "20" represents the number of common prefix bits in the specified range.</p>
<p><strong>Example 1:</strong><br/>
</p>
<pre><strong>Input:</strong> ip = "255.0.0.7", n = 10
<strong>Output:</strong> ["255.0.0.7/32","255.0.0.8/29","255.0.0.16/32"]
<strong>Explanation:</strong>
The initial ip address, when converted to binary, looks like this (spaces added for clarity):
255.0.0.7 -&gt; 11111111 00000000 00000000 00000111
The address "255.0.0.7/32" specifies all addresses with a common prefix of 32 bits to the given address,
ie. just this one address.

The address "255.0.0.8/29" specifies all addresses with a common prefix of 29 bits to the given address:
255.0.0.8 -&gt; 11111111 00000000 00000000 00001000
Addresses with common prefix of 29 bits are:
11111111 00000000 00000000 00001000
11111111 00000000 00000000 00001001
11111111 00000000 00000000 00001010
11111111 00000000 00000000 00001011
11111111 00000000 00000000 00001100
11111111 00000000 00000000 00001101
11111111 00000000 00000000 00001110
11111111 00000000 00000000 00001111

The address "255.0.0.16/32" specifies all addresses with a common prefix of 32 bits to the given address,
ie. just 11111111 00000000 00000000 00010000.

In total, the answer specifies the range of 10 ips starting with the address 255.0.0.7 .

There were other representations, such as:
["255.0.0.7/32","255.0.0.8/30", "255.0.0.12/30", "255.0.0.16/32"],
but our answer was the shortest possible.

Also note that a representation beginning with say, "255.0.0.7/30" would be incorrect,
because it includes addresses like 255.0.0.4 = 11111111 00000000 00000000 00000100 
that are outside the specified range.
</pre>
<p><strong>Note:</strong><br/>
</p>
<ol><ol>
<li><code>ip</code> will be a valid IPv4 address.</li>
<li>Every implied address <code>ip + x</code> (for <code>x &lt; n</code>) will be a valid IPv4 address.</li>
<li><code>n</code> will be an integer in the range <code>[1, 1000]</code>.</li>
</ol></ol>
<p> </p>
<p>这道题博主刚开始做的时候，看了半天，读不懂题目的意思，结果一看是一道Easy的题，直接？？？尼克杨问号脸？？？后来通过研究论坛上大家的解法，才总算明白了这道题让我们做什么。此题给了我们一个用字符串表示的ip地址，还有一个整数n，让我们以给定的ip地址为起点，需要覆盖n个ip地址。而这n个ip地址的写法使用无类别域间路由CIDR块来写，所谓的CIDR块，是由一个正常的ip地址，加上斜杠数字，斜杠后面的数字表示这些ip地址具有相同的前缀的个数，比如"255.0.0.7/32"，如果有32个相同的前缀，说明只有唯一的一个ip地址，因为IPv4总共就只有32位。再比如"255.0.0.8/29"，表示有29个相同的前缀，那么最后3位可以自由发挥，2的3次方为8，所以就共有8个ip地址。同理，"255.0.0.16/32"只表示一个地址，那么这三个CIDR块总共覆盖了10个地址，就是我们要求的结果。</p>
<p>由于题目中要求尽可能少的使用CIDR块，那么在n确定的情况下，CIDR块能覆盖的越多越好。根据我们前面的分析，当CIDR块斜杠后面的数字越小，该块覆盖的ip地址越多。那么就是说相同前缀的个数越少越好，但是我们的ip地址又不能小于给定的ip地址，所以我们只能将0变为1，而不能将1变为0。所以我们的选择就是有将最低位1后面的0进行变换，比如"255.0.0.8"末尾有3个0，可以变换出8个不同的地址。那么我们只要找出末尾1的位置，就知道能覆盖多少个地址了。找末尾1有个trick，就是利用 x &amp; -x 来快速找到，这个trick在之前做的题中也有应用。知道了最多能覆盖地址的数量，还要考虑到n的大小，不能超过n，因为题目只要求覆盖n个。确定了覆盖的个数，我们就可以进行生成CIDR块的操作了，之前我们为了求 x &amp; -x，将ip地址转为了一个十进制的数，现在我们要把每一块拆分出来，直接按对应位数量进行右移并与上255即可，斜杠后的数字计算通过覆盖的个数进行log2运算，再被32减去即可，参见代码如下： </p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; ipToCIDR(<span style="color: #0000ff;">string</span> ip, <span style="color: #0000ff;">int</span><span style="color: #000000;"> n) {
        vector</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">long</span> x = <span style="color: #800080;">0</span><span style="color: #000000;">;
        istringstream </span><span style="color: #0000ff;">is</span><span style="color: #000000;">(ip);
        </span><span style="color: #0000ff;">string</span><span style="color: #000000;"> t;
        </span><span style="color: #0000ff;">while</span> (getline(<span style="color: #0000ff;">is</span>, t, <span style="color: #800000;">'</span><span style="color: #800000;">.</span><span style="color: #800000;">'</span><span style="color: #000000;">)) {
            x </span>= x * <span style="color: #800080;">256</span> +<span style="color: #000000;"> stoi(t);
        }
        </span><span style="color: #0000ff;">while</span> (n &gt; <span style="color: #800080;">0</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">long</span> step = x &amp; -<span style="color: #000000;">x;
            </span><span style="color: #0000ff;">while</span> (step &gt; n) step /= <span style="color: #800080;">2</span><span style="color: #000000;">;
            res.push_back(convert(x, step));
            x </span>+=<span style="color: #000000;"> step;
            n </span>-=<span style="color: #000000;"> step;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">string</span> convert(<span style="color: #0000ff;">long</span> x, <span style="color: #0000ff;">int</span><span style="color: #000000;"> step) {
        </span><span style="color: #0000ff;">return</span> to_string((x &gt;&gt; <span style="color: #800080;">24</span>) &amp; <span style="color: #800080;">255</span>) + <span style="color: #800000;">"</span><span style="color: #800000;">.</span><span style="color: #800000;">"</span> + to_string((x &gt;&gt; <span style="color: #800080;">16</span>) &amp; <span style="color: #800080;">255</span>) + <span style="color: #800000;">"</span><span style="color: #800000;">.</span><span style="color: #800000;">"</span> + to_string((x &gt;&gt; <span style="color: #800080;">8</span>) &amp; <span style="color: #800080;">255</span>) + <span style="color: #800000;">"</span><span style="color: #800000;">.</span><span style="color: #800000;">"</span> + to_string(x &amp; <span style="color: #800080;">255</span>) + <span style="color: #800000;">"</span><span style="color: #800000;">/</span><span style="color: #800000;">"</span> + to_string(<span style="color: #800080;">32</span> - (<span style="color: #0000ff;">int</span><span style="color: #000000;">)log2(step));
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/6185339.html">Validate IP Address</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4305572.html" target="_blank">Restore IP Addresses</a> </p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/115127/10-lines-java-solution">https://discuss.leetcode.com/topic/115127/10-lines-java-solution</a></p>
<p><a href="https://discuss.leetcode.com/topic/114848/very-simple-java-solution-beat-100">https://discuss.leetcode.com/topic/114848/very-simple-java-solution-beat-100</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a> </p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-02-10 23:50</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=8440087" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(8440087);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/8433813.html" id="cb_post_title_url">[LeetCode] Number Of Corner Rectangles 边角矩形的数量</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a grid where each entry is only 0 or 1, find the number of corner rectangles.</p>
<p>A <em>corner rectangle</em> is 4 distinct 1s on the grid that form an axis-aligned rectangle. Note that only the corners need to have the value 1. Also, all four 1s used must be distinct.</p>
<p> </p>
<p>Example 1:</p>
<pre>Input: grid = 
[[1, 0, 0, 1, 0],
 [0, 0, 1, 0, 1],
 [0, 0, 0, 1, 0],
 [1, 0, 1, 0, 1]]
Output: 1
Explanation: There is only one corner rectangle, with corners grid[1][2], grid[1][4], grid[3][2], grid[3][4].
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input: grid = 
[[1, 1, 1],
 [1, 1, 1],
 [1, 1, 1]]
Output: 9
Explanation: There are four 2x2 rectangles, four 2x3 and 3x2 rectangles, and one 3x3 rectangle.
</pre>
<p> </p>
<p>Example 3:</p>
<pre>Input: grid = 
[[1, 1, 1, 1]]
Output: 0
Explanation: Rectangles must have four distinct corners.
</pre>
<p> </p>
<p>Note:</p>
<ol>
<li>The number of rows and columns of <code>grid</code> will each be in the range <code>[1, 200]</code>.</li>
<li>Each <code>grid[i][j]</code> will be either <code>0</code> or <code>1</code>.</li>
<li>The number of <code>1</code>s in the grid will be at most <code>6000</code>.</li>
</ol>
<p> </p>
<p>这道题给了我们一个由0和1组成的二维数组，这里定义了一种边角矩形，其四个顶点均为1，让我们求这个二维数组中有多少个不同的边角矩形。那么最简单直接的方法就是暴力破解啦，我们遍历所有的子矩形，并且检验其四个顶点是否为1即可。先确定左上顶点，每个顶点都可以当作左上顶点，所以需要两个for循环，然后我们直接跳过非1的左上顶点，接下来就是要确定右上顶点和左下顶点了，先用一个for循环确定左下顶点的位置，同理，如果左下顶点为0，直接跳过。再用一个for循环确定右上顶点的位置，如果右上顶点位置也确定了，那么此时四个顶点中确定了三个，右下顶点的位置也就确定了，此时如果右上和右下顶点均为1，则结果res自增1，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> countCornerRectangles(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> grid) {
        </span><span style="color: #0000ff;">int</span> m = grid.size(), n = grid[<span style="color: #800080;">0</span>].size(), res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; m; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; n; ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">if</span> (grid[i][j] == <span style="color: #800080;">0</span>) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> h = <span style="color: #800080;">1</span>; h &lt; m - i; ++<span style="color: #000000;">h) {
                    </span><span style="color: #0000ff;">if</span> (grid[i + h][j] == <span style="color: #800080;">0</span>) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> w = <span style="color: #800080;">1</span>; w &lt; n - j; ++<span style="color: #000000;">w) {
                        </span><span style="color: #0000ff;">if</span> (grid[i][j + w] == <span style="color: #800080;">1</span> &amp;&amp; grid[i + h][j + w] == <span style="color: #800080;">1</span>) ++<span style="color: #000000;">res;
                    }
                }
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>我们来看一种优化了时间复杂度的方法，这种方法的原理是两行同时遍历，如果两行中相同列位置的值都为1，则计数器cnt自增1，那么最后就相当于有了(cnt - 1)个相邻的格子，问题就转化为了求cnt-1个相邻的格子能组成多少个矩形，就变成了初中数学问题了，共有cnt*(cnt-1)/2个，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> countCornerRectangles(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> grid) {
        </span><span style="color: #0000ff;">int</span> m = grid.size(), n = grid[<span style="color: #800080;">0</span>].size(), res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; m; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = i + <span style="color: #800080;">1</span>; j &lt; m; ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">int</span> cnt = <span style="color: #800080;">0</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> k = <span style="color: #800080;">0</span>; k &lt; n; ++<span style="color: #000000;">k) {
                    </span><span style="color: #0000ff;">if</span> (grid[i][k] == <span style="color: #800080;">1</span> &amp;&amp; grid[j][k] == <span style="color: #800080;">1</span>) ++<span style="color: #000000;">cnt;
                }
                res </span>+= cnt * (cnt - <span style="color: #800080;">1</span>) / <span style="color: #800080;">2</span><span style="color: #000000;">;
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种解法由热心网友edyyy提供，最大亮点是将解法二的beat 65%提高到了beat 97%，速度杠杠的，要飞起来了的节奏。在遍历前一行的时候，将所有为1的位置存入到了一个数组ones中，然后在遍历其他行时，直接检测ones数组中的那些位置是否为1，这样省去了检查一些之前行为0的步骤，提高了运行速度，但是也牺牲了一些空间，比如需要ones数组，算是个trade off吧，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> countCornerRectangles(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> grid) {
        </span><span style="color: #0000ff;">int</span> m = grid.size(), n = grid[<span style="color: #800080;">0</span>].size(), res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; m - <span style="color: #800080;">1</span>; i++<span style="color: #000000;">) { 
            vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> ones;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> k = <span style="color: #800080;">0</span>; k &lt; n; k++) <span style="color: #0000ff;">if</span><span style="color: #000000;"> (grid[i][k]) ones.push_back(k);
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = i + <span style="color: #800080;">1</span>; j &lt; m; j++<span style="color: #000000;">) {
                </span><span style="color: #0000ff;">int</span> cnt = <span style="color: #800080;">0</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> l = <span style="color: #800080;">0</span>; l &lt; ones.size(); l++<span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">if</span> (grid[j][ones[l]]) cnt++<span style="color: #000000;">;
                }
                res </span>+= cnt * (cnt - <span style="color: #800080;">1</span>) / <span style="color: #800080;">2</span><span style="color: #000000;">;
            }           
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/114177/short-java-ac-solution-o-m-2-n-with-explanation" target="_blank">https://discuss.leetcode.com/topic/114177/short-java-ac-solution-o-m-2-n-with-explanation</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-02-08 23:34</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=8433813" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(8433813);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/8424780.html" id="cb_post_title_url">[LeetCode] Contain Virus 包含病毒</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>A virus is spreading rapidly, and your task is to quarantine the infected area by installing walls.</p>
<p>The world is modeled as a 2-D array of cells, where <code>0</code> represents uninfected cells, and <code>1</code> represents cells contaminated with the virus. A wall (and only one wall) can be installed between any two 4-directionally adjacent cells, on the shared boundary.</p>
<p>Every night, the virus spreads to all neighboring cells in all four directions unless blocked by a wall. Resources are limited. Each day, you can install walls around only one region -- the affected area (continuous block of infected cells) that threatens the most uninfected cells the following night. There will never be a tie.</p>
<p>Can you save the day? If so, what is the number of walls required? If not, and the world becomes fully infected, return the number of walls used.</p>
<p> </p>
<p>Example 1:</p>
<pre>Input: grid = 
[[0,1,0,0,0,0,0,1],
 [0,1,0,0,0,0,0,1],
 [0,0,0,0,0,0,0,1],
 [0,0,0,0,0,0,0,0]]
Output: 10
Explanation:
There are 2 contaminated regions.
On the first day, add 5 walls to quarantine the viral region on the left. The board after the virus spreads is:

[[0,1,0,0,0,0,1,1],
 [0,1,0,0,0,0,1,1],
 [0,0,0,0,0,0,1,1],
 [0,0,0,0,0,0,0,1]]

On the second day, add 5 walls to quarantine the viral region on the right. The virus is fully contained.
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input: grid = 
[[1,1,1],
 [1,0,1],
 [1,1,1]]
Output: 4
Explanation: Even though there is only one cell saved, there are 4 walls built.
Notice that walls are only built on the shared boundary of two different cells.
</pre>
<p> </p>
<p>Example 3:</p>
<pre>Input: grid = 
[[1,1,1,0,0,0,0,0,0],
 [1,0,1,0,1,1,1,1,1],
 [1,1,1,0,0,0,0,0,0]]
Output: 13
Explanation: The region on the left only builds two new walls.
</pre>
<p> </p>
<p>Note:</p>
<ol>
<li>The number of rows and columns of <code>grid</code> will each be in the range <code>[1, 50]</code>.</li>
<li>Each <code>grid[i][j]</code> will be either <code>0</code> or <code>1</code>.</li>
<li>Throughout the described process, there is always a contiguous viral region that will infect strictly moreuncontaminated squares in the next round.</li>
</ol>
<p> </p>
<p>这道题给了我们一个由0和1组成的二维数组，其中0表示健康细胞，而1表示病毒细胞，多个相邻的1组成了病毒细胞群，每天都会向周围扩散一圈，除非我们在其跟健康细胞之间建立隔离墙，这样其才会不会扩散。我们每天只能给一个病毒细胞群来建立隔离墙，其他的细胞群会进行扩散。问最终我们需要多少个隔离墙。这道题真的挺难，博主研究了好久才弄明白题目的意思。首先要明白一点，病毒细胞只会向上下左右四个方向相邻的健康细胞扩散。需要注意的一点是，需要的隔离墙的数量可能大于周围相邻的健康细胞，最明显的就是例子2中，只有一个健康细胞，但是需要四个隔离墙才能保护这个健康细胞不被感染。还有就是，我们需要隔离某个病毒细胞群的判定依据是其能感染的健康细胞的数量，而不是需要建的墙的数量或者病毒细胞的个数，这点很重要，博主之前没有注意这一点，导致fail了一个test case。所以我们要做的就是要求出每个病毒细胞群能感染的健康细胞的数量，其周围能建墙的地方，以及每个病毒细胞的位置。我们再其中选择能感染最多健康细胞的病毒细胞群进行建墙，建完墙后，我们将该群中的所有病毒细胞标记为-1，跟其他细胞区分出来。对于其他所有的病毒细胞群，将其周围能建墙的地方(即健康细胞)都标记为1，表示其现在已经被感染成了病毒细胞。然后再进行新的一轮循环检测，直到无法找出新的病毒细胞为止。</p>
<p>我们先找值为1的点，找到后，以其作为起点，进行BFS遍历，将和其相连的所有为1的点都找出来，在BFS遍历的过程中，如果我们检测到周围位置值为0，将其加入walls数组，表示这里可以建隔离墙，如果检测到周围位置为1，将其加入virus数组，表示这里是病毒细胞，注意起始位置也要提前加入virus数组。我们这里为了节省维度，将二维的坐标都encode成了一个int数字。BFS遍历结束后，我们根据walls数组来算出能感染的健康细胞的个数，因为我们前面提到过建隔离墙的位置可能大于健康细胞的个数，所以我们只要去除wall数组的重复项即可，利用HashSet的去重复项原理，然后将剩下的个数放入cells数组中。把cells，walls，和virus数组放入一个vector中，表示一个病毒细胞群的信息，再放入一个大数组all中，这样我们收集了所有病毒细胞群的信息后，可以根据可感染的健康细胞个数由多到少来排序，这样我们就把第一个病毒细胞群中所有virus数组的位置值变为-1，并且把可感染的健康细胞个数累加到结果res中。然后把后面所有的病毒细胞群中walls的位置值都变为1即可。当all数组为空时，跳出循环，表示没有检测到病毒细胞群或者全部都被感染了，参见代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> containVirus(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> grid) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span>, m = grid.size(), n = grid[<span style="color: #800080;">0</span><span style="color: #000000;">].size();
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; dirs{{-<span style="color: #800080;">1</span>,<span style="color: #800080;">0</span>},{<span style="color: #800080;">0</span>,<span style="color: #800080;">1</span>},{<span style="color: #800080;">1</span>,<span style="color: #800080;">0</span>},{<span style="color: #800080;">0</span>,-<span style="color: #800080;">1</span><span style="color: #000000;">}};
        </span><span style="color: #0000ff;">while</span> (<span style="color: #0000ff;">true</span><span style="color: #000000;">) {
            unordered_set</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> visited;
            vector</span>&lt;vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&gt;<span style="color: #000000;"> all;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; m; ++<span style="color: #000000;">i) {
                </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; n; ++<span style="color: #000000;">j) {
                    </span><span style="color: #0000ff;">if</span> (grid[i][j] == <span style="color: #800080;">1</span> &amp;&amp; !visited.count(i * n +<span style="color: #000000;"> j)) {
                        queue</span>&lt;<span style="color: #0000ff;">int</span>&gt; q{{i * n +<span style="color: #000000;"> j}};
                        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; virus{i * n +<span style="color: #000000;"> j};
                        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> walls;
                        visited.insert(i </span>* n +<span style="color: #000000;"> j);
                        </span><span style="color: #0000ff;">while</span> (!<span style="color: #000000;">q.empty()) {
                            auto t </span>=<span style="color: #000000;"> q.front(); q.pop();
                            </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto dir : dirs) {
                                </span><span style="color: #0000ff;">int</span> x = (t / n) + dir[<span style="color: #800080;">0</span>], y = (t % n) + dir[<span style="color: #800080;">1</span><span style="color: #000000;">];
                                </span><span style="color: #0000ff;">if</span> (x &lt; <span style="color: #800080;">0</span> || x &gt;= m || y &lt; <span style="color: #800080;">0</span> || y &gt;= n || visited.count(x * n + y)) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                                </span><span style="color: #0000ff;">if</span> (grid[x][y] == -<span style="color: #800080;">1</span>) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                                </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (grid[x][y] == <span style="color: #800080;">0</span>) walls.push_back(x * n +<span style="color: #000000;"> y);
                                </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (grid[x][y] == <span style="color: #800080;">1</span><span style="color: #000000;">) {
                                    visited.insert(x </span>* n +<span style="color: #000000;"> y);
                                    virus.push_back(x </span>* n +<span style="color: #000000;"> y);
                                    q.push(x </span>* n +<span style="color: #000000;"> y);
                                }
                            }
                        }
                        unordered_set</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> s(walls.begin(), walls.end());
                        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; cells{(<span style="color: #0000ff;">int</span><span style="color: #000000;">)s.size()};
                        all.push_back({cells ,walls, virus});
                    }
                }
            }
            </span><span style="color: #0000ff;">if</span> (all.empty()) <span style="color: #0000ff;">break</span><span style="color: #000000;">;
            sort(all.begin(), all.end(), [](vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; &amp;a, vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; &amp;b) {<span style="color: #0000ff;">return</span> a[<span style="color: #800080;">0</span>][<span style="color: #800080;">0</span>] &gt; b[<span style="color: #800080;">0</span>][<span style="color: #800080;">0</span><span style="color: #000000;">];});
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; all.size(); ++<span style="color: #000000;">i) {
                </span><span style="color: #0000ff;">if</span> (i == <span style="color: #800080;">0</span><span style="color: #000000;">) {
                    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; virus = all[<span style="color: #800080;">0</span>][<span style="color: #800080;">2</span><span style="color: #000000;">];
                    </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> idx : virus) grid[idx / n][idx % n] = -<span style="color: #800080;">1</span><span style="color: #000000;">;
                    res </span>+= all[<span style="color: #800080;">0</span>][<span style="color: #800080;">1</span><span style="color: #000000;">].size();
                } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; wall = all[i][<span style="color: #800080;">1</span><span style="color: #000000;">];
                    </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> idx : wall) grid[idx / n][idx % n] = <span style="color: #800080;">1</span><span style="color: #000000;">;
                }
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/114208/c-dfs-12ms" target="_blank">https://discuss.leetcode.com/topic/114208/c-dfs-12ms</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-02-06 23:49</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=8424780" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(8424780);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/8407446.html" id="cb_post_title_url">[LeetCode] Shortest Completing Word 最短完整的单词</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="question-description">
<p>Find the minimum length word from a given dictionary <code>words</code>, which has all the letters from the string <code>licensePlate</code>. Such a word is said to <em>complete</em> the given string <code>licensePlate</code></p>
<p>Here, for letters we ignore case. For example, <code>"P"</code> on the <code>licensePlate</code> still matches <code>"p"</code> on the word.</p>
<p>It is guaranteed an answer exists. If there are multiple answers, return the one that occurs first in the array.</p>
<p>The license plate might have the same letter occurring multiple times. For example, given a <code>licensePlate</code> of <code>"PP"</code>, the word <code>"pair"</code> does not complete the <code>licensePlate</code>, but the word <code>"supper"</code> does.</p>
<p> </p>
<p>Example 1:</p>
<pre>Input: licensePlate = "1s3 PSt", words = ["step", "steps", "stripe", "stepple"]
Output: "steps"
Explanation: The smallest length word that contains the letters "S", "P", "S", and "T".
Note that the answer is not "step", because the letter "s" must occur in the word twice.
Also note that we ignored case for the purposes of comparing whether a letter exists in the word.
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input: licensePlate = "1s3 456", words = ["looks", "pest", "stew", "show"]
Output: "pest"
Explanation: There are 3 smallest length words that contains the letters "s".
We return the one that occurred first.
</pre>
<p> </p>
<p>Note:</p>
<ol>
<li><code>licensePlate</code> will be a string with length in range <code>[1, 7]</code>.</li>
<li><code>licensePlate</code> will contain digits, spaces, or letters (uppercase or lowercase).</li>
<li><code>words</code> will have a length in the range <code>[10, 1000]</code>.</li>
<li>Every <code>words[i]</code> will consist of lowercase letters, and have length in range <code>[1, 15]</code>.</li>
</ol>
<p> </p>
</div>
<p>这道题给了我们一个车牌号，还有一些单词，让我们找出包含这个车牌号中所有字母的第一个最短的单词。车牌中的字母有大小写之分，但是单词只是由小写单词组成的，所以需要把车牌号中的所有大写字母都转为小写的，转换方法很简单，ASCII码加上32即可。我们建立车牌中各个字母和其出现的次数之间的映射，同时记录所有字母的个数total，然后遍历所有的单词，对于每个单词都要单独处理，我们遍历单词中所有的字母，如果其在车牌中也出现了，则对应字母的映射减1，同时还需匹配的字母数cnt也自减1，最后遍历字母完成后，如果cnt为0（说明车牌中所有的字母都在单词中出现了），并且结果res为空或长度大于当前单词word的话，更新结果即可，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> shortestCompletingWord(<span style="color: #0000ff;">string</span> licensePlate, vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp;<span style="color: #000000;"> words) {
        </span><span style="color: #0000ff;">string</span> res = <span style="color: #800000;">""</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> total = <span style="color: #800080;">0</span><span style="color: #000000;">;
        unordered_map</span>&lt;<span style="color: #0000ff;">char</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> freq; 
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span><span style="color: #000000;"> c : licensePlate) {
            </span><span style="color: #0000ff;">if</span> (c &gt;= <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span> &amp;&amp; c &lt;= <span style="color: #800000;">'</span><span style="color: #800000;">z</span><span style="color: #800000;">'</span>) {++freq[c]; ++<span style="color: #000000;">total;}
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (c &gt;= <span style="color: #800000;">'</span><span style="color: #800000;">A</span><span style="color: #800000;">'</span> &amp;&amp; c &lt;= <span style="color: #800000;">'</span><span style="color: #800000;">Z</span><span style="color: #800000;">'</span>) {++freq[c + <span style="color: #800080;">32</span>]; ++<span style="color: #000000;">total;}
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">string</span><span style="color: #000000;"> word : words) {
            </span><span style="color: #0000ff;">int</span> cnt =<span style="color: #000000;"> total;
            unordered_map</span>&lt;<span style="color: #0000ff;">char</span>, <span style="color: #0000ff;">int</span>&gt; t =<span style="color: #000000;"> freq;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span><span style="color: #000000;"> c : word) {
                </span><span style="color: #0000ff;">if</span> (--t[c] &gt;= <span style="color: #800080;">0</span>) --<span style="color: #000000;">cnt;
            }
            </span><span style="color: #0000ff;">if</span> (cnt == <span style="color: #800080;">0</span> &amp;&amp; (res.empty() || res.size() &gt;<span style="color: #000000;"> word.size())) {
                res </span>=<span style="color: #000000;"> word;
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
}; </span></pre>
</div>
<p> </p>
<p>如果这道题的单词是按长度排序的话，那么上面的方法就不是很高效了，因为其会强制遍历完所有的单词。所以我们考虑给单词排序，博主这里用了TreeMap这个数据结构建立单词长度和包含所有该长度单词的数组之间的映射，其会自动按照单词长度来排序。然后还使用了一个chars数组来记录车牌中的所有字母，这样就可以方便的统计出字母总个数。我们从单词长度等于字母总个数的映射开始遍历，先检验该长度的所有单词。这里检验方法跟上面略有不同，但都大同小异，用一个bool型变量succ，初始化为true，然后建立一个字母和其出现次数的映射，先遍历单词，统计各个字母出现的次数。然后就遍历chars数组，如果chars中某个字母不在单词中，那么succ赋值为false，然后break掉。最后我们看succ，如果仍为true，直接返回当前单词word，之后的单词就不用再检验了，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> shortestCompletingWord(<span style="color: #0000ff;">string</span> licensePlate, vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp;<span style="color: #000000;"> words) {
        map</span>&lt;<span style="color: #0000ff;">int</span>, vector&lt;<span style="color: #0000ff;">string</span>&gt;&gt;<span style="color: #000000;"> m;
        vector</span>&lt;<span style="color: #0000ff;">char</span>&gt;<span style="color: #000000;"> chars;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">string</span><span style="color: #000000;"> word : words) {
            m[word.size()].push_back(word);
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span><span style="color: #000000;"> c : licensePlate) {
            </span><span style="color: #0000ff;">if</span> (c &gt;= <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span> &amp;&amp; c &lt;= <span style="color: #800000;">'</span><span style="color: #800000;">z</span><span style="color: #800000;">'</span><span style="color: #000000;">) chars.push_back(c);
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (c &gt;= <span style="color: #800000;">'</span><span style="color: #800000;">A</span><span style="color: #800000;">'</span> &amp;&amp; c &lt;= <span style="color: #800000;">'</span><span style="color: #800000;">Z</span><span style="color: #800000;">'</span>) chars.push_back(c + <span style="color: #800080;">32</span><span style="color: #000000;">);
        }
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto a : m) {
            </span><span style="color: #0000ff;">if</span> (a.first &lt; chars.size()) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">string</span><span style="color: #000000;"> word : a.second) {
                </span><span style="color: #0000ff;">bool</span> succ = <span style="color: #0000ff;">true</span><span style="color: #000000;">;
                unordered_map</span>&lt;<span style="color: #0000ff;">char</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> freq;
                </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span> c : word) ++<span style="color: #000000;">freq[c];
                </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span><span style="color: #000000;"> c : chars) {
                    </span><span style="color: #0000ff;">if</span> (--freq[c] &lt; <span style="color: #800080;">0</span>) {succ = <span style="color: #0000ff;">false</span>; <span style="color: #0000ff;">break</span><span style="color: #000000;">;}
                }
                </span><span style="color: #0000ff;">if</span> (succ) <span style="color: #0000ff;">return</span><span style="color: #000000;"> word;
            }
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #800000;">""</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/114155/java-c-clean-code">https://discuss.leetcode.com/topic/114155/java-c-clean-code</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-02-02 23:29</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=8407446" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(8407446);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/8387593.html" id="cb_post_title_url">[LeetCode] Largest Number At Least Twice of Others 至少是其他数字两倍的最大数</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>In a given integer array <code>nums</code>, there is always exactly one largest element.</p>
<p>Find whether the largest element in the array is at least twice as much as every other number in the array.</p>
<p>If it is, return the index of the largest element, otherwise return -1.</p>
<p>Example 1:</p>
<pre>Input: nums = [3, 6, 1, 0]
Output: 1
Explanation: 6 is the largest integer, and for every other number in the array x,
6 is more than twice as big as x.  The index of value 6 is 1, so we return 1.
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input: nums = [1, 2, 3, 4]
Output: -1
Explanation: 4 isn't at least as big as twice the value of 3, so we return -1.
</pre>
<p> </p>
<p>Note:</p>
<ol>
<li><code>nums</code> will have a length in the range <code>[1, 50]</code>.</li>
<li>Every <code>nums[i]</code> will be an integer in the range <code>[0, 99]</code>.</li>
</ol>
<p> </p>
<p>这道题让我们找一个至少是其他数字两倍的最大数字，那么我们想，首先明确的一点是这个要求的数字一定是数组中的最大数字，因为其是其他所有的数字的至少两倍。然后就是，如果该数字是数组中第二大的数字至少两倍的话，那么它一定是其他所有数字的至少两倍，所以我们可以遍历一次数组分别求出最大数字和第二大数字，然后判断一下最大数字是否是第二大数字的两倍即可，注意这里我们判断两倍的方法并不是直接相除，为了避免除以零的情况，我们采用减法，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> dominantIndex(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        </span><span style="color: #0000ff;">int</span> mx = INT_MIN, secondMx = INT_MIN, mxId = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; nums.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (nums[i] &gt;<span style="color: #000000;"> mx) {
                secondMx </span>=<span style="color: #000000;"> mx;
                mx </span>=<span style="color: #000000;"> nums[i];
                mxId </span>=<span style="color: #000000;"> i;
            } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (nums[i] &gt;<span style="color: #000000;"> secondMx) {
                secondMx </span>=<span style="color: #000000;"> nums[i];
            }
        }
        </span><span style="color: #0000ff;">return</span> (mx - secondMx &gt;= secondMx) ? mxId : -<span style="color: #800080;">1</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>当然我们也可以使用更straightforward的方法，首先遍历一遍数组找出最大数字，然后再遍历一遍数组，验证这个数字是否是其他数字的至少两倍，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> dominantIndex(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        </span><span style="color: #0000ff;">int</span> mx = INT_MIN, mxId = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; nums.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (mx &lt;<span style="color: #000000;"> nums[i]) {
                mx </span>=<span style="color: #000000;"> nums[i];
                mxId </span>=<span style="color: #000000;"> i;
            }
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span><span style="color: #000000;"> num : nums) {
            </span><span style="color: #0000ff;">if</span> (mx != num &amp;&amp; mx - num &lt; num) <span style="color: #0000ff;">return</span> -<span style="color: #800080;">1</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> mxId;
    }
};</span></pre>
</div>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-01-30 22:06</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=8387593" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(8387593);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/8343874.html" id="cb_post_title_url">[LeetCode] Min Cost Climbing Stairs 爬楼梯的最小损失</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="question-description">
<p>On a staircase, the <code>i</code>-th step has some non-negative cost <code>cost[i]</code> assigned (0 indexed).</p>
<p>Once you pay the cost, you can either climb one or two steps. You need to find minimum cost to reach the top of the floor, and you can either start from the step with index 0, or the step with index 1.</p>
<p>Example 1:</p>
<pre>Input: cost = [10, 15, 20]
Output: 15
Explanation: Cheapest is start on cost[1], pay that cost and go to the top.
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]
Output: 6
Explanation: Cheapest is start on cost[0], and only step on 1s, skipping cost[3].
</pre>
<p> </p>
<p>Note:</p>
<ol>
<li><code>cost</code> will have a length in the range <code>[2, 1000]</code>.</li>
<li>Every <code>cost[i]</code> will be an integer in the range <code>[0, 999]</code>.</li>
</ol>
<p> </p>
</div>
<p>这道题应该算是之前那道<a href="http://www.cnblogs.com/grandyang/p/4079165.html" target="_blank">Climbing Stairs</a>的拓展，这里不是求步数，而是每个台阶上都有一个cost，让我们求爬到顶端的最小cost是多少。换汤不换药，还是用动态规划Dynamic Programming来做。这里我们定义一个一维的dp数组，其中dp[i]表示爬到第i层的最小cost，然后我们来想dp[i]如何推导。我们来思考一下如何才能到第i层呢？是不是只有两种可能性，一个是从第i-2层上直接跳上来，一个是从第i-1层上跳上来。不会再有别的方法，所以我们的dp[i]只和前两层有关系，所以可以写做如下：</p>
<p>dp[i] = min(dp[i- 2] + cost[i - 2], dp[i - 1] + cost[i - 1])</p>
<p>最后我们返回最后一个数字dp[n]即可，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> minCostClimbingStairs(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> cost) {
        </span><span style="color: #0000ff;">int</span> n =<span style="color: #000000;"> cost.size();
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; dp(n + <span style="color: #800080;">1</span>, <span style="color: #800080;">0</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">2</span>; i &lt; n + <span style="color: #800080;">1</span>; ++<span style="color: #000000;">i) {
            dp[i] </span>= min(dp[i- <span style="color: #800080;">2</span>] + cost[i - <span style="color: #800080;">2</span>], dp[i - <span style="color: #800080;">1</span>] + cost[i - <span style="color: #800080;">1</span><span style="color: #000000;">]);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> dp.back();
    }
};</span></pre>
</div>
<p> </p>
<p>再来看一种DP的解法，跟上面的解法很相近，不同在于dp数组长度为n，其中dp[i]表示到第i+1层的最小cost，分别初始化dp[0]和dp[1]为cost[0]和cost[1]。然后从i=2处开始遍历，此时我们的更新思路是，要爬当前的台阶，肯定需要加上当前的cost[i]，那么我们还是要从前一层或者前两层的台阶上跳上来，那么我们选择dp值小的那个，所以递归式如下：</p>
<p>dp[i] = cost[i] + min(dp[i- 1], dp[i - 2])</p>
<p>最后我们在最后两个dp值中选择一个较小的返回即可，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> minCostClimbingStairs(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> cost) {
        </span><span style="color: #0000ff;">int</span> n =<span style="color: #000000;"> cost.size();
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; dp(n, <span style="color: #800080;">0</span><span style="color: #000000;">);
        dp[</span><span style="color: #800080;">0</span>] = cost[<span style="color: #800080;">0</span>]; dp[<span style="color: #800080;">1</span>] = cost[<span style="color: #800080;">1</span><span style="color: #000000;">];
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">2</span>; i &lt; n; ++<span style="color: #000000;">i) {
            dp[i] </span>= cost[i] + min(dp[i- <span style="color: #800080;">1</span>], dp[i - <span style="color: #800080;">2</span><span style="color: #000000;">]);
        }
        </span><span style="color: #0000ff;">return</span> min(dp[n - <span style="color: #800080;">1</span>], dp[n - <span style="color: #800080;">2</span><span style="color: #000000;">]);
    }
};</span></pre>
</div>
<p> </p>
<p>我们可以对空间复杂度进行优化，通过前面的分析我们可以发现，当前的dp值仅仅依赖前面两个的值，所以我们不必把整个dp数组都记录下来，只需用两个变量a和b来记录前两个值，然后不停的用新得到的值来覆盖它们就好了。我们初始化a和b均为0，然后遍历cost数组，首先将a和b中较小值加上num放入临时变量t中，然后把b赋给a，把t赋给b即可，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> minCostClimbingStairs(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> cost) {
        </span><span style="color: #0000ff;">int</span> a = <span style="color: #800080;">0</span>, b = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span><span style="color: #000000;"> num : cost) {
            </span><span style="color: #0000ff;">int</span> t = min(a, b) +<span style="color: #000000;"> num;
            a </span>=<span style="color: #000000;"> b;
            b </span>=<span style="color: #000000;"> t;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> min(a, b);
    }
};</span></pre>
</div>
<p> </p>
<p>我们还可以用递归来写，需要优化计算量，即用哈希map来保存已经算过了台阶，用的还是dp的思想，参见代码如下：</p>
<p> </p>
<p>解法四：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> minCostClimbingStairs(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> cost) {
        unordered_map</span>&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> memo;
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> helper(cost, cost.size(), memo);
    }
    </span><span style="color: #0000ff;">int</span> helper(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; cost, <span style="color: #0000ff;">int</span> i, unordered_map&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> memo) {
        </span><span style="color: #0000ff;">if</span> (memo.count(i)) <span style="color: #0000ff;">return</span><span style="color: #000000;"> memo[i];
        </span><span style="color: #0000ff;">if</span> (i &lt;= <span style="color: #800080;">1</span>) <span style="color: #0000ff;">return</span> memo[i] =<span style="color: #000000;"> cost[i];
        </span><span style="color: #0000ff;">return</span> memo[i] = (i == cost.size() ? <span style="color: #800080;">0</span> : cost[i]) + min(helper(cost, i - <span style="color: #800080;">1</span>, memo), helper(cost, i - <span style="color: #800080;">2</span><span style="color: #000000;">, memo));
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4079165.html" target="_blank">Climbing Stairs</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/114149/c-o-1-space">https://discuss.leetcode.com/topic/114149/c-o-1-space</a></p>
<p><a href="https://discuss.leetcode.com/topic/114144/easy-to-understand-c-using-dp-with-detailed-explanation">https://discuss.leetcode.com/topic/114144/easy-to-understand-c-using-dp-with-detailed-explanation</a></p>
<p> </p>
<div class="blogpost-body" id="cnblogs_post_body">
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p>
</div></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-01-24 22:27</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=8343874" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(8343874);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/8331660.html" id="cb_post_title_url">[LeetCode] Prefix and Suffix Search 前后缀搜索</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given many <code>words</code>, <code>words[i]</code> has weight <code>i</code>.</p>
<p>Design a class <code>WordFilter</code> that supports one function, <code>WordFilter.f(String prefix, String suffix)</code>. It will return the word with given <code>prefix</code> and <code>suffix</code> with maximum weight. If no word exists, return -1.</p>
<p><strong>Examples:</strong><br/>
</p>
<pre><strong>Input:</strong>
WordFilter(["apple"])
WordFilter.f("a", "e") // returns 0
WordFilter.f("b", "") // returns -1
</pre>
<p><strong>Note:</strong><br/>
</p>
<ol><ol>
<li><code>words</code> has length in range <code>[1, 15000]</code>.</li>
<li>For each test case, up to <code>words.length</code> queries <code>WordFilter.f</code> may be made.</li>
<li><code>words[i]</code> has length in range <code>[1, 10]</code>.</li>
<li><code>prefix, suffix</code> have lengths in range <code>[0, 10]</code>.</li>
<li><code>words[i]</code> and <code>prefix, suffix</code> queries consist of lowercase letters only.</li>
</ol></ol>
<p> </p>
<p>这道题给了我们一些单词，让我们通过输入单词的前缀和后缀来查找单词的位置。单词的位置就是其权重值，如果给定的前后缀能对应到不只一个单词，那么返回最大的权重。首先，一个单词如果长度为n的话，那么其就有n个前缀，比如对于单词apple，其前缀即为"a", "ap", "app", "appl", "apple"，同理，后缀也有n个。那么其组成的情况就有n<sup>2</sup>个，所以最简单的方法就是把这n<sup>2</sup>个前后缀组成一个字符串，和当前权重建立映射。如果后面的单词有相同的前后缀，直接用后面的大权重来覆盖之前的权重即可。为了将前后缀encode成一个字符串，我们可以在中间加上一个非字母字符，比如'#'，然后在查找的时候，我们先拼出“前缀#后缀”字符串，直接去哈希map中找即可，这种解法的WordFilter函数时间复杂度为O(NL^2)，其中N是单词个数，L是单词长度。f函数时间复杂度为O(1)，空间复杂度为O(NL^2)，适合需要大量查找的情况下使用，参见代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> WordFilter {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    WordFilter(vector</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> words) {
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> k = <span style="color: #800080;">0</span>; k &lt; words.size(); ++<span style="color: #000000;">k) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt;= words[k].size(); ++<span style="color: #000000;">i) {
                </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt;= words[k].size(); ++<span style="color: #000000;">j) {
                    m[words[k].substr(</span><span style="color: #800080;">0</span>, i) + <span style="color: #800000;">"</span><span style="color: #800000;">#</span><span style="color: #800000;">"</span> + words[k].substr(words[k].size() - j)] =<span style="color: #000000;"> k;
                }
            }
        }
    }

    </span><span style="color: #0000ff;">int</span> f(<span style="color: #0000ff;">string</span> prefix, <span style="color: #0000ff;">string</span><span style="color: #000000;"> suffix) {
        </span><span style="color: #0000ff;">return</span> (m.count(prefix + <span style="color: #800000;">"</span><span style="color: #800000;">#</span><span style="color: #800000;">"</span> + suffix)) ? m[prefix + <span style="color: #800000;">"</span><span style="color: #800000;">#</span><span style="color: #800000;">"</span> + suffix] : -<span style="color: #800080;">1</span><span style="color: #000000;">;
    }

</span><span style="color: #0000ff;">private</span><span style="color: #000000;">:
    unordered_map</span>&lt;<span style="color: #0000ff;">string</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> m;
};</span></pre>
</div>
<p> </p>
<p>如果我们希望节省一些空间的话，可以使用下面的方法。使用两个哈希map，一个建立所有前缀和权重数组之间的映射，另一个建立所有后缀和权重数组之间的映射。在WordFilter函数中，我们遍历每个单词，然后先遍历其所有前缀，将遍历到的前缀的映射数组中加入当前权重，同理再遍历其所有后缀，将遍历到的后缀的映射数组中加入当前权重。在搜索函数f中，首先判断，如果前缀或后缀不存在的话，直接返回-1。否则我们分别把前缀和后缀的权重数组取出来，然后用两个指针i和j，分别指向数组的最后一个位置。当i和j不小于0时进行循环，如果两者的权重相等，直接返回，如果前缀的权重数组值大，则j自减1，反之i自减1，这种解法的WordFilter函数时间复杂度为O(NL)，其中N是单词个数，L是单词长度。f函数时间复杂度为O(N)，空间复杂度为O(NL)，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> WordFilter {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    WordFilter(vector</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> words) {
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> k = <span style="color: #800080;">0</span>; k &lt; words.size(); ++<span style="color: #000000;">k) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt;= words[k].size(); ++<span style="color: #000000;">i) {
                mp[words[k].substr(</span><span style="color: #800080;">0</span><span style="color: #000000;">, i)].push_back(k);
            }
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt;= words[k].size(); ++<span style="color: #000000;">i) {
                ms[words[k].substr(words[k].size() </span>-<span style="color: #000000;"> i)].push_back(k);
            }
        }
    }

    </span><span style="color: #0000ff;">int</span> f(<span style="color: #0000ff;">string</span> prefix, <span style="color: #0000ff;">string</span><span style="color: #000000;"> suffix) {
        </span><span style="color: #0000ff;">if</span> (!mp.count(prefix) || !ms.count(suffix)) <span style="color: #0000ff;">return</span> -<span style="color: #800080;">1</span><span style="color: #000000;">;
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; pre = mp[prefix], suf =<span style="color: #000000;"> ms[suffix];
        </span><span style="color: #0000ff;">int</span> i = pre.size() - <span style="color: #800080;">1</span>, j = suf.size() - <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (i &gt;= <span style="color: #800080;">0</span> &amp;&amp; j &gt;= <span style="color: #800080;">0</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">if</span> (pre[i] &lt; suf[j]) --<span style="color: #000000;">j;
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (pre[i] &gt; suf[j]) --<span style="color: #000000;">i;
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">return</span><span style="color: #000000;"> pre[i];
        }
        </span><span style="color: #0000ff;">return</span> -<span style="color: #800080;">1</span><span style="color: #000000;">;
    }

</span><span style="color: #0000ff;">private</span><span style="color: #000000;">:
    unordered_map</span>&lt;<span style="color: #0000ff;">string</span>, vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;<span style="color: #000000;"> mp, ms;
};</span></pre>
</div>
<p> </p>
<p><a href="https://discuss.leetcode.com/topic/113547/three-ways-to-solve-this-problem-in-java" target="_blank">moto72大神的帖子</a>中还有第三种解法，但是C++中没有startsWith()和endsWith()函数，以至于无法写出C++版本的，还是Java比较叼啊。</p>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4507286.html" target="_blank">Add and Search Word - Data structure design</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/113547/three-ways-to-solve-this-problem-in-java" target="_blank">https://discuss.leetcode.com/topic/113547/three-ways-to-solve-this-problem-in-java</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-01-22 23:18</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=8331660" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(8331660);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/8284940.html" id="cb_post_title_url">[LeetCode] Find Smallest Letter Greater Than Target 找比目标值大的最小字母</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a list of sorted characters <code>letters</code> containing only lowercase letters, and given a target letter <code>target</code>, find the smallest element in the list that is larger than the given target.</p>
<p>Letters also wrap around. For example, if the target is <code>target = 'z'</code> and <code>letters = ['a', 'b']</code>, the answer is <code>'a'</code>.</p>
<p>Examples:</p>
<pre>Input:
letters = ["c", "f", "j"]
target = "a"
Output: "c"

Input:
letters = ["c", "f", "j"]
target = "c"
Output: "f"

Input:
letters = ["c", "f", "j"]
target = "d"
Output: "f"

Input:
letters = ["c", "f", "j"]
target = "g"
Output: "j"

Input:
letters = ["c", "f", "j"]
target = "j"
Output: "c"

Input:
letters = ["c", "f", "j"]
target = "k"
Output: "c"
</pre>
<p> </p>
<p>Note:</p>
<ol>
<li><code>letters</code> has a length in range <code>[2, 10000]</code>.</li>
<li><code>letters</code> consists of lowercase letters, and contains at least 2 unique letters.</li>
<li><code>target</code> is a lowercase letter.</li>
</ol>
<p> </p>
<p>这道题给了我们一堆有序的字母，然后又给了我们一个target字母，让我们求字母数组中第一个大于target的字母，数组是循环的，如果没有，那就返回第一个字母。像这种在有序数组中找数字，二分法简直不要太适合啊。题目中说了数组至少有两个元素，那么我们首先用数组的尾元素来跟target比较，如果target大于等于尾元素的话，直接返回数组的首元素即可。否则就利用二分法来做，这里是查找第一个大于目标值的数组，博主之前做过二分法的总结，参见这个帖子<a class="entrylistItemTitle" href="http://www.cnblogs.com/grandyang/p/6854825.html" id="CategoryEntryList1_EntryStoryList_ctl00_Entries_TitleUrl_1">LeetCode Binary Search Summary 二分搜索法小结</a>，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">char</span> nextGreatestLetter(vector&lt;<span style="color: #0000ff;">char</span>&gt;&amp; letters, <span style="color: #0000ff;">char</span><span style="color: #000000;"> target) {
        </span><span style="color: #0000ff;">if</span> (target &gt;= letters.back()) <span style="color: #0000ff;">return</span> letters[<span style="color: #800080;">0</span><span style="color: #000000;">];
        </span><span style="color: #0000ff;">int</span> n = letters.size(), left = <span style="color: #800080;">0</span>, right =<span style="color: #000000;"> n;
        </span><span style="color: #0000ff;">while</span> (left &lt;<span style="color: #000000;"> right) {
            </span><span style="color: #0000ff;">int</span> mid = left + (right - left) / <span style="color: #800080;">2</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> (letters[mid] &lt;= target) left = mid + <span style="color: #800080;">1</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">else</span> right =<span style="color: #000000;"> mid;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> letters[right];
    }
};</span></pre>
</div>
<p> </p>
<p>我们也可以用STL自带的upper_bound函数来做，这个就是找第一个大于目标值的数字，如果返回end()，说明没找到，返回首元素即可，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">char</span> nextGreatestLetter(vector&lt;<span style="color: #0000ff;">char</span>&gt;&amp; letters, <span style="color: #0000ff;">char</span><span style="color: #000000;"> target) {
        auto it </span>=<span style="color: #000000;"> upper_bound(letters.begin(), letters.end(), target);
        </span><span style="color: #0000ff;">return</span> it == letters.end() ? *letters.begin() : *<span style="color: #000000;">it;
    }
};</span></pre>
</div>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-01-14 23:58</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=8284940" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(8284940);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/8278115.html" id="cb_post_title_url">[LeetCode] Network Delay Time 网络延迟时间</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>There are <code>N</code> network nodes, labelled <code>1</code> to <code>N</code>.</p>
<p>Given <code>times</code>, a list of travel times as directed edges <code>times[i] = (u, v, w)</code>, where <code>u</code> is the source node, <code>v</code> is the target node, and <code>w</code> is the time it takes for a signal to travel from source to target.</p>
<p>Now, we send a signal from a certain node <code>K</code>. How long will it take for all nodes to receive the signal? If it is impossible, return <code>-1</code>.</p>
<p>Note:</p>
<ol>
<li><code>N</code> will be in the range <code>[1, 100]</code>.</li>
<li><code>K</code> will be in the range <code>[1, N]</code>.</li>
<li>The length of <code>times</code> will be in the range <code>[1, 6000]</code>.</li>
<li>All edges <code>times[i] = (u, v, w)</code> will have <code>1 &lt;= u, v &lt;= N</code> and <code>1 &lt;= w &lt;= 100</code>.</li>
</ol>
<p> </p>
<p>这道题给了我们一些有向边，又给了一个结点K，问至少需要多少时间才能从K到达任何一个结点。这实际上是一个有向图求最短路径的问题，我们求出K点到每一个点到最短路径，然后取其中最大的一个就是需要的时间了。可以想成从结点K开始有水流向周围扩散，当水流到达最远的一个结点时，那么其他所有的结点一定已经流过水了。最短路径的常用解法有迪杰克斯特拉算法Dijkstra Algorithm, 弗洛伊德算法Floyd-Warshall Algorithm, 和贝尔曼福特算法Bellman-Ford Algorithm，其中，Floyd算法是多源最短路径，即求任意点到任意点到最短路径，而Dijkstra算法和Bellman-Ford算法是单源最短路径，即单个点到任意点到最短路径。这里因为起点只有一个K，所以使用单源最短路径就行了。这三种算法还有一点不同，就是Dijkstra算法处理有向权重图时，权重必须为正，而另外两种可以处理负权重有向图，但是不能出现负环，所谓负环，就是权重均为负的环。为啥呢，这里要先引入松弛操作Relaxtion，这是这三个算法的核心思想，当有对边 (u, v) 是结点u到结点v，如果 dist(v) &gt; dist(u) + w(u, v)，那么 dist(v) 就可以被更新，这是所有这些的算法的核心操作。Dijkstra算法是以起点为中心，向外层层扩展，直到扩展到终点为止。根据这特性，用BFS来实现时再好不过了，注意while循环里的第一层for循环，这保证了每一层的结点先被处理完，才会进入进入下一层，这种特性在用BFS遍历迷宫统计步数的时候很重要。对于每一个结点，我们都跟其周围的结点进行Relaxtion操作，从而更新周围结点的距离值。为了防止重复比较，我们需要使用visited数组来记录已访问过的结点，最后我们在所有的最小路径中选最大的返回，注意，如果结果res为INT_MAX，说明有些结点是无法到达的，返回-1。普通的实现方法的时间复杂度为O(V<sup>2</sup>)，基于优先队列的实现方法的时间复杂度为O(E + VlogV)，其中V和E分别为结点和边的个数，这里多说一句，Dijkstra算法这种类贪心算法的机制，使得其无法处理有负权重的最短距离，还好这道题的权重都是正数，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> networkDelayTime(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp; times, <span style="color: #0000ff;">int</span> N, <span style="color: #0000ff;">int</span><span style="color: #000000;"> K) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; edges(<span style="color: #800080;">101</span>, vector&lt;<span style="color: #0000ff;">int</span>&gt;(<span style="color: #800080;">101</span>, -<span style="color: #800080;">1</span><span style="color: #000000;">));
        queue</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> q{{K}};
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; dist(N + <span style="color: #800080;">1</span><span style="color: #000000;">, INT_MAX);
        dist[K] </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (auto e : times) edges[e[<span style="color: #800080;">0</span>]][e[<span style="color: #800080;">1</span>]] = e[<span style="color: #800080;">2</span><span style="color: #000000;">];
        </span><span style="color: #0000ff;">while</span> (!<span style="color: #000000;">q.empty()) {
            unordered_set</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> visited;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = q.size(); i &gt; <span style="color: #800080;">0</span>; --<span style="color: #000000;">i) {
                </span><span style="color: #0000ff;">int</span> u =<span style="color: #000000;"> q.front(); q.pop();
                </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> v = <span style="color: #800080;">1</span>; v &lt;= <span style="color: #800080;">100</span>; ++<span style="color: #000000;">v) {
                    </span><span style="color: #0000ff;">if</span> (edges[u][v] != -<span style="color: #800080;">1</span> &amp;&amp; dist[u] + edges[u][v] &lt;<span style="color: #000000;"> dist[v]) {
                        </span><span style="color: #0000ff;">if</span> (!<span style="color: #000000;">visited.count(v)) {
                            visited.insert(v);
                            q.push(v);
                        }
                        dist[v] </span>= dist[u] +<span style="color: #000000;"> edges[u][v];
                    }
                }
            }
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt;= N; ++<span style="color: #000000;">i) {
            res </span>=<span style="color: #000000;"> max(res, dist[i]);
        }
        </span><span style="color: #0000ff;">return</span> res == INT_MAX ? -<span style="color: #800080;">1</span><span style="color: #000000;"> : res;
    }
};</span></pre>
</div>
<p> </p>
<p>下面来看基于Bellman-Ford算法的解法，时间复杂度是O(VE)，V和E分别是结点和边的个数。这种算法是基于DP来求全局最优解，原理是对图进行V - 1次松弛操作，这里的V是所有结点的个数（为啥是V-1次呢，因为最短路径最多只有V-1条边，所以只需循环V-1次），在重复计算中，使得每个结点的距离被不停的更新，直到获得最小的距离，这种设计方法融合了暴力搜索之美，写法简洁又不失优雅。之前提到了，Bellman-Ford算法可以处理负权重的情况，但是不能有负环存在，一般形式的写法中最后一部分是检测负环的，如果存在负环则报错。不能有负环原因是，每转一圈，权重和都在减小，可以无限转，那么最后的最小距离都是负无穷，无意义了。没有负环的话，V-1次循环后各点的最小距离应该已经收敛了，所以在检测负环时，就再循环一次，如果最小距离还能更新的话，就说明存在负环。这道题由于不存在负权重，所以就不检测了，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> networkDelayTime(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp; times, <span style="color: #0000ff;">int</span> N, <span style="color: #0000ff;">int</span><span style="color: #000000;"> K) {
        </span><span style="color: #0000ff;">int</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; dist(N + <span style="color: #800080;">1</span><span style="color: #000000;">, INT_MAX);
        dist[k] </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt; N; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto e : times) {
                </span><span style="color: #0000ff;">int</span> u = e[<span style="color: #800080;">0</span>], v = e[<span style="color: #800080;">1</span>], w = e[<span style="color: #800080;">2</span><span style="color: #000000;">];
                </span><span style="color: #0000ff;">if</span> (dist[u] != INT_MAX &amp;&amp; dist[v] &gt; dist[u] +<span style="color: #000000;"> w) {
                    dist[v] </span>= dist[u] +<span style="color: #000000;"> w;
                }
            }
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt;= N; ++<span style="color: #000000;">i) {
            res </span>=<span style="color: #000000;"> max(res, dist[i]);
        }
        </span><span style="color: #0000ff;">return</span> res == INT_MAX ? -<span style="color: #800080;">1</span><span style="color: #000000;"> : res;
    }
};</span></pre>
</div>
<p> </p>
<p>最后，再来说说这个Floyd算法，这也是一种经典的动态规划算法，目的是要找结点i到结点j的最短路径。而结点i到结点j的走法就两种可能，一种是直接从结点i到结点j，另一种是经过若干个结点k到达结点j。所以对于每个中间结点k，我们检查dist(i, k) + dist(k, j) &lt; dist(i, j) 是否成立，成立的话就松弛它，这样遍历完所有的结点k，dist(i, j)中就是结点i到结点j的最短距离了。时间复杂度是O(V<sup>3</sup>)，处处透露着暴力美学。除了这三种算法外，还有一些很类似的优化算法，比如Bellman-Ford的优化算法-SPFA算法，还有融合了Bellman-Ford和Dijkstra算法的高效的多源最短路径算法-Johnson算法，这里就不过多赘述了，感兴趣的童鞋可尽情的Google之～</p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/113448/java-c-clean-code-bfs"><span style="color: #000000;"> </span></a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4606334.html" target="_blank">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-01-12 23:52</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=8278115" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(8278115);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/8245586.html" id="cb_post_title_url">[LeetCode] Closest Leaf in a Binary Tree 二叉树中最近的叶结点</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="question-description">
<p>Given a binary tree where every node has a unique value, and a target key <code>k</code>, find the value of the nearest leaf node to target <code>k</code> in the tree.</p>
<p>Here, <em>nearest</em> to a leaf means the least number of edges travelled on the binary tree to reach any leaf of the tree. Also, a node is called a <em>leaf</em> if it has no children.</p>
<p>In the following examples, the input tree is represented in flattened form row by row. The actual <code>root</code> tree given will be a TreeNode object.</p>
<p>Example 1:</p>
<pre>Input:
root = [1, 3, 2], k = 1
Diagram of binary tree:
          1
         / \
        3   2

Output: 2 (or 3)

Explanation: Either 2 or 3 is the nearest leaf node to the target of 1.
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input:
root = [1], k = 1
Output: 1

Explanation: The nearest leaf node is the root node itself.
</pre>
<p> </p>
<p>Example 3:</p>
<pre>Input:
root = [1,2,3,4,null,null,null,5,null,6], k = 2
Diagram of binary tree:
             1
            / \
           2   3
          /
         4
        /
       5
      /
     6

Output: 3
Explanation: The leaf node with value 3 (and not the leaf node with value 6) is nearest to the node with value 2.
</pre>
<p> </p>
<p>Note:</p>
<ol>
<li><code>root</code> represents a binary tree with at least <code>1</code> node and at most <code>1000</code> nodes.</li>
<li>Every node has a unique <code>node.val</code> in range <code>[1, 1000]</code>.</li>
<li>There exists some node in the given binary tree for which <code>node.val == k</code>.</li>
</ol>
<p> </p>
</div>
<p>这道题让我们找二叉树中最近的叶结点，叶结点就是最底端没有子结点的那个。我们观察题目中的例子3，发现结点2的最近叶结点是其右边的那个结点3，那么传统的二叉树的遍历只能去找其子结点中的叶结点，像这种同一层水平的结点该怎么弄呢？我们知道树的本质就是一种无向图，但是树只提供了父结点到子结点的连接，反过来就不行了，所以只要我们建立了反向连接，就可以用BFS来找最近的叶结点了。明白了这一点后，我们就先来做反向连接吧，用一个哈希map，建立子结点与其父结点之间的映射，其实我们不用做完所有的反向连接，而是做到要求的结点k就行了，因为结点k的子结点可以直接访问，不需要再反过来查找。我们用DFS来遍历结点，并做反向连接，直到遇到结点k时，将其返回。此时我们得到了结点k，并且做好了结点k上面所有结点的反向连接，那么就可以用BFS来找最近的叶结点了，将结点k加入队列queue和已访问集合visited中，然后开始循环，每次取出队首元素，如果是叶结点，说明已经找到了最近叶结点，直接返回；如果左子结点存在，并且不在visited集合中，那么先将其加入集合，然后再加入队列，同理，如果右子结点存在，并且不在visited集合中，那么先将其加入集合，然后再加入队列；再来看其父结点，如果不在visited集合中，那么先将其加入集合，然后再加入队列。因为题目中说了一定会有结点k，所以在循环内部就可以直接返回了，不会有退出循环的可能，但是为表尊重，我们最后还是加上return -1吧， 参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> findClosestLeaf(TreeNode* root, <span style="color: #0000ff;">int</span><span style="color: #000000;"> k) {
        unordered_map</span>&lt;TreeNode*, TreeNode*&gt;<span style="color: #000000;"> back;
        TreeNode </span>*kNode =<span style="color: #000000;"> find(root, k, back);
        queue</span>&lt;TreeNode*&gt;<span style="color: #000000;"> q{{kNode}};
        unordered_set</span>&lt;TreeNode*&gt;<span style="color: #000000;"> visited{{kNode}};
        </span><span style="color: #0000ff;">while</span> (!<span style="color: #000000;">q.empty()) {
            TreeNode </span>*t =<span style="color: #000000;"> q.front(); q.pop();
            </span><span style="color: #0000ff;">if</span> (!t-&gt;left &amp;&amp; !t-&gt;right) <span style="color: #0000ff;">return</span> t-&gt;<span style="color: #000000;">val;
            </span><span style="color: #0000ff;">if</span> (t-&gt;left &amp;&amp; !visited.count(t-&gt;<span style="color: #000000;">left)) {
                visited.insert(t</span>-&gt;<span style="color: #000000;">left);
                q.push(t</span>-&gt;<span style="color: #000000;">left);
            }
            </span><span style="color: #0000ff;">if</span> (t-&gt;right &amp;&amp; !visited.count(t-&gt;<span style="color: #000000;">right)) {
                visited.insert(t</span>-&gt;<span style="color: #000000;">right);
                q.push(t</span>-&gt;<span style="color: #000000;">right);
            }
            </span><span style="color: #0000ff;">if</span> (back.count(t) &amp;&amp; !<span style="color: #000000;">visited.count(back[t])) {
                visited.insert(back[t]);
                q.push(back[t]);
            }
        }
        </span><span style="color: #0000ff;">return</span> -<span style="color: #800080;">1</span><span style="color: #000000;">;
    }
    TreeNode</span>* find(TreeNode* node, <span style="color: #0000ff;">int</span> k, unordered_map&lt;TreeNode*, TreeNode*&gt;&amp;<span style="color: #000000;"> back) {
        </span><span style="color: #0000ff;">if</span> (node-&gt;val == k) <span style="color: #0000ff;">return</span><span style="color: #000000;"> node;
        </span><span style="color: #0000ff;">if</span> (node-&gt;<span style="color: #000000;">left) {
            back[node</span>-&gt;left] =<span style="color: #000000;"> node;
            TreeNode </span>*left = find(node-&gt;<span style="color: #000000;">left, k, back);
            </span><span style="color: #0000ff;">if</span> (left) <span style="color: #0000ff;">return</span><span style="color: #000000;"> left;
        }
        </span><span style="color: #0000ff;">if</span> (node-&gt;<span style="color: #000000;">right) {
            back[node</span>-&gt;right] =<span style="color: #000000;"> node;
            TreeNode </span>*right = find(node-&gt;<span style="color: #000000;">right, k, back);
            </span><span style="color: #0000ff;">if</span> (right) <span style="color: #0000ff;">return</span><span style="color: #000000;"> right;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> NULL;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种解法也挺巧妙的，虽然没有像上面的解法那样建立所有父结点的反向连接，但是这种解法直接提前算出来了所有父结点到结点k的距离，就比如说例子3中，结点k的父结点只有一个，即为结点1，那么算出其和结点k的距离为1，即建立结点1和距离1之间的映射，另外建立结点k和0之间的映射，这样便于从结点k开始像叶结点统计距离。接下来，我们维护一个最小值mn，表示结点k到叶结点的最小距离，还有结果res，指向那个最小距离的叶结点。下面就开始再次遍历二叉树了，如果当前结点为空， 直接返回。否则先在哈希map中看当前结点是否有映射值，有的话就取出来（如果有，则说明当前结点可能k或者其父结点），如果当前结点是叶结点了，那么我们要用当前距离cur和最小距离mn比较，如果cur更小的话，就将mn更新为cur，将结果res更新为当前结点。否则就对其左右子结点调用递归函数，注意cur要加1，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> findClosestLeaf(TreeNode* root, <span style="color: #0000ff;">int</span><span style="color: #000000;"> k) {
        </span><span style="color: #0000ff;">int</span> res = -<span style="color: #800080;">1</span>, mn =<span style="color: #000000;"> INT_MAX;
        unordered_map</span>&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> m;
        m[k] </span>= <span style="color: #800080;">0</span><span style="color: #000000;">;
        find(root, k, m);
        helper(root, </span>-<span style="color: #800080;">1</span><span style="color: #000000;">, m, mn, res);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">int</span> find(TreeNode* node, <span style="color: #0000ff;">int</span> k, unordered_map&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> m) {
        </span><span style="color: #0000ff;">if</span> (!node) <span style="color: #0000ff;">return</span> -<span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (node-&gt;val == k) <span style="color: #0000ff;">return</span> <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> r = find(node-&gt;<span style="color: #000000;">left, k, m);
        </span><span style="color: #0000ff;">if</span> (r != -<span style="color: #800080;">1</span><span style="color: #000000;">) {
            m[node</span>-&gt;val] =<span style="color: #000000;"> r; 
            </span><span style="color: #0000ff;">return</span> r + <span style="color: #800080;">1</span><span style="color: #000000;">;
        }
        r </span>= find(node-&gt;<span style="color: #000000;">right, k, m);
        </span><span style="color: #0000ff;">if</span> (r != -<span style="color: #800080;">1</span><span style="color: #000000;">) {
            m[node</span>-&gt;val] =<span style="color: #000000;"> r;
            </span><span style="color: #0000ff;">return</span> r + <span style="color: #800080;">1</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> -<span style="color: #800080;">1</span><span style="color: #000000;">;
    }
    </span><span style="color: #0000ff;">void</span> helper(TreeNode* node, <span style="color: #0000ff;">int</span> cur, unordered_map&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;&amp; m, <span style="color: #0000ff;">int</span>&amp; mn, <span style="color: #0000ff;">int</span>&amp;<span style="color: #000000;"> res) {
        </span><span style="color: #0000ff;">if</span> (!node) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (m.count(node-&gt;val)) cur = m[node-&gt;<span style="color: #000000;">val];
        </span><span style="color: #0000ff;">if</span> (!node-&gt;left &amp;&amp; !node-&gt;<span style="color: #000000;">right) {
            </span><span style="color: #0000ff;">if</span> (mn &gt;<span style="color: #000000;"> cur) {
                mn </span>=<span style="color: #000000;"> cur; 
                res </span>= node-&gt;<span style="color: #000000;">val;</span><span style="color: #000000;">
            }
        }
        helper(node</span>-&gt;left, cur + <span style="color: #800080;">1</span><span style="color: #000000;">, m, mn, res);
        helper(node</span>-&gt;right, cur + <span style="color: #800080;">1</span><span style="color: #000000;">, m, mn, res);
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/113482/java-dfs-bfs-27ms">https://discuss.leetcode.com/topic/113482/java-dfs-bfs-27ms</a></p>
<p><a href="https://discuss.leetcode.com/topic/113467/java-short-solution-28-ms-solution">https://discuss.leetcode.com/topic/113467/java-short-solution-28-ms-solution</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-01-08 23:46</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=8245586" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(8245586);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/8215787.html" id="cb_post_title_url">[LeetCode] Cherry Pickup 捡樱桃</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>In a N x N <code>grid</code> representing a field of cherries, each cell is one of three possible integers.</p>
<p> </p>
<ul>
<li>0 means the cell is empty, so you can pass through;</li>
<li>1 means the cell contains a cherry, that you can pick up and pass through;</li>
<li>-1 means the cell contains a thorn that blocks your way.</li>
</ul>
<p> </p>
<p>Your task is to collect maximum number of cherries possible by following the rules below:</p>
<p> </p>
<ul>
<li>Starting at the position (0, 0) and reaching (N-1, N-1) by moving right or down through valid path cells (cells with value 0 or 1);</li>
<li>After reaching (N-1, N-1), returning to (0, 0) by moving left or up through valid path cells;</li>
<li>When passing through a path cell containing a cherry, you pick it up and the cell becomes an empty cell (0);</li>
<li>If there is no valid path between (0, 0) and (N-1, N-1), then no cherries can be collected.</li>
</ul>
<p> </p>
<p> </p>
<p>Example 1:</p>
<pre>Input: grid =
[[0, 1, -1],
 [1, 0, -1],
 [1, 1,  1]]
Output: 5
Explanation: 
The player started at (0, 0) and went down, down, right right to reach (2, 2).
4 cherries were picked up during this single trip, and the matrix becomes [[0,1,-1],[0,0,-1],[0,0,0]].
Then, the player went left, up, up, left to return home, picking up one more cherry.
The total number of cherries picked up is 5, and this is the maximum possible.
</pre>
<p> </p>
<p>Note:</p>
<ul>
<li><code>grid</code> is an <code>N</code> by <code>N</code> 2D array, with <code>1 &lt;= N &lt;= 50</code>.</li>
<li>Each <code>grid[i][j]</code> is an integer in the set <code>{-1, 0, 1}</code>.</li>
<li>It is guaranteed that grid[0][0] and grid[N-1][N-1] are not -1.</li>
</ul>
<p> </p>
<p>这道题给了我们一个二维数组，每个数字只有三个数字，-1，0，和1，其中-1表示障碍物不能通过，1表示有樱桃并可以通过，0表示没有樱桃并可以通过，并设定左上角为起点，右下角为终点，让我们从起点走到终点，再从终点返回起点，求最多能捡的樱桃的个数，限定起点和终点都没有障碍物。博主开始想的是就用dp来做呗，先从起点走到终点，求最多能捡多个樱桃，然后将捡起樱桃后将grid值变为0，然后再走一遍，把两次得到的樱桃数相加即可，但是类似贪婪算法的dp解法却跪在了下面这个case：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #000000;"><span style="color: #ff0000;">1</span> <span style="color: #ff0000;">1 1 1</span> 0 0 0
0 0 0 <span style="color: #ff0000;">1</span> 0 0 0
0 0 0 <span style="color: #ff0000;">1</span> 0 0 1
1 0 0 <span style="color: #ff0000;">1</span> 0 0 0
0 0 0 <span style="color: #ff0000;">1</span> 0 0 0
0 0 0 <span style="color: #ff0000;">1</span> 0 0 0
0 0 0 <span style="color: #ff0000;">1 1 1 1</span></span></pre>
</div>
<p> </p>
<p>我们可以看出，红色的轨迹是第一次dp解法走过的路径，共拿到了13个樱桃，但是回到起点的话，剩下的两个樱桃无论如何也不可能同时拿到，只能拿到1颗，所以总共只能捡到14颗樱桃，而实际上所有的樱桃都可以捡到，需要换个走法的话，比如下面这种走法：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #000000;"><span style="color: #ff0000;">1</span> <span style="color: #0000ff;">1 1 1</span> 0 0 0
<span style="color: #ff0000;">0</span> 0 0 <span style="color: #0000ff;">1</span> 0 0 0
<span style="color: #ff0000;">0</span> 0 0 <span style="color: #0000ff;">1 0 0 1</span>
<span style="color: #ff0000;">1 0 0 1</span> 0 0 <span style="color: #0000ff;">0</span>
0 0 0 <span style="color: #ff0000;">1</span> 0 0 <span style="color: #0000ff;">0</span>
0 0 0 <span style="color: #ff0000;">1</span> 0 0 <span style="color: #0000ff;">0</span>
0 0 0 <span style="color: #ff0000;">1 1 1 1</span></span></pre>
</div>
<p> </p>
<p>红色为从起点到终点的走法，共拿到9颗樱桃，回去走蓝色的路径，可拿到6颗樱桃，所以总共15颗都能收入囊中。那这是怎么回事，原因出在了我们的dp递推式的设计上，博主之前设计式，当前位置的樱桃数跟上边和左边的樱桃数有关，取二者的较大值，如果只是从起点到终点走单程的话，这种设计是没有问题的，可以拿到最多的樱桃，但如果是round trip的话，那么就不行了。这里参考的还是<span class="username"><a href="https://discuss.leetcode.com/topic/113762/step-by-step-guidance-of-the-o-n-3-time-and-o-n-2-space-solution" target="_blank">fun4LeetCode大神的帖子</a>，范佛利特扣德大神的帖子每次讲解都写的巨详细，总是让博主有种读paper的感觉。博主就挑选部分来讲讲，完整版可以自己去读一读大神的亲笔～</span></p>
<p>最开始时博主定义的dp[i][j]为单程的，即到达(i, j)位置能捡到的最大樱桃数，即：</p>
<div class="cnblogs_code">
<pre>T(i, j) = grid[i][j] + max{ T(i-<span style="color: #800080;">1</span>, j), T(i, j-<span style="color: #800080;">1</span>) }</pre>
</div>
<p>但是定义单程就得改变grid的值，再进行一次dp计算时，就会陷入之前例子中的陷阱。所以我们的dp[i][j]还是需要定义为round trip的，即到达(i, j)位置并返回起点时能捡到的最大樱桃数，但是新的问题就来了，樱桃只有一个，只能捡一次，去程捡了，返程就不能再捡了，如何才能避免重复计算呢？我们只有i和j是不够的，其只能定义去程的位置，我们还需要pg，(不是pgone哈哈)，来定义返程的位置，那么重现关系Recurrence Relations就变成了 T(i, j, p, g)，我们有分别两种方式离开(i, j)和(p, g)，我们suppose时从终点往起点遍历，那么就有4种情况：</p>
<div class="cnblogs_code">
<pre>Case <span style="color: #800080;">1</span>: (<span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>) ==&gt; (i-<span style="color: #800080;">1</span>, j) ==&gt; (i, j); (p, q) ==&gt; (p-<span style="color: #800080;">1</span>, q) ==&gt; (<span style="color: #800080;">0</span>, <span style="color: #800080;">0</span><span style="color: #000000;">)
Case </span><span style="color: #800080;">2</span>: (<span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>) ==&gt; (i-<span style="color: #800080;">1</span>, j) ==&gt; (i, j); (p, q) ==&gt; (p, q-<span style="color: #800080;">1</span>) ==&gt; (<span style="color: #800080;">0</span>, <span style="color: #800080;">0</span><span style="color: #000000;">)
Case </span><span style="color: #800080;">3</span>: (<span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>) ==&gt; (i, j-<span style="color: #800080;">1</span>) ==&gt; (i, j); (p, q) ==&gt; (p-<span style="color: #800080;">1</span>, q) ==&gt; (<span style="color: #800080;">0</span>, <span style="color: #800080;">0</span><span style="color: #000000;">)
Case </span><span style="color: #800080;">4</span>: (<span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>) ==&gt; (i, j-<span style="color: #800080;">1</span>) ==&gt; (i, j); (p, q) ==&gt; (p, q-<span style="color: #800080;">1</span>) ==&gt; (<span style="color: #800080;">0</span>, <span style="color: #800080;">0</span>)</pre>
</div>
<p>根据定义，我们有：</p>
<div class="cnblogs_code">
<pre>Case <span style="color: #800080;">1</span> <span style="color: #0000ff;">is</span> equivalent to T(i-<span style="color: #800080;">1</span>, j, p-<span style="color: #800080;">1</span>, q) + grid[i][j] +<span style="color: #000000;"> grid[p][q];
Case </span><span style="color: #800080;">2</span> <span style="color: #0000ff;">is</span> equivalent to T(i-<span style="color: #800080;">1</span>, j, p, q-<span style="color: #800080;">1</span>) + grid[i][j] +<span style="color: #000000;"> grid[p][q];
Case </span><span style="color: #800080;">3</span> <span style="color: #0000ff;">is</span> equivalent to T(i, j-<span style="color: #800080;">1</span>, p-<span style="color: #800080;">1</span>, q) + grid[i][j] +<span style="color: #000000;"> grid[p][q];
Case </span><span style="color: #800080;">4</span> <span style="color: #0000ff;">is</span> equivalent to T(i, j-<span style="color: #800080;">1</span>, p, q-<span style="color: #800080;">1</span>) + grid[i][j] + grid[p][q];</pre>
</div>
<p>因此，我们的重现关系可以写作：</p>
<div class="cnblogs_code">
<pre>T(i, j, p, q) = grid[i][j] + grid[p][q] + max{T(i-<span style="color: #800080;">1</span>, j, p-<span style="color: #800080;">1</span>, q), T(i-<span style="color: #800080;">1</span>, j, p, q-<span style="color: #800080;">1</span>), T(i, j-<span style="color: #800080;">1</span>, p-<span style="color: #800080;">1</span>, q), T(i, j-<span style="color: #800080;">1</span>, p, q-<span style="color: #800080;">1</span>)}</pre>
</div>
<p>为了避免重复计算，我们希望 grid[i][j] 和 grid[p][g] 不出现在T(i-1, j, p-1, q), T(i-1, j, p, q-1), T(i, j-1, p-1, q) 和 T(i, j-1, p, q-1)中的任意一个上。显而易见的是(i, j)不会出现在(0, 0) ==&gt; (i-1, j) 或 (0, 0) ==&gt; (i, j-1) 的路径上，同理，(p, g) 也不会出现在 (p-1, q) ==&gt; (0, 0) 或 (p, q-1) ==&gt; (0, 0) 的路径上。因此，我们需要保证(i, j) 不会出现在 (p-1, q) ==&gt; (0, 0) 或 (p, q-1) ==&gt; (0, 0) 的路径上，同时 (p, g)不会出现在(0, 0) ==&gt; (i-1, j) 或 (0, 0) ==&gt; (i, j-1) 的路径上，怎么做呢？</p>
<p>我们观察到(0, 0) ==&gt; (i-1, j) 和 (0, 0) ==&gt; (i, j-1) 的所有点都在矩形 [0, 0, i, j] 中（除了右下角点(i, j)点），所以只要 (p, g) 不在矩形 [0, 0, i, j] 中就行了，注意(p, g) 和 (i, j) 是有可能重合了，这种情况特殊处理一下就行了。同理， (i, j) 也不能在矩形 [0, 0, p, g] 中，那么以下三个条件中需要满足一个：</p>
<div class="cnblogs_code">
<pre>i &lt; p &amp;&amp; j &gt;<span style="color: #000000;"> q
i </span>== p &amp;&amp; j ==<span style="color: #000000;"> q
i </span>&gt; p &amp;&amp; j &lt; q</pre>
</div>
<p>为了满足上述条件，我们希望当 i 或 p 增加的时候，j 或 q 减小，那么我们可以有这个等式:</p>
<div class="cnblogs_code">
<pre>k = i + j = p + q</pre>
</div>
<p>其中k为从起点开始走的步数，所以我们可以用 T(k, i, p)  来代替 T(i, j, p, g)，那么我们的重现关系式就变成了：</p>
<div class="cnblogs_code">
<pre>T(k, i, p) = grid[i][k-i] + grid[p][k-p] + max{T(k-<span style="color: #800080;">1</span>, i-<span style="color: #800080;">1</span>, p-<span style="color: #800080;">1</span>), T(k-<span style="color: #800080;">1</span>, i-<span style="color: #800080;">1</span>, p), T(k-<span style="color: #800080;">1</span>, i, p-<span style="color: #800080;">1</span>), T(k-<span style="color: #800080;">1</span>, i, p)}.</pre>
</div>
<p>当 i == p 时，grid[i][k-i] 和 grid[p][k-p] 就相等了，此时只能加一个。我们注意到 i, j, p, q 的范围是 [0, n)， 意味着k只能在范围 [0, 2n - 1) 中， 初始化时 T(0, 0, 0) = grid[0][0]。我们这里的重现关系T虽然是三维的，但是我们可以用二维dp数组来实现，因为第k步的值只依赖于第k-1步的情况，参见代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> cherryPickup(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> grid) {
        </span><span style="color: #0000ff;">int</span> n = grid.size(), mx = <span style="color: #800080;">2</span> * n - <span style="color: #800080;">1</span><span style="color: #000000;">;
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; dp(n, vector&lt;<span style="color: #0000ff;">int</span>&gt;(n, -<span style="color: #800080;">1</span><span style="color: #000000;">));
        dp[</span><span style="color: #800080;">0</span>][<span style="color: #800080;">0</span>] = grid[<span style="color: #800080;">0</span>][<span style="color: #800080;">0</span><span style="color: #000000;">];
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> k = <span style="color: #800080;">1</span>; k &lt; mx; ++<span style="color: #000000;">k) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = n - <span style="color: #800080;">1</span>; i &gt;= <span style="color: #800080;">0</span>; --<span style="color: #000000;">i) {
                </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> p = n - <span style="color: #800080;">1</span>; p &gt;= <span style="color: #800080;">0</span>; --<span style="color: #000000;">p) {
                    </span><span style="color: #0000ff;">int</span> j = k - i, q = k -<span style="color: #000000;"> p;
                    </span><span style="color: #0000ff;">if</span> (j &lt; <span style="color: #800080;">0</span> || j &gt;= n || q &lt; <span style="color: #800080;">0</span> || q &gt;= n || grid[i][j] &lt; <span style="color: #800080;">0</span> || grid[p][q] &lt; <span style="color: #800080;">0</span><span style="color: #000000;">) {
                        dp[i][p] </span>= -<span style="color: #800080;">1</span><span style="color: #000000;">;
                        </span><span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                    }
                    </span><span style="color: #0000ff;">if</span> (i &gt; <span style="color: #800080;">0</span>) dp[i][p] = max(dp[i][p], dp[i - <span style="color: #800080;">1</span><span style="color: #000000;">][p]);
                    </span><span style="color: #0000ff;">if</span> (p &gt; <span style="color: #800080;">0</span>) dp[i][p] = max(dp[i][p], dp[i][p - <span style="color: #800080;">1</span><span style="color: #000000;">]);
                    </span><span style="color: #0000ff;">if</span> (i &gt; <span style="color: #800080;">0</span> &amp;&amp; p &gt; <span style="color: #800080;">0</span>) dp[i][p] = max(dp[i][p], dp[i - <span style="color: #800080;">1</span>][p - <span style="color: #800080;">1</span><span style="color: #000000;">]);
                    </span><span style="color: #0000ff;">if</span> (dp[i][p] &gt;= <span style="color: #800080;">0</span>) dp[i][p] += grid[i][j] + (i != p ? grid[p][q] : <span style="color: #800080;">0</span><span style="color: #000000;">);
                }
            }
        }
        </span><span style="color: #0000ff;">return</span> max(dp[n - <span style="color: #800080;">1</span>][n - <span style="color: #800080;">1</span>], <span style="color: #800080;">0</span><span style="color: #000000;">);
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4353255.html" target="_blank">Minimum Path Sum</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4233035.html" target="_blank">Dungeon Game</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/112877/annotated-c-dp-solution">https://discuss.leetcode.com/topic/112877/annotated-c-dp-solution</a></p>
<p><a href="https://discuss.leetcode.com/topic/113762/step-by-step-guidance-of-the-o-n-3-time-and-o-n-2-space-solution">https://discuss.leetcode.com/topic/113762/step-by-step-guidance-of-the-o-n-3-time-and-o-n-2-space-solution</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-01-06 23:58</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=8215787" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(8215787);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/8176933.html" id="cb_post_title_url">[LeetCode] Delete and Earn 删除与赚取</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given an array <code>nums</code> of integers, you can perform operations on the array.</p>
<p>In each operation, you pick any <code>nums[i]</code> and delete it to earn <code>nums[i]</code> points. After, you must delete everyelement equal to <code>nums[i] - 1</code> or <code>nums[i] + 1</code>.</p>
<p>You start with 0 points. Return the maximum number of points you can earn by applying such operations.</p>
<p>Example 1:</p>
<pre>Input: nums = [3, 4, 2]
Output: 6
Explanation: 
Delete 4 to earn 4 points, consequently 3 is also deleted.
Then, delete 2 to earn 2 points. 6 total points are earned.
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input: nums = [2, 2, 3, 3, 3, 4]
Output: 9
Explanation: 
Delete 3 to earn 3 points, deleting both 2's and the 4.
Then, delete 3 again to earn 3 points, and 3 again to earn 3 points.
9 total points are earned.
</pre>
<p> </p>
<p>Note:</p>
<ul>
<li>The length of <code>nums</code> is at most <code>20000</code>.</li>
<li>Each element <code>nums[i]</code> is an integer in the range <code>[1, 10000]</code>.</li>
</ul>
<p> </p>
<p>博主浪了整整一个圣诞假期，现在也该收收心了，2018了，今年对于博主是很关键的一年，有太多的事情要去做，各种小目标需要完成，还有梦想去追逐，又要开始努力啦～在博主停更的这一周半的时间内，收到了网友们的私信和留言催更，请大家放心，2018年博主会继续坚持下去，继续追赶进度，虽然一直都没有完全追上-.-|||，照LeetCode这出题速度，今年题号有望突破一千大关啊，感觉碉堡了有木有，一起为了幸福而奋斗吧～</p>
<p>好了，来做题吧。这道题给了我们一个数组，每次让我们删除一个数字，删除的数字本身变为了积分累积，并且要同时移除之前数的加1和减1的数，但此时移除的数字不累计积分，让我们求最多能获得多少积分。博主最开始尝试的方法是积分大小来排列，先删除大的数字，但是不对。于是乎，博主发现相同的数字可以同时删除，于是就是建立了每个数字和其出现次数之间的映射，然后放到优先队列里，重写排序方式comparator为数字乘以其出现次数，先移除能产生最大积分的数字，可是还是不对。其实这道题跟之前那道<a href="http://www.cnblogs.com/grandyang/p/4383632.html" target="_blank">House Robber</a>的本质是一样的，那道题小偷不能偷相邻的房子，这道题相邻的数字不能累加积分，是不是一个道理？那么对于每一个数字，我们都有两个选择，拿或者不拿。如果我们拿了当前的数字，我们就不能拿之前的数字（如果我们从小往大遍历就不需要考虑后面的数字），那么当前的积分就是不拿前面的数字的积分加上当前数字之和。如果我们不拿当前的数字，那么对于前面的数字我们既可以拿也可以不拿，于是当前的积分就是拿前面的数字的积分和不拿前面数字的积分中的较大值。这里我们用take和skip分别表示拿与不拿上一个数字，takei和skipi分别表示拿与不拿当前数字，每次更新完当前的takei和skipi时，也要更新take和skip，为下一个数字做准备，最后只要返回take和skip中的较大值即可，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> deleteAndEarn(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; sums(<span style="color: #800080;">10001</span>, <span style="color: #800080;">0</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">int</span> take = <span style="color: #800080;">0</span>, skip = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> num : nums) sums[num] +=<span style="color: #000000;"> num;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; <span style="color: #800080;">10001</span>; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">int</span> takei = skip +<span style="color: #000000;"> sums[i];
            </span><span style="color: #0000ff;">int</span> skipi =<span style="color: #000000;"> max(skip, take);
            take </span>= takei; skip =<span style="color: #000000;"> skipi;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> max(skip, take); 
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种解法直接使用sums数组来更新，而没有使用额外的变量。上面解法中没有讲解这个sums数组，这里的sums实际上相当于建立了数字和其总积分的映射，这里的总积分的计算方法是由数字乘以其出现次数得来的。由于题目中说了每个数字不会超过10000，所以sums的长度可以初始化为10001，然后遍历原数组，将遇到的数字都累加到该数字在数组中的位置上。然后从sums数组的第三个数字开始遍历，更新方法跟上面解法的思路很类似，当前的sums[i]值就等于前一个值sums[i-1]和前两个值sums[i-2]加上当前的sums[i]值中的较大值，其实思想就是在不拿当前数的积分，跟不拿前一个数的积分加上当前的积分之和，取二者中的较大值更新当前值sums[i]，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> deleteAndEarn(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; sums(<span style="color: #800080;">10001</span>, <span style="color: #800080;">0</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> num : nums) sums[num] +=<span style="color: #000000;"> num;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">2</span>; i &lt; <span style="color: #800080;">10001</span>; ++<span style="color: #000000;">i) {
            sums[i] </span>= max(sums[i - <span style="color: #800080;">1</span>], sums[i - <span style="color: #800080;">2</span>] +<span style="color: #000000;"> sums[i]);
        }
        </span><span style="color: #0000ff;">return</span> sums[<span style="color: #800080;">10000</span><span style="color: #000000;">];
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4383632.html" target="_blank">House Robber</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/112807/java-c-clean-code-with-explanation">https://discuss.leetcode.com/topic/112807/java-c-clean-code-with-explanation</a></p>
<p><a href="https://discuss.leetcode.com/topic/112916/sharing-my-simple-straight-forward-java-o-n-solution-explanation-included">https://discuss.leetcode.com/topic/112916/sharing-my-simple-straight-forward-java-o-n-solution-explanation-included</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-01-02 14:00</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=8176933" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(8176933);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/8097513.html" id="cb_post_title_url">[LeetCode] Daily Temperatures 日常温度</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a list of daily <code>temperatures</code>, produce a list that, for each day in the input, tells you how many days you would have to wait until a warmer temperature. If there is no future day for which this is possible, put <code>0</code> instead.</p>
<p>For example, given the list <code>temperatures = [73, 74, 75, 71, 69, 72, 76, 73]</code>, your output should be <code>[1, 1, 4, 2, 1, 1, 0, 0]</code>.</p>
<p>Note: The length of <code>temperatures</code> will be in the range <code>[1, 30000]</code>. Each temperature will be an integer in the range <code>[30, 100]</code>.</p>
<p> </p>
<p>这道题给了我们一个数组，让我们找下一个比当前数字大的数字的距离，我们研究一下题目中给的例子，发现数组是无序的，所以没法用二分法快速定位下一个大的数字，那么最先考虑的方法就是暴力搜索了，写起来没有什么难度，但是OJ并不答应。实际上这道题应该使用递减栈Descending Stack来做，栈里只有递减元素，思路是这样的，我们遍历数组，如果栈不空，且当前数字大于栈顶元素，那么如果直接入栈的话就不是递减栈了，所以我们取出栈顶元素，那么由于当前数字大于栈顶元素的数字，而且一定是第一个大于栈顶元素的数，那么我们直接求出下标差就是二者的距离了，然后继续看新的栈顶元素，直到当前数字小于等于栈顶元素停止，然后将数字入栈，这样就可以一直保持递减栈，且每个数字和第一个大于它的数的距离也可以算出来了，参见代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; dailyTemperatures(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> temperatures) {
        </span><span style="color: #0000ff;">int</span> n =<span style="color: #000000;"> temperatures.size();
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; res(n, <span style="color: #800080;">0</span><span style="color: #000000;">);
        stack</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> st;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; temperatures.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">while</span> (!st.empty() &amp;&amp; temperatures[i] &gt;<span style="color: #000000;"> temperatures[st.top()]) {
                auto t </span>=<span style="color: #000000;"> st.top(); st.pop();
                res[t] </span>= i -<span style="color: #000000;"> t;
            }
            st.push(i);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/6399855.html" target="_blank">Next Greater Element I</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/112830/java-easy-ac-solution-with-stack">https://discuss.leetcode.com/topic/112830/java-easy-ac-solution-with-stack</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-12-24 10:37</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=8097513" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(8097513);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/8068326.html" id="cb_post_title_url">[LeetCode] Monotone Increasing Digits 单调递增数字</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="question-description">
<p>Given a non-negative integer <code>N</code>, find the largest number that is less than or equal to <code>N</code> with monotone increasing digits.</p>
<p>(Recall that an integer has <em>monotone increasing digits</em> if and only if each pair of adjacent digits <code>x</code> and <code>y</code> satisfy <code>x &lt;= y</code>.)</p>
<p> </p>
<p>Example 1:</p>
<pre>Input: N = 10
Output: 9
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input: N = 1234
Output: 1234
</pre>
<p> </p>
<p>Example 3:</p>
<pre>Input: N = 332
Output: 299
</pre>
<p> </p>
<p>Note: <code>N</code> is an integer in the range <code>[0, 10^9]</code>.</p>
<p> </p>
</div>
<p>这道题给了我们一个非负数，让我们求一个数字小于等于给定数字，且该数字各位上的数字是单调递增的。那么我们就来分析题目中给的几个例子吧，首先如果是10的话，我们知道1大于0，所以不是单调自增的，那么返回的数就是9。第二个例子是1234，各位上已经满足单调自增的条件了，返回原数即可。第三个例子是332，我们发现最后一位2小于之前的3，那么此时我们将前面位减1，先变成322，再往前看，还是小于前面的3，那么我们再将前面位减1，就变成了222，此时222不是最大的单调递增数，我们可以将后面两位变成9，于是乎就有了299，小于给定的332，符合题意。如果给定的数字是232，那么就会得到229，我们可以发现规律，要找到从后往前遍历的最后一个值升高的位置，让前一位减1，并把当前位以及后面的所有位都变成9，就可以得到最大的单调递增数啦。</p>
<p>我们用j表示最后一个值升高的位置，具体来说应该是其前一位的值大，初始化为总位数n，然后从后往前遍历，因为每次要和前一位比较，为防止越界，应遍历到第二个数停止，如果当前位大于等于前一位，符合单调递增，直接跳过；否则就将前一位自减1，j赋值为当前位i，循环结束后，从j位到末尾的位数都改为9即可，参见代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> monotoneIncreasingDigits(<span style="color: #0000ff;">int</span><span style="color: #000000;"> N) {
        </span><span style="color: #0000ff;">string</span> str =<span style="color: #000000;"> to_string(N);
        </span><span style="color: #0000ff;">int</span> n = str.size(), j =<span style="color: #000000;"> n;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = n - <span style="color: #800080;">1</span>; i &gt; <span style="color: #800080;">0</span>; --<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (str[i] &gt;= str[i - <span style="color: #800080;">1</span>]) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
            </span>--str[i - <span style="color: #800080;">1</span><span style="color: #000000;">];
            j </span>=<span style="color: #000000;"> i;
        }        
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = j; i &lt; n; ++<span style="color: #000000;">i) {
            str[i] </span>= <span style="color: #800000;">'</span><span style="color: #800000;">9</span><span style="color: #800000;">'</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> stoi(str);
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/5883736.html">Remove K Digits</a></p>
<p> </p>
<p><a href="http://www.cnblogs.com/grandyang/p/4606334.html" target="_blank">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-12-19 23:43</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=8068326" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(8068326);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/8053934.html" id="cb_post_title_url">[LeetCode] Sentence Similarity II 句子相似度之二</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given two sentences <code>words1, words2</code> (each represented as an array of strings), and a list of similar word pairs <code>pairs</code>, determine if two sentences are similar.</p>
<p>For example, <code>words1 = ["great", "acting", "skills"]</code> and <code>words2 = ["fine", "drama", "talent"]</code> are similar, if the similar word pairs are <code>pairs = [["great", "good"], ["fine", "good"], ["acting","drama"], ["skills","talent"]]</code>.</p>
<p>Note that the similarity relation is transitive. For example, if "great" and "good" are similar, and "fine" and "good" are similar, then "great" and "fine" are similar.</p>
<p>Similarity is also symmetric. For example, "great" and "fine" being similar is the same as "fine" and "great" being similar.</p>
<p>Also, a word is always similar with itself. For example, the sentences <code>words1 = ["great"], words2 = ["great"], pairs = []</code> are similar, even though there are no specified similar word pairs.</p>
<p>Finally, sentences can only be similar if they have the same number of words. So a sentence like <code>words1 = ["great"]</code> can never be similar to <code>words2 = ["doubleplus","good"]</code>.</p>
<p>Note:</p>
<ul>
<li>The length of <code>words1</code> and <code>words2</code> will not exceed <code>1000</code>.</li>
<li>The length of <code>pairs</code> will not exceed <code>2000</code>.</li>
<li>The length of each <code>pairs[i]</code> will be <code>2</code>.</li>
<li>The length of each <code>words[i]</code> and <code>pairs[i][j]</code> will be in the range <code>[1, 20]</code>.</li>
</ul>
<p> </p>
<p>这道题是之前那道<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/8016251.html" id="homepage1_HomePageDays_DaysList_ctl05_DayList_TitleUrl_0">Sentence Similarity</a>的拓展，那道题说单词之间不可传递，于是乎这道题就变成可以传递了，那么难度就增加了。不过没有关系，还是用我们的经典老三样来解，BFS，DFS，和Union Find。我们先来看BFS的解法，其实这道题的本质是无向连通图的问题，那么首先要做的就是建立这个连通图的数据结构，对于每个结点来说，我们要记录所有和其相连的结点，所以我们建立每个结点和其所有相连结点集合之间的映射，比如对于这三个相似对(a, b), (b, c)，和(c, d)，我们有如下的映射关系：</p>
<p>a -&gt; {b}</p>
<p>b -&gt; {a, c}</p>
<p>c -&gt; {b, d}</p>
<p>d -&gt; {c}</p>
<p>那么如果我们要验证a和d是否相似，就需要用到传递关系，a只能找到b，b可以找到a，c，为了不陷入死循环，我们将访问过的结点加入一个集合visited，那么此时b只能去，c只能去d，那么说明a和d是相似的了。那么我们用for循环来比较对应位置上的两个单词，如果二者相同，那么直接跳过去比较接下来的。否则就建一个访问即可visited，建一个队列queue，然后把words1中的单词放入queue，建一个布尔型变量succ，标记是否找到，然后就是传统的BFS遍历的写法了，从队列中取元素，如果和其相连的结点中有words2中的对应单词，标记succ为true，并break掉。否则就将取出的结点加入队列queue，并且遍历其所有相连结点，将其中未访问过的结点加入队列queue继续循环，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> areSentencesSimilarTwo(vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp; words1, vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp; words2, vector&lt;pair&lt;<span style="color: #0000ff;">string</span>, <span style="color: #0000ff;">string</span>&gt;&gt;<span style="color: #000000;"> pairs) {
        </span><span style="color: #0000ff;">if</span> (words1.size() != words2.size()) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        unordered_map</span>&lt;<span style="color: #0000ff;">string</span>, unordered_set&lt;<span style="color: #0000ff;">string</span>&gt;&gt;<span style="color: #000000;"> m;
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto pair : pairs) {
            m[pair.first].insert(pair.second);
            m[pair.second].insert(pair.first);
        }    
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; words1.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (words1[i] == words2[i]) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
            unordered_set</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> visited;
            queue</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> q{{words1[i]}};
            </span><span style="color: #0000ff;">bool</span> succ = <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">while</span> (!<span style="color: #000000;">q.empty()) {
                auto t </span>=<span style="color: #000000;"> q.front(); q.pop();
                </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (m[t].count(words2[i])) {
                    succ </span>= <span style="color: #0000ff;">true</span>; <span style="color: #0000ff;">break</span><span style="color: #000000;">;
                }
                visited.insert(t);
                </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto a : m[t]) {
                    </span><span style="color: #0000ff;">if</span> (!<span style="color: #000000;">visited.count(a)) q.push(a);
                }
            }
            </span><span style="color: #0000ff;">if</span> (!succ) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        }    
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>下面来看递归的写法，解题思路跟上面的完全一样，把主要操作都放到了一个递归函数中来写，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> areSentencesSimilarTwo(vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp; words1, vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp; words2, vector&lt;pair&lt;<span style="color: #0000ff;">string</span>, <span style="color: #0000ff;">string</span>&gt;&gt;<span style="color: #000000;"> pairs) {
        </span><span style="color: #0000ff;">if</span> (words1.size() != words2.size()) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        unordered_map</span>&lt;<span style="color: #0000ff;">string</span>, unordered_set&lt;<span style="color: #0000ff;">string</span>&gt;&gt;<span style="color: #000000;"> m;
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto pair : pairs) {
            m[pair.first].insert(pair.second);
            m[pair.second].insert(pair.first);
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; words1.size(); ++<span style="color: #000000;">i) {</span><span style="color: #000000;">
            unordered_set</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> visited;
            </span><span style="color: #0000ff;">if</span> (!helper(m, words1[i], words2[i], visited)) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
    </span><span style="color: #0000ff;">bool</span> helper(unordered_map&lt;<span style="color: #0000ff;">string</span>, unordered_set&lt;<span style="color: #0000ff;">string</span>&gt;&gt;&amp; m, <span style="color: #0000ff;">string</span>&amp; cur, <span style="color: #0000ff;">string</span>&amp; target, unordered_set&lt;<span style="color: #0000ff;">string</span>&gt;&amp;<span style="color: #000000;"> visited) {
        </span><span style="color: #0000ff;">if</span> (cur == target) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        visited.insert(cur);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">string</span><span style="color: #000000;"> word : m[cur]) {
            </span><span style="color: #0000ff;">if</span> (!visited.count(word) &amp;&amp; helper(m, word, target, visited)) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种解法就是碉堡了的联合查找Union Find了，这种解法的核心是一个getRoot函数，如果两个元素属于同一个群组的话，调用getRoot函数会返回相同的值。主要分为两部，第一步是建立群组关系，suppose开始时每一个元素都是独立的个体，各自属于不同的群组。然后对于每一个给定的关系对，我们对两个单词分别调用getRoot函数，找到二者的祖先结点，如果从未建立过联系的话，那么二者的祖先结点时不同的，此时就要建立二者的关系。等所有的关系都建立好了以后，第二步就是验证两个任意的元素是否属于同一个群组，就只需要比较二者的祖先结点都否相同啦。是不是有点深度学习的赶脚，先建立模型training，然后再test。哈哈，博主乱扯的，二者并没有什么联系。我们保存群组关系的数据结构，有时用数组，有时用哈希map，看输入的数据类型吧，如果输入元素的整型数的话，用root数组就可以了，如果是像本题这种的字符串的话，需要用哈希表来建立映射，建立每一个结点和其祖先结点的映射。注意这里的祖先结点不一定是最终祖先结点，而最终祖先结点的映射一定是最重祖先结点，所以我们的getRoot函数的设计思路就是要找到最终祖先结点，那么就是当结点和其映射结点相同时返回，否则继续循环，可以递归写，也可以迭代写，这无所谓。注意这里第一行判空是相当于初始化，这个操作可以在外面写，就是要让初始时每个元素属于不同的群组，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> areSentencesSimilarTwo(vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp; words1, vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp; words2, vector&lt;pair&lt;<span style="color: #0000ff;">string</span>, <span style="color: #0000ff;">string</span>&gt;&gt;<span style="color: #000000;"> pairs) {
        </span><span style="color: #0000ff;">if</span> (words1.size() != words2.size()) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        unordered_map</span>&lt;<span style="color: #0000ff;">string</span>, <span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> m;       
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto pair : pairs) {
            </span><span style="color: #0000ff;">string</span> x = getRoot(pair.first, m), y =<span style="color: #000000;"> getRoot(pair.second, m);
            </span><span style="color: #0000ff;">if</span> (x != y) m[x] =<span style="color: #000000;"> y;
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; words1.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (getRoot(words1[i], m) != getRoot(words2[i], m)) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
    </span><span style="color: #0000ff;">string</span> getRoot(<span style="color: #0000ff;">string</span> word, unordered_map&lt;<span style="color: #0000ff;">string</span>, <span style="color: #0000ff;">string</span>&gt;&amp;<span style="color: #000000;"> m) {
        </span><span style="color: #0000ff;">if</span> (!m.count(word)) m[word] =<span style="color: #000000;"> word;
        </span><span style="color: #0000ff;">return</span> word == m[word] ?<span style="color: #000000;"> word : getRoot(m[word], m);
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/6686983.html">Friend Circles</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/7829169.html">Accounts Merge</a></p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/8016251.html" id="homepage1_HomePageDays_DaysList_ctl05_DayList_TitleUrl_0">Sentence Similarity</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/112146/c-dfs-solution">https://discuss.leetcode.com/topic/112146/c-dfs-solution</a></p>
<p><a href="https://discuss.leetcode.com/topic/112183/java-c-clean-code-with-explanation">https://discuss.leetcode.com/topic/112183/java-c-clean-code-with-explanation</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-12-17 23:49</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=8053934" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(8053934);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/8045255.html" id="cb_post_title_url">[LeetCode] Parse Lisp Expression 解析Lisp表达式</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>You are given a string <code>expression</code> representing a Lisp-like expression to return the integer value of.</p>
<p>The syntax for these expressions is given as follows. </p>
<ul>
<li>An expression is either an integer, a let-expression, an add-expression, a mult-expression, or an assigned variable. Expressions always evaluate to a single integer.</li>
</ul>
<ul>
<li>(An integer could be positive or negative.)</li>
</ul>
<ul>
<li>A let-expression takes the form <code>(let v1 e1 v2 e2 ... vn en expr)</code>, where <code>let</code> is always the string <code>"let"</code>, then there are 1 or more pairs of alternating variables and expressions, meaning that the first variable <code>v1</code> is assigned the value of the expression <code>e1</code>, the second variable <code>v2</code> is assigned the value of the expression <code>e2</code>, and so on sequentially; and then the value of this let-expression is the value of the expression <code>expr</code>.</li>
</ul>
<ul>
<li>An add-expression takes the form <code>(add e1 e2)</code> where <code>add</code> is always the string <code>"add"</code>, there are always two expressions <code>e1, e2</code>, and this expression evaluates to the addition of the evaluation of <code>e1</code> and the evaluation of <code>e2</code>.</li>
</ul>
<ul>
<li>A mult-expression takes the form <code>(mult e1 e2)</code> where <code>mult</code> is always the string <code>"mult"</code>, there are always two expressions <code>e1, e2</code>, and this expression evaluates to the multiplication of the evaluation of <code>e1</code> and the evaluation of <code>e2</code>.</li>
</ul>
<ul>
<li>For the purposes of this question, we will use a smaller subset of variable names. A variable starts with a lowercase letter, then zero or more lowercase letters or digits. Additionally for your convenience, the names "add", "let", or "mult" are protected and will never be used as variable names.</li>
</ul>
<ul>
<li>Finally, there is the concept of scope. When an expression of a variable name is evaluated, within the context of that evaluation, the innermost scope (in terms of parentheses) is checked first for the value of that variable, and then outer scopes are checked sequentially. It is guaranteed that every expression is legal. Please see the examples for more details on scope.</li>
</ul>
<p>Evaluation Examples:</p>
<pre>Input: (add 1 2)
Output: 3

Input: (mult 3 (add 2 3))
Output: 15

Input: (let x 2 (mult x 5))
Output: 10

Input: (let x 2 (mult x (let x 3 y 4 (add x y))))
Output: 14
Explanation: In the expression (add x y), when checking for the value of the variable x,
we check from the innermost scope to the outermost in the context of the variable we are trying to evaluate.
Since x = 3 is found first, the value of x is 3.

Input: (let x 3 x 2 x)
Output: 2
Explanation: Assignment in let statements is processed sequentially.

Input: (let x 1 y 2 x (add x y) (add x y))
Output: 5
Explanation: The first (add x y) evaluates as 3, and is assigned to x.
The second (add x y) evaluates as 3+2 = 5.

Input: (let x 2 (add (let x 3 (let x 4 x)) x))
Output: 6
Explanation: Even though (let x 4 x) has a deeper scope, it is outside the context
of the final x in the add-expression.  That final x will equal 2.

Input: (let a1 3 b2 (add a1 1) b2) 
Output 4
Explanation: Variable names can contain digits after the first character.

</pre>
<p>Note:</p>
<ul>
<li>The given string <code>expression</code> is well formatted: There are no leading or trailing spaces, there is only a single space separating different components of the string, and no space between adjacent parentheses. The expression is guaranteed to be legal and evaluate to an integer.</li>
<li>The length of <code>expression</code> is at most 2000. (It is also non-empty, as that would not be a legal expression.)</li>
<li>The answer and all intermediate calculations of that answer are guaranteed to fit in a 32-bit integer.</li>
</ul>
<p> </p>
<p>这道题让我们解析Lisp语言的表达式，以前听说过Lisp语言，但是完全没有接触过，看了题目中的描述和给的例子，感觉很叼。估计题目只让我们处理一些简单的情况，毕竟不可能让我们写一个编译器出来。题目中说了给定的表达式都是合法的，这样也降低了难度。还有一个好的地方是题目给了充足的例子，让我们去更好的理解这门新的语言。我们通过分析例子发现，所有的命令都是用括号来包裹的，而且里面还可以嵌套小括号即子命令。让我们处理的命令只有三种，add，mult，和let。其中add和mult比较简单就是加法和乘法，就把后面两个数字或者子表达式的值加起来或成起来即可。let命令稍稍麻烦一些，后面可以跟好多变量或表达式，最简单的是三个，一般第一个是个变量，比如x，后面会跟一个数字或子表达式，就是把后面的数字或子表达式的值赋值给前面的变量，第三个位置是个表达式，其值是当前let命令的返回值。还有一个比较重要的特性是外层的变量值不会随着里层的变量值改变，比如对于下面这个例子：</p>
<div class="cnblogs_code">
<pre>(let x <span style="color: #800080;">2</span> (add (let x <span style="color: #800080;">3</span> (let x <span style="color: #800080;">4</span> x)) x))</pre>
</div>
<p>刚开始x被赋值为2了，然后在返回值表达式中，又有一个add操作，add操作的第一个变量又是一个子表达式，在这个子表达式中又定义了一个变量x，并复制为3，再其返回值表达式又定义了一个变量x，赋值为4，并返回这个x，那么最内层的表达式的返回值是4，那么x被赋值为3的那层的返回值也是4，此时add的第一个数就是4，那么其第二个x是多少，其实这个x并没有被里层的x的影响，仍然是刚开始赋值的2，那么我们就看出特点了，外层的变量是能影响里层变量的，而里层变量无法影响外层变量。那么我们只要在递归的时候不加引用就行了，这样值就不会在递归函数中被更改了。</p>
<p>对于这种长度不定且每个可能包含子表达式的题，递归是一个很好的选择，由于需要给变量赋值，所以需要建立一个变量和其值之间的映射，然后我们就要来写递归函数了，最开始我们给定的表达式肯定是有括号的，所以我们先处理这种情况，括号对于我们的解析没有用，所以要去掉首尾的括号，然后我们用一个变量cur表示当前指向字符的位置，初始化为0，下面要做的就是先解析出命令单词，我们调用一个子函数parse，在parse函数中，简单的情况就是解析出add，mult，或let这三个命令单词，我们用一个指针来遍历字符，当越界或遇到空格就停止，但是如果我们需要解析的是个子表达式，而且里面可能还有多个子表达式，那么我们就需要找出最外面这个左括号对应的右括号，因为中间可能还会有别的左右括号，里面的内容就再之后再次调用递归函数时处理。判断的方法就是利用匹配括号的方法，用变量cnt来表示左括号的的个数，初始化为1，当要parse的表达式第一个字符是左括号时，进入循环，循环条件是cnt不为0，当遇到左括号时cnt自增1，反之当遇到右括号时cnt自减1，每次指针end都向右移动一个，最后我们根据end的位置减去初始时cur的值（保存在变量t中），可以得到表达式。如果解析出的是命令let，那么进行while循环，然后继续解析后面的内容，如果此时cur大于s的长度了，说明此时是let命令的最后一个部分，也就是返回值部分，直接调用递归函数返回即可。否则就再解析下一个部分，说明此时是变量和其对应值，我们要建立映射关系。如果之前解析出来的是add命令，那么比较简单，就直接解析出后面的两个部分的表达式，并分别调用递归函数，将递归函数的返回值累加并返回即可。对于mult命令同样的处理方式，只不过是将两个递归函数的返回值乘起来并返回。然后我们再来看如果表达式不是以左括号开头的，说明只能是数字或者变量，那么先来检测数字，如果第一个字符是负号或者0到9之间的数字，那么直接将表达式转为int型即可；否则的话就是变量，我们直接从哈希map中取值即可。最后需要注意的就是递归函数的参数哈希map一定不能加引用，具体可以参见上面那个例子的分析，加了引用后外层的变量值就会受内层的影响，这是不符合题意的，参见代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> evaluate(<span style="color: #0000ff;">string</span><span style="color: #000000;"> expression) {
        unordered_map</span>&lt;<span style="color: #0000ff;">string</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> m;
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> helper(expression, m);
    }
    </span><span style="color: #0000ff;">int</span> helper(<span style="color: #0000ff;">string</span> str, unordered_map&lt;<span style="color: #0000ff;">string</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> m) {
        </span><span style="color: #0000ff;">if</span> (str[<span style="color: #800080;">0</span>] == <span style="color: #800000;">'</span><span style="color: #800000;">-</span><span style="color: #800000;">'</span> || (str[<span style="color: #800080;">0</span>] &gt;= <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span> &amp;&amp; str[<span style="color: #800080;">0</span>] &lt;= <span style="color: #800000;">'</span><span style="color: #800000;">9</span><span style="color: #800000;">'</span>)) <span style="color: #0000ff;">return</span><span style="color: #000000;"> stoi(str);
        </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (str[<span style="color: #800080;">0</span>] != <span style="color: #800000;">'</span><span style="color: #800000;">(</span><span style="color: #800000;">'</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;"> m[str];
        </span><span style="color: #0000ff;">string</span> s = str.substr(<span style="color: #800080;">1</span>, str.size() - <span style="color: #800080;">2</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">int</span> cur = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">string</span> cmd =<span style="color: #000000;"> parse(s, cur);
        </span><span style="color: #0000ff;">if</span> (cmd == <span style="color: #800000;">"</span><span style="color: #800000;">let</span><span style="color: #800000;">"</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">while</span> (<span style="color: #0000ff;">true</span><span style="color: #000000;">) {
                </span><span style="color: #0000ff;">string</span> <span style="color: #0000ff;">var</span> =<span style="color: #000000;"> parse(s, cur);
                </span><span style="color: #0000ff;">if</span> (cur &gt; s.size()) <span style="color: #0000ff;">return</span> helper(<span style="color: #0000ff;">var</span><span style="color: #000000;">, m);
                </span><span style="color: #0000ff;">string</span> t =<span style="color: #000000;"> parse(s, cur);
                m[</span><span style="color: #0000ff;">var</span>] =<span style="color: #000000;"> helper(t, m);
            }
        } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (cmd == <span style="color: #800000;">"</span><span style="color: #800000;">add</span><span style="color: #800000;">"</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">return</span> helper(parse(s, cur), m) +<span style="color: #000000;"> helper(parse(s, cur), m);
        } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (cmd == <span style="color: #800000;">"</span><span style="color: #800000;">mult</span><span style="color: #800000;">"</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">return</span> helper(parse(s, cur), m) *<span style="color: #000000;"> helper(parse(s, cur), m);
        }
    }
    </span><span style="color: #0000ff;">string</span> parse(<span style="color: #0000ff;">string</span>&amp; s, <span style="color: #0000ff;">int</span>&amp;<span style="color: #000000;"> cur) {
        </span><span style="color: #0000ff;">int</span> end = cur + <span style="color: #800080;">1</span>, t = cur, cnt = <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (s[cur] == <span style="color: #800000;">'</span><span style="color: #800000;">(</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">while</span> (cnt != <span style="color: #800080;">0</span><span style="color: #000000;">) {
                </span><span style="color: #0000ff;">if</span> (s[end] == <span style="color: #800000;">'</span><span style="color: #800000;">(</span><span style="color: #800000;">'</span>) ++<span style="color: #000000;">cnt;
                </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (s[end] == <span style="color: #800000;">'</span><span style="color: #800000;">)</span><span style="color: #800000;">'</span>) --<span style="color: #000000;">cnt;
                </span>++<span style="color: #000000;">end;
            }
        } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            </span><span style="color: #0000ff;">while</span> (end &lt; s.size() &amp;&amp; s[end] != <span style="color: #800000;">'</span> <span style="color: #800000;">'</span>) ++<span style="color: #000000;">end;
        }
        cur </span>= end + <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span> s.substr(t, end -<span style="color: #000000;"> t);
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/6022498.html">Ternary Expression Parser</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/112079/c-recursion-solution-with-explaination/2">https://discuss.leetcode.com/topic/112079/c-recursion-solution-with-explaination/2</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-12-15 23:48</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=8045255" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(8045255);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/8035551.html" id="cb_post_title_url">[LeetCode] Asteroid Collision 行星碰撞</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>We are given an array <code>asteroids</code> of integers representing asteroids in a row.</p>
<p>For each asteroid, the absolute value represents its size, and the sign represents its direction (positive meaning right, negative meaning left). Each asteroid moves at the same speed.</p>
<p>Find out the state of the asteroids after all collisions. If two asteroids meet, the smaller one will explode. If both are the same size, both will explode. Two asteroids moving in the same direction will never meet.</p>
<p>Example 1:</p>
<pre>Input: 
asteroids = [5, 10, -5]
Output: [5, 10]
Explanation: 
The 10 and -5 collide resulting in 10.  The 5 and 10 never collide.
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input: 
asteroids = [8, -8]
Output: []
Explanation: 
The 8 and -8 collide exploding each other.
</pre>
<p> </p>
<p>Example 3:</p>
<pre>Input: 
asteroids = [10, 2, -5]
Output: [10]
Explanation: 
The 2 and -5 collide resulting in -5.  The 10 and -5 collide resulting in 10.
</pre>
<p> </p>
<p>Example 4:</p>
<pre>Input: 
asteroids = [-2, -1, 1, 2]
Output: [-2, -1, 1, 2]
Explanation: 
The -2 and -1 are moving left, while the 1 and 2 are moving right.
Asteroids moving the same direction never meet, so no asteroids will meet each other.
</pre>
<p> </p>
<p>Note:</p>
<ul>
<li>The length of <code>asteroids</code> will be at most <code>10000</code>.</li>
<li>Each asteroid will be a non-zero integer in the range <code>[-1000, 1000].</code>.</li>
</ul>
<p> </p>
<p>这道题用一个数组来模拟行星碰撞，正数代表行星向右移动，负数表示向左移动，绝对值大小表示行星的质量，如果两个相邻的行星相向移动会碰撞，质量大的行星会完好无损的保存，质量小的就会灰飞烟灭。那么博主最开始想的方法就是按照题目要求来一个一个的处理，我们先把给定的数组放到结果res中，然后进行while循环，如果此时结果res中的数字个数小于等于1个，直接返回即可，没有可碰撞的了。否则我们建立一个临时数组t，把结果res中的首元素放到t中，然后从第二个数字开始遍历结果res，如果此时t为空了，或者当前数字大于0而t数组最后一个数字小于0（此时两个行星向相反方向运动，不会相撞），或者两个数字的符号相同（此时两个行星向同一个方向运动，不会相撞），这三种情况下都把当前数字res[i]加到数组t中；那么剩下的情况就是两个行星相向运动了，如果两个数字相加等于0，则说明两个行星质量相同，且相向运动，则一起消失，我们将数组t中最后一个数字移除；如果当前数字小于0，且两个数字相加小于0，那么此时相撞后会留下质量大的行星，我们将数组t的最后一个数字赋值为res[i]即可。for循环之和，如果数组t和结果res的大小相等，说明此时状态已经稳定了，我们直接break，否则就把数组t赋值给结果res并继续循环，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; asteroidCollision(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> asteroids) {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; res =<span style="color: #000000;"> asteroids;
        </span><span style="color: #0000ff;">while</span> (<span style="color: #0000ff;">true</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">if</span> (res.size() &lt;= <span style="color: #800080;">1</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
            vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; t{res[<span style="color: #800080;">0</span><span style="color: #000000;">]};
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt; res.size(); ++<span style="color: #000000;">i) {
                </span><span style="color: #0000ff;">if</span> (t.empty() || (res[i] &gt; <span style="color: #800080;">0</span> &amp;&amp; t.back() &lt; <span style="color: #800080;">0</span>) || res[i] * t.back() &gt; <span style="color: #800080;">0</span><span style="color: #000000;">) {
                    t.push_back(res[i]);
                } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (res[i] + t.back() == <span style="color: #800080;">0</span><span style="color: #000000;">) {
                    t.pop_back();
                } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (res[i] &lt; <span style="color: #800080;">0</span> &amp;&amp; res[i] + t.back() &lt; <span style="color: #800080;">0</span><span style="color: #000000;">) {
                     t.back() </span>=<span style="color: #000000;"> res[i];
                }
            }
            </span><span style="color: #0000ff;">if</span> (t.size() == res.size()) <span style="color: #0000ff;">break</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">else</span> res =<span style="color: #000000;"> t;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>实际上我们可以写的更加简洁一些，我们遍历所有的数字，如果当前数字是正数的话，我们直接加入结果res；否则我们遇到的都是负数，如果结果res为空，或者结果res的最后一个数字小于0（此时两个行星同时向左运动），直接将当前数字加入结果res；如果结果res的最后一个数字（此时为正数）小于当前数字的绝对值，说明碰撞后消失了，那么我们将i自减一个，然后将res最后一个数字移除，这样下次遍历的时候还是这个质量大的行星。如果两个质量相等，那么直接移除res最后一个数字，此时两个行星都消失了，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; asteroidCollision(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> asteroids) {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; asteroids.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (asteroids[i] &gt; <span style="color: #800080;">0</span><span style="color: #000000;">) {
                res.push_back(asteroids[i]);
            } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (res.empty() || res.back() &lt; <span style="color: #800080;">0</span><span style="color: #000000;">) {
                res.push_back(asteroids[i]);
            } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (res.back() &lt;= -<span style="color: #000000;">asteroids[i]) {
                </span><span style="color: #0000ff;">if</span> (res.back() &lt; -asteroids[i]) --<span style="color: #000000;">i;
                res.pop_back();
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/6983982.html">Can Place Flowers</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/112034/java-c-clean-code">https://discuss.leetcode.com/topic/112034/java-c-clean-code</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-12-13 23:41</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=8035551" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(8035551);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/8016251.html" id="cb_post_title_url">[LeetCode] Sentence Similarity 句子相似度</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given two sentences <code>words1, words2</code> (each represented as an array of strings), and a list of similar word pairs <code>pairs</code>, determine if two sentences are similar.</p>
<p>For example, "great acting skills" and "fine drama talent" are similar, if the similar word pairs are <code>pairs = [["great", "fine"], ["acting","drama"], ["skills","talent"]]</code>.</p>
<p>Note that the similarity relation is not transitive. For example, if "great" and "fine" are similar, and "fine" and "good" are similar, "great" and "good" are not necessarily similar.</p>
<p>However, similarity is symmetric. For example, "great" and "fine" being similar is the same as "fine" and "great" being similar.</p>
<p>Also, a word is always similar with itself. For example, the sentences <code>words1 = ["great"], words2 = ["great"], pairs = []</code> are similar, even though there are no specified similar word pairs.</p>
<p>Finally, sentences can only be similar if they have the same number of words. So a sentence like <code>words1 = ["great"]</code> can never be similar to <code>words2 = ["doubleplus","good"]</code>.</p>
<p>Note:</p>
<ul>
<li>The length of <code>words1</code> and <code>words2</code> will not exceed <code>1000</code>.</li>
<li>The length of <code>pairs</code> will not exceed <code>2000</code>.</li>
<li>The length of each <code>pairs[i]</code> will be <code>2</code>.</li>
<li>The length of each <code>words[i]</code> and <code>pairs[i][j]</code> will be in the range <code>[1, 20]</code>.</li>
</ul>
<p> </p>
<p>这道题给了我们两个句子，问这两个句子是否是相似的。判定的条件是两个句子的单词数要相同，而且每两个对应的单词要是相似度，这里会给一些相似的单词对，这里说明了单词对的相似具有互逆性但是没有传递性。看到这里博主似乎已经看到了Follow up了，加上传递性就是一个很好的拓展。那么这里没有传递性，就使得问题变得很容易了，我们只要建立一个单词和其所有相似单词的集合的映射就可以了，比如说如果great和fine类似，且great和good类似，那么就有下面这个映射：</p>
<p>great -&gt; {fine, good}</p>
<p>所以我们在逐个检验两个句子中对应的单词时就可以直接去映射中找，注意有可能遇到的单词对时反过来的，比如fine和great，所以我们两个单词都要带到映射中去查找，只要有一个能查找到，就说明是相似的，反之，如果两个都没查找到，说明不相似，直接返回false，参见代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">bool</span> areSentencesSimilar(vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp; words1, vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp; words2, vector&lt;pair&lt;<span style="color: #0000ff;">string</span>, <span style="color: #0000ff;">string</span>&gt;&gt;<span style="color: #000000;"> pairs) {
        </span><span style="color: #0000ff;">if</span> (words1.size() != words2.size()) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        unordered_map</span>&lt;<span style="color: #0000ff;">string</span>, unordered_set&lt;<span style="color: #0000ff;">string</span>&gt;&gt;<span style="color: #000000;"> m;
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto pair : pairs) {
            m[pair.first].insert(pair.second);
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; words1.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (words1[i] == words2[i]) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> (!m[words1[i]].count(words2[i]) &amp;&amp; !m[words2[i]].count(words1[i])) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/6686983.html">Friend Circles</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/7829169.html">Accounts Merge</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-12-10 09:42</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=8016251" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(8016251);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7990046.html" id="cb_post_title_url">[LeetCode] Flood Fill 洪水填充</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>An <code>image</code> is represented by a 2-D array of integers, each integer representing the pixel value of the image (from 0 to 65535).</p>
<p>Given a coordinate <code>(sr, sc)</code> representing the starting pixel (row and column) of the flood fill, and a pixel value <code>newColor</code>, "flood fill" the image.</p>
<p>To perform a "flood fill", consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color as the starting pixel), and so on. Replace the color of all of the aforementioned pixels with the newColor.</p>
<p>At the end, return the modified image.</p>
<p>Example 1:</p>
<pre>Input: 
image = [[1,1,1],[1,1,0],[1,0,1]]
sr = 1, sc = 1, newColor = 2
Output: [[2,2,2],[2,2,0],[2,0,1]]
Explanation: 
From the center of the image (with position (sr, sc) = (1, 1)), all pixels connected 
by a path of the same color as the starting pixel are colored with the new color.
Note the bottom corner is not colored 2, because it is not 4-directionally connected
to the starting pixel.
</pre>
<p> </p>
<p>Note:</p>
<ul>
<li>The length of <code>image</code> and <code>image[0]</code> will be in the range <code>[1, 50]</code>.</li>
<li>The given starting pixel will satisfy <code>0 &lt;= sr &lt; image.length</code> and <code>0 &lt;= sc &lt; image[0].length</code>.</li>
<li>The value of each color in <code>image[i][j]</code> and <code>newColor</code> will be an integer in <code>[0, 65535]</code>.</li>
</ul>
<p> </p>
<p>这道题给了我们一个用二维数组表示的图像，不同的数字代表不同的颜色，给了我们一个起始点坐标，还有一个新的颜色，让我们把起始点的颜色以及其相邻的同样的颜色都换成新的颜色。那么实际上就是一个找相同区间的题，我们可以用BFS或者DFS来做。先来看BFS的解法，我们使用一个队列queue来辅助，首先将给定点放入队列中，然后进行while循环，条件是queue不为空，然后进行类似层序遍历的方法，取出队首元素，将其赋值为新的颜色，然后遍历周围四个点，如果不越界，且周围的颜色跟起始颜色相同的话，将位置加入队列中，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; floodFill(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp; image, <span style="color: #0000ff;">int</span> sr, <span style="color: #0000ff;">int</span> sc, <span style="color: #0000ff;">int</span><span style="color: #000000;"> newColor) {
        </span><span style="color: #0000ff;">int</span> m = image.size(), n = image[<span style="color: #800080;">0</span>].size(), color =<span style="color: #000000;"> image[sr][sc];
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; res =<span style="color: #000000;"> image;
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; dirs{{<span style="color: #800080;">0</span>,-<span style="color: #800080;">1</span>},{-<span style="color: #800080;">1</span>,<span style="color: #800080;">0</span>},{<span style="color: #800080;">0</span>,<span style="color: #800080;">1</span>},{<span style="color: #800080;">1</span>,<span style="color: #800080;">0</span><span style="color: #000000;">}};
        queue</span>&lt;pair&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;&gt;<span style="color: #000000;"> q{{{sr, sc}}};
        </span><span style="color: #0000ff;">while</span> (!<span style="color: #000000;">q.empty()) {
            </span><span style="color: #0000ff;">int</span> len =<span style="color: #000000;"> q.size();
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; len; ++<span style="color: #000000;">i) {
                auto t </span>=<span style="color: #000000;"> q.front(); q.pop();
                res[t.first][t.second] </span>=<span style="color: #000000;"> newColor;
                </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto dir : dirs) {
                    </span><span style="color: #0000ff;">int</span> x = t.first + dir[<span style="color: #800080;">0</span>], y = t.second + dir[<span style="color: #800080;">1</span><span style="color: #000000;">];
                    </span><span style="color: #0000ff;">if</span> (x &lt; <span style="color: #800080;">0</span> || x &gt;= m || y &lt; <span style="color: #800080;">0</span> || y &gt;= n || res[x][y] != color) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                    q.push({x, y});
                }
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>DFS的写法相对简洁一些，首先判断如果给定位置的颜色跟新的颜色相同的话，直接返回，否则就对给定位置调用递归函数。在递归函数中，如果越界或者当前颜色跟起始颜色不同，直接返回。否则就给当前位置赋上新的颜色，然后对周围四个点继续调用递归函数，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; floodFill(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp; image, <span style="color: #0000ff;">int</span> sr, <span style="color: #0000ff;">int</span> sc, <span style="color: #0000ff;">int</span><span style="color: #000000;"> newColor) {
        </span><span style="color: #0000ff;">if</span> (image[sr][sc] == newColor) <span style="color: #0000ff;">return</span><span style="color: #000000;"> image;
        helper(image, sr, sc, image[sr][sc], newColor);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> image;
    }
    </span><span style="color: #0000ff;">void</span> helper(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp; image, <span style="color: #0000ff;">int</span> i, <span style="color: #0000ff;">int</span> j, <span style="color: #0000ff;">int</span> color, <span style="color: #0000ff;">int</span><span style="color: #000000;"> newColor) {
        </span><span style="color: #0000ff;">int</span> m = image.size(), n = image[<span style="color: #800080;">0</span><span style="color: #000000;">].size();
        </span><span style="color: #0000ff;">if</span> (i &lt; <span style="color: #800080;">0</span> || i &gt;= m || j &lt; <span style="color: #800080;">0</span> || j &gt;= n || image[i][j] != color) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
        image[i][j] </span>=<span style="color: #000000;"> newColor;
        helper(image, i </span>+ <span style="color: #800080;">1</span><span style="color: #000000;">, j, color, newColor);
        helper(image, i, j </span>+ <span style="color: #800080;">1</span><span style="color: #000000;">, color, newColor);
        helper(image, i </span>- <span style="color: #800080;">1</span><span style="color: #000000;">, j, color, newColor);
        helper(image, i, j </span>- <span style="color: #800080;">1</span><span style="color: #000000;">, color, newColor);
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/6096138.html">Island Perimeter</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/112055/java-9-liner-dfs">https://discuss.leetcode.com/topic/112055/java-9-liner-dfs</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-12-05 23:23</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7990046" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7990046);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/8005054.html" id="cb_post_title_url">[LeetCode] My Calendar III 我的日历之三</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="question-description">
<p>Implement a <code>MyCalendarThree</code> class to store your events. A new event can always be added.</p>
<p>Your class will have one method, <code>book(int start, int end)</code>. Formally, this represents a booking on the half open interval <code>[start, end)</code>, the range of real numbers <code>x</code> such that <code>start &lt;= x &lt; end</code>.</p>
<p>A <em>K-booking</em> happens when K events have some non-empty intersection (ie., there is some time that is common to all K events.)</p>
<p>For each call to the method <code>MyCalendar.book</code>, return an integer <code>K</code> representing the largest integer such that there exists a <code>K</code>-booking in the calendar.</p>
Your class will be called like this: <code>MyCalendarThree cal = new MyCalendarThree();</code> <code>MyCalendarThree.book(start, end)</code>
<p>Example 1:</p>
<pre>MyCalendarThree();
MyCalendarThree.book(10, 20); // returns 1
MyCalendarThree.book(50, 60); // returns 1
MyCalendarThree.book(10, 40); // returns 2
MyCalendarThree.book(5, 15); // returns 3
MyCalendarThree.book(5, 10); // returns 3
MyCalendarThree.book(25, 55); // returns 3
Explanation: 
The first two events can be booked and are disjoint, so the maximum K-booking is a 1-booking.
The third event [10, 40) intersects the first event, and the maximum K-booking is a 2-booking.
The remaining events cause the maximum K-booking to be only a 3-booking.
Note that the last event locally causes a 2-booking, but the answer is still 3 because
eg. [10, 20), [10, 40), and [5, 15) are still triple booked.
</pre>
<p> </p>
<p>Note:</p>
<ul>
<li>The number of calls to <code>MyCalendarThree.book</code> per test case will be at most <code>400</code>.</li>
<li>In calls to <code>MyCalendarThree.book(start, end)</code>, <code>start</code> and <code>end</code> are integers in the range <code>[0, 10^9]</code>.</li>
</ul>
<p> </p>
<p>这道题是之前那两道题<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/7968035.html" id="homepage1_HomePageDays_DaysList_ctl02_DayList_TitleUrl_0">My Calendar II</a>，<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/7920253.html" id="homepage1_HomePageDays_DaysList_ctl04_DayList_TitleUrl_0">My Calendar I</a>的拓展，论坛上有人说这题不应该算是Hard类的，但实际上如果没有之前那两道题做铺垫，直接上这道其实还是还蛮有难度的。这道题博主在做完之前那道，再做这道一下子就做出来了，因为用的就是之前那道<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/7968035.html" id="homepage1_HomePageDays_DaysList_ctl02_DayList_TitleUrl_0">My Calendar II</a>的解法二，具体的讲解可以参见那道题，反正博主写完那道题再来做这道题就是秒解啊，参见代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> MyCalendarThree {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    MyCalendarThree() {}
    
    </span><span style="color: #0000ff;">int</span> book(<span style="color: #0000ff;">int</span> start, <span style="color: #0000ff;">int</span><span style="color: #000000;"> end) {
        </span>++<span style="color: #000000;">freq[start];
        </span>--<span style="color: #000000;">freq[end];
        </span><span style="color: #0000ff;">int</span> cnt = <span style="color: #800080;">0</span>, mx = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto f : freq) {
            cnt </span>+=<span style="color: #000000;"> f.second;
            mx </span>=<span style="color: #000000;"> max(mx, cnt);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> mx;
    }
    
</span><span style="color: #0000ff;">private</span><span style="color: #000000;">:
    map</span>&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> freq;
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/7968035.html" id="homepage1_HomePageDays_DaysList_ctl02_DayList_TitleUrl_0">My Calendar II</a></p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/7920253.html" id="homepage1_HomePageDays_DaysList_ctl04_DayList_TitleUrl_0">My Calendar I</a></p>
</div>
<div id="interviewed-div"> </div>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/111978/java-c-clean-code">https://discuss.leetcode.com/topic/111978/java-c-clean-code</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-12-08 13:53</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=8005054" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(8005054);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7968035.html" id="cb_post_title_url">[LeetCode] My Calendar II 我的日历之二</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Implement a <code>MyCalendarTwo</code> class to store your events. A new event can be added if adding the event will not cause a triple booking.</p>
<p>Your class will have one method, <code>book(int start, int end)</code>. Formally, this represents a booking on the half open interval <code>[start, end)</code>, the range of real numbers <code>x</code> such that <code>start &lt;= x &lt; end</code>.</p>
<p>A <em>triple booking</em> happens when three events have some non-empty intersection (ie., there is some time that is common to all 3 events.)</p>
<p>For each call to the method <code>MyCalendar.book</code>, return <code>true</code> if the event can be added to the calendar successfully without causing a triple booking. Otherwise, return <code>false</code> and do not add the event to the calendar.</p>
<p>Your class will be called like this: <code>MyCalendar cal = new MyCalendar();</code> <code>MyCalendar.book(start, end)</code></p>
<p>Example 1:</p>
<pre>MyCalendar();
MyCalendar.book(10, 20); // returns true
MyCalendar.book(50, 60); // returns true
MyCalendar.book(10, 40); // returns true
MyCalendar.book(5, 15); // returns false
MyCalendar.book(5, 10); // returns true
MyCalendar.book(25, 55); // returns true
Explanation: 
The first two events can be booked.  The third event can be double booked.
The fourth event (5, 15) can't be booked, because it would result in a triple booking.
The fifth event (5, 10) can be booked, as it does not use time 10 which is already double booked.
The sixth event (25, 55) can be booked, as the time in [25, 40) will be double booked with the third event;
the time [40, 50) will be single booked, and the time [50, 55) will be double booked with the second event.
</pre>
<p> </p>
<p>Note:</p>
<ul>
<li>The number of calls to <code>MyCalendar.book</code> per test case will be at most <code>1000</code>.</li>
<li>In calls to <code>MyCalendar.book(start, end)</code>, <code>start</code> and <code>end</code> are integers in the range <code>[0, 10^9]</code>.</li>
</ul>
<p> </p>
<p>这道题是<a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/7920253.html" id="homepage1_HomePageDays_DaysList_ctl04_DayList_TitleUrl_0">My Calendar I</a>的拓展，之前那道题说是不能有任何的重叠区间，而这道题说最多容忍两个重叠区域，注意是重叠区域，不是事件。比如事件A，B，C互不重叠，但是有一个事件D，和这三个事件都重叠，这样是可以的，因为重叠的区域最多只有两个。所以关键还是要知道具体的重叠区域，如果两个事件重叠，那么重叠区域就是它们的交集，求交集的方法是两个区间的起始时间中的较大值，到结束时间中的较小值。那么我们可以用一个集合来专门存重叠区间，再用一个集合来存完整的区间，那么我们的思路就是，先遍历专门存重叠区间的集合，因为能在这里出现的区间，都已经是出现两次了，如果当前新的区间跟重叠区间有交集的话，说明此时三个事件重叠了，直接返回false。如果当前区间跟重叠区间没有交集的话，那么再来遍历完整区间的集合，如果有交集的话，那么应该算出重叠区间并且加入放重叠区间的集合中。最后记得将新区间加入完整区间的集合中，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> MyCalendarTwo {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    MyCalendarTwo() {}
    
    </span><span style="color: #0000ff;">bool</span> book(<span style="color: #0000ff;">int</span> start, <span style="color: #0000ff;">int</span><span style="color: #000000;"> end) {
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto a : s2) {
            </span><span style="color: #0000ff;">if</span> (start &gt;= a.second || end &lt;= a.first) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto a : s1) {
            </span><span style="color: #0000ff;">if</span> (start &gt;= a.second || end &lt;= a.first) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> s2.insert({max(start, a.first), min(end, a.second)});
        }
        s1.insert({start, end});
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }

</span><span style="color: #0000ff;">private</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">set</span>&lt;pair&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;&gt;<span style="color: #000000;"> s1, s2;
};</span></pre>
</div>
<p> </p>
<p>下面这种方法相当的巧妙，我们建立一个时间点和次数之间的映射，规定遇到起始时间点，次数加1，遇到结束时间点，次数减1。那么我们首先更改新的起始时间start和结束时间end的映射，start对应值增1，end对应值减1。然后定义一个变量cnt，来统计当前的次数。我们使用treemap具有自动排序的功能，所以我们遍历的时候就是按时间顺序的，最先遍历到的一定是一个起始时间，所以加上其映射值，一定是个正数。那么我们想，如果此时只有一个区间，就是刚加进来的区间的话，那么首先肯定遍历到start，那么cnt此时加1，然后就会遍历到end，那么此时cnt减1，最后下来cnt为0，没有重叠。还是用具体数字来说吧，我们现在假设treemap中已经加入了一个区间[3, 5)了，那么我们就有下面的映射：</p>
<p>3 -&gt; 1</p>
<p>5 -&gt; -1</p>
<p>假如我们此时要加入的区间为[6, 8)的话，那么在遍历到6的时候，前面经过3和5，分别加1减1，那么cnt又重置为0了，而后面的6和8也是分别加1减1，还是0。那么加入我们新加入的区间为[3, 8]时，那么此时的映射为：</p>
<p>3 -&gt; 2</p>
<p>5 -&gt; -1</p>
<p>8 -&gt; -1</p>
<p>那么我们最先遍历到3，cnt为2，没有超过3，我们知道此时有两个事件有重叠，是允许的。然后遍历5和8，分别减去1，最终又变成0了，始终cnt没有超过2，所以是符合题意的。如果此时我们再加入一个新的区间[1, 4)，那么此时的映射为：</p>
<p>1 -&gt; 1</p>
<p>3 -&gt; 2</p>
<p>4 -&gt; -1</p>
<p>5 -&gt; -1</p>
<p>8 -&gt; -1</p>
<p>那么我们先遍历到1，cnt为1，然后遍历到3，此时cnt为3了，那么我们就知道有三个事件有重叠区间了，所以这个新区间是不能加入的，那么我们要还原其start和end做的操作，把start的映射值减1，end的映射值加1，然后返回false。否则没有三个事件有共同重叠区间的话，返回true即可，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> MyCalendarTwo {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    MyCalendarTwo() {}
    
    </span><span style="color: #0000ff;">bool</span> book(<span style="color: #0000ff;">int</span> start, <span style="color: #0000ff;">int</span><span style="color: #000000;"> end) {
        </span>++<span style="color: #000000;">freq[start];
        </span>--<span style="color: #000000;">freq[end];
        </span><span style="color: #0000ff;">int</span> cnt = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto f : freq) {
            cnt </span>+=<span style="color: #000000;"> f.second;
            </span><span style="color: #0000ff;">if</span> (cnt == <span style="color: #800080;">3</span><span style="color: #000000;">) {
                </span>--<span style="color: #000000;">freq[start];
                </span>++<span style="color: #000000;">freq[end];
                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            }
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }

</span><span style="color: #0000ff;">private</span><span style="color: #000000;">:
    map</span>&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> freq;
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/7920253.html" id="homepage1_HomePageDays_DaysList_ctl04_DayList_TitleUrl_0">My Calendar I</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/111276/simplified-winner-s-solution">https://discuss.leetcode.com/topic/111276/simplified-winner-s-solution</a></p>
<p><a href="https://discuss.leetcode.com/topic/111279/c-solution-easy-to-understand">https://discuss.leetcode.com/topic/111279/c-solution-easy-to-understand</a></p>
<p><a href="https://discuss.leetcode.com/topic/111198/java-c-clean-code-with-explanation">https://discuss.leetcode.com/topic/111198/java-c-clean-code-with-explanation</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-12-03 23:50</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7968035" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7968035);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7942040.html" id="cb_post_title_url">[LeetCode] Count Different Palindromic Subsequences 计数不同的回文子序列的个数</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a string S, find the number of different non-empty palindromic subsequences in S, and return that number modulo <code>10^9 + 7</code>.</p>
<p>A subsequence of a string S is obtained by deleting 0 or more characters from S.</p>
<p>A sequence is palindromic if it is equal to the sequence reversed.</p>
<p>Two sequences <code>A_1, A_2, ...</code> and <code>B_1, B_2, ...</code> are different if there is some <code>i</code> for which <code>A_i != B_i</code>.</p>
<p>Example 1:</p>
<pre>Input: 
S = 'bccb'
Output: 6
Explanation: 
The 6 different non-empty palindromic subsequences are 'b', 'c', 'bb', 'cc', 'bcb', 'bccb'.
Note that 'bcb' is counted only once, even though it occurs twice.
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input: 
S = 'abcdabcdabcdabcdabcdabcdabcdabcddcbadcbadcbadcbadcbadcbadcbadcba'
Output: 104860361
Explanation: 
There are 3104860382 different non-empty palindromic subsequences, which is 104860361 modulo 10^9 + 7.
</pre>
<p> </p>
<p>Note:</p>
<ul>
<li>The length of <code>S</code> will be in the range <code>[1, 1000]</code>.</li>
<li>Each character <code>S[i]</code> will be in the set <code>{'a', 'b', 'c', 'd'}</code>.</li>
</ul>
<p> </p>
<p>这道题给了给了我们一个字符串，让我们求出所有的非空回文子序列的个数，虽然这题限制了字符只有四种，但是我们还是按一般的情况来解吧，可以有26个字母。然后说最终结果要对一个很大的数字取余，这就暗示了结果会是一个很大的值，那么对于这种问题一般都是用DP或者是带记忆数组memo的递归来解，二者的本质其实是一样的。我们先来看带记忆数组memo的递归解法，这种解法的思路是一层一层剥洋葱，比如"bccb"，按照字母来剥，先剥字母b，确定最外层"b _ _ b"，这会产生两个回文子序列"b"和"bb"，然后递归进中间的部分，把中间的回文子序列个数算出来加到结果res中，然后开始剥字母c，找到最外层"cc"，此时会产生两个回文子序列"c"和"cc"，然后由于中间没有字符串了，所以递归返回0，按照这种方法就可以算出所有的回文子序列了。</p>
<p>我们建立一个二维数组chars，外层长度为26，里面放一个空数组。这是为了统计每个字母在原字符串中出现的位置，然后定义一个二维记忆数组memo，其中memo[i][j]表示第i个字符到第j个字符之间的子字符串中的回文子序列的个数，初始化均为0。然后我们遍历字符串S，将每个字符的位置加入其对应的数组中，比如对于"bccb"，那么有：</p>
<p>b -&gt; {0, 3}</p>
<p>c -&gt; {1, 2}</p>
<p>然后在[0, n]的范围内调用递归函数，在递归函数中，首先判断如果start大于等于end，返回0。如果当前位置在memo的值大于0，说明当前情况已经计算过了，直接返回memo数组中的值。否则进行所有字母的遍历，如果某个字母对应的数组中没有值，说明该字母不曾在字符串中出现，跳过。然后我们在字母数组中查找第一个不小于start的位置，查找第一个小于end的位置，当前循环中，start为0，end为4，当前处理字母b，我们的new_start指向0，new_end指向3，如果当前new_start指向了end()，或者其指向的位置大于end，说明当前范围内没有字母b，直接跳过，否则结果res自增1，因为此时new_start存在，至少有个单个的字母b，也可以当作回文子序列，然后看new_start和new_end如果不相同，说明两者各指向了不同的b，此时res应自增1，因为又增加了一个新的回文子序列"bb"，下面就是对中间部分调用递归函数了，把返回值加到结果res中。此时字母b就处理完了，现在处理字母c，此时的start还是0，end还是4，new_start指向1，new_end指向2，跟上面的分析相同，new_start在范围内，结果自增1，因为加上了"c"，然后new_start和new_end不同，结果res再自增1，因为加上了"cc"，其中间没有字符了，调用递归的结果是0，for循环结束，我们将memo[start][end]的值对超大数取余，将该值返回即可，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> countPalindromicSubsequences(<span style="color: #0000ff;">string</span><span style="color: #000000;"> S) {
        </span><span style="color: #0000ff;">int</span> n =<span style="color: #000000;"> S.size();
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; chars(<span style="color: #800080;">26</span>, vector&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;">());
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; memo(n + <span style="color: #800080;">1</span>, vector&lt;<span style="color: #0000ff;">int</span>&gt;(n + <span style="color: #800080;">1</span>, <span style="color: #800080;">0</span><span style="color: #000000;">));
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            chars[S[i] </span>- <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span><span style="color: #000000;">].push_back(i);
        }
        </span><span style="color: #0000ff;">return</span> helper(S, chars, <span style="color: #800080;">0</span><span style="color: #000000;">, n, memo);
    }
    </span><span style="color: #0000ff;">int</span> helper(<span style="color: #0000ff;">string</span> S, vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp; chars, <span style="color: #0000ff;">int</span> start, <span style="color: #0000ff;">int</span> end, vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> memo) {
        </span><span style="color: #0000ff;">if</span> (start &gt;= end) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (memo[start][end] &gt; <span style="color: #800080;">0</span>) <span style="color: #0000ff;">return</span><span style="color: #000000;"> memo[start][end];
        </span><span style="color: #0000ff;">long</span> res = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; <span style="color: #800080;">26</span>; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (chars[i].empty()) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
            auto new_start </span>=<span style="color: #000000;"> lower_bound(chars[i].begin(), chars[i].end(), start);
            auto new_end </span>= lower_bound(chars[i].begin(), chars[i].end(), end) - <span style="color: #800080;">1</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> (new_start == chars[i].end() || *new_start &gt;= end) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
            </span>++<span style="color: #000000;">res;
            </span><span style="color: #0000ff;">if</span> (new_start != new_end) ++<span style="color: #000000;">res;
            res </span>+= helper(S, chars, *new_start + <span style="color: #800080;">1</span>, *<span style="color: #000000;">new_end, memo);
        }
        memo[start][end] </span>= res % <span style="color: #0000ff;">int</span>(1e9 + <span style="color: #800080;">7</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> memo[start][end];
    }
};</span></pre>
</div>
<p> </p>
<p>我们再来看一种迭代的写法，使用一个二维的dp数组，其中dp[i][j]表示子字符串[i, j]中的不同回文子序列的个数，我们初始化dp[i][i]为1，因为任意一个单个字符就是一个回文子序列，其余均为0。这里的更新顺序不是正向，也不是逆向，而是斜着更新，对于"bccb"的例子，其最终dp数组如下，我们可以看到其更新顺序分别是红-绿-蓝-橙。</p>
<div class="cnblogs_code">
<pre><span style="color: #ff0000;"><span style="color: #000000;">  b c c b</span><br/><span style="color: #000000;">b</span> 1</span> <span style="color: #008000;">2</span> <span style="color: #0000ff;">3</span> <span style="color: #ff9900;">6</span>
<span style="color: #000000;">c 0</span> <span style="color: #ff0000;">1</span> <span style="color: #008000;">2</span> <span style="color: #0000ff;">3</span>
<span style="color: #000000;">c 0</span> <span style="color: #000000;">0</span> <span style="color: #ff0000;">1</span> <span style="color: #008000;">2</span>
<span style="color: #000000;">b 0 0 0</span> <span style="color: #ff0000;">1</span></pre>
</div>
<p>这样更新的好处是，更新当前位置时，其左，下，和左下位置的dp值均已存在，而当前位置的dp值需要用到这三个位置的dp值。我们观察上面的dp数组，可以发现当S[i]不等于S[j]的时候，dp[i][j] = dp[i][j - 1] + dp[i + 1][j] - dp[i + 1][j - 1]，即当前的dp值等于左边值加下边值减去左下值，因为算左边值的时候包括了左下的所有情况，而算下边值的时候也包括了左下值的所有情况，那么左下值就多算了一遍，所以要减去。而当S[i]等于S[j]的时候，情况就比较复杂了，需要分情况讨论，因为我们不知道中间还有几个和S[i]相等的值。举个简单的例子，比如"aba"和"aaa"，当i = 0, j = 2的时候，两个字符串均有S[i] == S[j]，此时二者都新增两个子序列"a"和"aa"，但是"aba"中间的"b"就可以加到结果res中，而"aaa"中的"a"就不能加了，因为和外层的单独"a"重复了。我们的目标就要找到中间重复的"a"。所以我们让left = i + 1, right = j - 1，然后对left进行while循环，如果left &lt;= right, 且S[left] != S[i]的时候，left向右移动一个；同理，对right进行while循环，如果left &lt;= right, 且S[right] != S[i]的时候，left向左移动一个。这样最终left和right值就有三种情况：</p>
<p>1. 当left &gt; righ时，说明中间没有和S[i]相同的字母了，就是"aba"这种情况，那么就有dp[i][j] = dp[i + 1][j - 1] * 2 + 2，其中dp[i + 1][j - 1]是中间部分的回文子序列个数，为啥要乘2呢，因为中间的所有子序列可以单独存在，也可以再外面包裹上字母a，所以是成对出现的，要乘2。加2的原因是外层的"a"和"aa"也要统计上。</p>
<p>2. 当left = right时，说明中间只有一个和S[i]相同的字母，就是"aaa"这种情况，那么有dp[i][j] = dp[i + 1][j - 1] * 2 + 1，其中乘2的部分跟上面的原因相同，加1的原因是单个字母"a"的情况已经在中间部分算过了，外层就只能再加上个"aa"了。</p>
<p>3. 当left &lt; right时，说明中间至少有两个和S[i]相同的字母，就是"aabaa"这种情况，那么有dp[i][j] = dp[i + 1][j - 1] * 2 - dp[left + 1][right - 1]，其中乘2的部分跟上面的原因相同，要减去left和right中间部分的子序列个数的原因是其被计算了两遍，要将多余的减掉。</p>
<p>参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> countPalindromicSubsequences(<span style="color: #0000ff;">string</span><span style="color: #000000;"> S) {
        </span><span style="color: #0000ff;">int</span> n = S.size(), M = 1e9 + <span style="color: #800080;">7</span><span style="color: #000000;">;
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; dp(n, vector&lt;<span style="color: #0000ff;">int</span>&gt;(n, <span style="color: #800080;">0</span><span style="color: #000000;">));
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++i) dp[i][i] = <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> len = <span style="color: #800080;">1</span>; len &lt; n; ++<span style="color: #000000;">len) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n - len; ++<span style="color: #000000;">i) {
                </span><span style="color: #0000ff;">int</span> j = i +<span style="color: #000000;"> len;
                </span><span style="color: #0000ff;">if</span> (S[i] ==<span style="color: #000000;"> S[j]) {
                    </span><span style="color: #0000ff;">int</span> left = i + <span style="color: #800080;">1</span>, right = j - <span style="color: #800080;">1</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">while</span> (left &lt;= right &amp;&amp; S[left] != S[i]) ++<span style="color: #000000;">left;
                    </span><span style="color: #0000ff;">while</span> (left &lt;= right &amp;&amp; S[right] != S[i]) --<span style="color: #000000;">right;
                    </span><span style="color: #0000ff;">if</span> (left &gt;<span style="color: #000000;"> right) {
                        dp[i][j] </span>= dp[i + <span style="color: #800080;">1</span>][j - <span style="color: #800080;">1</span>] * <span style="color: #800080;">2</span> + <span style="color: #800080;">2</span><span style="color: #000000;">;
                    } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (left ==<span style="color: #000000;"> right) {
                        dp[i][j] </span>= dp[i + <span style="color: #800080;">1</span>][j - <span style="color: #800080;">1</span>] * <span style="color: #800080;">2</span> + <span style="color: #800080;">1</span><span style="color: #000000;">;
                    } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                        dp[i][j] </span>= dp[i + <span style="color: #800080;">1</span>][j - <span style="color: #800080;">1</span>] * <span style="color: #800080;">2</span> - dp[left + <span style="color: #800080;">1</span>][right - <span style="color: #800080;">1</span><span style="color: #000000;">];
                    }
                } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    dp[i][j] </span>= dp[i][j - <span style="color: #800080;">1</span>] + dp[i + <span style="color: #800080;">1</span>][j] - dp[i + <span style="color: #800080;">1</span>][j - <span style="color: #800080;">1</span><span style="color: #000000;">];
                }
                dp[i][j] </span>= (dp[i][j] &lt; <span style="color: #800080;">0</span>) ? dp[i][j] + M : dp[i][j] %<span style="color: #000000;"> M;
            }
        }
        </span><span style="color: #0000ff;">return</span> dp[<span style="color: #800080;">0</span>][n - <span style="color: #800080;">1</span><span style="color: #000000;">];
    }
};</span></pre>
</div>
<p> </p>
<p>讨论：这道题确实是一道很难的题，和它类似的题目还有几道，虽然那些题有的还有非DP解法，但是DP解法始终是核心的，也是我们最应该掌握的方法。首先我们要分清子串和子序列的题，个人感觉子序列要更难一些。在之前那道<a href="http://www.cnblogs.com/grandyang/p/6493182.html">Longest Palindromic Subsequence</a>中要我们求最长的回文子序列，我们需要逆向遍历dp数组，当s[i]和s[j]相同时，长度为中间部分的dp值加2，否则就是左边值和下边值中的较大值，因为是子序列，不匹配就可以忽略当前字符。而对于回文子串的问题，比如<a href="http://www.cnblogs.com/grandyang/p/4464476.html" target="_blank">Longest Palindromic Substring</a>和<a href="http://www.cnblogs.com/grandyang/p/7404777.html">Palindromic Substrings</a>，一个是求最长的回文子串，一个是求所有的回文子串个数，他们的dp定义是看子串[i, j]是否是回文串，求最长回文子串就是维护一个最大值，不停用当前回文子串的长度更新这个最大值，同时更新最大值的左右边界。而求所有回文子串的个数就是如果当前dp[i][j]判断是回文串，计数器就自增1。而判断当前dp[i][j]是否是回文串的核心就是s[i]==s[j]，且i，j中间没有字符了，或者中间的dp值为true。</p>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/6493182.html">Longest Palindromic Subsequence</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4464476.html" target="_blank">Longest Palindromic Substring</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/7404777.html">Palindromic Substrings</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/111230/accepted-java-solution-using-memoization">https://discuss.leetcode.com/topic/111230/accepted-java-solution-using-memoization</a></p>
<p><a href="https://discuss.leetcode.com/topic/111483/java-96ms-dp-solution-with-detailed-explanation">https://discuss.leetcode.com/topic/111483/java-96ms-dp-solution-with-detailed-explanation</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-12-01 14:13</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7942040" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7942040);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7920253.html" id="cb_post_title_url">[LeetCode] My Calendar I 我的日历之一</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="question-description">
<p>Implement a <code>MyCalendar</code> class to store your events. A new event can be added if adding the event will not cause a double booking.</p>
<p>Your class will have the method, <code>book(int start, int end)</code>. Formally, this represents a booking on the half open interval <code>[start, end)</code>, the range of real numbers <code>x</code> such that <code>start &lt;= x &lt; end</code>.</p>
<p>A <em>double booking</em> happens when two events have some non-empty intersection (ie., there is some time that is common to both events.)</p>
<p>For each call to the method <code>MyCalendar.book</code>, return <code>true</code> if the event can be added to the calendar successfully without causing a double booking. Otherwise, return <code>false</code> and do not add the event to the calendar.</p>
Your class will be called like this: <code>MyCalendar cal = new MyCalendar();</code> <code>MyCalendar.book(start, end)</code>
<p>Example 1:</p>
<pre>MyCalendar();
MyCalendar.book(10, 20); // returns true
MyCalendar.book(15, 25); // returns false
MyCalendar.book(20, 30); // returns true
Explanation: 
The first event can be booked.  The second can't because time 15 is already booked by another event.
The third event can be booked, as the first event takes every time less than 20, but not including 20.
</pre>
<p> </p>
<p>Note:</p>
<ul>
<li>The number of calls to <code>MyCalendar.book</code> per test case will be at most <code>1000</code>.</li>
<li>In calls to <code>MyCalendar.book(start, end)</code>, <code>start</code> and <code>end</code> are integers in the range <code>[0, 10^9]</code>.</li>
</ul>
<p> </p>
<p>这道题让我们设计一个我的日历类，里面有一个book函数，需要给定一个起始时间和结束时间，与Google Calendar不同的是，我们的事件事件上不能重叠，实际上这道题的本质就是检查区间是否重叠。那么我们可以暴力搜索，对于每一个将要加入的区间，我们都和已经已经存在的区间进行比较，看是否有重复。而新加入的区间和当前区间产生重复的情况有两种，一种是新加入区间的前半段重复，并且，另一种是新加入区间的后半段重复。比如当前区间如果是[3, 8)，那么第一种情况下新加入区间就是[6, 9)，那么触发条件就是当前区间的起始时间小于等于新加入区间的起始时间，并且结束时间大于新加入区间的结束时间。第二种情况下新加入区间就是[2,5)，那么触发条件就是当前区间的起始时间大于等于新加入区间的起始时间，并且起始时间小于新加入区间的结束时间。这两种情况均返回false，否则就将新区间加入数组，并返回true即可，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> MyCalendar {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    MyCalendar() {}
    
    </span><span style="color: #0000ff;">bool</span> book(<span style="color: #0000ff;">int</span> start, <span style="color: #0000ff;">int</span><span style="color: #000000;"> end) {
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto a : cal) {
            </span><span style="color: #0000ff;">if</span> (a.first &lt;= start &amp;&amp; a.second &gt; start) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">if</span> (a.first &gt;= start &amp;&amp; a.first &lt; end) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        }
        cal.push_back({start, end});
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }

</span><span style="color: #0000ff;">private</span><span style="color: #000000;">:
    vector</span>&lt;pair&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;&gt;<span style="color: #000000;"> cal;
};</span></pre>
</div>
<p> </p>
<p>下面这种方法将上面方法的两个if判断融合成为了一个，我们来观察两个区间的起始和结束位置的关系发现，如果两个区间的起始时间中的较大值小于结束区间的较小值，那么就有重合，返回false。比如 [3, 8) 和 [6, 9)，3和6中的较大值6，小于8和9中的较小值8，有重叠。再比如[3, 8) 和 [2, 5)，3和2中的较大值3，就小于8和5中的较小值5，有重叠。而对于[3, 8) 和 [9, 10)，3和9中的较大值9，不小于8和10中的较小值8，所以没有重叠，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> MyCalendar {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    MyCalendar() {}
    
    </span><span style="color: #0000ff;">bool</span> book(<span style="color: #0000ff;">int</span> start, <span style="color: #0000ff;">int</span><span style="color: #000000;"> end) {
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto a : cal) {
            </span><span style="color: #0000ff;">if</span> (max(a.first, start) &lt; min(a.second, end)) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        }
        cal.push_back({start, end});
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }

</span><span style="color: #0000ff;">private</span><span style="color: #000000;">:
    vector</span>&lt;pair&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;&gt;<span style="color: #000000;"> cal;
};</span></pre>
</div>
<p> </p>
<p>上面两种解法都是线性搜索，我们起始可以优化搜索时间，如果我们的区间是有序的话。所以我们用一个map来建立起始时间和结束时间的映射，map会按照起始时间进行自动排序。然后对于新进来的区间，我们在已有区间中查找第一个不小于新入区间的起始时间的区间，如果这个区间存在的话，说明新入区间的起始时间小于等于当前区间，也就是解法一中的第二个if情况，当前区间起始时间小于新入区间结束时间的话返回false。我们还要跟前面一个区间进行查重叠操作，那么判断如果当前区间不是第一个区间的话，就找到前一个区间，此时是解法一中第一个if情况，并且如果前一个区间的结束时间大于新入区间的起始时间的话，返回false。否则就建立新的映射，返回true即可，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> MyCalendar {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    MyCalendar() {}
    
    </span><span style="color: #0000ff;">bool</span> book(<span style="color: #0000ff;">int</span> start, <span style="color: #0000ff;">int</span><span style="color: #000000;"> end) {
        auto it </span>=<span style="color: #000000;"> cal.lower_bound(start);
        </span><span style="color: #0000ff;">if</span> (it != cal.end() &amp;&amp; it-&gt;first &lt; end) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (it != cal.begin() &amp;&amp; prev(it)-&gt;second &gt; start) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        cal[start] </span>=<span style="color: #000000;"> end;
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }

</span><span style="color: #0000ff;">private</span><span style="color: #000000;">:
    map</span>&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> cal;
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/111205/java-8-liner-treemap">https://discuss.leetcode.com/topic/111205/java-8-liner-treemap</a></p>
<p><a href="https://discuss.leetcode.com/topic/111244/simple-c-o-n-solution">https://discuss.leetcode.com/topic/111244/simple-c-o-n-solution</a> </p>
<p><a href="https://discuss.leetcode.com/topic/111306/clean-c-o-logn-solution">https://discuss.leetcode.com/topic/111306/clean-c-o-logn-solution</a></p>
</div>
<div id="interviewed-div"><a href="https://discuss.leetcode.com/topic/111194/java-c-clean-code-with-explanation">https://discuss.leetcode.com/topic/111194/java-c-clean-code-with-explanation</a></div>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-11-29 14:14</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7920253" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7920253);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7906786.html" id="cb_post_title_url">[LeetCode] Self Dividing Numbers 自整除数字</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>A <em>self-dividing number</em> is a number that is divisible by every digit it contains.</p>
<p>For example, 128 is a self-dividing number because <code>128 % 1 == 0</code>, <code>128 % 2 == 0</code>, and <code>128 % 8 == 0</code>.</p>
<p>Also, a self-dividing number is not allowed to contain the digit zero.</p>
<p>Given a lower and upper number bound, output a list of every possible self dividing number, including the bounds if possible.</p>
<p>Example 1:</p>
<pre>Input: 
left = 1, right = 22
Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]
</pre>
<p> </p>
<p>Note:</p>
<ul>
<li>The boundaries of each input argument are <code>1 &lt;= left &lt;= right &lt;= 10000</code>.</li>
</ul>
<p> </p>
<p>这道题让我们找一个给定范围内的所有的自整除数字，所谓的自整除数字就是该数字可以整除其每一个位上的数字。既然这道题是Easy类，那么一般来说不需要用tricky的方法，直接暴力搜索就行了，遍历区间内的所有数字，然后调用子函数判断其是否是自整除数，是的话就加入结果res中。在子函数中，我们先把数字转为字符串，然后遍历每个字符，只要其为0，或者num无法整除该位上的数字，就返回false，循环结束后返回true，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; selfDividingNumbers(<span style="color: #0000ff;">int</span> left, <span style="color: #0000ff;">int</span><span style="color: #000000;"> right) {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = left; i &lt;= right; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (check(i)) res.push_back(i);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">bool</span> check(<span style="color: #0000ff;">int</span><span style="color: #000000;"> num) {
        </span><span style="color: #0000ff;">string</span> str =<span style="color: #000000;"> to_string(num);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span><span style="color: #000000;"> c : str) {
            </span><span style="color: #0000ff;">if</span> (c == <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span> || num % (c - <span style="color: #800000;">'</span><span style="color: #800000;">0</span><span style="color: #800000;">'</span>)) <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>我们可以不用子函数，直接在大的for循环中加上一个for循环进行判断即可，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; selfDividingNumbers(<span style="color: #0000ff;">int</span> left, <span style="color: #0000ff;">int</span><span style="color: #000000;"> right) {
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = left, n = <span style="color: #800080;">0</span>; i &lt;= right; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (n = i; n &gt; <span style="color: #800080;">0</span>; n /= <span style="color: #800080;">10</span><span style="color: #000000;">) {
                </span><span style="color: #0000ff;">if</span> (n % <span style="color: #800080;">10</span> == <span style="color: #800080;">0</span> || i % (n % <span style="color: #800080;">10</span>) != <span style="color: #800080;">0</span>) <span style="color: #0000ff;">break</span><span style="color: #000000;">;
            }
            </span><span style="color: #0000ff;">if</span> (n == <span style="color: #800080;">0</span><span style="color: #000000;">) res.push_back(i);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/6636879.html">Perfect Number</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/111201/java-c-clean-code">https://discuss.leetcode.com/topic/111201/java-c-clean-code</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-11-27 23:55</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7906786" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7906786);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/8684817.html" id="cb_post_title_url">[LeetCode] Minimum Window Subsequence 最小窗口序列</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given strings <code>S</code> and <code>T</code>, find the minimum (contiguous) substring <code>W</code> of <code>S</code>, so that <code>T</code> is a subsequence of <code>W</code>.</p>
<p>If there is no such window in <code>S</code> that covers all characters in <code>T</code>, return the empty string <code>""</code>. If there are multiple such minimum-length windows, return the one with the left-most starting index.</p>
<p>Example 1:</p>
<pre>Input: 
S = "abcdebdde", T = "bde"
Output: "bcde"
Explanation: 
"bcde" is the answer because it occurs before "bdde" which has the same length.
"deb" is not a smaller window because the elements of T in the window must occur in order.
</pre>
<p> </p>
<p>Note:</p>
<ul>
<li>All the strings in the input will only contain lowercase letters.</li>
<li>The length of <code>S</code> will be in the range <code>[1, 20000]</code>.</li>
<li>The length of <code>T</code> will be in the range <code>[1, 100]</code>.</li>
</ul>
<p> </p>
<p>这道题给了我们两个字符串S和T，让我们找出S的一个长度最短子串W，使得T是W的子序列，如果长度相同，取起始位置靠前的。清楚子串和子序列的区别，那么题意就不难理解，题目中给的例子也很好的解释了题意。我们经过研究可以发现，返回的子串的起始字母和T的起始字母一定相同，这样才能保证最短。那么你肯定会想先试试暴力搜索吧，以S中每个T的起始字母为起点，均开始搜索字符串T，然后维护一个子串长度的最小值。如果是这种思路，那么还是趁早打消念头吧，博主已经替你试过了，OJ不依。原因也不难想，假如S中有大量的连续b，并且如果T也很长的话，这种算法实在是不高效啊。根据博主多年经验，这种玩字符串且还是Hard的题，十有八九都是要用动态规划Dynamic Programming来做的，那么就直接往DP上去想吧。DP的第一步就是设计dp数组，像这种两个字符串的题，一般都是一个二维数组，想想该怎么定义。确定一个子串的两个关键要素是起始位置和长度，那么我们的dp值到底应该是定起始位置还是长度呢？That is a question! 仔细想一想，其实起始位置是长度的基础，因为我们一旦知道了起始位置，那么当前位置减去起始位置，就是长度了，所以我们dp值定为起始位置。那么 dp[i][j] 表示范围S中前i个字符包含范围T中前j个字符的子串的起始位置，注意这里的包含是子序列包含关系。然后就是确定长度了，有时候会使用字符串的原长度，有时候会多加1，看个人习惯吧，这里博主长度多加了个1。</p>
<p>OK，下面就是重中之重啦，求递推式。一般来说，dp[i][j]的值是依赖于之前已经求出的dp值的，在递归形式的解法中，dp数组也可以看作是记忆数组，从而省去了大量的重复计算，这也是dp解法凌驾于暴力搜索之上的主要原因。牛B的方法总是最难想出来的，dp的递推式就是其中之一。在脑子一片浆糊的情况下，博主的建议是从最简单的例子开始分析，比如 S = "b", T = "b", 那么我们就有 dp[1][1] = 0，因为S中的起始位置为0，长度为1的子串可以包含T。如果当 S = "d", T = "b"，那么我们有 dp[1][1] = -1，因为我们的dp数组初始化均为-1，表示未匹配或者无法匹配。下面来看一个稍稍复杂些的例子，S = "dbd", T = "bd"，我们的dp数组是：</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">   ∅  b  d
∅  </span>?  ?  ?<span style="color: #000000;">
d  </span>? -<span style="color: #800080;">1</span> -<span style="color: #800080;">1</span><span style="color: #000000;">
b  </span>?  <span style="color: #800080;">1</span> -<span style="color: #800080;">1</span><span style="color: #000000;">
d  </span>?  <span style="color: #800080;">1</span>  <span style="color: #800080;">1</span></pre>
</div>
<p>这里的问号是边界，我们还不知道如何初给边界赋值，我们看到，为-1的地方是对应的字母不相等的地方。我们首先要明确的是dp[i][j]中的j不能大于i，因为T的长度不能大于S的长度，所以j大于i的dp[i][j]一定都是-1的。再来看为1的几个位置，首先是 dp[2][1] = 1，这里表示db包含b的子串起始位置为1，make sense！然后是 dp[3][1] = 1，这里表示dbd包含b的子串起始位置为1，没错！然后是 dp[3][2] = 1，这里表示dbd包含bd的起始位置为1，all right! 那么我们可以观察出，当 S[i] == T[j] 的时候，实际上起始位置和 dp[i - 1][j - 1] 是一样的，比如dbd包含bd的起始位置和db包含b的起始位置一样，所以可以继承过来。那么当 S[i] != T[j] 的时候，怎么搞？其实是和 dp[i - 1][j] 是一样的，比如dbd包含b的起始位置和db包含b的起始位置是一样的。</p>
<p>嗯，这就是递推式的核心了，下面再来看边界怎么赋值，由于j比如小于等于i，所以第一行的第二个位置往后一定都是-1，我们只需要给第一列赋值即可。通过前面的分析，我们知道了当 S[i] == T[j] 时，我们取的是左上角的dp值，表示当前字母在S中的位置，由于我们dp数组提前加过1，所以第一列的数只要赋值为当前行数即可。最终的dp数组如下：</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">   ∅  b  d
∅  </span><span style="color: #800080;">0</span> -<span style="color: #800080;">1</span> -<span style="color: #800080;">1</span><span style="color: #000000;">
d  </span><span style="color: #800080;">1</span> -<span style="color: #800080;">1</span> -<span style="color: #800080;">1</span><span style="color: #000000;">
b  </span><span style="color: #800080;">2</span>  <span style="color: #800080;">1</span> -<span style="color: #800080;">1</span><span style="color: #000000;">
d  </span><span style="color: #800080;">3</span>  <span style="color: #800080;">1</span>  <span style="color: #800080;">1</span></pre>
</div>
<p>为了使代码更加简洁，我们在遍历完每一行，检测如果 dp[i][n] 不为-1，说明T已经被完全包含了，且当前的位置跟起始位置都知道了，我们计算出长度来更新一个全局最小值minLen，同时更新最小值对应的起始位置start，最后取出这个全局最短子串，如果没有找到返回空串即可，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> minWindow(<span style="color: #0000ff;">string</span> S, <span style="color: #0000ff;">string</span><span style="color: #000000;"> T) {
        </span><span style="color: #0000ff;">int</span> m = S.size(), n = T.size(), start = -<span style="color: #800080;">1</span>, minLen =<span style="color: #000000;"> INT_MAX;
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; dp(m + <span style="color: #800080;">1</span>, vector&lt;<span style="color: #0000ff;">int</span>&gt;(n + <span style="color: #800080;">1</span>, -<span style="color: #800080;">1</span><span style="color: #000000;">));
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt;= m; ++i) dp[i][<span style="color: #800080;">0</span>] =<span style="color: #000000;"> i;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt;= m; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">1</span>; j &lt;= min(i, n); ++<span style="color: #000000;">j) {
                dp[i][j] </span>= (S[i - <span style="color: #800080;">1</span>] == T[j - <span style="color: #800080;">1</span>]) ? dp[i - <span style="color: #800080;">1</span>][j - <span style="color: #800080;">1</span>] : dp[i - <span style="color: #800080;">1</span><span style="color: #000000;">][j];
            }
            </span><span style="color: #0000ff;">if</span> (dp[i][n] != -<span style="color: #800080;">1</span><span style="color: #000000;">) {
                </span><span style="color: #0000ff;">int</span> len = i -<span style="color: #000000;"> dp[i][n];
                </span><span style="color: #0000ff;">if</span> (minLen &gt;<span style="color: #000000;"> len) {
                    minLen </span>=<span style="color: #000000;"> len;
                    start </span>=<span style="color: #000000;"> dp[i][n];
                }
            }
        }
        </span><span style="color: #0000ff;">return</span> (start != -<span style="color: #800080;">1</span>) ? S.substr(start, minLen) : <span style="color: #800000;">""</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> minWindow(<span style="color: #0000ff;">string</span> S, <span style="color: #0000ff;">string</span><span style="color: #000000;"> T) {
        </span><span style="color: #0000ff;">int</span> m = S.size(), n = T.size(), start = -<span style="color: #800080;">1</span>, minLen = INT_MAX, i = <span style="color: #800080;">0</span>, j = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (i &lt;<span style="color: #000000;"> m) {
            </span><span style="color: #0000ff;">if</span> (S[i] ==<span style="color: #000000;"> T[j]) {
                </span><span style="color: #0000ff;">if</span> (++j ==<span style="color: #000000;"> n) {
                    </span><span style="color: #0000ff;">int</span> end = i + <span style="color: #800080;">1</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">while</span> (--j &gt;= <span style="color: #800080;">0</span><span style="color: #000000;">) {
                        </span><span style="color: #0000ff;">while</span> (S[i--] !=<span style="color: #000000;"> T[j]);
                    }
                    </span>++i; ++<span style="color: #000000;">j;
                    </span><span style="color: #0000ff;">if</span> (end - i &lt;<span style="color: #000000;"> minLen) {
                        minLen </span>= end -<span style="color: #000000;"> i;
                        start </span>=<span style="color: #000000;"> i;
                    }
                }
            }
            </span>++<span style="color: #000000;">i;
        }
        </span><span style="color: #0000ff;">return</span> (start != -<span style="color: #800080;">1</span>) ? S.substr(start, minLen) : <span style="color: #800000;">""</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/8679286.html" id="homepage1_HomePageDays_DaysList_ctl03_DayList_TitleUrl_0">Largest Plus Sign</a></p>
<p>Cheapest Flights Within K Stops</p>
<p>Domino and Tromino Tiling</p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-03-31 23:54</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=8684817" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(8684817);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/8667239.html" id="cb_post_title_url">[LeetCode] Number of Atoms 原子的个数</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a chemical <code>formula</code> (given as a string), return the count of each atom.</p>
<p>An atomic element always starts with an uppercase character, then zero or more lowercase letters, representing the name.</p>
<p>1 or more digits representing the count of that element may follow if the count is greater than 1. If the count is 1, no digits will follow. For example, H2O and H2O2 are possible, but H1O2 is impossible.</p>
<p>Two formulas concatenated together produce another formula. For example, H2O2He3Mg4 is also a formula.</p>
<p>A formula placed in parentheses, and a count (optionally added) is also a formula. For example, (H2O2) and (H2O2)3 are formulas.</p>
<p>Given a formula, output the count of all elements as a string in the following form: the first name (in sorted order), followed by its count (if that count is more than 1), followed by the second name (in sorted order), followed by its count (if that count is more than 1), and so on.</p>
<p>Example 1:</p>
<pre>Input: 
formula = "H2O"
Output: "H2O"
Explanation: 
The count of elements are {'H': 2, 'O': 1}.
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input: 
formula = "Mg(OH)2"
Output: "H2MgO2"
Explanation: 
The count of elements are {'H': 2, 'Mg': 1, 'O': 2}.
</pre>
<p> </p>
<p>Example 3:</p>
<pre>Input: 
formula = "K4(ON(SO3)2)2"
Output: "K4N2O14S4"
Explanation: 
The count of elements are {'K': 4, 'N': 2, 'O': 14, 'S': 4}.
</pre>
<p> </p>
<p>Note:</p>
<ul>
<li>All atom names consist of lowercase letters, except for the first character which is uppercase.</li>
<li>The length of <code>formula</code> will be in the range <code>[1, 1000]</code>.</li>
<li><code>formula</code> will only consist of letters, digits, and round parentheses, and is a valid formula as defined in the problem.</li>
</ul>
<p> </p>
<p>这道题给了我们一个化学式，让我们数其中原子的个数。比如水是H2O，里面有两个氢原子，一个氧原子，返回还是H2O。例子2给的是氢氧化镁（哈哈，想不到这么多年过去了，高中化学还没有完全还给老师，呀，暴露年龄了呢|||-.-），里面有一个镁原子，氧原子和氢原子各两个，我们返回H2MgO2，可以看到元素是按字母顺序排列的，这道题就是纯粹玩字符串，不需要任何的化学知识。再看第三个例子K4(ON(SO3)2)2，就算你不认识里面的钾，硫，氮，氧等元素，也不影响做题，这个例子的返回是K4N2O14S4，钾原子有4个，氮原子有2个，氧原子有14个，是3x2x2 + 2 = 14得来的，硫原子有4个，是2x2 = 4得来的。那么我们可以发现规律，先统计括号里的原子个数，然后如果括号外面有数字，那么括号里每个原子的个数乘以外面的数字即可，然后在外层若还有数字，那么就继续乘这个数字，这种带有嵌套形式的字符串，比较适合用递归来做。我们最终的目的是统计每个原子的数量，所以我们只要建立了每个元素和其出现次数的映射，就可以生成返回的字符串了，由于需要按元素的字母顺序排列，所以我们使用TreeMap来建立映射。我们使用一个变量pos，来记录我们遍历的位置，这是个全局的变量，在递归函数参数中需要设置引用。我们遍历的时候，需要分三种情况讨论，分别是遇到左括号，右括号，和其他。我们一个个来看：</p>
<p>如果当前是左括号，那么我们pos先自增1，跳过括号位置，然后我们可以调用递归函数，来处理这个括号中包括的所有内容，外加上后面的数字，比如Mg(OH)2，在pos=2处遇到左括号，调用完递归函数后pos指向了最后一个字符的后一位，即pos=7。而在K4(ON(SO3)2)2中，如果是遇到中间的那个左括号pos=5时，调用完递归函数后pos指向了第二个右括号，即pos=11。递归函数返回了中间部分所有原子跟其个数之间的映射，我们直接将其都加入到当前的映射中即可。</p>
<p>如果当前是右括号，说明一个完整的括号已经遍历完了，我们需要取出其后面的数字，如果括号存在，那么后面一定会跟数字，否则不需要括号。所以我们先让pos自增1，跳过括号的位置，然后用个变量i记录当前位置，再进行while循环，找出第一个非数字的位置，那么中间就都是数字啦，用substr将其提取出来，并转为整数，然后遍历当前的映射对，每个值都乘以这个倍数即可，然后返回。</p>
<p>如果当前是字母，那么需要将元素名提取出来了，题目中说了元素名只有第一个字母是大写，后面如果有的话，都是小写字母。所以我们用个while循环找到第一个非小写字母的位置，用substr取出中间的字符串，即元素名。由于元素名后也可能跟数字，所以在用个while循环，来找之后第一个非数字的位置，用substr提取出数字字符串。当然也可能元素名后没有数字，提取出来的数字字符串就是空的，我们加的时候判断一下，如果为空就只加1，否则就加上转化后的整数，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> countOfAtoms(<span style="color: #0000ff;">string</span><span style="color: #000000;"> formula) {
        </span><span style="color: #0000ff;">string</span> res = <span style="color: #800000;">""</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> pos = <span style="color: #800080;">0</span><span style="color: #000000;">;
        map</span>&lt;<span style="color: #0000ff;">string</span>, <span style="color: #0000ff;">int</span>&gt; m =<span style="color: #000000;"> parse(formula, pos);
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto a : m) {
            res </span>+= a.first + (a.second == <span style="color: #800080;">1</span> ? <span style="color: #800000;">""</span><span style="color: #000000;"> : to_string(a.second));
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    map</span>&lt;<span style="color: #0000ff;">string</span>, <span style="color: #0000ff;">int</span>&gt; parse(<span style="color: #0000ff;">string</span>&amp; str, <span style="color: #0000ff;">int</span>&amp;<span style="color: #000000;"> pos) {
        map</span>&lt;<span style="color: #0000ff;">string</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">while</span> (pos &lt;<span style="color: #000000;"> str.size()) {
            </span><span style="color: #0000ff;">if</span> (str[pos] == <span style="color: #800000;">'</span><span style="color: #800000;">(</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                </span>++<span style="color: #000000;">pos;
                </span><span style="color: #0000ff;">for</span> (auto a : parse(str, pos)) res[a.first] +=<span style="color: #000000;"> a.second;
            } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (str[pos] == <span style="color: #800000;">'</span><span style="color: #800000;">)</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                </span><span style="color: #0000ff;">int</span> i = ++<span style="color: #000000;">pos;
                </span><span style="color: #0000ff;">while</span> (pos &lt; str.size() &amp;&amp; isdigit(str[pos])) ++<span style="color: #000000;">pos;
                </span><span style="color: #0000ff;">int</span> multiple = stoi(str.substr(i, pos -<span style="color: #000000;"> i));
                </span><span style="color: #0000ff;">for</span> (auto a : res) res[a.first] *=<span style="color: #000000;"> multiple;
                </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                </span><span style="color: #0000ff;">int</span> i = pos++<span style="color: #000000;">;
                </span><span style="color: #0000ff;">while</span> (pos &lt; str.size() &amp;&amp; islower(str[pos])) ++<span style="color: #000000;">pos;
                </span><span style="color: #0000ff;">string</span> elem = str.substr(i, pos -<span style="color: #000000;"> i);
                i </span>=<span style="color: #000000;"> pos;
                </span><span style="color: #0000ff;">while</span> (pos &lt; str.size() &amp;&amp; isdigit(str[pos])) ++<span style="color: #000000;">pos;
                </span><span style="color: #0000ff;">string</span> cnt = str.substr(i, pos -<span style="color: #000000;"> i);
                res[elem] </span>+= cnt.empty() ? <span style="color: #800080;">1</span><span style="color: #000000;"> : stoi(cnt);
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种解法是迭代形式，根据上面的递归解法改写而来。使用栈来代替递归函数，本身之上基本没有任何区别。需要注意的是，在遇到左括号时，我们将当前映射集cur加入了栈，这里用了个自带的move函数，表示将cur中所有的映射对移出并加入栈，之后cur就为空了。还有就是在处理右括号时，算出了倍数后，我们把当前的映射值乘以倍数后加到栈顶映射集中，然后用栈顶映射集来更新cur，并移除栈顶元素，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> countOfAtoms(<span style="color: #0000ff;">string</span><span style="color: #000000;"> formula) {
        </span><span style="color: #0000ff;">string</span> res = <span style="color: #800000;">""</span><span style="color: #000000;">;
        stack</span>&lt;map&lt;<span style="color: #0000ff;">string</span>, <span style="color: #0000ff;">int</span>&gt;&gt;<span style="color: #000000;"> st;
        map</span>&lt;<span style="color: #0000ff;">string</span>, <span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> cur;
        </span><span style="color: #0000ff;">int</span> n = formula.size(), pos = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">while</span> (pos &lt;<span style="color: #000000;"> n) {
            </span><span style="color: #0000ff;">if</span> (formula[pos] == <span style="color: #800000;">'</span><span style="color: #800000;">(</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                </span>++<span style="color: #000000;">pos;
                st.push(move(cur));
            } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (formula[pos] == <span style="color: #800000;">'</span><span style="color: #800000;">)</span><span style="color: #800000;">'</span><span style="color: #000000;">) {
                </span><span style="color: #0000ff;">int</span> i = ++<span style="color: #000000;">pos;
                </span><span style="color: #0000ff;">while</span> (pos &lt; n &amp;&amp; isdigit(formula[pos])) ++<span style="color: #000000;">pos;
                </span><span style="color: #0000ff;">int</span> multiple = stoi(formula.substr(i, pos -<span style="color: #000000;"> i));
                </span><span style="color: #0000ff;">for</span> (auto a : cur) st.top()[a.first] += a.second *<span style="color: #000000;"> multiple;
                cur </span>=<span style="color: #000000;"> move(st.top());
                st.pop();
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                </span><span style="color: #0000ff;">int</span> i = pos++<span style="color: #000000;">;
                </span><span style="color: #0000ff;">while</span> (pos &lt; n &amp;&amp; islower(formula[pos])) ++<span style="color: #000000;">pos;
                </span><span style="color: #0000ff;">string</span> elem = formula.substr(i, pos -<span style="color: #000000;"> i);
                i </span>=<span style="color: #000000;"> pos;
                </span><span style="color: #0000ff;">while</span> (pos &lt; n &amp;&amp; isdigit(formula[pos])) ++<span style="color: #000000;">pos;
                </span><span style="color: #0000ff;">string</span> cnt = formula.substr(i, pos -<span style="color: #000000;"> i);
                cur[elem] </span>+= cnt.empty() ? <span style="color: #800080;">1</span><span style="color: #000000;"> : stoi(cnt);
            }
        }
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto a : cur) {
            res </span>+= a.first + (a.second == <span style="color: #800080;">1</span> ? <span style="color: #800000;">""</span><span style="color: #000000;"> : to_string(a.second));
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/5849037.html">Decode String</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/6194403.html">Encode String with Shortest Length</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/8045255.html">Parse Lisp Expression</a></p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-03-28 23:44</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=8667239" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(8667239);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7878548.html" id="cb_post_title_url">[LeetCode] Split Linked List in Parts 拆分链表成部分</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a (singly) linked list with head node <code>root</code>, write a function to split the linked list into <code>k</code> consecutive linked list "parts".</p>
<p>The length of each part should be as equal as possible: no two parts should have a size differing by more than 1. This may lead to some parts being null.</p>
<p>The parts should be in order of occurrence in the input list, and parts occurring earlier should always have a size greater than or equal parts occurring later.</p>
<p>Return a List of ListNode's representing the linked list parts that are formed.</p>
<p>Examples 1-&gt;2-&gt;3-&gt;4, k = 5 // 5 equal parts [ [1], [2], [3], [4], null ]</p>
<p>Example 1:</p>
<pre>Input: 
root = [1, 2, 3], k = 5
Output: [[1],[2],[3],[],[]]
Explanation:
The input and each element of the output are ListNodes, not arrays.
For example, the input root has root.val = 1, root.next.val = 2, \root.next.next.val = 3, and root.next.next.next = null.
The first element output[0] has output[0].val = 1, output[0].next = null.
The last element output[4] is null, but it's string representation as a ListNode is [].
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input: 
root = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k = 3
Output: [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]]
Explanation:
The input has been split into consecutive parts with size difference at most 1, and earlier parts are a larger size than the later parts.
</pre>
<p> </p>
<p>Note:</p>
<ul>
<li>The length of <code>root</code> will be in the range <code>[0, 1000]</code>.</li>
<li>Each value of a node in the input will be an integer in the range <code>[0, 999]</code>.</li>
<li><code>k</code> will be an integer in the range <code>[1, 50]</code>.</li>
</ul>
<p> </p>
<p>这道题给我们一个链表和一个正数k，让我们分割链表成k部分，尽可能的平均分割，如果结点不够了，就用空结点，比如例子1中的。如果无法平均分，那么多余的结点就按顺序放在子链表中，如例子2中所示。我们要知道每个部分结点的个数，才能将整个链表断开成子链表，所以我们首先要统计链表中结点的总个数，然后除以k，得到的商avg就是能分成的部分个数，余数ext就是包含有多余的结点的子链表的个数。我们开始for循环，循环的结束条件是i小于k且root存在，要生成k个子链表，在循环中，先把头结点加入结果res中对应的位置，然后就要遍历该子链表的结点个数了，首先每个子链表都一定包含有avg个结点，这是之前除法得到的商，然后还要有没有多余结点，如果i小于ext，就说明当前子链表还得有一个多余结点，然后我们将指针向后移动一个，注意我们这里的j是从1开始，我们希望移动到子链表的最后一个结点上，而不是移动到下一个子链表的首结点，因为我们要断开链表。我们新建一个临时结点t指向下一个结点，也就是下一个子链表的首结点，然后将链表断开，再将root指向临时结点t，这样就完成了断开链表的操作，参见代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;ListNode*&gt; splitListToParts(ListNode* root, <span style="color: #0000ff;">int</span><span style="color: #000000;"> k) {
        vector</span>&lt;ListNode*&gt;<span style="color: #000000;"> res(k);
        </span><span style="color: #0000ff;">int</span> len = <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (ListNode *t = root; t; t = t-&gt;next) ++<span style="color: #000000;">len;
        </span><span style="color: #0000ff;">int</span> avg = len / k, ext = len %<span style="color: #000000;"> k;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; k &amp;&amp; root; ++<span style="color: #000000;">i) {
            res[i] </span>=<span style="color: #000000;"> root;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">1</span>; j &lt; avg + (i &lt; ext); ++<span style="color: #000000;">j) {
                root </span>= root-&gt;<span style="color: #000000;">next;
            }
            ListNode </span>*t = root-&gt;<span style="color: #000000;">next;
            root</span>-&gt;next =<span style="color: #000000;"> NULL;
            root </span>=<span style="color: #000000;"> t;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>下面的内容和本题无关，是博主对于这个感恩节刷屏的大事，国内某恶魔色幼儿园的侵害幼童事件的看法。博主经常听人说，贫穷限制了我们的想象，意思是你永远无法了解富人生活的奢华程度。同样的道理，博主要说，善良限制了我们的想象，你永远无法想象这个世界恶魔的邪恶程度。鲁迅先生说，我向来不惮以最坏的恶意揣测中国人，实际应该改成，我向来不惮以最坏的恶意揣测人类。人性中的恶就像潘多拉的盒子，在没有限制和约束的时候就会被打开，飞出去祸害众生。幼童是人的一生中可以说性格形成的重要时期，也是最脆弱最容易受到伤害的时期，多少变态的罪犯都是有过幼年时期被侵害的经历，形成了畸形的人格，幼年时期被侵害就像被在心中种下了恶，恶之花结出了恶果从而再去侵害其他无辜的人，形成了恶性循环，贻害无穷。难以想象，是什么样扭曲的心灵可以对那么天真无邪的儿童下得去毒手。毕竟这些受侵害的孩子还有父母，侵害还是可能被发现，博主不敢想象孤儿院或者聋哑学校的那些可怜的孩子遭受了侵害，谁会为他们伸张正义。韩国拍出了《熔炉》，《素媛》这些伟大的电影去直面人性中的恶，其中《熔炉》更是推动了韩国对于幼童侵害方面的立法的完善。欣慰的是，国内近期上映的《嘉年华》也是一部反映社会问题的电影，希望能有多一些这类型的电影出现，直到成为中国《熔炉》，改变完善国内相关保障儿童安全的法案。另一方面，家长们也需要加强对于幼童这方面的教育，这一点美国做的能好一些，他们不会让陌生人轻易碰触，估计家长的功课做的比较足。这边的学校也会让做在线的儿童保护的trainning，说明还是相当重视的。国内由于种种原因，对于性教育这方面总感觉能拖就拖，或者干脆自己去领悟，记得之前某出版社曾推出过一本幼童性教育的书，后来因为家长们的强烈反对没有使用，博主也看了，当时偏向于保守的博主也觉得的这书有些“少儿不宜”，但是现在看来，与其被坏人侵害，还不如早些普及这些知识，及早预防，毕竟你觉得孩子小，不应该接触这些东西，但是坏人不会觉得你孩子小而不施加侵害。希望善恶到头终有报，希望世上能少一些罪恶，多一些美好。</p>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4355505.html" target="_blank">Rotate List</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/5138936.html">Odd Even Linked List</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/110475/c-solution-o-1-space-9ms">https://discuss.leetcode.com/topic/110475/c-solution-o-1-space-9ms</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a> </p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-11-22 12:04</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7878548" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7878548);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7865693.html" id="cb_post_title_url">[LeetCode] Find Pivot Index 寻找中枢点</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given an array of integers <code>nums</code>, write a method that returns the "pivot" index of this array.</p>
<p>We define the pivot index as the index where the sum of the numbers to the left of the index is equal to the sum of the numbers to the right of the index.</p>
<p>If no such index exists, we should return -1. If there are multiple pivot indexes, you should return the left-most pivot index.</p>
<p>Example 1:</p>
<pre>Input: 
nums = [1, 7, 3, 6, 5, 6]
Output: 3
Explanation: 
The sum of the numbers to the left of index 3 (nums[3] = 6) is equal to the sum of numbers to the right of index 3.
Also, 3 is the first index where this occurs.
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input: 
nums = [1, 2, 3]
Output: -1
Explanation: 
There is no index that satisfies the conditions in the problem statement.
</pre>
<p> </p>
<p>Note:</p>
<ul>
<li>The length of <code>nums</code> will be in the range <code>[0, 10000]</code>.</li>
<li>Each element <code>nums[i]</code> will be an integer in the range <code>[-1000, 1000]</code>.</li>
</ul>
<p> </p>
<p>这道题给了我们一个数组，让我们求一个中枢点，使得该位置左右两边的子数组之和相等。这道题难度不大，直接按题意去搜索就行了，因为中枢点可能出现的位置就是数组上的位置，所以我们搜索一遍就可以找出来，我们先求出数组的总和，然后维护一个当前数组之和curSum，然后对于遍历到的位置，用总和减去当前数字，看得到的结果是否是curSum的两倍，是的话，那么当前位置就是中枢点，返回即可；否则就将当前数字加到curSum中继续遍历，遍历结束后还没返回，说明没有中枢点，返回-1即可，参见代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> pivotIndex(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        </span><span style="color: #0000ff;">int</span> sum = accumulate(nums.begin(), nums.end(), <span style="color: #800080;">0</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">int</span> curSum = <span style="color: #800080;">0</span>, n =<span style="color: #000000;"> nums.size();
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (sum - nums[i] == <span style="color: #800080;">2</span> * curSum) <span style="color: #0000ff;">return</span><span style="color: #000000;"> i;
            curSum </span>+=<span style="color: #000000;"> nums[i];
        }
        </span><span style="color: #0000ff;">return</span> -<span style="color: #800080;">1</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/6810361.html">Subarray Sum Equals K</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-11-20 12:08</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7865693" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7865693);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7858414.html" id="cb_post_title_url">[LeetCode] Candy Crush 糖果消消乐</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>This question is about implementing a basic elimination algorithm for Candy Crush.</p>
<p>Given a 2D integer array <code>board</code> representing the grid of candy, different positive integers <code>board[i][j]</code> represent different types of candies. A value of <code>board[i][j] = 0</code> represents that the cell at position <code>(i, j)</code> is empty. The given board represents the state of the game following the player's move. Now, you need to restore the board to a <em>stable state</em> by crushing candies according to the following rules:</p>
<ol>
<li>If three or more candies of the same type are adjacent vertically or horizontally, "crush" them all at the same time - these positions become empty.</li>
<li>After crushing all candies simultaneously, if an empty space on the board has candies on top of itself, then these candies will drop until they hit a candy or bottom at the same time. (No new candies will drop outside the top boundary.)</li>
<li>After the above steps, there may exist more candies that can be crushed. If so, you need to repeat the above steps.</li>
<li>If there does not exist more candies that can be crushed (ie. the board is <em>stable</em>), then return the current board.</li>
</ol>
<p>You need to perform the above rules until the board becomes stable, then return the current board.</p>
<p>Example 1:</p>
<pre>Input:
board = 
[[110,5,112,113,114],[210,211,5,213,214],[310,311,3,313,314],[410,411,412,5,414],[5,1,512,3,3],[610,4,1,613,614],[710,1,2,713,714],[810,1,2,1,1],[1,1,2,2,2],[4,1,4,4,1014]]
Output:
[[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[110,0,0,0,114],[210,0,0,0,214],[310,0,0,113,314],[410,0,0,213,414],[610,211,112,313,614],[710,311,412,613,714],[810,411,512,713,1014]]
Explanation: 
</pre>
<p><img alt="" src="https://leetcode.com/static/images/problemset/candy_crush_example_2.png"/></p>
<p> </p>
<p>Note:</p>
<ol>
<li>The length of <code>board</code> will be in the range [3, 50].</li>
<li>The length of <code>board[i]</code> will be in the range [3, 50].</li>
<li>Each <code>board[i][j]</code> will initially start as an integer in the range [1, 2000].</li>
</ol>
<p> </p>
<p>这道题就是糖果消消乐，博主刚开始做的时候，没有看清楚题意，以为就像游戏中的那样，每次只能点击一个地方，然后消除后糖果落下，这样会导致一个问题，就是原本其他可以消除的地方在糖果落下后可能就没有了，所以博主在想点击的顺序肯定会影响最终的stable的状态，可是题目怎么没有要求返回所剩糖果最少的状态？后来发现，其实这道题一次消除table中所有可消除的糖果，然后才下落，形成新的table，这样消除后得到的结果就是统一的了，这样也大大的降低了难度。下面就来看如何找到要消除的糖果，可能有人会想像之前的岛屿的题目一样找连通区域，可是这道题的有限制条件，只有横向或竖向相同的糖果数达到三个才能消除，并不是所有的连通区域都能消除，所以找连通区域不是一个好办法。最好的办法其实是每个糖果单独检查其是否能被消除，然后把所有能被删除的糖果都标记出来统一删除，然后在下落糖果，然后再次查找，直到无法找出能够消除的糖果时达到稳定状态。好，那么我们用一个数组来保存可以被消除的糖果的位置坐标，判断某个位置上的糖果能否被消除的方法就是检查其横向和纵向的最大相同糖果的个数，只要有一个方向达到三个了，当前糖果就可以被消除。所以我们对当前糖果的上下左右四个方向进行查看，用四个变量x0, x1, y0, y1，其中x0表示上方相同的糖果的最大位置，x1表示下方相同糖果的最大位置，y0表示左边相同糖果的最大位置，y1表示右边相同糖果的最大位置，均初始化为当前糖果的位置，然后使用while循环向每个方向遍历，注意我们并不需要遍历到头，而是只要遍历三个糖果就行了，因为一旦查到了三个相同的，就说明当前的糖果已经可以消除了，没必要再往下查了。查的过程还要注意处理越界情况，好，我们得到了上下左右的最大的位置，分别让相同方向的做差，如果水平和竖直方向任意一个大于3了，就说明可以消除，将坐标加入数组del中。注意这里一定要大于3，是因为当发现不相等退出while循环时，坐标值已经改变了，所以已经多加了或者减了一个，所以差值要大于3。遍历完成后，如果数组del为空，说明已经stable了，直接break掉，否则将要消除的糖果位置都标记为0，然后进行下落处理。下落处理实际上是把数组中的0都移动到开头，那么就从数组的末尾开始遍历，用一个变量t先指向末尾，然后然后当遇到非0的数，就将其和t位置上的数置换，然后t自减1，这样t一路减下来都是非0的数，而0都被置换到数组开头了，参见代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt; candyCrush(vector&lt;vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;&amp;<span style="color: #000000;"> board) {
        </span><span style="color: #0000ff;">int</span> m = board.size(), n = board[<span style="color: #800080;">0</span><span style="color: #000000;">].size();
        </span><span style="color: #0000ff;">while</span> (<span style="color: #0000ff;">true</span><span style="color: #000000;">) {
            vector</span>&lt;pair&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&gt;&gt;<span style="color: #000000;"> del;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; m; ++<span style="color: #000000;">i) {
                </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; n; ++<span style="color: #000000;">j) {
                    </span><span style="color: #0000ff;">if</span> (board[i][j] == <span style="color: #800080;">0</span>) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                    </span><span style="color: #0000ff;">int</span> x0 = i, x1 = i, y0 = j, y1 =<span style="color: #000000;"> j;
                    </span><span style="color: #0000ff;">while</span> (x0 &gt;= <span style="color: #800080;">0</span> &amp;&amp; x0 &gt; i - <span style="color: #800080;">3</span> &amp;&amp; board[x0][j] == board[i][j]) --<span style="color: #000000;">x0;
                    </span><span style="color: #0000ff;">while</span> (x1 &lt; m &amp;&amp; x1 &lt; i + <span style="color: #800080;">3</span> &amp;&amp; board[x1][j] == board[i][j]) ++<span style="color: #000000;">x1;
                    </span><span style="color: #0000ff;">while</span> (y0 &gt;= <span style="color: #800080;">0</span> &amp;&amp; y0 &gt; j - <span style="color: #800080;">3</span> &amp;&amp; board[i][y0] == board[i][j]) --<span style="color: #000000;">y0;
                    </span><span style="color: #0000ff;">while</span> (y1 &lt; n &amp;&amp; y1 &lt; j + <span style="color: #800080;">3</span> &amp;&amp; board[i][y1] == board[i][j]) ++<span style="color: #000000;">y1;
                    </span><span style="color: #0000ff;">if</span> (x1 - x0 &gt; <span style="color: #800080;">3</span> || y1 - y0 &gt; <span style="color: #800080;">3</span><span style="color: #000000;">) del.push_back({i, j});
                }
            }
            </span><span style="color: #0000ff;">if</span> (del.empty()) <span style="color: #0000ff;">break</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">for</span> (auto a : del) board[a.first][a.second] = <span style="color: #800080;">0</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">0</span>; j &lt; n; ++<span style="color: #000000;">j) {
                </span><span style="color: #0000ff;">int</span> t = m - <span style="color: #800080;">1</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = m - <span style="color: #800080;">1</span>; i &gt;= <span style="color: #800080;">0</span>; --<span style="color: #000000;">i) {
                    </span><span style="color: #0000ff;">if</span> (board[i][j]) swap(board[t--<span style="color: #000000;">][j], board[i][j]);   
                }</span><span style="color: #000000;">
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> board;
    }
};</span></pre>
</div>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/109635/simple-c-brute-force">https://discuss.leetcode.com/topic/109635/simple-c-brute-force</a></p>
<p><a href="https://discuss.leetcode.com/topic/109952/ac-java-solution-easy-to-understand">https://discuss.leetcode.com/topic/109952/ac-java-solution-easy-to-understand</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-11-18 23:40</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7858414" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7858414);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7841824.html" id="cb_post_title_url">[LeetCode] Remove Comments 移除注释</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a C++ program, remove comments from it. The program <code>source</code> is an array where <code>source[i]</code> is the <code>i</code>-th line of the source code. This represents the result of splitting the original source code string by the newline character <code>\n</code>.</p>
<p>In C++, there are two types of comments, line comments, and block comments.</p>
<p>The string <code>//</code> denotes a line comment, which represents that it and rest of the characters to the right of it in the same line should be ignored.</p>
<p>The string <code>/*</code> denotes a block comment, which represents that all characters until the next (non-overlapping) occurrence of <code>*/</code> should be ignored. (Here, occurrences happen in reading order: line by line from left to right.) To be clear, the string <code>/*/</code> does not yet end the block comment, as the ending would be overlapping the beginning.</p>
<p>The first effective comment takes precedence over others: if the string <code>//</code> occurs in a block comment, it is ignored. Similarly, if the string <code>/*</code> occurs in a line or block comment, it is also ignored.</p>
<p>If a certain line of code is empty after removing comments, you must not output that line: each string in the answer list will be non-empty.</p>
<p>There will be no control characters, single quote, or double quote characters. For example, <code>source = "string s = "/* Not a comment. */";"</code> will not be a test case. (Also, nothing else such as defines or macros will interfere with the comments.)</p>
<p>It is guaranteed that every open block comment will eventually be closed, so <code>/*</code> outside of a line or block comment always starts a new comment.</p>
<p>Finally, implicit newline characters can be deleted by block comments. Please see the examples below for details.</p>
<p>After removing the comments from the source code, return the source code in the same format.</p>
<p><strong>Example 1:</strong><br/>
</p>
<pre><strong>Input:</strong> 
source = ["/*Test program */", "int main()", "{ ", "  // variable declaration ", "int a, b, c;", "/* This is a test", "   multiline  ", "   comment for ", "   testing */", "a = b + c;", "}"]

The line by line code is visualized as below:
/*Test program */
int main()
{ 
  // variable declaration 
int a, b, c;
/* This is a test
   multiline  
   comment for 
   testing */
a = b + c;
}

<strong>Output:</strong> ["int main()","{ ","  ","int a, b, c;","a = b + c;","}"]

The line by line code is visualized as below:
int main()
{ 
  
int a, b, c;
a = b + c;
}

<strong>Explanation:</strong> 
The string <code class="hljs">/*</code> denotes a block comment, including line 1 and lines 6-9. The string <code class="hljs 1c"><span class="hljs-comment">//</span></code> denotes line 4 as comments.
</pre>
<p><strong>Example 2:</strong><br/>
</p>
<pre><strong>Input:</strong> 
source = ["a/*comment", "line", "more_comment*/b"]
<strong>Output:</strong> ["ab"]
<strong>Explanation:</strong> The original source string is "a/*comment<strong>\n</strong>line<strong>\n</strong>more_comment*/b", where we have bolded the newline characters.  After deletion, the <em>implicit</em> newline characters are deleted, leaving the string "ab", which when delimited by newline characters becomes ["ab"].
</pre>
<p><strong>Note:</strong></p>
<div class="question-description">
<ul>
<li>The length of <code>source</code> is in the range <code>[1, 100]</code>.</li>
<li>The length of <code>source[i]</code> is in the range <code>[0, 80]</code>.</li>
<li>Every open block comment is eventually closed.</li>
<li>There are no single-quote, double-quote, or control characters in the source code.</li>
</ul>
</div>
<p> </p>
<p>这道题让我们移除代码中的注释部分，就是写代码中经常遇到的两种注释，单行注释和多行注释，也可以叫块注释，当然最最重要的就是要找到这两种注释的起始标识符"//"和"/*"，注意它们两者之间存在覆盖的关系，谁在前面谁work，比如"//abc/*"，那么此时后面的块注释起始符被忽略掉，同样"/*abc//"，后面的单行注释起始符也不起作用，所以两者之间的前后顺序很重要。博主刚开始想的方法是用string的find函数来分别找"//"和"/*"的起始位置，如果不存在就返回-1，但是需要分多种情况来处理，其是否存在，还有二者的前后顺序，处理起来比较麻烦。起始我们可以直接按字符来一个一个处理，由于块注释是多行注释，所以一旦之前有了块注释的起始符，当前行的处理方式就有所不同了，所以我们需要一个变量blocked来记录当前是否为块注释状态，初始化为false。建立空字符out，用来保存去除注释后的字符。然后我们遍历整个代码的每一行，遍历每一行中的每一个字符，如果当前字符是最后一个字符了，说明不会再有注释了，将当前字符加入out中，否则取出当前位置和下一个位置的两个字符，如果其正好是"/*"，说明之后的部分都是块注释了，我们将blocked赋值为true，然后指针向后移动一个，明明两个字符啊，为啥只移动一个呢，因为另一个可以在for循环中的++i移动；如果当前两个字符正好是"//"，说明当前行之后都是注释，我们并不care后面有啥，所以可以直接break掉当前行；如果都不是，说明当前字符是代码，将其加入out中。好，下面来看blocked为true的情况，说明之后的内容都是块注释的内容，我们唯一关心的是有没有结束符"*/"，所以还是先做判断，如果当前不是最后一个字符，说明至少还有两个字符，然后取出两个字符，如果正好是块注释结束符，那么我们将标识重置为false，指针要后移动一个。当前行遍历完后，如果out不为空，且blocked为false，则将out存入结果res中，参见代码如下：</p>
<p> </p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; removeComments(vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp;<span style="color: #000000;"> source) {
        vector</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">bool</span> blocked = <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">string</span> <span style="color: #0000ff;">out</span> = <span style="color: #800000;">""</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">string</span><span style="color: #000000;"> line : source) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; line.size(); ++<span style="color: #000000;">i) {
                </span><span style="color: #0000ff;">if</span> (!<span style="color: #000000;">blocked) {
                    </span><span style="color: #0000ff;">if</span> (i == line.size() - <span style="color: #800080;">1</span>) <span style="color: #0000ff;">out</span> +=<span style="color: #000000;"> line[i];
                    </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                        </span><span style="color: #0000ff;">string</span> t = line.substr(i, <span style="color: #800080;">2</span><span style="color: #000000;">);
                        </span><span style="color: #0000ff;">if</span> (t == <span style="color: #800000;">"</span><span style="color: #800000;">/*</span><span style="color: #800000;">"</span>) blocked = <span style="color: #0000ff;">true</span>, ++<span style="color: #000000;">i;
                        </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (t == <span style="color: #800000;">"</span><span style="color: #800000;">//</span><span style="color: #800000;">"</span>) <span style="color: #0000ff;">break</span><span style="color: #000000;">;
                        </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">out</span> +=<span style="color: #000000;"> line[i];
                    }
                } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    </span><span style="color: #0000ff;">if</span> (i &lt; line.size() - <span style="color: #800080;">1</span><span style="color: #000000;">) {
                        </span><span style="color: #0000ff;">string</span> t = line.substr(i, <span style="color: #800080;">2</span><span style="color: #000000;">);
                        </span><span style="color: #0000ff;">if</span> (t == <span style="color: #800000;">"</span><span style="color: #800000;">*/</span><span style="color: #800000;">"</span>) blocked = <span style="color: #0000ff;">false</span>, ++<span style="color: #000000;">i;
                    }
                }
            }
            </span><span style="color: #0000ff;">if</span> (!<span style="color: #0000ff;">out</span>.empty() &amp;&amp; !<span style="color: #000000;">blocked) {
                res.push_back(</span><span style="color: #0000ff;">out</span><span style="color: #000000;">);
                </span><span style="color: #0000ff;">out</span> = <span style="color: #800000;">""</span><span style="color: #000000;">;
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/6022498.html">Ternary Expression Parser</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/5771434.html">Mini Parser</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/109943/c-easy-solution">https://discuss.leetcode.com/topic/109943/c-easy-solution</a></p>
<p><a href="https://discuss.leetcode.com/topic/109637/c-o-n-one-pass">https://discuss.leetcode.com/topic/109637/c-o-n-one-pass</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-11-15 23:58</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7841824" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7841824);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7829169.html" id="cb_post_title_url">[LeetCode] Accounts Merge 账户合并</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<div class="question-description">
<p>Given a list <code>accounts</code>, each element <code>accounts[i]</code> is a list of strings, where the first element <code>accounts[i][0]</code> is a <em>name</em>, and the rest of the elements are <em>emails</em> representing emails of the account.</p>
<p>Now, we would like to merge these accounts. Two accounts definitely belong to the same person if there is some email that is common to both accounts. Note that even if two accounts have the same name, they may belong to different people as people could have the same name. A person can have any number of accounts initially, but all of their accounts definitely have the same name.</p>
<p>After merging the accounts, return the accounts in the following format: the first element of each account is the name, and the rest of the elements are emails in sorted order. The accounts themselves can be returned in any order.</p>
<p>Example 1:</p>
<pre>Input: 
accounts = [["John", "johnsmith@mail.com", "john00@mail.com"], ["John", "johnnybravo@mail.com"], ["John", "johnsmith@mail.com", "john_newyork@mail.com"], ["Mary", "mary@mail.com"]]
Output: [["John", 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com'],  ["John", "johnnybravo@mail.com"], ["Mary", "mary@mail.com"]]
Explanation: 
The first and third John's are the same person as they have the common email "johnsmith@mail.com".
The second John and Mary are different people as none of their email addresses are used by other accounts.
We could return these lists in any order, for example the answer [['Mary', 'mary@mail.com'], ['John', 'johnnybravo@mail.com'], 
['John', 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com']] would still be accepted.
</pre>
<p> </p>
<p>Note:</p>
<ul>
<li>The length of <code>accounts</code> will be in the range <code>[1, 1000]</code>.</li>
<li>The length of <code>accounts[i]</code> will be in the range <code>[1, 10]</code>.</li>
<li>The length of <code>accounts[i][j]</code> will be in the range <code>[1, 30]</code>.</li>
</ul>
<p> </p>
<p>这道题给了我们一堆人名和邮箱，一个名字可能有多个邮箱，但是一个邮箱只属于一个人，让我们把同一个人的邮箱都合并到一起，名字相同不一定是同一个人，只有当两个名字有相同的邮箱，才能确定是同一个人，题目中的例子很好说明了这个问题，输入有三个John，最后合并之后就只有两个了。这道题博主最开始尝试使用贪婪算法来做，结果发现对于下面这个例子不适用：</p>
<p>["John", "a@gmail.com", "b@gmail.com"]</p>
<p>["John", "c@gmail.com", "d@gmail.com"]</p>
<p>["John", "a@gmail.com", "c@gmail.com"]</p>
<p>我们可以看到其实这三个John是同一个人，但是贪婪算法遍历完前两个John，还是认为其是两个不同的人，当遍历第三个John时，就直接加到第一个John中了，而没有同时把第二个John加进来，也可能博主写的是假的贪婪算法，反正不管了，还是参考大神们的解法吧。这个归组类的问题，最典型的就是岛屿问题(例如<a href="http://www.cnblogs.com/grandyang/p/5190419.html" target="_blank">Number of Islands II</a>)，很适合使用Union Find来做，LeetCode中有很多道可以使用这个方法来做的题，比如<a href="http://www.cnblogs.com/grandyang/p/6686983.html">Friend Circles</a>，<a href="http://www.cnblogs.com/grandyang/p/5257919.html" target="_blank">Graph Valid Tree</a>，<a href="http://www.cnblogs.com/grandyang/p/5166356.html" target="_blank">Number of Connected Components in an Undirected Graph</a>，和<a href="http://www.cnblogs.com/grandyang/p/7628977.html">Redundant Connection</a>等等。都是要用一个root数组，每个点开始初始化为不同的值，如果两个点属于相同的组，就将其中一个点的root值赋值为另一个点的位置，这样只要是相同组里的两点，通过find函数得到相同的值。在这里，由于邮件是字符串不是数字，所以root可以用哈希map来代替，我们还需要一个哈希映射owner，建立每个邮箱和其所有者姓名之前的映射，另外用一个哈希映射来建立用户和其所有的邮箱之间的映射，也就是合并后的结果。</p>
<p>首先我们遍历每个账户和其中的所有邮箱，先将每个邮箱的root映射为其自身，然后将owner赋值为用户名。然后开始另一个循环，遍历每一个账号，首先对帐号的第一个邮箱调用find函数，得到其父串p，然后遍历之后的邮箱，对每个遍历到的邮箱先调用find函数，将其父串的root值赋值为p，这样做相当于将相同账号内的所有邮箱都链接起来了。我们下来要做的就是再次遍历每个账户内的所有邮箱，先对该邮箱调用find函数，找到父串，然后将该邮箱加入该父串映射的集合汇总，这样就我们就完成了合并。最后只需要将集合转为字符串数组，加入结果res中，通过owner映射找到父串的用户名，加入字符串数组的首位置，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;vector&lt;<span style="color: #0000ff;">string</span>&gt;&gt; accountsMerge(vector&lt;vector&lt;<span style="color: #0000ff;">string</span>&gt;&gt;&amp;<span style="color: #000000;"> accounts) {
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">string</span>&gt;&gt;<span style="color: #000000;"> res;
        unordered_map</span>&lt;<span style="color: #0000ff;">string</span>, <span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> root;
        unordered_map</span>&lt;<span style="color: #0000ff;">string</span>, <span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> owner;
        unordered_map</span>&lt;<span style="color: #0000ff;">string</span>, <span style="color: #0000ff;">set</span>&lt;<span style="color: #0000ff;">string</span>&gt;&gt;<span style="color: #000000;"> m;
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto account : accounts) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt; account.size(); ++<span style="color: #000000;">i) {
                root[account[i]] </span>=<span style="color: #000000;"> account[i];
                owner[account[i]] </span>= account[<span style="color: #800080;">0</span><span style="color: #000000;">];
            }
        }
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto account : accounts) {
            </span><span style="color: #0000ff;">string</span> p = find(account[<span style="color: #800080;">1</span><span style="color: #000000;">], root);
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">2</span>; i &lt; account.size(); ++<span style="color: #000000;">i) {
                root[find(account[i], root)] </span>=<span style="color: #000000;"> p;
            }
        }
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto account : accounts) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt; account.size(); ++<span style="color: #000000;">i) {
                m[find(account[i], root)].insert(account[i]);
            }
        }
        </span><span style="color: #0000ff;">for</span><span style="color: #000000;"> (auto a : m) {
            vector</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> v(a.second.begin(), a.second.end());
            v.insert(v.begin(), owner[a.first]);
            res.push_back(v);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">string</span> find(<span style="color: #0000ff;">string</span> s, unordered_map&lt;<span style="color: #0000ff;">string</span>, <span style="color: #0000ff;">string</span>&gt;&amp;<span style="color: #000000;"> root) {
        </span><span style="color: #0000ff;">return</span> root[s] == s ?<span style="color: #000000;"> s : find(root[s], root);
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种方法是使用BFS来解的，建立了每个邮箱和其所有出现的账户数组之间的映射，比如还是这个例子：</p>
<p>["John", "a@gmail.com", "b@gmail.com"]</p>
<p>["John", "c@gmail.com", "d@gmail.com"]</p>
<p>["John", "a@gmail.com", "c@gmail.com"]</p>
<p>那么建立的映射就是：</p>
<p>"a@gmail.com" -&gt; [0, 2]</p>
<p>"b@gmail.com" -&gt; [0]</p>
<p>"c@gmail.com" -&gt; [1, 2]</p>
<p>"d@gmail.com" -&gt; [1]</p>
<p>然后我们还需要一个visited数组，来标记某个账户是否已经被遍历过，0表示为未访问，1表示已访问。在建立好哈希map之后，我们遍历所有的账户，如果账户未被访问过，将其加入队列queue，新建一个集合set，此时进行队列不为空的while循环，取出队首账户，将该该账户标记已访问1，此时将该账户的所有邮箱取出来放入数组mails中，然后遍历mails中的每一个邮箱，将遍历到的邮箱加入集合set中，根据映射来找到该邮箱所属的所有账户，如果该账户未访问，则加入队列中并标记已访问。当while循环结束后，当前账户的所有合并后的邮箱都保存在集合set中，将其转为字符串数组，并且加上用户名在首位置，最后加入结果res中即可，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;vector&lt;<span style="color: #0000ff;">string</span>&gt;&gt; accountsMerge(vector&lt;vector&lt;<span style="color: #0000ff;">string</span>&gt;&gt;&amp;<span style="color: #000000;"> accounts) {
        vector</span>&lt;vector&lt;<span style="color: #0000ff;">string</span>&gt;&gt;<span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">int</span> n =<span style="color: #000000;"> accounts.size();
        unordered_map</span>&lt;<span style="color: #0000ff;">string</span>, vector&lt;<span style="color: #0000ff;">int</span>&gt;&gt;<span style="color: #000000;"> m;
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; visited(n, <span style="color: #800080;">0</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = <span style="color: #800080;">1</span>; j &lt; accounts[i].size(); ++<span style="color: #000000;">j) {
                m[accounts[i][j]].push_back(i);
            }
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (visited[i] != <span style="color: #800080;">0</span>) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
            queue</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> q{{i}};
            </span><span style="color: #0000ff;">set</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> s;
            </span><span style="color: #0000ff;">while</span> (!<span style="color: #000000;">q.empty()) {
                </span><span style="color: #0000ff;">int</span> t =<span style="color: #000000;"> q.front(); q.pop();
                visited[t] </span>= <span style="color: #800080;">1</span><span style="color: #000000;">;
                vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; mails(accounts[t].begin() + <span style="color: #800080;">1</span><span style="color: #000000;">, accounts[t].end());
                </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">string</span><span style="color: #000000;"> mail : mails) {
                    s.insert(mail);
                    </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span><span style="color: #000000;"> user : m[mail]) {
                        </span><span style="color: #0000ff;">if</span> (visited[user] != <span style="color: #800080;">0</span>) <span style="color: #0000ff;">continue</span><span style="color: #000000;">;
                        q.push(user);
                        visited[user] </span>= <span style="color: #800080;">1</span><span style="color: #000000;">;
                    }
                }
            }
            vector</span>&lt;<span style="color: #0000ff;">string</span>&gt; <span style="color: #0000ff;">out</span><span style="color: #000000;">(s.begin(), s.end());
            </span><span style="color: #0000ff;">out</span>.insert(<span style="color: #0000ff;">out</span>.begin(), accounts[i][<span style="color: #800080;">0</span><span style="color: #000000;">]);
            res.push_back(</span><span style="color: #0000ff;">out</span><span style="color: #000000;">);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span> </pre>
</div>
</div>
<div id="interviewed-div"> </div>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/7628977.html">Redundant Connection</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/109661/simple-c-sol">https://discuss.leetcode.com/topic/109661/simple-c-sol</a></p>
<p><a href="https://discuss.leetcode.com/topic/109642/java-c-union-find">https://discuss.leetcode.com/topic/109642/java-c-union-find</a></p>
<p><a href="https://discuss.leetcode.com/topic/109641/java-solution-build-graph-dfs-search">https://discuss.leetcode.com/topic/109641/java-solution-build-graph-dfs-search</a></p>
<p> </p>
<div id="cnblogs_post_body">
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p>
</div></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-11-13 23:52</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7829169" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7829169);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/7817011.html" id="cb_post_title_url">[LeetCode] Longest Word in Dictionary 字典中的最长单词</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given a list of strings <code>words</code> representing an English Dictionary, find the longest word in <code>words</code> that can be built one character at a time by other words in <code>words</code>. If there is more than one possible answer, return the longest word with the smallest lexicographical order.</p>
<p>If there is no answer, return the empty string.</p>
<p>Example 1:</p>
<pre>Input: 
words = ["w","wo","wor","worl", "world"]
Output: "world"
Explanation: 
The word "world" can be built one character at a time by "w", "wo", "wor", and "worl".
</pre>
<p> </p>
<p>Example 2:</p>
<pre>Input: 
words = ["a", "banana", "app", "appl", "ap", "apply", "apple"]
Output: "apple"
Explanation: 
Both "apply" and "apple" can be built from other words in the dictionary. However, "apple" is lexicographically smaller than "apply".
</pre>
<p> </p>
<p>Note:</p>
<ul>
<li>All the strings in the input will only contain lowercase letters.</li>
<li>The length of <code>words</code> will be in the range <code>[1, 1000]</code>.</li>
<li>The length of <code>words[i]</code> will be in the range <code>[1, 30]</code>.</li>
</ul>
<p> </p>
<p>这道题给了我们一个字典，是个字符串数组，然后问我们从单个字符开始拼，最长能组成啥单词，注意中间生成的字符串也要在字典中存在，而且当组成的单词长度相等时，返回字母顺序小的那个。好，看到这么多前缀一样多字符串，是不是很容易想到用前缀树来做，其实我们并不需要真正的建立前缀树结点，可以借鉴查找的思想来做。那么为了快速的查找某个单词是否在字典中存在，我们将所有单词放到哈希集合中，在查找的时候，可以采用BFS或者DFS都行。先来看BFS的做法，使用一个queue来辅助，我们先把所有长度为1的单词找出排入queue中，当作种子选手，然后我们进行循环，每次从队首取一个元素出来，如果其长度大于我们维护的最大值mxLen，则更新mxLen和结果res，如果正好相等，也要更新结果res，取字母顺序小的那个。然后我们试着增加长度，做法就是遍历26个字母，将每个字母都加到单词后面，然后看是否在字典中存在，存在的话，就加入queue中等待下一次遍历，完了以后记得要恢复状态，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> longestWord(vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp;<span style="color: #000000;"> words) {
        </span><span style="color: #0000ff;">string</span> res = <span style="color: #800000;">""</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> mxLen = <span style="color: #800080;">0</span><span style="color: #000000;">;
        unordered_set</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> s(words.begin(), words.end());
        queue</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> q;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">string</span><span style="color: #000000;"> word : words) {
            </span><span style="color: #0000ff;">if</span> (word.size() == <span style="color: #800080;">1</span><span style="color: #000000;">) q.push(word);
        }
        </span><span style="color: #0000ff;">while</span> (!<span style="color: #000000;">q.empty()) {
            </span><span style="color: #0000ff;">string</span> t =<span style="color: #000000;"> q.front(); q.pop();
            </span><span style="color: #0000ff;">if</span> (t.size() &gt;<span style="color: #000000;"> mxLen) {
                mxLen </span>=<span style="color: #000000;"> t.size();
                res </span>=<span style="color: #000000;"> t;
            } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (t.size() ==<span style="color: #000000;"> mxLen) {
                res </span>=<span style="color: #000000;"> min(res, t);
            }
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span> c = <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span>; c &lt;= <span style="color: #800000;">'</span><span style="color: #800000;">z</span><span style="color: #800000;">'</span>; ++<span style="color: #000000;">c) {
                t.push_back(c);
                </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (s.count(t)) q.push(t);
                t.pop_back();
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>下面来看递归的解法，前面都一样，不同在于直接对长度为1的单词调用递归函数，在递归中，还是先判断单词和mxLen关系来更新结果res，然后就是遍历所有字符，加到单词后面，如果在集合中存在，调用递归函数，结束后恢复状态，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> longestWord(vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp;<span style="color: #000000;"> words) {
        </span><span style="color: #0000ff;">string</span> res = <span style="color: #800000;">""</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> mxLen = <span style="color: #800080;">0</span><span style="color: #000000;">;
        unordered_set</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> s(words.begin(), words.end());</span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">string</span><span style="color: #000000;"> word : words) {
            </span><span style="color: #0000ff;">if</span> (word.size() == <span style="color: #800080;">1</span><span style="color: #000000;">) helper(s, word, mxLen, res);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">void</span> helper(unordered_set&lt;<span style="color: #0000ff;">string</span>&gt;&amp; s, <span style="color: #0000ff;">string</span> word, <span style="color: #0000ff;">int</span>&amp; mxLen, <span style="color: #0000ff;">string</span>&amp;<span style="color: #000000;"> res) {
        </span><span style="color: #0000ff;">if</span> (word.size() &gt;<span style="color: #000000;"> mxLen) {
            mxLen </span>=<span style="color: #000000;"> word.size();
            res </span>=<span style="color: #000000;"> word;
        } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (word.size() ==<span style="color: #000000;"> mxLen) {
            res </span>=<span style="color: #000000;"> min(res, word);
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span> c = <span style="color: #800000;">'</span><span style="color: #800000;">a</span><span style="color: #800000;">'</span>; c &lt;= <span style="color: #800000;">'</span><span style="color: #800000;">z</span><span style="color: #800000;">'</span>; ++<span style="color: #000000;">c) {
            word.push_back(c);
            </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (s.count(word)) helper(s, word, mxLen, res);
            word.pop_back();
        }
    }
};</span></pre>
</div>
<p> </p>
<p>下面这种解法是论坛上的高分解法，其实我们只要给数组排个序，就可以使用贪婪算法来做了，并不需要什么DFS或BFS这么复杂。首先建立一个空的哈希set，然后我们直接遍历排序后的字典，对于当前的单词，如果当前单词长度为1，或者该单词去掉最后一个字母后在集合中存在，这也不难理解，长度为1，说明是起始单词，不需要的多余的判断，否则的话就要判断其去掉最后一个字母后的单词是否在集合中存在，存在的话，才说明其中间单词都存在，因为此时是从短单词向长单词遍历，只要符合要求的才会加入集合，所以一旦其去掉尾字母的单词存在的话，那么其之前所有的中间情况都会在集合中存在。我们更新结果res时，要判断当前单词长度是否大于结果res的长度，因为排序过后，默认先更新的字母顺序小的单词，所有只有当当前单词长度大，才更新结果res，之后别忘了把当前单词加入集合中，参见代码如下：</p>
<p> </p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">string</span> longestWord(vector&lt;<span style="color: #0000ff;">string</span>&gt;&amp;<span style="color: #000000;"> words) {
        </span><span style="color: #0000ff;">string</span> res = <span style="color: #800000;">""</span><span style="color: #000000;">;
        unordered_set</span>&lt;<span style="color: #0000ff;">string</span>&gt;<span style="color: #000000;"> s;
        sort(words.begin(), words.end());
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">string</span><span style="color: #000000;"> word : words) {
            </span><span style="color: #0000ff;">if</span> (word.size() == <span style="color: #800080;">1</span> || s.count(word.substr(<span style="color: #800080;">0</span>, word.size() - <span style="color: #800080;">1</span><span style="color: #000000;">))) {
                res </span>= (word.size() &gt; res.size()) ?<span style="color: #000000;"> word : res;
                s.insert(word);
            }
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/6523344.html">Longest Word in Dictionary through Deleting</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/7612918.html">Implement Magic Dictionary</a></p>
<p> </p>
<p>参考资料：</p>
<p><a href="https://discuss.leetcode.com/topic/109643/java-c-clean-code">https://discuss.leetcode.com/topic/109643/java-c-clean-code</a></p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2017-11-10 23:52</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=7817011" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(7817011);return false;">收藏</a></div>
</div><div class="post">
<h1 class="postTitle">
<a class="postTitle2" href="https://www.cnblogs.com/grandyang/p/8627783.html" id="cb_post_title_url">[LeetCode] Find K-th Smallest Pair Distance 找第K小的数对儿距离</a>
</h1>
<div class="clear"></div>
<div class="postBody">
<div class="blogpost-body" id="cnblogs_post_body"><p> </p>
<p>Given an integer array, return the k-th smallest distance among all the pairs. The distance of a pair (A, B) is defined as the absolute difference between A and B.</p>
<p>Example 1:</p>
<pre>Input:
nums = [1,3,1]
k = 1
Output: 0 
Explanation:
Here are all the pairs:
(1,3) -&gt; 2
(1,1) -&gt; 0
(3,1) -&gt; 2
Then the 1st smallest distance pair is (1,1), and its distance is 0.
</pre>
<p> </p>
<p>Note:</p>
<ol>
<li><code>2 &lt;= len(nums) &lt;= 10000</code>.</li>
<li><code>0 &lt;= nums[i] &lt; 1000000</code>.</li>
<li><code>1 &lt;= k &lt;= len(nums) * (len(nums) - 1) / 2</code>.</li>
</ol>
<p> </p>
<p>这道题给了我们一个数组，让我们找第k小的数对儿距离，数对儿距离就是任意两个数字之间的绝对值差。那么我们先来考虑最暴力的解法，是不是就是遍历任意两个数字，算出其绝对值差，然后将所有距离排序，取第k小的就行了。But，OJ摇着头说图样图森破。但是我们可以在纯暴力搜索的基础上做些优化，从而让OJ说YES。那么下面这种利用了桶排序的解法就是一种很好的优化，题目中给了数字的大小范围，不会超过一百万，所以我们就建立一百万个桶，然后还是遍历任意两个数字，将计算出的距离放到对应的桶中，这里桶不是存的具体距离，而是该距离出现的次数，桶本身的位置就是距离，所以我们才建立了一百万个桶。然后我们就可以从0开始遍历到一百万了，这样保证了我们先处理小距离，如果某个距离的出现次数大于等于k了，那么我们返回这个距离，否则就用k减去这个距离的出现次数，参见代码如下：</p>
<p> </p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> smallestDistancePair(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; nums, <span style="color: #0000ff;">int</span><span style="color: #000000;"> k) {
        </span><span style="color: #0000ff;">int</span> n = nums.size(), N = <span style="color: #800080;">1000000</span><span style="color: #000000;">;
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; cnt(N, <span style="color: #800080;">0</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> j = i + <span style="color: #800080;">1</span>; j &lt; n; ++<span style="color: #000000;">j) {
                </span>++cnt[abs(nums[i] -<span style="color: #000000;"> nums[j])];
            }
        }
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; N; ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (cnt[i] &gt;= k) <span style="color: #0000ff;">return</span><span style="color: #000000;"> i;
            k </span>-=<span style="color: #000000;"> cnt[i];
        }
        </span><span style="color: #0000ff;">return</span> -<span style="color: #800080;">1</span><span style="color: #000000;">;
    }
};</span></pre>
</div>
<p> </p>
<p>上面的解法虽然逃脱了OJ的魔掌，但也仅仅是险过，并不高效。我们来看一种基于二分搜索的解法。这道题使用的二分搜索法是博主归纳总结帖<a class="entrylistItemTitle" href="http://www.cnblogs.com/grandyang/p/6854825.html" id="CategoryEntryList1_EntryStoryList_ctl00_Entries_TitleUrl_1">LeetCode Binary Search Summary 二分搜索法小结</a>中的第四种，即二分法的判定条件不是简单的大小关系，而是可以抽离出子函数的情况，下面我们来看具体怎么弄。我们的目标是快速定位出第k小的距离，那么很适合用二分法来快速的缩小查找范围，然而最大的难点就是如何找到判定依据来折半查找，即如果确定搜索目标是在左半边还是右半边。做过<a href="http://www.cnblogs.com/grandyang/p/5727892.html">Kth Smallest Element in a Sorted Matrix</a>和<a href="http://www.cnblogs.com/grandyang/p/8367505.html" target="_blank">Kth Smallest Number in Multiplication Table</a>这两道题的同学应该对这种搜索方式并不陌生。核心思想是二分确定一个中间数，然后找到所有小于等于这个中间数的距离个数，用其跟k比较来确定折半的方向。具体的操作是，我们首先要给数组排序，二分搜索的起始left为0，结束位置right为最大距离，即排序后的数字最后一个元素减去首元素。然后进入while循环，算出中间值mid，此外我们还需要两个变量cnt和start，其中cnt是记录小于等于mid的距离个数，start是较小数字的位置，均初始化为0，然后我们遍历整个数组，先进行while循环，如果start未越界，并且当前数字减去start指向的数组之差大于mid，说明此时距离太大了，我们增加减数大小，通过将start右移一个，那么while循环退出后，就有i - start个距离小于等于mid，将其加入cnt中，举个栗子来说：</p>
<p>   1    2    3    3    5</p>
<p>start              i</p>
<p>mid = 2</p>
<p>如果start在位置0，i在位置3，那么以nums[i]为较大数可以产生三个（i - start）小于等于mid的距离，[1 3], [2 3], [3 3]，这样当i遍历完所有的数字后，所有小于等于mid的距离的个数就求出来了，即cnt。然后我们跟k比较，如果其小于k，那么left赋值为mid+1，反之，则right赋值为mid。最终返回right或left均可，参见代码如下：</p>
<p> </p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> smallestDistancePair(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp; nums, <span style="color: #0000ff;">int</span><span style="color: #000000;"> k) {
        sort(nums.begin(), nums.end());
        </span><span style="color: #0000ff;">int</span> n = nums.size(), left = <span style="color: #800080;">0</span>, right = nums.back() - nums[<span style="color: #800080;">0</span><span style="color: #000000;">];
        </span><span style="color: #0000ff;">while</span> (left &lt;<span style="color: #000000;"> right) {
            </span><span style="color: #0000ff;">int</span> mid = left + (right - left) / <span style="color: #800080;">2</span>, cnt = <span style="color: #800080;">0</span>, start = <span style="color: #800080;">0</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
                </span><span style="color: #0000ff;">while</span> (start &lt; n &amp;&amp; nums[i] - nums[start] &gt; mid) ++<span style="color: #000000;">start;
                cnt </span>+= i -<span style="color: #000000;"> start;
            }
            </span><span style="color: #0000ff;">if</span> (cnt &lt; k) left = mid + <span style="color: #800080;">1</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">else</span> right =<span style="color: #000000;"> mid;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> right;
    }
};</span></pre>
</div>
<p> </p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/5653127.html">Find K Pairs with Smallest Sums</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/5727892.html">Kth Smallest Element in a Sorted Matrix</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/7519466.html">Find K Closest Elements</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/8367505.html" target="_blank">Kth Smallest Number in Multiplication Table</a></p>
<p>K-th Smallest Prime Fraction</p>
<p> </p>
<p>参考资料：</p>
<p> </p>
<p><a class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html" id="cb_post_title_url">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>
</div>
<div class="postDesc">posted @ <span id="post-date">2018-03-22 23:48</span> <a href="https://www.cnblogs.com/grandyang/">Grandyang</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=8627783" rel="nofollow">编辑</a> <a href="#" onclick="AddToWz(8627783);return false;">收藏</a></div>
</div>
</html>